   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"state.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.stateInit,"ax",%progbits
  20              		.align	1
  21              		.global	stateInit
  22              		.thumb
  23              		.thumb_func
  25              	stateInit:
  26              	.LFB139:
  27              		.file 1 "state.c"
   1:state.c       **** /*
   2:state.c       ****  * Copyright (C) 2011-2012 Felix Ruess <felix.ruess@gmail.com>
   3:state.c       ****  *
   4:state.c       ****  * This file is part of paparazzi.
   5:state.c       ****  *
   6:state.c       ****  * paparazzi is free software; you can redistribute it and/or modify
   7:state.c       ****  * it under the terms of the GNU General Public License as published by
   8:state.c       ****  * the Free Software Foundation; either version 2, or (at your option)
   9:state.c       ****  * any later version.
  10:state.c       ****  *
  11:state.c       ****  * paparazzi is distributed in the hope that it will be useful,
  12:state.c       ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:state.c       ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:state.c       ****  * GNU General Public License for more details.
  15:state.c       ****  *
  16:state.c       ****  * You should have received a copy of the GNU General Public License
  17:state.c       ****  * along with paparazzi; see the file COPYING.  If not, see
  18:state.c       ****  * <http://www.gnu.org/licenses/>.
  19:state.c       ****  */
  20:state.c       **** 
  21:state.c       **** /**
  22:state.c       ****  * @file state.c
  23:state.c       ****  *
  24:state.c       ****  * General interface for the main vehicle states.
  25:state.c       ****  *
  26:state.c       ****  * This file contains the functions to automatically convert between
  27:state.c       ****  * the different representations. They should normally not be used
  28:state.c       ****  * directly and instead the stateGet/Set interfaces used.
  29:state.c       ****  * Also see the @ref state_interface "State Interface" page.
  30:state.c       ****  *
  31:state.c       ****  * @author Felix Ruess <felix.ruess@gmail.com>
  32:state.c       ****  */
  33:state.c       **** 
  34:state.c       **** #include "state.h"
  35:state.c       **** 
  36:state.c       **** struct State state;
  37:state.c       **** 
  38:state.c       **** /**
  39:state.c       ****  * @addtogroup state_interface
  40:state.c       ****  * @{
  41:state.c       ****  */
  42:state.c       **** 
  43:state.c       **** void stateInit(void)
  44:state.c       **** {
  28              		.loc 1 44 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  45:state.c       ****   state.pos_status = 0;
  33              		.loc 1 45 0
  34 0000 094B     		ldr	r3, .L2
  35 0002 0022     		movs	r2, #0
  36 0004 1A80     		strh	r2, [r3]	@ movhi
  46:state.c       ****   state.speed_status = 0;
  37              		.loc 1 46 0
  38 0006 A3F81421 		strh	r2, [r3, #276]	@ movhi
  47:state.c       ****   state.accel_status = 0;
  39              		.loc 1 47 0
  40 000a 83F87021 		strb	r2, [r3, #368]
  48:state.c       ****   state.ned_to_body_orientation.status = 0;
  41              		.loc 1 48 0
  42 000e 83F8A421 		strb	r2, [r3, #420]
  49:state.c       ****   state.rate_status = 0;
  43              		.loc 1 49 0
  44 0012 83F82822 		strb	r2, [r3, #552]
  50:state.c       ****   state.wind_air_status = 0;
  45              		.loc 1 50 0
  46 0016 83F84422 		strb	r2, [r3, #580]
  51:state.c       ****   state.ned_initialized_i = FALSE;
  47              		.loc 1 51 0
  48 001a 83F85C20 		strb	r2, [r3, #92]
  52:state.c       ****   state.ned_initialized_f = FALSE;
  49              		.loc 1 52 0
  50 001e 83F8E420 		strb	r2, [r3, #228]
  53:state.c       ****   state.utm_initialized_f = FALSE;
  51              		.loc 1 53 0
  52 0022 83F8F820 		strb	r2, [r3, #248]
  53 0026 7047     		bx	lr
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0028 00000000 		.word	.LANCHOR0
  58              		.cfi_endproc
  59              	.LFE139:
  61              		.global	__aeabi_f2d
  62              		.global	__aeabi_dmul
  63              		.global	__aeabi_d2iz
  64              		.section	.text.stateCalcPositionEcef_i,"ax",%progbits
  65              		.align	1
  66              		.global	stateCalcPositionEcef_i
  67              		.thumb
  68              		.thumb_func
  70              	stateCalcPositionEcef_i:
  71              	.LFB140:
  54:state.c       **** }
  55:state.c       **** 
  56:state.c       **** 
  57:state.c       **** /*******************************************************************************
  58:state.c       ****  *                                                                             *
  59:state.c       ****  * transformation functions for the POSITION representations                   *
  60:state.c       ****  *                                                                             *
  61:state.c       ****  ******************************************************************************/
  62:state.c       **** /** @addtogroup state_position
  63:state.c       ****  *  @{ */
  64:state.c       **** 
  65:state.c       **** void stateCalcPositionEcef_i(void)
  66:state.c       **** {
  72              		.loc 1 66 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76 0000 38B5     		push	{r3, r4, r5, lr}
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 3, -16
  79              		.cfi_offset 4, -12
  80              		.cfi_offset 5, -8
  81              		.cfi_offset 14, -4
  67:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
  82              		.loc 1 67 0
  83 0002 404C     		ldr	r4, .L28
  84 0004 2388     		ldrh	r3, [r4]
  85 0006 DA07     		lsls	r2, r3, #31
  86 0008 7AD4     		bmi	.L4
  68:state.c       ****     return;
  69:state.c       ****   }
  70:state.c       **** 
  71:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
  87              		.loc 1 71 0
  88 000a 9D06     		lsls	r5, r3, #26
  89 000c 53D4     		bmi	.L26
  72:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
  73:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_i) {
  90              		.loc 1 73 0
  91 000e 9807     		lsls	r0, r3, #30
  92 0010 0AD5     		bpl	.L8
  93              		.loc 1 73 0 is_stmt 0 discriminator 1
  94 0012 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
  95 0016 3AB1     		cbz	r2, .L8
  74:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
  96              		.loc 1 74 0 is_stmt 1
  97 0018 201D     		adds	r0, r4, #4
  98 001a 04F11C01 		add	r1, r4, #28
  99 001e 04F16002 		add	r2, r4, #96
 100 0022 FFF7FEFF 		bl	ecef_of_ned_pos_i
 101              	.LVL0:
 102 0026 67E0     		b	.L7
 103              	.L8:
  75:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_f) {
 104              		.loc 1 75 0
 105 0028 5906     		lsls	r1, r3, #25
 106 002a 31D5     		bpl	.L9
 107              		.loc 1 75 0 is_stmt 0 discriminator 1
 108 002c 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 109 0030 344D     		ldr	r5, .L28
 110 0032 6AB3     		cbz	r2, .L9
  76:state.c       ****     /* transform ned_f to ecef_f, set status bit, then convert to int */
  77:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 111              		.loc 1 77 0 is_stmt 1
 112 0034 05F1FC02 		add	r2, r5, #252
 113 0038 05F19800 		add	r0, r5, #152
 114 003c 05F1A401 		add	r1, r5, #164
 115 0040 FFF7FEFF 		bl	ecef_of_ned_point_f
 116              	.LVL1:
  78:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 117              		.loc 1 78 0
 118 0044 2B88     		ldrh	r3, [r5]
  79:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 119              		.loc 1 79 0
 120 0046 D5F89800 		ldr	r0, [r5, #152]	@ float
  78:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 121              		.loc 1 78 0
 122 004a 43F02003 		orr	r3, r3, #32
 123 004e 2B80     		strh	r3, [r5]	@ movhi
 124              		.loc 1 79 0
 125 0050 FFF7FEFF 		bl	__aeabi_f2d
 126              	.LVL2:
 127 0054 0022     		movs	r2, #0
 128 0056 2C4B     		ldr	r3, .L28+4
 129 0058 FFF7FEFF 		bl	__aeabi_dmul
 130              	.LVL3:
 131 005c FFF7FEFF 		bl	__aeabi_d2iz
 132              	.LVL4:
 133 0060 6860     		str	r0, [r5, #4]
 134 0062 D5F89C00 		ldr	r0, [r5, #156]	@ float
 135 0066 FFF7FEFF 		bl	__aeabi_f2d
 136              	.LVL5:
 137 006a 0022     		movs	r2, #0
 138 006c 264B     		ldr	r3, .L28+4
 139 006e FFF7FEFF 		bl	__aeabi_dmul
 140              	.LVL6:
 141 0072 FFF7FEFF 		bl	__aeabi_d2iz
 142              	.LVL7:
 143 0076 A860     		str	r0, [r5, #8]
 144 0078 D5F8A000 		ldr	r0, [r5, #160]	@ float
 145 007c FFF7FEFF 		bl	__aeabi_f2d
 146              	.LVL8:
 147 0080 0022     		movs	r2, #0
 148 0082 214B     		ldr	r3, .L28+4
 149 0084 FFF7FEFF 		bl	__aeabi_dmul
 150              	.LVL9:
 151 0088 FFF7FEFF 		bl	__aeabi_d2iz
 152              	.LVL10:
 153 008c E860     		str	r0, [r5, #12]
 154 008e 33E0     		b	.L7
 155              	.L9:
  80:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 156              		.loc 1 80 0
 157 0090 1A07     		lsls	r2, r3, #28
 158 0092 05D5     		bpl	.L10
  81:state.c       ****     ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i);
 159              		.loc 1 81 0
 160 0094 1D48     		ldr	r0, .L28+8
 161 0096 00F10C01 		add	r1, r0, #12
 162 009a FFF7FEFF 		bl	ecef_of_lla_i
 163              	.LVL11:
 164 009e 2BE0     		b	.L7
 165              	.L10:
  82:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 166              		.loc 1 82 0
 167 00a0 DB05     		lsls	r3, r3, #23
 168 00a2 29D5     		bpl	.L7
  83:state.c       ****     /* transform lla_f to ecef_f, set status bit, then convert to int */
  84:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 169              		.loc 1 84 0
 170 00a4 1A48     		ldr	r0, .L28+12
 171 00a6 A0F10C01 		sub	r1, r0, #12
 172 00aa FFF7FEFF 		bl	ecef_of_lla_f
 173              	.LVL12:
  85:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 174              		.loc 1 85 0
 175 00ae 2388     		ldrh	r3, [r4]
 176 00b0 43F02003 		orr	r3, r3, #32
 177 00b4 2380     		strh	r3, [r4]	@ movhi
 178              	.L26:
  86:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 179              		.loc 1 86 0
 180 00b6 D4F89800 		ldr	r0, [r4, #152]	@ float
 181 00ba FFF7FEFF 		bl	__aeabi_f2d
 182              	.LVL13:
 183 00be 0022     		movs	r2, #0
 184 00c0 114B     		ldr	r3, .L28+4
 185 00c2 FFF7FEFF 		bl	__aeabi_dmul
 186              	.LVL14:
 187 00c6 FFF7FEFF 		bl	__aeabi_d2iz
 188              	.LVL15:
 189 00ca 6060     		str	r0, [r4, #4]
 190 00cc D4F89C00 		ldr	r0, [r4, #156]	@ float
 191 00d0 FFF7FEFF 		bl	__aeabi_f2d
 192              	.LVL16:
 193 00d4 0022     		movs	r2, #0
 194 00d6 0C4B     		ldr	r3, .L28+4
 195 00d8 FFF7FEFF 		bl	__aeabi_dmul
 196              	.LVL17:
 197 00dc FFF7FEFF 		bl	__aeabi_d2iz
 198              	.LVL18:
 199 00e0 A060     		str	r0, [r4, #8]
 200 00e2 D4F8A000 		ldr	r0, [r4, #160]	@ float
 201 00e6 FFF7FEFF 		bl	__aeabi_f2d
 202              	.LVL19:
 203 00ea 0022     		movs	r2, #0
 204 00ec 064B     		ldr	r3, .L28+4
 205 00ee FFF7FEFF 		bl	__aeabi_dmul
 206              	.LVL20:
 207 00f2 FFF7FEFF 		bl	__aeabi_d2iz
 208              	.LVL21:
 209 00f6 E060     		str	r0, [r4, #12]
 210              	.L7:
  87:state.c       ****   } else {
  88:state.c       ****     /* could not get this representation,  set errno */
  89:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
  90:state.c       ****     //return _ecef_zero;
  91:state.c       ****   }
  92:state.c       ****   /* set bit to indicate this representation is computed */
  93:state.c       ****   SetBit(state.pos_status, POS_ECEF_I);
 211              		.loc 1 93 0
 212 00f8 2388     		ldrh	r3, [r4]
 213 00fa 43F00103 		orr	r3, r3, #1
 214 00fe 2380     		strh	r3, [r4]	@ movhi
 215              	.L4:
 216 0100 38BD     		pop	{r3, r4, r5, pc}
 217              	.L29:
 218 0102 00BF     		.align	2
 219              	.L28:
 220 0104 00000000 		.word	.LANCHOR0
 221 0108 00005940 		.word	1079574528
 222 010c 04000000 		.word	.LANCHOR0+4
 223 0110 98000000 		.word	.LANCHOR0+152
 224              		.cfi_endproc
 225              	.LFE140:
 227              		.global	__aeabi_ddiv
 228              		.global	__aeabi_d2f
 229              		.section	.text.stateCalcPositionNed_i,"ax",%progbits
 230              		.align	1
 231              		.global	stateCalcPositionNed_i
 232              		.thumb
 233              		.thumb_func
 235              	stateCalcPositionNed_i:
 236              	.LFB141:
  94:state.c       **** }
  95:state.c       **** 
  96:state.c       **** void stateCalcPositionNed_i(void)
  97:state.c       **** {
 237              		.loc 1 97 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241 0000 38B5     		push	{r3, r4, r5, lr}
 242              		.cfi_def_cfa_offset 16
 243              		.cfi_offset 3, -16
 244              		.cfi_offset 4, -12
 245              		.cfi_offset 5, -8
 246              		.cfi_offset 14, -4
  98:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_I)) {
 247              		.loc 1 98 0
 248 0002 994C     		ldr	r4, .L61+16
 249 0004 2588     		ldrh	r5, [r4]
 250 0006 AA07     		lsls	r2, r5, #30
 251 0008 00F12381 		bmi	.L30
 252              	.LVL22:
  99:state.c       ****     return;
 100:state.c       ****   }
 101:state.c       **** 
 102:state.c       ****   int errno = 0;
 103:state.c       ****   if (state.ned_initialized_i) {
 253              		.loc 1 103 0
 254 000c 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 255 0010 002B     		cmp	r3, #0
 256 0012 53D0     		beq	.L32
 104:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 257              		.loc 1 104 0
 258 0014 6B06     		lsls	r3, r5, #25
 259 0016 30D4     		bmi	.L59
 105:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 106:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 260              		.loc 1 106 0
 261 0018 6807     		lsls	r0, r5, #29
 262 001a 05D5     		bpl	.L35
 263              	.L41:
 107:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 264              		.loc 1 107 0
 265 001c 236F     		ldr	r3, [r4, #112]
 266 001e 2366     		str	r3, [r4, #96]
 267 0020 E36E     		ldr	r3, [r4, #108]
 268 0022 6366     		str	r3, [r4, #100]
 269 0024 636F     		ldr	r3, [r4, #116]
 270 0026 79E0     		b	.L58
 271              	.L35:
 108:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 272              		.loc 1 108 0
 273 0028 2906     		lsls	r1, r5, #24
 274 002a 52D4     		bmi	.L57
 109:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 110:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 111:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 112:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 275              		.loc 1 112 0
 276 002c EA07     		lsls	r2, r5, #31
 277 002e 07D5     		bpl	.L37
 113:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 278              		.loc 1 113 0
 279 0030 04F16000 		add	r0, r4, #96
 280 0034 04F11C01 		add	r1, r4, #28
 281 0038 221D     		adds	r2, r4, #4
 282 003a FFF7FEFF 		bl	ned_of_ecef_pos_i
 283              	.LVL23:
 284 003e 04E1     		b	.L34
 285              	.L37:
 114:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 286              		.loc 1 114 0
 287 0040 AB06     		lsls	r3, r5, #26
 288 0042 02D5     		bpl	.L38
 115:state.c       ****       /* transform ecef_f -> ned_f, set status bit, then convert to int */
 116:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 289              		.loc 1 116 0
 290 0044 04F1FC00 		add	r0, r4, #252
 291 0048 0DE0     		b	.L60
 292              	.L38:
 117:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 118:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 119:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 293              		.loc 1 119 0
 294 004a E805     		lsls	r0, r5, #23
 295 004c 2AD5     		bpl	.L39
 120:state.c       ****       /* transform lla_f -> ecef_f -> ned_f, set status bits, then convert to int */
 121:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 296              		.loc 1 121 0
 297 004e 04F19800 		add	r0, r4, #152
 298 0052 04F18C01 		add	r1, r4, #140
 299 0056 FFF7FEFF 		bl	ecef_of_lla_f
 300              	.LVL24:
 122:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 301              		.loc 1 122 0
 302 005a 2388     		ldrh	r3, [r4]
 303 005c 2046     		mov	r0, r4
 304 005e 43F02003 		orr	r3, r3, #32
 305 0062 20F8FC3B 		strh	r3, [r0], #252	@ movhi
 306              	.L60:
 123:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 307              		.loc 1 123 0
 308 0066 04F1A401 		add	r1, r4, #164
 309 006a 04F19802 		add	r2, r4, #152
 310 006e FFF7FEFF 		bl	ned_of_ecef_point_f
 311              	.LVL25:
 124:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 312              		.loc 1 124 0
 313 0072 2388     		ldrh	r3, [r4]
 314 0074 43F04003 		orr	r3, r3, #64
 315 0078 2380     		strh	r3, [r4]	@ movhi
 316              	.L59:
 125:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 317              		.loc 1 125 0
 318 007a DFED7C7A 		flds	s15, .L61+20
 319 007e 94ED3F7A 		flds	s14, [r4, #252]
 320 0082 27EE277A 		fmuls	s14, s14, s15
 321 0086 BDEEC77A 		ftosizs	s14, s14
 322 008a 84ED187A 		fsts	s14, [r4, #96]	@ int
 323 008e 94ED407A 		flds	s14, [r4, #256]
 324 0092 27EE277A 		fmuls	s14, s14, s15
 325 0096 BDEEC77A 		ftosizs	s14, s14
 326 009a 84ED197A 		fsts	s14, [r4, #100]	@ int
 327 009e 94ED417A 		flds	s14, [r4, #260]
 328 00a2 CCE0     		b	.L54
 329              	.L39:
 126:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 330              		.loc 1 126 0
 331 00a4 2907     		lsls	r1, r5, #28
 332 00a6 40F1D080 		bpl	.L34
 127:state.c       ****       ned_of_lla_point_i(&state.ned_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 333              		.loc 1 127 0
 334 00aa 04F16000 		add	r0, r4, #96
 335 00ae 04F11C01 		add	r1, r4, #28
 336 00b2 04F11002 		add	r2, r4, #16
 337 00b6 FFF7FEFF 		bl	ned_of_lla_point_i
 338              	.LVL26:
 339 00ba C6E0     		b	.L34
 340              	.L32:
 128:state.c       ****     } else { /* could not get this representation,  set errno */
 129:state.c       ****       errno = 1;
 130:state.c       ****     }
 131:state.c       ****   } else if (state.utm_initialized_f) {
 341              		.loc 1 131 0
 342 00bc 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 343 00c0 002B     		cmp	r3, #0
 344 00c2 00F0C280 		beq	.L34
 132:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 345              		.loc 1 132 0
 346 00c6 6A06     		lsls	r2, r5, #25
 347 00c8 D7D4     		bmi	.L59
 133:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 134:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 348              		.loc 1 134 0
 349 00ca 6B07     		lsls	r3, r5, #29
 350 00cc A6D4     		bmi	.L41
 135:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 136:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 351              		.loc 1 136 0
 352 00ce 2806     		lsls	r0, r5, #24
 353 00d0 27D5     		bpl	.L42
 354              	.L57:
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 355              		.loc 1 137 0
 356 00d2 DFED667A 		flds	s15, .L61+20
 357 00d6 94ED427A 		flds	s14, [r4, #264]
 358 00da 27EE277A 		fmuls	s14, s14, s15
 138:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 359              		.loc 1 138 0
 360 00de 45F00405 		orr	r5, r5, #4
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 361              		.loc 1 137 0
 362 00e2 BDEEC77A 		ftosizs	s14, s14
 363              		.loc 1 138 0
 364 00e6 2580     		strh	r5, [r4]	@ movhi
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 365              		.loc 1 137 0
 366 00e8 17EE102A 		fmrs	r2, s14	@ int
 367 00ec 84ED1B7A 		fsts	s14, [r4, #108]	@ int
 368 00f0 94ED437A 		flds	s14, [r4, #268]
 139:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 369              		.loc 1 139 0
 370 00f4 6266     		str	r2, [r4, #100]
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 371              		.loc 1 137 0
 372 00f6 27EE277A 		fmuls	s14, s14, s15
 373 00fa BDEEC77A 		ftosizs	s14, s14
 374 00fe 17EE101A 		fmrs	r1, s14	@ int
 375 0102 84ED1C7A 		fsts	s14, [r4, #112]	@ int
 376 0106 94ED447A 		flds	s14, [r4, #272]
 377              		.loc 1 139 0
 378 010a 2166     		str	r1, [r4, #96]
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 379              		.loc 1 137 0
 380 010c 67EE277A 		fmuls	s15, s14, s15
 381 0110 FDEEE77A 		ftosizs	s15, s15
 382 0114 17EE903A 		fmrs	r3, s15	@ int
 383 0118 C4ED1D7A 		fsts	s15, [r4, #116]	@ int
 384              	.L58:
 385              		.loc 1 139 0
 386 011c 5B42     		negs	r3, r3
 387 011e A366     		str	r3, [r4, #104]
 388 0120 93E0     		b	.L34
 389              	.L42:
 140:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 390              		.loc 1 140 0
 391 0122 A905     		lsls	r1, r5, #22
 392 0124 1BD5     		bpl	.L43
 141:state.c       ****       /* transform utm_f -> ned_f -> ned_i, set status bits */
 142:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 393              		.loc 1 142 0
 394 0126 D4ED3A7A 		flds	s15, [r4, #232]
 395 012a 94ED1E6A 		flds	s12, [r4, #120]
 396 012e D4ED1F6A 		flds	s13, [r4, #124]
 397 0132 94ED3C7A 		flds	s14, [r4, #240]
 398 0136 36EE676A 		fsubs	s12, s12, s15
 399 013a D4ED3B7A 		flds	s15, [r4, #236]
 400 013e 84ED3F6A 		fsts	s12, [r4, #252]
 401 0142 76EEE76A 		fsubs	s13, s13, s15
 402 0146 D4ED207A 		flds	s15, [r4, #128]
 403 014a C4ED406A 		fsts	s13, [r4, #256]
 404 014e 37EE677A 		fsubs	s14, s14, s15
 143:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 405              		.loc 1 143 0
 406 0152 45F04005 		orr	r5, r5, #64
 142:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 407              		.loc 1 142 0
 408 0156 84ED417A 		fsts	s14, [r4, #260]
 409              		.loc 1 143 0
 410 015a 2580     		strh	r5, [r4]	@ movhi
 411 015c 61E0     		b	.L56
 412              	.L43:
 144:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 145:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 413              		.loc 1 145 0
 414 015e EA05     		lsls	r2, r5, #23
 415 0160 02D5     		bpl	.L44
 146:state.c       ****       /* transform lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 147:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 416              		.loc 1 147 0
 417 0162 04F17800 		add	r0, r4, #120
 418 0166 3CE0     		b	.L55
 419              	.L44:
 148:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 149:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 150:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 151:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 152:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 420              		.loc 1 152 0
 421 0168 2B07     		lsls	r3, r5, #28
 422 016a 6ED5     		bpl	.L34
 153:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 154:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 423              		.loc 1 154 0
 424 016c D4ED047A 		flds	s15, [r4, #16]	@ int
 425 0170 F8EEE77A 		fsitos	s15, s15
 155:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 426              		.loc 1 155 0
 427 0174 45F48075 		orr	r5, r5, #256
 154:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 428              		.loc 1 154 0
 429 0178 17EE900A 		fmrs	r0, s15
 430 017c FFF7FEFF 		bl	__aeabi_f2d
 431              	.LVL27:
 432 0180 35A3     		adr	r3, .L61
 433 0182 D3E90023 		ldrd	r2, [r3]
 434 0186 FFF7FEFF 		bl	__aeabi_dmul
 435              	.LVL28:
 436 018a 35A3     		adr	r3, .L61+8
 437 018c D3E90023 		ldrd	r2, [r3]
 438 0190 FFF7FEFF 		bl	__aeabi_ddiv
 439              	.LVL29:
 440 0194 FFF7FEFF 		bl	__aeabi_d2f
 441              	.LVL30:
 442 0198 D4ED057A 		flds	s15, [r4, #20]	@ int
 443 019c C4F88C00 		str	r0, [r4, #140]	@ float
 444 01a0 F8EEE77A 		fsitos	s15, s15
 445 01a4 17EE900A 		fmrs	r0, s15
 446 01a8 FFF7FEFF 		bl	__aeabi_f2d
 447              	.LVL31:
 448 01ac 2AA3     		adr	r3, .L61
 449 01ae D3E90023 		ldrd	r2, [r3]
 450 01b2 FFF7FEFF 		bl	__aeabi_dmul
 451              	.LVL32:
 452 01b6 2AA3     		adr	r3, .L61+8
 453 01b8 D3E90023 		ldrd	r2, [r3]
 454 01bc FFF7FEFF 		bl	__aeabi_ddiv
 455              	.LVL33:
 456 01c0 FFF7FEFF 		bl	__aeabi_d2f
 457              	.LVL34:
 458 01c4 D4ED067A 		flds	s15, [r4, #24]	@ int
 459 01c8 C4F89000 		str	r0, [r4, #144]	@ float
 460 01cc B8EEE77A 		fsitos	s14, s15
 461 01d0 DFED277A 		flds	s15, .L61+24
 462 01d4 C7EE277A 		fdivs	s15, s14, s15
 463              		.loc 1 155 0
 464 01d8 2046     		mov	r0, r4
 465 01da 20F8785B 		strh	r5, [r0], #120	@ movhi
 154:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 466              		.loc 1 154 0
 467 01de C4ED257A 		fsts	s15, [r4, #148]
 468              	.L55:
 156:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 469              		.loc 1 156 0
 470 01e2 04F18C01 		add	r1, r4, #140
 471 01e6 FFF7FEFF 		bl	utm_of_lla_f
 472              	.LVL35:
 157:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 158:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 473              		.loc 1 158 0
 474 01ea D4ED3A7A 		flds	s15, [r4, #232]
 475 01ee 94ED1E6A 		flds	s12, [r4, #120]
 476 01f2 D4ED1F6A 		flds	s13, [r4, #124]
 477 01f6 94ED3C7A 		flds	s14, [r4, #240]
 157:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 478              		.loc 1 157 0
 479 01fa 2388     		ldrh	r3, [r4]
 480              		.loc 1 158 0
 481 01fc 36EE676A 		fsubs	s12, s12, s15
 482 0200 D4ED3B7A 		flds	s15, [r4, #236]
 483 0204 84ED3F6A 		fsts	s12, [r4, #252]
 484 0208 76EEE76A 		fsubs	s13, s13, s15
 485 020c D4ED207A 		flds	s15, [r4, #128]
 486 0210 C4ED406A 		fsts	s13, [r4, #256]
 487 0214 37EE677A 		fsubs	s14, s14, s15
 159:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 488              		.loc 1 159 0
 489 0218 43F41073 		orr	r3, r3, #576
 158:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 490              		.loc 1 158 0
 491 021c 84ED417A 		fsts	s14, [r4, #260]
 492              		.loc 1 159 0
 493 0220 2380     		strh	r3, [r4]	@ movhi
 494              	.L56:
 160:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 495              		.loc 1 160 0
 496 0222 DFED127A 		flds	s15, .L61+20
 497 0226 26EE276A 		fmuls	s12, s12, s15
 498 022a 66EEA76A 		fmuls	s13, s13, s15
 499 022e BDEEC66A 		ftosizs	s12, s12
 500 0232 FDEEE66A 		ftosizs	s13, s13
 501 0236 84ED186A 		fsts	s12, [r4, #96]	@ int
 502 023a C4ED196A 		fsts	s13, [r4, #100]	@ int
 503              	.L54:
 504 023e 67EE277A 		fmuls	s15, s14, s15
 505 0242 FDEEE77A 		ftosizs	s15, s15
 506 0246 C4ED1A7A 		fsts	s15, [r4, #104]	@ int
 507              	.L34:
 161:state.c       ****     } else { /* could not get this representation,  set errno */
 162:state.c       ****       errno = 2;
 163:state.c       ****     }
 164:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 165:state.c       ****     errno = 3;
 166:state.c       ****   }
 167:state.c       ****   if (errno) {
 168:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 169:state.c       ****     //return _ned_zero;
 170:state.c       ****   }
 171:state.c       ****   /* set bit to indicate this representation is computed */
 172:state.c       ****   SetBit(state.pos_status, POS_NED_I);
 508              		.loc 1 172 0
 509 024a 2388     		ldrh	r3, [r4]
 510 024c 43F00203 		orr	r3, r3, #2
 511 0250 2380     		strh	r3, [r4]	@ movhi
 512              	.LVL36:
 513              	.L30:
 514 0252 38BD     		pop	{r3, r4, r5, pc}
 515              	.L62:
 516 0254 AFF30080 		.align	3
 517              	.L61:
 518 0258 399D52A2 		.word	-1571644103
 519 025c 46DF913F 		.word	1066524486
 520 0260 00000000 		.word	0
 521 0264 D0126341 		.word	1097011920
 522 0268 00000000 		.word	.LANCHOR0
 523 026c 00008043 		.word	1132462080
 524 0270 00007A44 		.word	1148846080
 525              		.cfi_endproc
 526              	.LFE141:
 528 0274 AFF30080 		.section	.text.stateCalcPositionEnu_i,"ax",%progbits
 529              		.align	1
 530              		.global	stateCalcPositionEnu_i
 531              		.thumb
 532              		.thumb_func
 534              	stateCalcPositionEnu_i:
 535              	.LFB142:
 173:state.c       **** }
 174:state.c       **** 
 175:state.c       **** void stateCalcPositionEnu_i(void)
 176:state.c       **** {
 536              		.loc 1 176 0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 0
 539              		@ frame_needed = 0, uses_anonymous_args = 0
 540 0000 38B5     		push	{r3, r4, r5, lr}
 541              		.cfi_def_cfa_offset 16
 542              		.cfi_offset 3, -16
 543              		.cfi_offset 4, -12
 544              		.cfi_offset 5, -8
 545              		.cfi_offset 14, -4
 177:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_I)) {
 546              		.loc 1 177 0
 547 0002 974C     		ldr	r4, .L94+16
 548 0004 2588     		ldrh	r5, [r4]
 549 0006 6A07     		lsls	r2, r5, #29
 550 0008 00F12081 		bmi	.L63
 551              	.LVL37:
 178:state.c       ****     return;
 179:state.c       ****   }
 180:state.c       **** 
 181:state.c       ****   int errno = 0;
 182:state.c       ****   if (state.ned_initialized_i) {
 552              		.loc 1 182 0
 553 000c 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 554 0010 002B     		cmp	r3, #0
 555 0012 50D0     		beq	.L65
 183:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 556              		.loc 1 183 0
 557 0014 AB07     		lsls	r3, r5, #30
 558 0016 05D5     		bpl	.L66
 559              	.L74:
 184:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 560              		.loc 1 184 0
 561 0018 636E     		ldr	r3, [r4, #100]
 562 001a E366     		str	r3, [r4, #108]
 563 001c 236E     		ldr	r3, [r4, #96]
 564 001e 2367     		str	r3, [r4, #112]
 565 0020 A36E     		ldr	r3, [r4, #104]
 566 0022 78E0     		b	.L87
 567              	.L66:
 185:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 568              		.loc 1 185 0
 569 0024 2806     		lsls	r0, r5, #24
 570 0026 25D4     		bmi	.L93
 186:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 187:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 571              		.loc 1 187 0
 572 0028 6906     		lsls	r1, r5, #25
 573 002a 4FD4     		bmi	.L91
 188:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 189:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 190:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 191:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 574              		.loc 1 191 0
 575 002c EA07     		lsls	r2, r5, #31
 576 002e 07D5     		bpl	.L70
 192:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 577              		.loc 1 192 0
 578 0030 04F16C00 		add	r0, r4, #108
 579 0034 04F11C01 		add	r1, r4, #28
 580 0038 221D     		adds	r2, r4, #4
 581 003a FFF7FEFF 		bl	enu_of_ecef_pos_i
 582              	.LVL38:
 583 003e 01E1     		b	.L67
 584              	.L70:
 193:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 585              		.loc 1 193 0
 586 0040 AB06     		lsls	r3, r5, #26
 587 0042 0BD4     		bmi	.L92
 194:state.c       ****       /* transform ecef_f -> enu_f, set status bit, then convert to int */
 195:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 196:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 197:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 198:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 588              		.loc 1 198 0
 589 0044 E805     		lsls	r0, r5, #23
 590 0046 2AD5     		bpl	.L72
 199:state.c       ****       /* transform lla_f -> ecef_f -> enu_f, set status bits, then convert to int */
 200:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 591              		.loc 1 200 0
 592 0048 04F19800 		add	r0, r4, #152
 593 004c 04F18C01 		add	r1, r4, #140
 594 0050 FFF7FEFF 		bl	ecef_of_lla_f
 595              	.LVL39:
 201:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 596              		.loc 1 201 0
 597 0054 2388     		ldrh	r3, [r4]
 598 0056 43F02003 		orr	r3, r3, #32
 599 005a 2380     		strh	r3, [r4]	@ movhi
 600              	.L92:
 202:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 601              		.loc 1 202 0
 602 005c 04F58470 		add	r0, r4, #264
 603 0060 04F1A401 		add	r1, r4, #164
 604 0064 04F19802 		add	r2, r4, #152
 605 0068 FFF7FEFF 		bl	enu_of_ecef_point_f
 606              	.LVL40:
 203:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 607              		.loc 1 203 0
 608 006c 2388     		ldrh	r3, [r4]
 609 006e 43F08003 		orr	r3, r3, #128
 610 0072 2380     		strh	r3, [r4]	@ movhi
 611              	.L93:
 204:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 612              		.loc 1 204 0
 613 0074 DFED7B7A 		flds	s15, .L94+20
 614 0078 94ED427A 		flds	s14, [r4, #264]
 615 007c 27EE277A 		fmuls	s14, s14, s15
 616 0080 BDEEC77A 		ftosizs	s14, s14
 617 0084 84ED1B7A 		fsts	s14, [r4, #108]	@ int
 618 0088 94ED437A 		flds	s14, [r4, #268]
 619 008c 27EE277A 		fmuls	s14, s14, s15
 620 0090 BDEEC77A 		ftosizs	s14, s14
 621 0094 84ED1C7A 		fsts	s14, [r4, #112]	@ int
 622 0098 94ED447A 		flds	s14, [r4, #272]
 623 009c CCE0     		b	.L90
 624              	.L72:
 205:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 625              		.loc 1 205 0
 626 009e 2907     		lsls	r1, r5, #28
 627 00a0 40F1D080 		bpl	.L67
 206:state.c       ****       enu_of_lla_point_i(&state.enu_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 628              		.loc 1 206 0
 629 00a4 04F16C00 		add	r0, r4, #108
 630 00a8 04F11C01 		add	r1, r4, #28
 631 00ac 04F11002 		add	r2, r4, #16
 632 00b0 FFF7FEFF 		bl	enu_of_lla_point_i
 633              	.LVL41:
 634 00b4 C6E0     		b	.L67
 635              	.L65:
 207:state.c       ****     } else { /* could not get this representation,  set errno */
 208:state.c       ****       errno = 1;
 209:state.c       ****     }
 210:state.c       ****   } else if (state.utm_initialized_f) {
 636              		.loc 1 210 0
 637 00b6 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 638 00ba 002B     		cmp	r3, #0
 639 00bc 00F0C280 		beq	.L67
 211:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_F)) {
 640              		.loc 1 211 0
 641 00c0 2A06     		lsls	r2, r5, #24
 642 00c2 D7D4     		bmi	.L93
 212:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 213:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 643              		.loc 1 213 0
 644 00c4 AB07     		lsls	r3, r5, #30
 645 00c6 A7D4     		bmi	.L74
 214:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 215:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 646              		.loc 1 215 0
 647 00c8 6806     		lsls	r0, r5, #25
 648 00ca 27D5     		bpl	.L75
 649              	.L91:
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 650              		.loc 1 216 0
 651 00cc DFED657A 		flds	s15, .L94+20
 652 00d0 94ED3F7A 		flds	s14, [r4, #252]
 653 00d4 27EE277A 		fmuls	s14, s14, s15
 217:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 654              		.loc 1 217 0
 655 00d8 45F00205 		orr	r5, r5, #2
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 656              		.loc 1 216 0
 657 00dc BDEEC77A 		ftosizs	s14, s14
 658              		.loc 1 217 0
 659 00e0 2580     		strh	r5, [r4]	@ movhi
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 660              		.loc 1 216 0
 661 00e2 17EE102A 		fmrs	r2, s14	@ int
 662 00e6 84ED187A 		fsts	s14, [r4, #96]	@ int
 663 00ea 94ED407A 		flds	s14, [r4, #256]
 218:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 664              		.loc 1 218 0
 665 00ee 2267     		str	r2, [r4, #112]
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 666              		.loc 1 216 0
 667 00f0 27EE277A 		fmuls	s14, s14, s15
 668 00f4 BDEEC77A 		ftosizs	s14, s14
 669 00f8 17EE101A 		fmrs	r1, s14	@ int
 670 00fc 84ED197A 		fsts	s14, [r4, #100]	@ int
 671 0100 94ED417A 		flds	s14, [r4, #260]
 672              		.loc 1 218 0
 673 0104 E166     		str	r1, [r4, #108]
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 674              		.loc 1 216 0
 675 0106 67EE277A 		fmuls	s15, s14, s15
 676 010a FDEEE77A 		ftosizs	s15, s15
 677 010e 17EE903A 		fmrs	r3, s15	@ int
 678 0112 C4ED1A7A 		fsts	s15, [r4, #104]	@ int
 679              	.L87:
 680              		.loc 1 218 0
 681 0116 5B42     		negs	r3, r3
 682 0118 6367     		str	r3, [r4, #116]
 683 011a 93E0     		b	.L67
 684              	.L75:
 219:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 685              		.loc 1 219 0
 686 011c A905     		lsls	r1, r5, #22
 687 011e 1BD5     		bpl	.L76
 220:state.c       ****       /* transform utm_f -> enu_f -> enu_i , set status bits */
 221:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 688              		.loc 1 221 0
 689 0120 D4ED3B7A 		flds	s15, [r4, #236]
 690 0124 94ED1F6A 		flds	s12, [r4, #124]
 691 0128 D4ED1E6A 		flds	s13, [r4, #120]
 692 012c 94ED207A 		flds	s14, [r4, #128]
 693 0130 36EE676A 		fsubs	s12, s12, s15
 694 0134 D4ED3A7A 		flds	s15, [r4, #232]
 695 0138 84ED426A 		fsts	s12, [r4, #264]
 696 013c 76EEE76A 		fsubs	s13, s13, s15
 697 0140 D4ED3C7A 		flds	s15, [r4, #240]
 698 0144 C4ED436A 		fsts	s13, [r4, #268]
 699 0148 37EE677A 		fsubs	s14, s14, s15
 222:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 700              		.loc 1 222 0
 701 014c 45F08005 		orr	r5, r5, #128
 221:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 702              		.loc 1 221 0
 703 0150 84ED447A 		fsts	s14, [r4, #272]
 704              		.loc 1 222 0
 705 0154 2580     		strh	r5, [r4]	@ movhi
 706 0156 61E0     		b	.L89
 707              	.L76:
 223:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 224:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 708              		.loc 1 224 0
 709 0158 EA05     		lsls	r2, r5, #23
 710 015a 02D5     		bpl	.L77
 225:state.c       ****       /* transform lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 226:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 711              		.loc 1 226 0
 712 015c 04F17800 		add	r0, r4, #120
 713 0160 3CE0     		b	.L88
 714              	.L77:
 227:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 228:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 229:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 230:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 231:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 715              		.loc 1 231 0
 716 0162 2B07     		lsls	r3, r5, #28
 717 0164 6ED5     		bpl	.L67
 232:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 233:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 718              		.loc 1 233 0
 719 0166 D4ED047A 		flds	s15, [r4, #16]	@ int
 720 016a F8EEE77A 		fsitos	s15, s15
 234:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 721              		.loc 1 234 0
 722 016e 45F48075 		orr	r5, r5, #256
 233:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 723              		.loc 1 233 0
 724 0172 17EE900A 		fmrs	r0, s15
 725 0176 FFF7FEFF 		bl	__aeabi_f2d
 726              	.LVL42:
 727 017a 35A3     		adr	r3, .L94
 728 017c D3E90023 		ldrd	r2, [r3]
 729 0180 FFF7FEFF 		bl	__aeabi_dmul
 730              	.LVL43:
 731 0184 34A3     		adr	r3, .L94+8
 732 0186 D3E90023 		ldrd	r2, [r3]
 733 018a FFF7FEFF 		bl	__aeabi_ddiv
 734              	.LVL44:
 735 018e FFF7FEFF 		bl	__aeabi_d2f
 736              	.LVL45:
 737 0192 D4ED057A 		flds	s15, [r4, #20]	@ int
 738 0196 C4F88C00 		str	r0, [r4, #140]	@ float
 739 019a F8EEE77A 		fsitos	s15, s15
 740 019e 17EE900A 		fmrs	r0, s15
 741 01a2 FFF7FEFF 		bl	__aeabi_f2d
 742              	.LVL46:
 743 01a6 2AA3     		adr	r3, .L94
 744 01a8 D3E90023 		ldrd	r2, [r3]
 745 01ac FFF7FEFF 		bl	__aeabi_dmul
 746              	.LVL47:
 747 01b0 29A3     		adr	r3, .L94+8
 748 01b2 D3E90023 		ldrd	r2, [r3]
 749 01b6 FFF7FEFF 		bl	__aeabi_ddiv
 750              	.LVL48:
 751 01ba FFF7FEFF 		bl	__aeabi_d2f
 752              	.LVL49:
 753 01be D4ED067A 		flds	s15, [r4, #24]	@ int
 754 01c2 C4F89000 		str	r0, [r4, #144]	@ float
 755 01c6 B8EEE77A 		fsitos	s14, s15
 756 01ca DFED277A 		flds	s15, .L94+24
 757 01ce C7EE277A 		fdivs	s15, s14, s15
 758              		.loc 1 234 0
 759 01d2 2046     		mov	r0, r4
 760 01d4 20F8785B 		strh	r5, [r0], #120	@ movhi
 233:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 761              		.loc 1 233 0
 762 01d8 C4ED257A 		fsts	s15, [r4, #148]
 763              	.L88:
 235:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 764              		.loc 1 235 0
 765 01dc 04F18C01 		add	r1, r4, #140
 766 01e0 FFF7FEFF 		bl	utm_of_lla_f
 767              	.LVL50:
 236:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 237:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 768              		.loc 1 237 0
 769 01e4 D4ED3B7A 		flds	s15, [r4, #236]
 770 01e8 94ED1F6A 		flds	s12, [r4, #124]
 771 01ec D4ED1E6A 		flds	s13, [r4, #120]
 772 01f0 94ED207A 		flds	s14, [r4, #128]
 236:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 773              		.loc 1 236 0
 774 01f4 2388     		ldrh	r3, [r4]
 775              		.loc 1 237 0
 776 01f6 36EE676A 		fsubs	s12, s12, s15
 777 01fa D4ED3A7A 		flds	s15, [r4, #232]
 778 01fe 84ED426A 		fsts	s12, [r4, #264]
 779 0202 76EEE76A 		fsubs	s13, s13, s15
 780 0206 D4ED3C7A 		flds	s15, [r4, #240]
 781 020a C4ED436A 		fsts	s13, [r4, #268]
 782 020e 37EE677A 		fsubs	s14, s14, s15
 238:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 783              		.loc 1 238 0
 784 0212 43F42073 		orr	r3, r3, #640
 237:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 785              		.loc 1 237 0
 786 0216 84ED447A 		fsts	s14, [r4, #272]
 787              		.loc 1 238 0
 788 021a 2380     		strh	r3, [r4]	@ movhi
 789              	.L89:
 239:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 790              		.loc 1 239 0
 791 021c DFED117A 		flds	s15, .L94+20
 792 0220 26EE276A 		fmuls	s12, s12, s15
 793 0224 66EEA76A 		fmuls	s13, s13, s15
 794 0228 BDEEC66A 		ftosizs	s12, s12
 795 022c FDEEE66A 		ftosizs	s13, s13
 796 0230 84ED1B6A 		fsts	s12, [r4, #108]	@ int
 797 0234 C4ED1C6A 		fsts	s13, [r4, #112]	@ int
 798              	.L90:
 799 0238 67EE277A 		fmuls	s15, s14, s15
 800 023c FDEEE77A 		ftosizs	s15, s15
 801 0240 C4ED1D7A 		fsts	s15, [r4, #116]	@ int
 802              	.L67:
 240:state.c       ****     } else { /* could not get this representation,  set errno */
 241:state.c       ****       errno = 2;
 242:state.c       ****     }
 243:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 244:state.c       ****     errno = 3;
 245:state.c       ****   }
 246:state.c       ****   if (errno) {
 247:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 248:state.c       ****     //return _enu_zero;
 249:state.c       ****   }
 250:state.c       ****   /* set bit to indicate this representation is computed */
 251:state.c       ****   SetBit(state.pos_status, POS_ENU_I);
 803              		.loc 1 251 0
 804 0244 2388     		ldrh	r3, [r4]
 805 0246 43F00403 		orr	r3, r3, #4
 806 024a 2380     		strh	r3, [r4]	@ movhi
 807              	.LVL51:
 808              	.L63:
 809 024c 38BD     		pop	{r3, r4, r5, pc}
 810              	.L95:
 811 024e 00BF     		.align	3
 812              	.L94:
 813 0250 399D52A2 		.word	-1571644103
 814 0254 46DF913F 		.word	1066524486
 815 0258 00000000 		.word	0
 816 025c D0126341 		.word	1097011920
 817 0260 00000000 		.word	.LANCHOR0
 818 0264 00008043 		.word	1132462080
 819 0268 00007A44 		.word	1148846080
 820              		.cfi_endproc
 821              	.LFE142:
 823 026c AFF30080 		.section	.text.stateCalcPositionLla_i,"ax",%progbits
 824              		.align	1
 825              		.global	stateCalcPositionLla_i
 826              		.thumb
 827              		.thumb_func
 829              	stateCalcPositionLla_i:
 830              	.LFB143:
 252:state.c       **** }
 253:state.c       **** 
 254:state.c       **** /**
 255:state.c       ****  * Calculate LLA (int) from any other available representation.
 256:state.c       ****  * Note that since LLA in float has bad precision this is the last choice.
 257:state.c       ****  * So we mostly first convert to ECEF and then use lla_of_ecef_i
 258:state.c       ****  * which provides higher precision but is currently using the double function internally.
 259:state.c       ****  */
 260:state.c       **** void stateCalcPositionLla_i(void)
 261:state.c       **** {
 831              		.loc 1 261 0
 832              		.cfi_startproc
 833              		@ args = 0, pretend = 0, frame = 0
 834              		@ frame_needed = 0, uses_anonymous_args = 0
 835 0000 70B5     		push	{r4, r5, r6, lr}
 836              		.cfi_def_cfa_offset 16
 837              		.cfi_offset 4, -16
 838              		.cfi_offset 5, -12
 839              		.cfi_offset 6, -8
 840              		.cfi_offset 14, -4
 262:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I)) {
 841              		.loc 1 262 0
 842 0002 7B4C     		ldr	r4, .L138+16
 843 0004 2588     		ldrh	r5, [r4]
 844 0006 2807     		lsls	r0, r5, #28
 845 0008 00F1E980 		bmi	.L96
 263:state.c       ****     return;
 264:state.c       ****   }
 265:state.c       **** 
 266:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 846              		.loc 1 266 0
 847 000c E907     		lsls	r1, r5, #31
 848 000e 02D5     		bpl	.L98
 267:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 849              		.loc 1 267 0
 850 0010 04F11000 		add	r0, r4, #16
 851 0014 27E0     		b	.L133
 852              	.L98:
 268:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 853              		.loc 1 268 0
 854 0016 AA06     		lsls	r2, r5, #26
 855 0018 29D5     		bpl	.L100
 269:state.c       ****     /* transform ecef_f -> ecef_i -> lla_i, set status bits */
 270:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 856              		.loc 1 270 0
 857 001a D4F89800 		ldr	r0, [r4, #152]	@ float
 858 001e FFF7FEFF 		bl	__aeabi_f2d
 859              	.LVL52:
 860 0022 0022     		movs	r2, #0
 861 0024 734B     		ldr	r3, .L138+20
 862 0026 FFF7FEFF 		bl	__aeabi_dmul
 863              	.LVL53:
 864 002a FFF7FEFF 		bl	__aeabi_d2iz
 865              	.LVL54:
 866 002e 6060     		str	r0, [r4, #4]
 867 0030 D4F89C00 		ldr	r0, [r4, #156]	@ float
 868 0034 FFF7FEFF 		bl	__aeabi_f2d
 869              	.LVL55:
 870 0038 0022     		movs	r2, #0
 871 003a 6E4B     		ldr	r3, .L138+20
 872 003c FFF7FEFF 		bl	__aeabi_dmul
 873              	.LVL56:
 874 0040 FFF7FEFF 		bl	__aeabi_d2iz
 875              	.LVL57:
 876 0044 A060     		str	r0, [r4, #8]
 877 0046 D4F8A000 		ldr	r0, [r4, #160]	@ float
 878 004a FFF7FEFF 		bl	__aeabi_f2d
 879              	.LVL58:
 880 004e 0022     		movs	r2, #0
 881 0050 684B     		ldr	r3, .L138+20
 882 0052 FFF7FEFF 		bl	__aeabi_dmul
 883              	.LVL59:
 884 0056 FFF7FEFF 		bl	__aeabi_d2iz
 885              	.LVL60:
 886 005a E060     		str	r0, [r4, #12]
 271:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 887              		.loc 1 271 0
 888 005c 2046     		mov	r0, r4
 889 005e 45F00105 		orr	r5, r5, #1
 890 0062 20F8105B 		strh	r5, [r0], #16	@ movhi
 891              	.L133:
 272:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 892              		.loc 1 272 0
 893 0066 211D     		adds	r1, r4, #4
 894              	.L135:
 895 0068 FFF7FEFF 		bl	lla_of_ecef_i
 896              	.LVL61:
 897 006c B3E0     		b	.L99
 898              	.L100:
 273:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_i) {
 899              		.loc 1 273 0
 900 006e AB07     		lsls	r3, r5, #30
 901 0070 10D5     		bpl	.L101
 902              		.loc 1 273 0 is_stmt 0 discriminator 1
 903 0072 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 904 0076 6BB1     		cbz	r3, .L101
 274:state.c       ****     /* transform ned_i -> ecef_i -> lla_i, set status bits */
 275:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 905              		.loc 1 275 0 is_stmt 1
 906 0078 201D     		adds	r0, r4, #4
 907 007a 04F11C01 		add	r1, r4, #28
 908 007e 04F16002 		add	r2, r4, #96
 909 0082 FFF7FEFF 		bl	ecef_of_ned_pos_i
 910              	.LVL62:
 276:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 911              		.loc 1 276 0
 912 0086 2388     		ldrh	r3, [r4]
 913 0088 2046     		mov	r0, r4
 914 008a 43F00103 		orr	r3, r3, #1
 915 008e 20F8103B 		strh	r3, [r0], #16	@ movhi
 916 0092 E8E7     		b	.L133
 917              	.L101:
 277:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 278:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ENU_I) && state.ned_initialized_i) {
 918              		.loc 1 278 0
 919 0094 6E07     		lsls	r6, r5, #29
 920 0096 05D5     		bpl	.L102
 921              		.loc 1 278 0 is_stmt 0 discriminator 1
 922 0098 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 923 009c 544E     		ldr	r6, .L138+16
 924 009e 0BB1     		cbz	r3, .L102
 279:state.c       ****     /* transform enu_i -> ecef_i -> lla_i, set status bits */
 280:state.c       ****     ecef_of_enu_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.enu_pos_i);
 925              		.loc 1 280 0 is_stmt 1
 926 00a0 301D     		adds	r0, r6, #4
 927 00a2 50E0     		b	.L137
 928              	.L102:
 281:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 282:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 283:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_i) {
 929              		.loc 1 283 0
 930 00a4 6806     		lsls	r0, r5, #25
 931 00a6 29D5     		bpl	.L103
 932              		.loc 1 283 0 is_stmt 0 discriminator 1
 933 00a8 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 934 00ac 504E     		ldr	r6, .L138+16
 935 00ae 2BB3     		cbz	r3, .L103
 284:state.c       ****     /* transform ned_f -> ned_i -> ecef_i -> lla_i, set status bits */
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 936              		.loc 1 285 0 is_stmt 1
 937 00b0 DFED517A 		flds	s15, .L138+24
 938 00b4 96ED3F7A 		flds	s14, [r6, #252]
 939 00b8 27EE277A 		fmuls	s14, s14, s15
 286:state.c       ****     SetBit(state.pos_status, POS_NED_I);
 940              		.loc 1 286 0
 941 00bc 3046     		mov	r0, r6
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 942              		.loc 1 285 0
 943 00be BDEEC77A 		ftosizs	s14, s14
 944              		.loc 1 286 0
 945 00c2 45F00205 		orr	r5, r5, #2
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 946              		.loc 1 285 0
 947 00c6 86ED187A 		fsts	s14, [r6, #96]	@ int
 948 00ca 96ED407A 		flds	s14, [r6, #256]
 949              		.loc 1 286 0
 950 00ce 20F8045B 		strh	r5, [r0], #4	@ movhi
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 951              		.loc 1 285 0
 952 00d2 27EE277A 		fmuls	s14, s14, s15
 287:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 953              		.loc 1 287 0
 954 00d6 06F11C01 		add	r1, r6, #28
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 955              		.loc 1 285 0
 956 00da BDEEC77A 		ftosizs	s14, s14
 957              		.loc 1 287 0
 958 00de 06F16002 		add	r2, r6, #96
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 959              		.loc 1 285 0
 960 00e2 86ED197A 		fsts	s14, [r6, #100]	@ int
 961 00e6 96ED417A 		flds	s14, [r6, #260]
 962 00ea 67EE277A 		fmuls	s15, s14, s15
 963 00ee FDEEE77A 		ftosizs	s15, s15
 964 00f2 C6ED1A7A 		fsts	s15, [r6, #104]	@ int
 965              		.loc 1 287 0
 966 00f6 FFF7FEFF 		bl	ecef_of_ned_pos_i
 967              	.LVL63:
 968 00fa 2AE0     		b	.L136
 969              	.L103:
 288:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 289:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 290:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ENU_F) && state.ned_initialized_i) {
 970              		.loc 1 290 0
 971 00fc 2906     		lsls	r1, r5, #24
 972 00fe 30D5     		bpl	.L104
 973              		.loc 1 290 0 is_stmt 0 discriminator 1
 974 0100 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 975 0104 3A4E     		ldr	r6, .L138+16
 976 0106 63B3     		cbz	r3, .L104
 291:state.c       ****     /* transform enu_f -> enu_i -> ecef_i -> lla_i, set status bits */
 292:state.c       ****     ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 977              		.loc 1 292 0 is_stmt 1
 978 0108 DFED3B7A 		flds	s15, .L138+24
 979 010c 96ED427A 		flds	s14, [r6, #264]
 980 0110 27EE277A 		fmuls	s14, s14, s15
 293:state.c       ****     SetBit(state.pos_status, POS_ENU_I);
 981              		.loc 1 293 0
 982 0114 3046     		mov	r0, r6
 292:state.c       ****     ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 983              		.loc 1 292 0
 984 0116 BDEEC77A 		ftosizs	s14, s14
 985              		.loc 1 293 0
 986 011a 45F00405 		orr	r5, r5, #4
 292:state.c       ****     ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 987              		.loc 1 292 0
 988 011e 86ED1B7A 		fsts	s14, [r6, #108]	@ int
 989 0122 96ED437A 		flds	s14, [r6, #268]
 990              		.loc 1 293 0
 991 0126 20F8045B 		strh	r5, [r0], #4	@ movhi
 292:state.c       ****     ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 992              		.loc 1 292 0
 993 012a 27EE277A 		fmuls	s14, s14, s15
 994 012e BDEEC77A 		ftosizs	s14, s14
 995 0132 86ED1C7A 		fsts	s14, [r6, #112]	@ int
 996 0136 96ED447A 		flds	s14, [r6, #272]
 997 013a 67EE277A 		fmuls	s15, s14, s15
 998 013e FDEEE77A 		ftosizs	s15, s15
 999 0142 C6ED1D7A 		fsts	s15, [r6, #116]	@ int
 1000              	.L137:
 294:state.c       ****     ecef_of_enu_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.enu_pos_i);
 1001              		.loc 1 294 0
 1002 0146 06F11C01 		add	r1, r6, #28
 1003 014a 06F16C02 		add	r2, r6, #108
 1004 014e FFF7FEFF 		bl	ecef_of_enu_pos_i
 1005              	.LVL64:
 1006              	.L136:
 295:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 1007              		.loc 1 295 0
 1008 0152 3388     		ldrh	r3, [r6]
 1009 0154 3046     		mov	r0, r6
 1010 0156 43F00103 		orr	r3, r3, #1
 1011 015a 20F8103B 		strh	r3, [r0], #16	@ movhi
 296:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 1012              		.loc 1 296 0
 1013 015e 311D     		adds	r1, r6, #4
 1014 0160 82E7     		b	.L135
 1015              	.L104:
 297:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1016              		.loc 1 297 0
 1017 0162 EA05     		lsls	r2, r5, #23
 1018 0164 0AD4     		bmi	.L134
 298:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 299:state.c       ****   } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1019              		.loc 1 299 0
 1020 0166 AB05     		lsls	r3, r5, #22
 1021 0168 35D5     		bpl	.L99
 300:state.c       ****     /* transform utm_f -> lla_f -> lla_i, set status bits */
 301:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 1022              		.loc 1 301 0
 1023 016a 2448     		ldr	r0, .L138+28
 1024 016c A0F11401 		sub	r1, r0, #20
 1025 0170 FFF7FEFF 		bl	lla_of_utm_f
 1026              	.LVL65:
 302:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1027              		.loc 1 302 0
 1028 0174 2388     		ldrh	r3, [r4]
 1029 0176 43F48073 		orr	r3, r3, #256
 1030 017a 2380     		strh	r3, [r4]	@ movhi
 1031              	.L134:
 303:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 1032              		.loc 1 303 0
 1033 017c D4F88C00 		ldr	r0, [r4, #140]	@ float
 1034 0180 FFF7FEFF 		bl	__aeabi_f2d
 1035              	.LVL66:
 1036 0184 16A3     		adr	r3, .L138
 1037 0186 D3E90023 		ldrd	r2, [r3]
 1038 018a FFF7FEFF 		bl	__aeabi_dmul
 1039              	.LVL67:
 1040 018e 16A3     		adr	r3, .L138+8
 1041 0190 D3E90023 		ldrd	r2, [r3]
 1042 0194 FFF7FEFF 		bl	__aeabi_dmul
 1043              	.LVL68:
 1044 0198 FFF7FEFF 		bl	__aeabi_d2iz
 1045              	.LVL69:
 1046 019c 2061     		str	r0, [r4, #16]
 1047 019e D4F89000 		ldr	r0, [r4, #144]	@ float
 1048 01a2 FFF7FEFF 		bl	__aeabi_f2d
 1049              	.LVL70:
 1050 01a6 0EA3     		adr	r3, .L138
 1051 01a8 D3E90023 		ldrd	r2, [r3]
 1052 01ac FFF7FEFF 		bl	__aeabi_dmul
 1053              	.LVL71:
 1054 01b0 0DA3     		adr	r3, .L138+8
 1055 01b2 D3E90023 		ldrd	r2, [r3]
 1056 01b6 FFF7FEFF 		bl	__aeabi_dmul
 1057              	.LVL72:
 1058 01ba FFF7FEFF 		bl	__aeabi_d2iz
 1059              	.LVL73:
 1060 01be 6061     		str	r0, [r4, #20]
 1061 01c0 D4F89400 		ldr	r0, [r4, #148]	@ float
 1062 01c4 FFF7FEFF 		bl	__aeabi_f2d
 1063              	.LVL74:
 1064 01c8 0022     		movs	r2, #0
 1065 01ca 0D4B     		ldr	r3, .L138+32
 1066 01cc FFF7FEFF 		bl	__aeabi_dmul
 1067              	.LVL75:
 1068 01d0 FFF7FEFF 		bl	__aeabi_d2iz
 1069              	.LVL76:
 1070 01d4 A061     		str	r0, [r4, #24]
 1071              	.L99:
 304:state.c       ****   } else {
 305:state.c       ****     /* could not get this representation,  set errno */
 306:state.c       ****     //struct LlaCoor_i _lla_zero = {0};
 307:state.c       ****     //return _lla_zero;
 308:state.c       ****   }
 309:state.c       ****   /* set bit to indicate this representation is computed */
 310:state.c       ****   SetBit(state.pos_status, POS_LLA_I);
 1072              		.loc 1 310 0
 1073 01d6 2388     		ldrh	r3, [r4]
 1074 01d8 43F00803 		orr	r3, r3, #8
 1075 01dc 2380     		strh	r3, [r4]	@ movhi
 1076              	.L96:
 1077 01de 70BD     		pop	{r4, r5, r6, pc}
 1078              	.L139:
 1079              		.align	3
 1080              	.L138:
 1081 01e0 F8C1631A 		.word	442745336
 1082 01e4 DCA54C40 		.word	1078765020
 1083 01e8 00000000 		.word	0
 1084 01ec D0126341 		.word	1097011920
 1085 01f0 00000000 		.word	.LANCHOR0
 1086 01f4 00005940 		.word	1079574528
 1087 01f8 00008043 		.word	1132462080
 1088 01fc 8C000000 		.word	.LANCHOR0+140
 1089 0200 00408F40 		.word	1083129856
 1090              		.cfi_endproc
 1091              	.LFE143:
 1093 0204 AFF30080 		.section	.text.stateCalcPositionUtm_f,"ax",%progbits
 1094              		.align	1
 1095              		.global	stateCalcPositionUtm_f
 1096              		.thumb
 1097              		.thumb_func
 1099              	stateCalcPositionUtm_f:
 1100              	.LFB144:
 311:state.c       **** }
 312:state.c       **** 
 313:state.c       **** void stateCalcPositionUtm_f(void)
 314:state.c       **** {
 1101              		.loc 1 314 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105 0000 38B5     		push	{r3, r4, r5, lr}
 1106              		.cfi_def_cfa_offset 16
 1107              		.cfi_offset 3, -16
 1108              		.cfi_offset 4, -12
 1109              		.cfi_offset 5, -8
 1110              		.cfi_offset 14, -4
 315:state.c       ****   if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1111              		.loc 1 315 0
 1112 0002 774C     		ldr	r4, .L158+16
 1113 0004 2588     		ldrh	r5, [r4]
 1114 0006 A905     		lsls	r1, r5, #22
 1115 0008 00F1DF80 		bmi	.L140
 316:state.c       ****     return;
 317:state.c       ****   }
 318:state.c       **** 
 319:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1116              		.loc 1 319 0
 1117 000c EA05     		lsls	r2, r5, #23
 1118 000e 02D5     		bpl	.L142
 320:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1119              		.loc 1 320 0
 1120 0010 04F17800 		add	r0, r4, #120
 1121 0014 3CE0     		b	.L154
 1122              	.L142:
 321:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1123              		.loc 1 321 0
 1124 0016 2B07     		lsls	r3, r5, #28
 1125 0018 3FD5     		bpl	.L144
 322:state.c       ****     /* transform lla_i -> lla_f -> utm_f, set status bits */
 323:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1126              		.loc 1 323 0
 1127 001a D4ED045A 		flds	s11, [r4, #16]	@ int
 1128 001e F8EEE55A 		fsitos	s11, s11
 324:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1129              		.loc 1 324 0
 1130 0022 45F48075 		orr	r5, r5, #256
 323:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1131              		.loc 1 323 0
 1132 0026 15EE900A 		fmrs	r0, s11
 1133 002a FFF7FEFF 		bl	__aeabi_f2d
 1134              	.LVL77:
 1135 002e 68A3     		adr	r3, .L158
 1136 0030 D3E90023 		ldrd	r2, [r3]
 1137 0034 FFF7FEFF 		bl	__aeabi_dmul
 1138              	.LVL78:
 1139 0038 67A3     		adr	r3, .L158+8
 1140 003a D3E90023 		ldrd	r2, [r3]
 1141 003e FFF7FEFF 		bl	__aeabi_ddiv
 1142              	.LVL79:
 1143 0042 FFF7FEFF 		bl	__aeabi_d2f
 1144              	.LVL80:
 1145 0046 94ED056A 		flds	s12, [r4, #20]	@ int
 1146 004a C4F88C00 		str	r0, [r4, #140]	@ float
 1147 004e B8EEC66A 		fsitos	s12, s12
 1148 0052 16EE100A 		fmrs	r0, s12
 1149 0056 FFF7FEFF 		bl	__aeabi_f2d
 1150              	.LVL81:
 1151 005a 5DA3     		adr	r3, .L158
 1152 005c D3E90023 		ldrd	r2, [r3]
 1153 0060 FFF7FEFF 		bl	__aeabi_dmul
 1154              	.LVL82:
 1155 0064 5CA3     		adr	r3, .L158+8
 1156 0066 D3E90023 		ldrd	r2, [r3]
 1157 006a FFF7FEFF 		bl	__aeabi_ddiv
 1158              	.LVL83:
 1159 006e FFF7FEFF 		bl	__aeabi_d2f
 1160              	.LVL84:
 1161 0072 D4ED067A 		flds	s15, [r4, #24]	@ int
 1162 0076 C4F89000 		str	r0, [r4, #144]	@ float
 1163 007a B8EEE77A 		fsitos	s14, s15
 1164 007e DFED597A 		flds	s15, .L158+20
 1165 0082 C7EE277A 		fdivs	s15, s14, s15
 1166              		.loc 1 324 0
 1167 0086 2046     		mov	r0, r4
 1168 0088 20F8785B 		strh	r5, [r0], #120	@ movhi
 323:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1169              		.loc 1 323 0
 1170 008c C4ED257A 		fsts	s15, [r4, #148]
 1171              	.L154:
 325:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1172              		.loc 1 325 0
 1173 0090 04F18C01 		add	r1, r4, #140
 1174 0094 FFF7FEFF 		bl	utm_of_lla_f
 1175              	.LVL85:
 1176 0098 93E0     		b	.L143
 1177              	.L144:
 326:state.c       ****   } else if (state.utm_initialized_f) {
 1178              		.loc 1 326 0
 1179 009a 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1180 009e 002B     		cmp	r3, #0
 1181 00a0 00F08F80 		beq	.L143
 327:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1182              		.loc 1 327 0
 1183 00a4 2806     		lsls	r0, r5, #24
 1184 00a6 14D5     		bpl	.L145
 328:state.c       ****       UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
 1185              		.loc 1 328 0
 1186 00a8 94ED3B7A 		flds	s14, [r4, #236]
 1187 00ac D4ED427A 		flds	s15, [r4, #264]
 1188 00b0 77EE277A 		fadds	s15, s14, s15
 1189 00b4 94ED3A7A 		flds	s14, [r4, #232]
 1190 00b8 C4ED1F7A 		fsts	s15, [r4, #124]
 1191 00bc D4ED437A 		flds	s15, [r4, #268]
 1192 00c0 77EE277A 		fadds	s15, s14, s15
 1193 00c4 94ED3C7A 		flds	s14, [r4, #240]
 1194 00c8 C4ED1E7A 		fsts	s15, [r4, #120]
 1195 00cc D4ED447A 		flds	s15, [r4, #272]
 1196 00d0 2CE0     		b	.L157
 1197              	.L145:
 329:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1198              		.loc 1 329 0
 1199 00d2 6907     		lsls	r1, r5, #29
 1200 00d4 2DD5     		bpl	.L146
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1201              		.loc 1 330 0
 1202 00d6 D4ED1B5A 		flds	s11, [r4, #108]	@ int
 1203 00da 94ED1C6A 		flds	s12, [r4, #112]	@ int
 1204 00de DFED427A 		flds	s15, .L158+24
 1205 00e2 F8EEE56A 		fsitos	s13, s11
 1206 00e6 D4ED1D5A 		flds	s11, [r4, #116]	@ int
 1207 00ea B8EEC67A 		fsitos	s14, s12
 1208 00ee B8EEE56A 		fsitos	s12, s11
 1209 00f2 66EEA76A 		fmuls	s13, s13, s15
 1210 00f6 27EE277A 		fmuls	s14, s14, s15
 1211 00fa 66EE277A 		fmuls	s15, s12, s15
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 332:state.c       ****       UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
 1212              		.loc 1 332 0
 1213 00fe 94ED3B6A 		flds	s12, [r4, #236]
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1214              		.loc 1 330 0
 1215 0102 C4ED426A 		fsts	s13, [r4, #264]
 1216              		.loc 1 332 0
 1217 0106 76EE266A 		fadds	s13, s12, s13
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1218              		.loc 1 330 0
 1219 010a 84ED437A 		fsts	s14, [r4, #268]
 1220              		.loc 1 332 0
 1221 010e C4ED1F6A 		fsts	s13, [r4, #124]
 1222 0112 D4ED3A6A 		flds	s13, [r4, #232]
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1223              		.loc 1 330 0
 1224 0116 C4ED447A 		fsts	s15, [r4, #272]
 1225              		.loc 1 332 0
 1226 011a 36EE877A 		fadds	s14, s13, s14
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1227              		.loc 1 331 0
 1228 011e 45F08005 		orr	r5, r5, #128
 1229              		.loc 1 332 0
 1230 0122 84ED1E7A 		fsts	s14, [r4, #120]
 1231 0126 94ED3C7A 		flds	s14, [r4, #240]
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1232              		.loc 1 331 0
 1233 012a 2580     		strh	r5, [r4]	@ movhi
 1234              	.L157:
 1235              		.loc 1 332 0
 1236 012c 77EE277A 		fadds	s15, s14, s15
 1237 0130 45E0     		b	.L156
 1238              	.L146:
 333:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1239              		.loc 1 333 0
 1240 0132 6A06     		lsls	r2, r5, #25
 1241 0134 14D5     		bpl	.L147
 334:state.c       ****       UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
 1242              		.loc 1 334 0
 1243 0136 94ED3B7A 		flds	s14, [r4, #236]
 1244 013a D4ED407A 		flds	s15, [r4, #256]
 1245 013e 77EE277A 		fadds	s15, s14, s15
 1246 0142 94ED3A7A 		flds	s14, [r4, #232]
 1247 0146 C4ED1F7A 		fsts	s15, [r4, #124]
 1248 014a D4ED3F7A 		flds	s15, [r4, #252]
 1249 014e 77EE277A 		fadds	s15, s14, s15
 1250 0152 94ED3C7A 		flds	s14, [r4, #240]
 1251 0156 C4ED1E7A 		fsts	s15, [r4, #120]
 1252 015a D4ED417A 		flds	s15, [r4, #260]
 1253 015e 2CE0     		b	.L155
 1254              	.L147:
 335:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1255              		.loc 1 335 0
 1256 0160 AB07     		lsls	r3, r5, #30
 1257 0162 2ED5     		bpl	.L143
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1258              		.loc 1 336 0
 1259 0164 D4ED195A 		flds	s11, [r4, #100]	@ int
 1260 0168 94ED186A 		flds	s12, [r4, #96]	@ int
 1261 016c DFED1E7A 		flds	s15, .L158+24
 1262 0170 F8EEE56A 		fsitos	s13, s11
 1263 0174 D4ED1A5A 		flds	s11, [r4, #104]	@ int
 1264 0178 B8EEC67A 		fsitos	s14, s12
 1265 017c B8EEE56A 		fsitos	s12, s11
 1266 0180 27EE277A 		fmuls	s14, s14, s15
 1267 0184 66EEA76A 		fmuls	s13, s13, s15
 1268 0188 66EE277A 		fmuls	s15, s12, s15
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 338:state.c       ****       UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
 1269              		.loc 1 338 0
 1270 018c 94ED3B6A 		flds	s12, [r4, #236]
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1271              		.loc 1 336 0
 1272 0190 C4ED406A 		fsts	s13, [r4, #256]
 1273              		.loc 1 338 0
 1274 0194 76EE266A 		fadds	s13, s12, s13
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1275              		.loc 1 336 0
 1276 0198 84ED3F7A 		fsts	s14, [r4, #252]
 1277              		.loc 1 338 0
 1278 019c C4ED1F6A 		fsts	s13, [r4, #124]
 1279 01a0 D4ED3A6A 		flds	s13, [r4, #232]
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1280              		.loc 1 336 0
 1281 01a4 C4ED417A 		fsts	s15, [r4, #260]
 1282              		.loc 1 338 0
 1283 01a8 36EE877A 		fadds	s14, s13, s14
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1284              		.loc 1 337 0
 1285 01ac 45F04005 		orr	r5, r5, #64
 1286              		.loc 1 338 0
 1287 01b0 84ED1E7A 		fsts	s14, [r4, #120]
 1288 01b4 94ED3C7A 		flds	s14, [r4, #240]
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1289              		.loc 1 337 0
 1290 01b8 2580     		strh	r5, [r4]	@ movhi
 1291              	.L155:
 1292              		.loc 1 338 0
 1293 01ba 77EE677A 		fsubs	s15, s14, s15
 1294              	.L156:
 1295 01be C4ED207A 		fsts	s15, [r4, #128]
 1296              	.L143:
 339:state.c       ****     }
 340:state.c       ****   } else {
 341:state.c       ****     /* could not get this representation,  set errno */
 342:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 343:state.c       ****     //return _ecef_zero;
 344:state.c       ****   }
 345:state.c       ****   /* set bit to indicate this representation is computed */
 346:state.c       ****   SetBit(state.pos_status, POS_UTM_F);
 1297              		.loc 1 346 0
 1298 01c2 2388     		ldrh	r3, [r4]
 1299 01c4 43F40073 		orr	r3, r3, #512
 1300 01c8 2380     		strh	r3, [r4]	@ movhi
 1301              	.L140:
 1302 01ca 38BD     		pop	{r3, r4, r5, pc}
 1303              	.L159:
 1304 01cc AFF30080 		.align	3
 1305              	.L158:
 1306 01d0 399D52A2 		.word	-1571644103
 1307 01d4 46DF913F 		.word	1066524486
 1308 01d8 00000000 		.word	0
 1309 01dc D0126341 		.word	1097011920
 1310 01e0 00000000 		.word	.LANCHOR0
 1311 01e4 00007A44 		.word	1148846080
 1312 01e8 0000803B 		.word	998244352
 1313              		.cfi_endproc
 1314              	.LFE144:
 1316              		.global	__aeabi_i2d
 1317 01ec AFF30080 		.section	.text.stateCalcPositionEcef_f,"ax",%progbits
 1318              		.align	1
 1319              		.global	stateCalcPositionEcef_f
 1320              		.thumb
 1321              		.thumb_func
 1323              	stateCalcPositionEcef_f:
 1324              	.LFB145:
 347:state.c       **** }
 348:state.c       **** 
 349:state.c       **** void stateCalcPositionEcef_f(void)
 350:state.c       **** {
 1325              		.loc 1 350 0
 1326              		.cfi_startproc
 1327              		@ args = 0, pretend = 0, frame = 0
 1328              		@ frame_needed = 0, uses_anonymous_args = 0
 1329 0000 38B5     		push	{r3, r4, r5, lr}
 1330              		.cfi_def_cfa_offset 16
 1331              		.cfi_offset 3, -16
 1332              		.cfi_offset 4, -12
 1333              		.cfi_offset 5, -8
 1334              		.cfi_offset 14, -4
 351:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1335              		.loc 1 351 0
 1336 0002 4B4C     		ldr	r4, .L172+16
 1337 0004 2588     		ldrh	r5, [r4]
 1338 0006 AA06     		lsls	r2, r5, #26
 1339 0008 00F18680 		bmi	.L160
 352:state.c       ****     return;
 353:state.c       ****   }
 354:state.c       **** 
 355:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1340              		.loc 1 355 0
 1341 000c EB07     		lsls	r3, r5, #31
 1342 000e 17D4     		bmi	.L170
 356:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 357:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && &state.ned_initialized_f) {
 1343              		.loc 1 357 0
 1344 0010 6806     		lsls	r0, r5, #25
 1345 0012 08D5     		bpl	.L164
 358:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 1346              		.loc 1 358 0
 1347 0014 04F19800 		add	r0, r4, #152
 1348 0018 04F1A401 		add	r1, r4, #164
 1349 001c 04F1FC02 		add	r2, r4, #252
 1350 0020 FFF7FEFF 		bl	ecef_of_ned_point_f
 1351              	.LVL86:
 1352 0024 74E0     		b	.L163
 1353              	.L164:
 359:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && &state.ned_initialized_i) {
 1354              		.loc 1 359 0
 1355 0026 A907     		lsls	r1, r5, #30
 1356 0028 2CD5     		bpl	.L165
 360:state.c       ****     /* transform ned_i -> ecef_i -> ecef_f, set status bits */
 361:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 1357              		.loc 1 361 0
 1358 002a 201D     		adds	r0, r4, #4
 1359 002c 04F11C01 		add	r1, r4, #28
 1360 0030 04F16002 		add	r2, r4, #96
 1361 0034 FFF7FEFF 		bl	ecef_of_ned_pos_i
 1362              	.LVL87:
 362:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 1363              		.loc 1 362 0
 1364 0038 2388     		ldrh	r3, [r4]
 1365 003a 43F02003 		orr	r3, r3, #32
 1366 003e 2380     		strh	r3, [r4]	@ movhi
 1367              	.L170:
 363:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 1368              		.loc 1 363 0
 1369 0040 6068     		ldr	r0, [r4, #4]
 1370 0042 FFF7FEFF 		bl	__aeabi_i2d
 1371              	.LVL88:
 1372 0046 0022     		movs	r2, #0
 1373 0048 3A4B     		ldr	r3, .L172+20
 1374 004a FFF7FEFF 		bl	__aeabi_ddiv
 1375              	.LVL89:
 1376 004e FFF7FEFF 		bl	__aeabi_d2f
 1377              	.LVL90:
 1378 0052 C4F89800 		str	r0, [r4, #152]	@ float
 1379 0056 A068     		ldr	r0, [r4, #8]
 1380 0058 FFF7FEFF 		bl	__aeabi_i2d
 1381              	.LVL91:
 1382 005c 0022     		movs	r2, #0
 1383 005e 354B     		ldr	r3, .L172+20
 1384 0060 FFF7FEFF 		bl	__aeabi_ddiv
 1385              	.LVL92:
 1386 0064 FFF7FEFF 		bl	__aeabi_d2f
 1387              	.LVL93:
 1388 0068 C4F89C00 		str	r0, [r4, #156]	@ float
 1389 006c E068     		ldr	r0, [r4, #12]
 1390 006e FFF7FEFF 		bl	__aeabi_i2d
 1391              	.LVL94:
 1392 0072 0022     		movs	r2, #0
 1393 0074 2F4B     		ldr	r3, .L172+20
 1394 0076 FFF7FEFF 		bl	__aeabi_ddiv
 1395              	.LVL95:
 1396 007a FFF7FEFF 		bl	__aeabi_d2f
 1397              	.LVL96:
 1398 007e C4F8A000 		str	r0, [r4, #160]	@ float
 1399 0082 45E0     		b	.L163
 1400              	.L165:
 364:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1401              		.loc 1 364 0
 1402 0084 EA05     		lsls	r2, r5, #23
 1403 0086 02D5     		bpl	.L166
 365:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1404              		.loc 1 365 0
 1405 0088 04F19800 		add	r0, r4, #152
 1406 008c 3CE0     		b	.L171
 1407              	.L166:
 366:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1408              		.loc 1 366 0
 1409 008e 2B07     		lsls	r3, r5, #28
 1410 0090 3ED5     		bpl	.L163
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1411              		.loc 1 367 0
 1412 0092 D4ED047A 		flds	s15, [r4, #16]	@ int
 1413 0096 F8EEE77A 		fsitos	s15, s15
 368:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1414              		.loc 1 368 0
 1415 009a 45F48075 		orr	r5, r5, #256
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1416              		.loc 1 367 0
 1417 009e 17EE900A 		fmrs	r0, s15
 1418 00a2 FFF7FEFF 		bl	__aeabi_f2d
 1419              	.LVL97:
 1420 00a6 1EA3     		adr	r3, .L172
 1421 00a8 D3E90023 		ldrd	r2, [r3]
 1422 00ac FFF7FEFF 		bl	__aeabi_dmul
 1423              	.LVL98:
 1424 00b0 1DA3     		adr	r3, .L172+8
 1425 00b2 D3E90023 		ldrd	r2, [r3]
 1426 00b6 FFF7FEFF 		bl	__aeabi_ddiv
 1427              	.LVL99:
 1428 00ba FFF7FEFF 		bl	__aeabi_d2f
 1429              	.LVL100:
 1430 00be D4ED057A 		flds	s15, [r4, #20]	@ int
 1431 00c2 C4F88C00 		str	r0, [r4, #140]	@ float
 1432 00c6 F8EEE77A 		fsitos	s15, s15
 1433 00ca 17EE900A 		fmrs	r0, s15
 1434 00ce FFF7FEFF 		bl	__aeabi_f2d
 1435              	.LVL101:
 1436 00d2 13A3     		adr	r3, .L172
 1437 00d4 D3E90023 		ldrd	r2, [r3]
 1438 00d8 FFF7FEFF 		bl	__aeabi_dmul
 1439              	.LVL102:
 1440 00dc 12A3     		adr	r3, .L172+8
 1441 00de D3E90023 		ldrd	r2, [r3]
 1442 00e2 FFF7FEFF 		bl	__aeabi_ddiv
 1443              	.LVL103:
 1444 00e6 FFF7FEFF 		bl	__aeabi_d2f
 1445              	.LVL104:
 1446 00ea D4ED067A 		flds	s15, [r4, #24]	@ int
 1447 00ee C4F89000 		str	r0, [r4, #144]	@ float
 1448 00f2 B8EEE77A 		fsitos	s14, s15
 1449 00f6 DFED107A 		flds	s15, .L172+24
 1450 00fa C7EE277A 		fdivs	s15, s14, s15
 1451              		.loc 1 368 0
 1452 00fe 2046     		mov	r0, r4
 1453 0100 20F8985B 		strh	r5, [r0], #152	@ movhi
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1454              		.loc 1 367 0
 1455 0104 C4ED257A 		fsts	s15, [r4, #148]
 1456              	.L171:
 369:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1457              		.loc 1 369 0
 1458 0108 04F18C01 		add	r1, r4, #140
 1459 010c FFF7FEFF 		bl	ecef_of_lla_f
 1460              	.LVL105:
 1461              	.L163:
 370:state.c       ****   } else {
 371:state.c       ****     /* could not get this representation,  set errno */
 372:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 373:state.c       ****     //return _ecef_zero;
 374:state.c       ****   }
 375:state.c       ****   /* set bit to indicate this representation is computed */
 376:state.c       ****   SetBit(state.pos_status, POS_ECEF_F);
 1462              		.loc 1 376 0
 1463 0110 2388     		ldrh	r3, [r4]
 1464 0112 43F02003 		orr	r3, r3, #32
 1465 0116 2380     		strh	r3, [r4]	@ movhi
 1466              	.L160:
 1467 0118 38BD     		pop	{r3, r4, r5, pc}
 1468              	.L173:
 1469 011a 00BFAFF3 		.align	3
 1469      0080
 1470              	.L172:
 1471 0120 399D52A2 		.word	-1571644103
 1472 0124 46DF913F 		.word	1066524486
 1473 0128 00000000 		.word	0
 1474 012c D0126341 		.word	1097011920
 1475 0130 00000000 		.word	.LANCHOR0
 1476 0134 00005940 		.word	1079574528
 1477 0138 00007A44 		.word	1148846080
 1478              		.cfi_endproc
 1479              	.LFE145:
 1481 013c AFF30080 		.section	.text.stateCalcPositionNed_f,"ax",%progbits
 1482              		.align	1
 1483              		.global	stateCalcPositionNed_f
 1484              		.thumb
 1485              		.thumb_func
 1487              	stateCalcPositionNed_f:
 1488              	.LFB146:
 377:state.c       **** }
 378:state.c       **** 
 379:state.c       **** void stateCalcPositionNed_f(void)
 380:state.c       **** {
 1489              		.loc 1 380 0
 1490              		.cfi_startproc
 1491              		@ args = 0, pretend = 0, frame = 0
 1492              		@ frame_needed = 0, uses_anonymous_args = 0
 1493 0000 38B5     		push	{r3, r4, r5, lr}
 1494              		.cfi_def_cfa_offset 16
 1495              		.cfi_offset 3, -16
 1496              		.cfi_offset 4, -12
 1497              		.cfi_offset 5, -8
 1498              		.cfi_offset 14, -4
 381:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_F)) {
 1499              		.loc 1 381 0
 1500 0002 934C     		ldr	r4, .L202+16
 1501 0004 2588     		ldrh	r5, [r4]
 1502 0006 6806     		lsls	r0, r5, #25
 1503 0008 00F11781 		bmi	.L174
 1504              	.LVL106:
 382:state.c       ****     return;
 383:state.c       ****   }
 384:state.c       **** 
 385:state.c       ****   int errno = 0;
 386:state.c       ****   if (state.ned_initialized_f) {
 1505              		.loc 1 386 0
 1506 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1507 0010 002B     		cmp	r3, #0
 1508 0012 70D0     		beq	.L176
 387:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1509              		.loc 1 387 0
 1510 0014 A907     		lsls	r1, r5, #30
 1511 0016 16D5     		bpl	.L177
 1512              	.L182:
 388:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1513              		.loc 1 388 0
 1514 0018 D4ED185A 		flds	s11, [r4, #96]	@ int
 1515 001c DFED8D7A 		flds	s15, .L202+20
 1516 0020 94ED196A 		flds	s12, [r4, #100]	@ int
 1517 0024 D4ED1A6A 		flds	s13, [r4, #104]	@ int
 1518 0028 B8EEE57A 		fsitos	s14, s11
 1519 002c 27EE277A 		fmuls	s14, s14, s15
 1520 0030 84ED3F7A 		fsts	s14, [r4, #252]
 1521 0034 B8EEC67A 		fsitos	s14, s12
 1522 0038 27EE277A 		fmuls	s14, s14, s15
 1523 003c 84ED407A 		fsts	s14, [r4, #256]
 1524 0040 B8EEE67A 		fsitos	s14, s13
 1525 0044 54E0     		b	.L199
 1526              	.L177:
 389:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1527              		.loc 1 389 0
 1528 0046 AA06     		lsls	r2, r5, #26
 1529 0048 08D5     		bpl	.L179
 390:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1530              		.loc 1 390 0
 1531 004a 04F1FC00 		add	r0, r4, #252
 1532 004e 04F1A401 		add	r1, r4, #164
 1533 0052 04F19802 		add	r2, r4, #152
 1534 0056 FFF7FEFF 		bl	ned_of_ecef_point_f
 1535              	.LVL107:
 1536 005a EAE0     		b	.L178
 1537              	.L179:
 391:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1538              		.loc 1 391 0
 1539 005c EB07     		lsls	r3, r5, #31
 1540 005e 0FD5     		bpl	.L180
 392:state.c       ****       /* transform ecef_i -> ned_i -> ned_f, set status bits */
 393:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1541              		.loc 1 393 0
 1542 0060 04F16000 		add	r0, r4, #96
 1543 0064 04F11C01 		add	r1, r4, #28
 1544 0068 221D     		adds	r2, r4, #4
 1545 006a FFF7FEFF 		bl	ned_of_ecef_pos_i
 1546              	.LVL108:
 394:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1547              		.loc 1 394 0
 1548 006e 2388     		ldrh	r3, [r4]
 395:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1549              		.loc 1 395 0
 1550 0070 D4ED187A 		flds	s15, [r4, #96]	@ int
 394:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1551              		.loc 1 394 0
 1552 0074 43F00203 		orr	r3, r3, #2
 1553 0078 2380     		strh	r3, [r4]	@ movhi
 1554              		.loc 1 395 0
 1555 007a B8EEE77A 		fsitos	s14, s15
 1556 007e 25E0     		b	.L201
 1557              	.L180:
 396:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1558              		.loc 1 396 0
 1559 0080 E805     		lsls	r0, r5, #23
 1560 0082 08D5     		bpl	.L181
 397:state.c       ****       ned_of_lla_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1561              		.loc 1 397 0
 1562 0084 04F1FC00 		add	r0, r4, #252
 1563 0088 04F1A401 		add	r1, r4, #164
 1564 008c 04F18C02 		add	r2, r4, #140
 1565 0090 FFF7FEFF 		bl	ned_of_lla_point_f
 1566              	.LVL109:
 1567 0094 CDE0     		b	.L178
 1568              	.L181:
 398:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1569              		.loc 1 398 0
 1570 0096 2907     		lsls	r1, r5, #28
 1571 0098 40F1CB80 		bpl	.L178
 399:state.c       ****       /* transform lla_i -> ecef_i -> ned_i -> ned_f, set status bits */
 400:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1572              		.loc 1 400 0
 1573 009c 201D     		adds	r0, r4, #4
 1574 009e 04F11001 		add	r1, r4, #16
 1575 00a2 FFF7FEFF 		bl	ecef_of_lla_i
 1576              	.LVL110:
 401:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1577              		.loc 1 401 0
 1578 00a6 2388     		ldrh	r3, [r4]
 1579 00a8 2046     		mov	r0, r4
 1580 00aa 43F00103 		orr	r3, r3, #1
 1581 00ae 20F8603B 		strh	r3, [r0], #96	@ movhi
 402:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1582              		.loc 1 402 0
 1583 00b2 04F11C01 		add	r1, r4, #28
 1584 00b6 221D     		adds	r2, r4, #4
 1585 00b8 FFF7FEFF 		bl	ned_of_ecef_pos_i
 1586              	.LVL111:
 403:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1587              		.loc 1 403 0
 1588 00bc 2388     		ldrh	r3, [r4]
 404:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1589              		.loc 1 404 0
 1590 00be D4ED186A 		flds	s13, [r4, #96]	@ int
 403:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1591              		.loc 1 403 0
 1592 00c2 43F00203 		orr	r3, r3, #2
 1593              		.loc 1 404 0
 1594 00c6 B8EEE67A 		fsitos	s14, s13
 403:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1595              		.loc 1 403 0
 1596 00ca 2380     		strh	r3, [r4]	@ movhi
 1597              	.L201:
 1598              		.loc 1 404 0
 1599 00cc DFED617A 		flds	s15, .L202+20
 1600 00d0 D4ED195A 		flds	s11, [r4, #100]	@ int
 1601 00d4 94ED1A6A 		flds	s12, [r4, #104]	@ int
 1602 00d8 27EE277A 		fmuls	s14, s14, s15
 1603 00dc 84ED3F7A 		fsts	s14, [r4, #252]
 1604 00e0 B8EEE57A 		fsitos	s14, s11
 1605 00e4 27EE277A 		fmuls	s14, s14, s15
 1606 00e8 84ED407A 		fsts	s14, [r4, #256]
 1607 00ec B8EEC67A 		fsitos	s14, s12
 1608              	.L199:
 1609 00f0 67EE277A 		fmuls	s15, s14, s15
 1610 00f4 9BE0     		b	.L196
 1611              	.L176:
 405:state.c       ****     } else { /* could not get this representation,  set errno */
 406:state.c       ****       errno = 1;
 407:state.c       ****     }
 408:state.c       ****   } else if (state.utm_initialized_f) {
 1612              		.loc 1 408 0
 1613 00f6 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1614 00fa 002B     		cmp	r3, #0
 1615 00fc 00F09980 		beq	.L178
 409:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1616              		.loc 1 409 0
 1617 0100 AA07     		lsls	r2, r5, #30
 1618 0102 89D4     		bmi	.L182
 410:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 411:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1619              		.loc 1 411 0
 1620 0104 6B07     		lsls	r3, r5, #29
 1621 0106 21D5     		bpl	.L183
 412:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1622              		.loc 1 412 0
 1623 0108 D4ED1B6A 		flds	s13, [r4, #108]	@ int
 1624 010c D4ED1C5A 		flds	s11, [r4, #112]	@ int
 1625 0110 DFED507A 		flds	s15, .L202+20
 1626 0114 B8EEE67A 		fsitos	s14, s13
 1627 0118 F8EEE56A 		fsitos	s13, s11
 1628 011c D4ED1D5A 		flds	s11, [r4, #116]	@ int
 1629 0120 B8EEE56A 		fsitos	s12, s11
 1630 0124 27EE277A 		fmuls	s14, s14, s15
 1631 0128 66EEA76A 		fmuls	s13, s13, s15
 1632 012c 66EE277A 		fmuls	s15, s12, s15
 413:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1633              		.loc 1 413 0
 1634 0130 45F08005 		orr	r5, r5, #128
 412:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1635              		.loc 1 412 0
 1636 0134 84ED427A 		fsts	s14, [r4, #264]
 1637 0138 C4ED436A 		fsts	s13, [r4, #268]
 1638 013c C4ED447A 		fsts	s15, [r4, #272]
 1639              		.loc 1 413 0
 1640 0140 2580     		strh	r5, [r4]	@ movhi
 414:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1641              		.loc 1 414 0
 1642 0142 C4ED3F6A 		fsts	s13, [r4, #252]
 1643 0146 84ED407A 		fsts	s14, [r4, #256]
 1644 014a 0BE0     		b	.L200
 1645              	.L183:
 415:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1646              		.loc 1 415 0
 1647 014c 2806     		lsls	r0, r5, #24
 1648 014e 0CD5     		bpl	.L184
 416:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1649              		.loc 1 416 0
 1650 0150 D4F80C31 		ldr	r3, [r4, #268]	@ float
 1651 0154 C4F8FC30 		str	r3, [r4, #252]	@ float
 1652 0158 D4ED447A 		flds	s15, [r4, #272]
 1653 015c D4F80831 		ldr	r3, [r4, #264]	@ float
 1654 0160 C4F80031 		str	r3, [r4, #256]	@ float
 1655              	.L200:
 1656 0164 F1EE677A 		fnegs	s15, s15
 1657 0168 61E0     		b	.L196
 1658              	.L184:
 417:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1659              		.loc 1 417 0
 1660 016a A905     		lsls	r1, r5, #22
 1661 016c 49D4     		bmi	.L198
 418:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 419:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1662              		.loc 1 419 0
 1663 016e EA05     		lsls	r2, r5, #23
 1664 0170 02D5     		bpl	.L186
 420:state.c       ****       /* transform lla_f -> utm_f -> ned, set status bits */
 421:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1665              		.loc 1 421 0
 1666 0172 04F17800 		add	r0, r4, #120
 1667 0176 3CE0     		b	.L197
 1668              	.L186:
 422:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 423:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 424:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1669              		.loc 1 424 0
 1670 0178 2B07     		lsls	r3, r5, #28
 1671 017a 5AD5     		bpl	.L178
 425:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned, set status bits */
 426:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1672              		.loc 1 426 0
 1673 017c 94ED046A 		flds	s12, [r4, #16]	@ int
 1674 0180 B8EEC66A 		fsitos	s12, s12
 427:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1675              		.loc 1 427 0
 1676 0184 45F48075 		orr	r5, r5, #256
 426:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1677              		.loc 1 426 0
 1678 0188 16EE100A 		fmrs	r0, s12
 1679 018c FFF7FEFF 		bl	__aeabi_f2d
 1680              	.LVL112:
 1681 0190 2BA3     		adr	r3, .L202
 1682 0192 D3E90023 		ldrd	r2, [r3]
 1683 0196 FFF7FEFF 		bl	__aeabi_dmul
 1684              	.LVL113:
 1685 019a 2BA3     		adr	r3, .L202+8
 1686 019c D3E90023 		ldrd	r2, [r3]
 1687 01a0 FFF7FEFF 		bl	__aeabi_ddiv
 1688              	.LVL114:
 1689 01a4 FFF7FEFF 		bl	__aeabi_d2f
 1690              	.LVL115:
 1691 01a8 D4ED056A 		flds	s13, [r4, #20]	@ int
 1692 01ac C4F88C00 		str	r0, [r4, #140]	@ float
 1693 01b0 F8EEE66A 		fsitos	s13, s13
 1694 01b4 16EE900A 		fmrs	r0, s13
 1695 01b8 FFF7FEFF 		bl	__aeabi_f2d
 1696              	.LVL116:
 1697 01bc 20A3     		adr	r3, .L202
 1698 01be D3E90023 		ldrd	r2, [r3]
 1699 01c2 FFF7FEFF 		bl	__aeabi_dmul
 1700              	.LVL117:
 1701 01c6 20A3     		adr	r3, .L202+8
 1702 01c8 D3E90023 		ldrd	r2, [r3]
 1703 01cc FFF7FEFF 		bl	__aeabi_ddiv
 1704              	.LVL118:
 1705 01d0 FFF7FEFF 		bl	__aeabi_d2f
 1706              	.LVL119:
 1707 01d4 D4ED067A 		flds	s15, [r4, #24]	@ int
 1708 01d8 C4F89000 		str	r0, [r4, #144]	@ float
 1709 01dc B8EEE77A 		fsitos	s14, s15
 1710 01e0 DFED1D7A 		flds	s15, .L202+24
 1711 01e4 C7EE277A 		fdivs	s15, s14, s15
 1712              		.loc 1 427 0
 1713 01e8 2046     		mov	r0, r4
 1714 01ea 20F8785B 		strh	r5, [r0], #120	@ movhi
 426:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1715              		.loc 1 426 0
 1716 01ee C4ED257A 		fsts	s15, [r4, #148]
 1717              	.L197:
 428:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1718              		.loc 1 428 0
 1719 01f2 04F18C01 		add	r1, r4, #140
 1720 01f6 FFF7FEFF 		bl	utm_of_lla_f
 1721              	.LVL120:
 429:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 1722              		.loc 1 429 0
 1723 01fa 2388     		ldrh	r3, [r4]
 1724 01fc 43F40073 		orr	r3, r3, #512
 1725 0200 2380     		strh	r3, [r4]	@ movhi
 1726              	.L198:
 430:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 1727              		.loc 1 430 0
 1728 0202 94ED1E7A 		flds	s14, [r4, #120]
 1729 0206 D4ED3A7A 		flds	s15, [r4, #232]
 1730 020a 77EE677A 		fsubs	s15, s14, s15
 1731 020e 94ED1F7A 		flds	s14, [r4, #124]
 1732 0212 C4ED3F7A 		fsts	s15, [r4, #252]
 1733 0216 D4ED3B7A 		flds	s15, [r4, #236]
 1734 021a 77EE677A 		fsubs	s15, s14, s15
 1735 021e 94ED3C7A 		flds	s14, [r4, #240]
 1736 0222 C4ED407A 		fsts	s15, [r4, #256]
 1737 0226 D4ED207A 		flds	s15, [r4, #128]
 1738 022a 77EE677A 		fsubs	s15, s14, s15
 1739              	.L196:
 1740 022e C4ED417A 		fsts	s15, [r4, #260]
 1741              	.L178:
 431:state.c       ****     } else { /* could not get this representation,  set errno */
 432:state.c       ****       errno = 2;
 433:state.c       ****     }
 434:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 435:state.c       ****     errno = 3;
 436:state.c       ****   }
 437:state.c       ****   if (errno) {
 438:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 439:state.c       ****     //return _ned_zero;
 440:state.c       ****   }
 441:state.c       ****   /* set bit to indicate this representation is computed */
 442:state.c       ****   SetBit(state.pos_status, POS_NED_F);
 1742              		.loc 1 442 0
 1743 0232 2388     		ldrh	r3, [r4]
 1744 0234 43F04003 		orr	r3, r3, #64
 1745 0238 2380     		strh	r3, [r4]	@ movhi
 1746              	.LVL121:
 1747              	.L174:
 1748 023a 38BD     		pop	{r3, r4, r5, pc}
 1749              	.L203:
 1750 023c AFF30080 		.align	3
 1751              	.L202:
 1752 0240 399D52A2 		.word	-1571644103
 1753 0244 46DF913F 		.word	1066524486
 1754 0248 00000000 		.word	0
 1755 024c D0126341 		.word	1097011920
 1756 0250 00000000 		.word	.LANCHOR0
 1757 0254 0000803B 		.word	998244352
 1758 0258 00007A44 		.word	1148846080
 1759              		.cfi_endproc
 1760              	.LFE146:
 1762 025c AFF30080 		.section	.text.stateCalcPositionEnu_f,"ax",%progbits
 1763              		.align	1
 1764              		.global	stateCalcPositionEnu_f
 1765              		.thumb
 1766              		.thumb_func
 1768              	stateCalcPositionEnu_f:
 1769              	.LFB147:
 443:state.c       **** }
 444:state.c       **** 
 445:state.c       **** void stateCalcPositionEnu_f(void)
 446:state.c       **** {
 1770              		.loc 1 446 0
 1771              		.cfi_startproc
 1772              		@ args = 0, pretend = 0, frame = 0
 1773              		@ frame_needed = 0, uses_anonymous_args = 0
 1774 0000 38B5     		push	{r3, r4, r5, lr}
 1775              		.cfi_def_cfa_offset 16
 1776              		.cfi_offset 3, -16
 1777              		.cfi_offset 4, -12
 1778              		.cfi_offset 5, -8
 1779              		.cfi_offset 14, -4
 447:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1780              		.loc 1 447 0
 1781 0002 914C     		ldr	r4, .L235+16
 1782 0004 2588     		ldrh	r5, [r4]
 1783 0006 2A06     		lsls	r2, r5, #24
 1784 0008 00F11381 		bmi	.L204
 1785              	.LVL122:
 448:state.c       ****     return;
 449:state.c       ****   }
 450:state.c       **** 
 451:state.c       ****   int errno = 0;
 452:state.c       ****   if (state.ned_initialized_f) {
 1786              		.loc 1 452 0
 1787 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1788 0010 002B     		cmp	r3, #0
 1789 0012 77D0     		beq	.L206
 453:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 1790              		.loc 1 453 0
 1791 0014 6B06     		lsls	r3, r5, #25
 1792 0016 0AD5     		bpl	.L207
 1793              	.L215:
 454:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1794              		.loc 1 454 0
 1795 0018 D4F80031 		ldr	r3, [r4, #256]	@ float
 1796 001c C4F80831 		str	r3, [r4, #264]	@ float
 1797 0020 D4F8FC30 		ldr	r3, [r4, #252]	@ float
 1798 0024 C4F80C31 		str	r3, [r4, #268]	@ float
 1799 0028 D4ED417A 		flds	s15, [r4, #260]
 1800 002c 96E0     		b	.L231
 1801              	.L207:
 455:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1802              		.loc 1 455 0
 1803 002e 6807     		lsls	r0, r5, #29
 1804 0030 16D5     		bpl	.L209
 1805              	.L214:
 456:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1806              		.loc 1 456 0
 1807 0032 D4ED1B5A 		flds	s11, [r4, #108]	@ int
 1808 0036 DFED857A 		flds	s15, .L235+20
 1809 003a 94ED1C6A 		flds	s12, [r4, #112]	@ int
 1810 003e D4ED1D6A 		flds	s13, [r4, #116]	@ int
 1811 0042 B8EEE57A 		fsitos	s14, s11
 1812 0046 27EE277A 		fmuls	s14, s14, s15
 1813 004a 84ED427A 		fsts	s14, [r4, #264]
 1814 004e B8EEC67A 		fsitos	s14, s12
 1815 0052 27EE277A 		fmuls	s14, s14, s15
 1816 0056 84ED437A 		fsts	s14, [r4, #268]
 1817 005a B8EEE67A 		fsitos	s14, s13
 1818 005e 4EE0     		b	.L232
 1819              	.L209:
 457:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1820              		.loc 1 457 0
 1821 0060 A907     		lsls	r1, r5, #30
 1822 0062 04D5     		bpl	.L210
 458:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1823              		.loc 1 458 0
 1824 0064 D4ED187A 		flds	s15, [r4, #96]	@ int
 1825 0068 B8EEE77A 		fsitos	s14, s15
 1826 006c 59E0     		b	.L233
 1827              	.L210:
 459:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 460:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 461:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1828              		.loc 1 461 0
 1829 006e AA06     		lsls	r2, r5, #26
 1830 0070 08D5     		bpl	.L211
 462:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1831              		.loc 1 462 0
 1832 0072 04F58470 		add	r0, r4, #264
 1833 0076 04F1A401 		add	r1, r4, #164
 1834 007a 04F19802 		add	r2, r4, #152
 1835 007e FFF7FEFF 		bl	enu_of_ecef_point_f
 1836              	.LVL123:
 1837 0082 D2E0     		b	.L208
 1838              	.L211:
 463:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1839              		.loc 1 463 0
 1840 0084 EB07     		lsls	r3, r5, #31
 1841 0086 02D5     		bpl	.L212
 464:state.c       ****       /* transform ecef_i -> enu_i -> enu_f, set status bits */
 465:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1842              		.loc 1 465 0
 1843 0088 04F16C00 		add	r0, r4, #108
 1844 008c 18E0     		b	.L234
 1845              	.L212:
 466:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 467:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 468:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1846              		.loc 1 468 0
 1847 008e E805     		lsls	r0, r5, #23
 1848 0090 08D5     		bpl	.L213
 469:state.c       ****       enu_of_lla_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1849              		.loc 1 469 0
 1850 0092 04F58470 		add	r0, r4, #264
 1851 0096 04F1A401 		add	r1, r4, #164
 1852 009a 04F18C02 		add	r2, r4, #140
 1853 009e FFF7FEFF 		bl	enu_of_lla_point_f
 1854              	.LVL124:
 1855 00a2 C2E0     		b	.L208
 1856              	.L213:
 470:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1857              		.loc 1 470 0
 1858 00a4 2907     		lsls	r1, r5, #28
 1859 00a6 40F1C080 		bpl	.L208
 471:state.c       ****       /* transform lla_i -> ecef_i -> enu_i -> enu_f, set status bits */
 472:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1860              		.loc 1 472 0
 1861 00aa 201D     		adds	r0, r4, #4
 1862 00ac 04F11001 		add	r1, r4, #16
 1863 00b0 FFF7FEFF 		bl	ecef_of_lla_i
 1864              	.LVL125:
 473:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1865              		.loc 1 473 0
 1866 00b4 2388     		ldrh	r3, [r4]
 1867 00b6 2046     		mov	r0, r4
 1868 00b8 43F00103 		orr	r3, r3, #1
 1869 00bc 20F86C3B 		strh	r3, [r0], #108	@ movhi
 1870              	.L234:
 474:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1871              		.loc 1 474 0
 1872 00c0 04F11C01 		add	r1, r4, #28
 1873 00c4 221D     		adds	r2, r4, #4
 1874 00c6 FFF7FEFF 		bl	enu_of_ecef_pos_i
 1875              	.LVL126:
 475:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 476:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1876              		.loc 1 476 0
 1877 00ca 94ED1B6A 		flds	s12, [r4, #108]	@ int
 1878 00ce DFED5F7A 		flds	s15, .L235+20
 1879 00d2 D4ED1C6A 		flds	s13, [r4, #112]	@ int
 475:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 1880              		.loc 1 475 0
 1881 00d6 2388     		ldrh	r3, [r4]
 1882              		.loc 1 476 0
 1883 00d8 D4ED1D5A 		flds	s11, [r4, #116]	@ int
 1884 00dc B8EEC67A 		fsitos	s14, s12
 475:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 1885              		.loc 1 475 0
 1886 00e0 43F00403 		orr	r3, r3, #4
 1887              		.loc 1 476 0
 1888 00e4 27EE277A 		fmuls	s14, s14, s15
 475:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 1889              		.loc 1 475 0
 1890 00e8 2380     		strh	r3, [r4]	@ movhi
 1891              		.loc 1 476 0
 1892 00ea 84ED427A 		fsts	s14, [r4, #264]
 1893 00ee B8EEE67A 		fsitos	s14, s13
 1894 00f2 27EE277A 		fmuls	s14, s14, s15
 1895 00f6 84ED437A 		fsts	s14, [r4, #268]
 1896 00fa B8EEE57A 		fsitos	s14, s11
 1897              	.L232:
 1898 00fe 67EE277A 		fmuls	s15, s14, s15
 1899 0102 90E0     		b	.L228
 1900              	.L206:
 477:state.c       ****     } else { /* could not get this representation,  set errno */
 478:state.c       ****       errno = 1;
 479:state.c       ****     }
 480:state.c       ****   } else if (state.utm_initialized_f) {
 1901              		.loc 1 480 0
 1902 0104 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1903 0108 002B     		cmp	r3, #0
 1904 010a 00F08E80 		beq	.L208
 481:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1905              		.loc 1 481 0
 1906 010e 6A07     		lsls	r2, r5, #29
 1907 0110 8FD4     		bmi	.L214
 482:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 483:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1908              		.loc 1 483 0
 1909 0112 6B06     		lsls	r3, r5, #25
 1910 0114 80D4     		bmi	.L215
 484:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 485:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1911              		.loc 1 485 0
 1912 0116 A807     		lsls	r0, r5, #30
 1913 0118 23D5     		bpl	.L216
 486:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1914              		.loc 1 486 0
 1915 011a 94ED186A 		flds	s12, [r4, #96]	@ int
 1916 011e B8EEC67A 		fsitos	s14, s12
 1917              	.L233:
 1918 0122 D4ED195A 		flds	s11, [r4, #100]	@ int
 1919 0126 DFED497A 		flds	s15, .L235+20
 1920 012a F8EEE56A 		fsitos	s13, s11
 1921 012e D4ED1A5A 		flds	s11, [r4, #104]	@ int
 1922 0132 B8EEE56A 		fsitos	s12, s11
 1923 0136 27EE277A 		fmuls	s14, s14, s15
 1924 013a 66EEA76A 		fmuls	s13, s13, s15
 1925 013e 66EE277A 		fmuls	s15, s12, s15
 487:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1926              		.loc 1 487 0
 1927 0142 45F04005 		orr	r5, r5, #64
 486:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1928              		.loc 1 486 0
 1929 0146 84ED3F7A 		fsts	s14, [r4, #252]
 1930 014a C4ED406A 		fsts	s13, [r4, #256]
 1931 014e C4ED417A 		fsts	s15, [r4, #260]
 1932              		.loc 1 487 0
 1933 0152 2580     		strh	r5, [r4]	@ movhi
 488:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1934              		.loc 1 488 0
 1935 0154 C4ED426A 		fsts	s13, [r4, #264]
 1936 0158 84ED437A 		fsts	s14, [r4, #268]
 1937              	.L231:
 1938 015c F1EE677A 		fnegs	s15, s15
 1939 0160 61E0     		b	.L228
 1940              	.L216:
 489:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1941              		.loc 1 489 0
 1942 0162 A905     		lsls	r1, r5, #22
 1943 0164 49D4     		bmi	.L230
 490:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 491:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1944              		.loc 1 491 0
 1945 0166 EA05     		lsls	r2, r5, #23
 1946 0168 02D5     		bpl	.L218
 492:state.c       ****       /* transform lla_f -> utm_f -> enu, set status bits */
 493:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1947              		.loc 1 493 0
 1948 016a 04F17800 		add	r0, r4, #120
 1949 016e 3CE0     		b	.L229
 1950              	.L218:
 494:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 495:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 496:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1951              		.loc 1 496 0
 1952 0170 2B07     		lsls	r3, r5, #28
 1953 0172 5AD5     		bpl	.L208
 497:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu, set status bits */
 498:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1954              		.loc 1 498 0
 1955 0174 94ED046A 		flds	s12, [r4, #16]	@ int
 1956 0178 B8EEC66A 		fsitos	s12, s12
 499:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1957              		.loc 1 499 0
 1958 017c 45F48075 		orr	r5, r5, #256
 498:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1959              		.loc 1 498 0
 1960 0180 16EE100A 		fmrs	r0, s12
 1961 0184 FFF7FEFF 		bl	__aeabi_f2d
 1962              	.LVL127:
 1963 0188 2BA3     		adr	r3, .L235
 1964 018a D3E90023 		ldrd	r2, [r3]
 1965 018e FFF7FEFF 		bl	__aeabi_dmul
 1966              	.LVL128:
 1967 0192 2BA3     		adr	r3, .L235+8
 1968 0194 D3E90023 		ldrd	r2, [r3]
 1969 0198 FFF7FEFF 		bl	__aeabi_ddiv
 1970              	.LVL129:
 1971 019c FFF7FEFF 		bl	__aeabi_d2f
 1972              	.LVL130:
 1973 01a0 D4ED056A 		flds	s13, [r4, #20]	@ int
 1974 01a4 C4F88C00 		str	r0, [r4, #140]	@ float
 1975 01a8 F8EEE66A 		fsitos	s13, s13
 1976 01ac 16EE900A 		fmrs	r0, s13
 1977 01b0 FFF7FEFF 		bl	__aeabi_f2d
 1978              	.LVL131:
 1979 01b4 20A3     		adr	r3, .L235
 1980 01b6 D3E90023 		ldrd	r2, [r3]
 1981 01ba FFF7FEFF 		bl	__aeabi_dmul
 1982              	.LVL132:
 1983 01be 20A3     		adr	r3, .L235+8
 1984 01c0 D3E90023 		ldrd	r2, [r3]
 1985 01c4 FFF7FEFF 		bl	__aeabi_ddiv
 1986              	.LVL133:
 1987 01c8 FFF7FEFF 		bl	__aeabi_d2f
 1988              	.LVL134:
 1989 01cc D4ED067A 		flds	s15, [r4, #24]	@ int
 1990 01d0 C4F89000 		str	r0, [r4, #144]	@ float
 1991 01d4 B8EEE77A 		fsitos	s14, s15
 1992 01d8 DFED1D7A 		flds	s15, .L235+24
 1993 01dc C7EE277A 		fdivs	s15, s14, s15
 1994              		.loc 1 499 0
 1995 01e0 2046     		mov	r0, r4
 1996 01e2 20F8785B 		strh	r5, [r0], #120	@ movhi
 498:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1997              		.loc 1 498 0
 1998 01e6 C4ED257A 		fsts	s15, [r4, #148]
 1999              	.L229:
 500:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 2000              		.loc 1 500 0
 2001 01ea 04F18C01 		add	r1, r4, #140
 2002 01ee FFF7FEFF 		bl	utm_of_lla_f
 2003              	.LVL135:
 501:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 2004              		.loc 1 501 0
 2005 01f2 2388     		ldrh	r3, [r4]
 2006 01f4 43F40073 		orr	r3, r3, #512
 2007 01f8 2380     		strh	r3, [r4]	@ movhi
 2008              	.L230:
 502:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 2009              		.loc 1 502 0
 2010 01fa 94ED1F7A 		flds	s14, [r4, #124]
 2011 01fe D4ED3B7A 		flds	s15, [r4, #236]
 2012 0202 77EE677A 		fsubs	s15, s14, s15
 2013 0206 94ED1E7A 		flds	s14, [r4, #120]
 2014 020a C4ED427A 		fsts	s15, [r4, #264]
 2015 020e D4ED3A7A 		flds	s15, [r4, #232]
 2016 0212 77EE677A 		fsubs	s15, s14, s15
 2017 0216 94ED207A 		flds	s14, [r4, #128]
 2018 021a C4ED437A 		fsts	s15, [r4, #268]
 2019 021e D4ED3C7A 		flds	s15, [r4, #240]
 2020 0222 77EE677A 		fsubs	s15, s14, s15
 2021              	.L228:
 2022 0226 C4ED447A 		fsts	s15, [r4, #272]
 2023              	.L208:
 503:state.c       ****     } else { /* could not get this representation,  set errno */
 504:state.c       ****       errno = 2;
 505:state.c       ****     }
 506:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 507:state.c       ****     errno = 3;
 508:state.c       ****   }
 509:state.c       ****   if (errno) {
 510:state.c       ****     //struct EnuCoor_f _enu_zero = {0.0f};
 511:state.c       ****     //return _enu_zero;
 512:state.c       ****   }
 513:state.c       ****   /* set bit to indicate this representation is computed */
 514:state.c       ****   SetBit(state.pos_status, POS_ENU_F);
 2024              		.loc 1 514 0
 2025 022a 2388     		ldrh	r3, [r4]
 2026 022c 43F08003 		orr	r3, r3, #128
 2027 0230 2380     		strh	r3, [r4]	@ movhi
 2028              	.LVL136:
 2029              	.L204:
 2030 0232 38BD     		pop	{r3, r4, r5, pc}
 2031              	.L236:
 2032 0234 AFF30080 		.align	3
 2033              	.L235:
 2034 0238 399D52A2 		.word	-1571644103
 2035 023c 46DF913F 		.word	1066524486
 2036 0240 00000000 		.word	0
 2037 0244 D0126341 		.word	1097011920
 2038 0248 00000000 		.word	.LANCHOR0
 2039 024c 0000803B 		.word	998244352
 2040 0250 00007A44 		.word	1148846080
 2041              		.cfi_endproc
 2042              	.LFE147:
 2044 0254 AFF30080 		.section	.text.stateCalcPositionLla_f,"ax",%progbits
 2045              		.align	1
 2046              		.global	stateCalcPositionLla_f
 2047              		.thumb
 2048              		.thumb_func
 2050              	stateCalcPositionLla_f:
 2051              	.LFB148:
 515:state.c       **** }
 516:state.c       **** 
 517:state.c       **** void stateCalcPositionLla_f(void)
 518:state.c       **** {
 2052              		.loc 1 518 0
 2053              		.cfi_startproc
 2054              		@ args = 0, pretend = 0, frame = 0
 2055              		@ frame_needed = 0, uses_anonymous_args = 0
 2056 0000 70B5     		push	{r4, r5, r6, lr}
 2057              		.cfi_def_cfa_offset 16
 2058              		.cfi_offset 4, -16
 2059              		.cfi_offset 5, -12
 2060              		.cfi_offset 6, -8
 2061              		.cfi_offset 14, -4
 519:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 2062              		.loc 1 519 0
 2063 0002 614C     		ldr	r4, .L262+16
 2064 0004 2688     		ldrh	r6, [r4]
 2065 0006 F205     		lsls	r2, r6, #23
 2066 0008 00F1B480 		bmi	.L237
 520:state.c       ****     return;
 521:state.c       ****   }
 522:state.c       **** 
 523:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I)) {
 2067              		.loc 1 523 0
 2068 000c 3307     		lsls	r3, r6, #28
 2069 000e 2CD5     		bpl	.L239
 524:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_f);
 2070              		.loc 1 524 0
 2071 0010 D4F88C00 		ldr	r0, [r4, #140]	@ float
 2072 0014 FFF7FEFF 		bl	__aeabi_f2d
 2073              	.LVL137:
 2074 0018 57A3     		adr	r3, .L262
 2075 001a D3E90023 		ldrd	r2, [r3]
 2076 001e FFF7FEFF 		bl	__aeabi_dmul
 2077              	.LVL138:
 2078 0022 57A3     		adr	r3, .L262+8
 2079 0024 D3E90023 		ldrd	r2, [r3]
 2080 0028 FFF7FEFF 		bl	__aeabi_ddiv
 2081              	.LVL139:
 2082 002c FFF7FEFF 		bl	__aeabi_d2f
 2083              	.LVL140:
 2084 0030 C4F88C00 		str	r0, [r4, #140]	@ float
 2085 0034 D4F89000 		ldr	r0, [r4, #144]	@ float
 2086 0038 FFF7FEFF 		bl	__aeabi_f2d
 2087              	.LVL141:
 2088 003c 4EA3     		adr	r3, .L262
 2089 003e D3E90023 		ldrd	r2, [r3]
 2090 0042 FFF7FEFF 		bl	__aeabi_dmul
 2091              	.LVL142:
 2092 0046 4EA3     		adr	r3, .L262+8
 2093 0048 D3E90023 		ldrd	r2, [r3]
 2094 004c FFF7FEFF 		bl	__aeabi_ddiv
 2095              	.LVL143:
 2096 0050 FFF7FEFF 		bl	__aeabi_d2f
 2097              	.LVL144:
 2098 0054 94ED257A 		flds	s14, [r4, #148]
 2099 0058 DFED4C7A 		flds	s15, .L262+20
 2100 005c C4F89000 		str	r0, [r4, #144]	@ float
 2101 0060 C7EE277A 		fdivs	s15, s14, s15
 2102 0064 C4ED257A 		fsts	s15, [r4, #148]
 2103 0068 80E0     		b	.L240
 2104              	.L239:
 525:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 2105              		.loc 1 525 0
 2106 006a B506     		lsls	r5, r6, #26
 2107 006c 02D5     		bpl	.L241
 526:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2108              		.loc 1 526 0
 2109 006e 04F18C00 		add	r0, r4, #140
 2110 0072 27E0     		b	.L260
 2111              	.L241:
 527:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 2112              		.loc 1 527 0
 2113 0074 F007     		lsls	r0, r6, #31
 2114 0076 2AD5     		bpl	.L242
 528:state.c       ****     /* transform ecef_i -> ecef_f -> lla_f, set status bits */
 529:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 2115              		.loc 1 529 0
 2116 0078 6068     		ldr	r0, [r4, #4]
 2117 007a FFF7FEFF 		bl	__aeabi_i2d
 2118              	.LVL145:
 2119 007e 0022     		movs	r2, #0
 2120 0080 434B     		ldr	r3, .L262+24
 2121 0082 FFF7FEFF 		bl	__aeabi_ddiv
 2122              	.LVL146:
 2123 0086 FFF7FEFF 		bl	__aeabi_d2f
 2124              	.LVL147:
 2125 008a C4F89800 		str	r0, [r4, #152]	@ float
 2126 008e A068     		ldr	r0, [r4, #8]
 2127 0090 FFF7FEFF 		bl	__aeabi_i2d
 2128              	.LVL148:
 2129 0094 0022     		movs	r2, #0
 2130 0096 3E4B     		ldr	r3, .L262+24
 2131 0098 FFF7FEFF 		bl	__aeabi_ddiv
 2132              	.LVL149:
 2133 009c FFF7FEFF 		bl	__aeabi_d2f
 2134              	.LVL150:
 2135 00a0 C4F89C00 		str	r0, [r4, #156]	@ float
 2136 00a4 E068     		ldr	r0, [r4, #12]
 2137 00a6 FFF7FEFF 		bl	__aeabi_i2d
 2138              	.LVL151:
 2139 00aa 0022     		movs	r2, #0
 2140 00ac 384B     		ldr	r3, .L262+24
 2141 00ae FFF7FEFF 		bl	__aeabi_ddiv
 2142              	.LVL152:
 2143 00b2 FFF7FEFF 		bl	__aeabi_d2f
 2144              	.LVL153:
 2145 00b6 C4F8A000 		str	r0, [r4, #160]	@ float
 530:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2146              		.loc 1 530 0
 2147 00ba 2046     		mov	r0, r4
 2148 00bc 46F02006 		orr	r6, r6, #32
 2149 00c0 20F88C6B 		strh	r6, [r0], #140	@ movhi
 2150              	.L260:
 531:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2151              		.loc 1 531 0
 2152 00c4 04F19801 		add	r1, r4, #152
 2153              	.L261:
 2154 00c8 FFF7FEFF 		bl	lla_of_ecef_f
 2155              	.LVL154:
 2156 00cc 4EE0     		b	.L240
 2157              	.L242:
 532:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_f) {
 2158              		.loc 1 532 0
 2159 00ce 7106     		lsls	r1, r6, #25
 2160 00d0 11D5     		bpl	.L243
 2161              		.loc 1 532 0 is_stmt 0 discriminator 1
 2162 00d2 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 2163 00d6 73B1     		cbz	r3, .L243
 533:state.c       ****     /* transform ned_f -> ecef_f -> lla_f, set status bits */
 534:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 2164              		.loc 1 534 0 is_stmt 1
 2165 00d8 04F19800 		add	r0, r4, #152
 2166 00dc 04F1A401 		add	r1, r4, #164
 2167 00e0 04F1FC02 		add	r2, r4, #252
 2168 00e4 FFF7FEFF 		bl	ecef_of_ned_point_f
 2169              	.LVL155:
 535:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2170              		.loc 1 535 0
 2171 00e8 2388     		ldrh	r3, [r4]
 2172 00ea 2046     		mov	r0, r4
 2173 00ec 43F02003 		orr	r3, r3, #32
 2174 00f0 20F88C3B 		strh	r3, [r0], #140	@ movhi
 2175 00f4 E6E7     		b	.L260
 2176              	.L243:
 536:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 537:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_f) {
 2177              		.loc 1 537 0
 2178 00f6 B207     		lsls	r2, r6, #30
 2179 00f8 31D5     		bpl	.L244
 2180              		.loc 1 537 0 is_stmt 0 discriminator 1
 2181 00fa 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 2182 00fe 224D     		ldr	r5, .L262+16
 2183 0100 6BB3     		cbz	r3, .L244
 538:state.c       ****     /* transform ned_i -> ned_f -> ecef_f -> lla_f, set status bits */
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2184              		.loc 1 539 0 is_stmt 1
 2185 0102 D5ED186A 		flds	s13, [r5, #96]	@ int
 2186 0106 DFED237A 		flds	s15, .L262+28
 2187 010a B8EEE67A 		fsitos	s14, s13
 2188 010e D5ED196A 		flds	s13, [r5, #100]	@ int
 2189 0112 27EE277A 		fmuls	s14, s14, s15
 540:state.c       ****     SetBit(state.pos_status, POS_NED_F);
 2190              		.loc 1 540 0
 2191 0116 2846     		mov	r0, r5
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2192              		.loc 1 539 0
 2193 0118 85ED3F7A 		fsts	s14, [r5, #252]
 2194 011c B8EEE67A 		fsitos	s14, s13
 2195 0120 D5ED1A6A 		flds	s13, [r5, #104]	@ int
 2196 0124 27EE277A 		fmuls	s14, s14, s15
 2197              		.loc 1 540 0
 2198 0128 46F04006 		orr	r6, r6, #64
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2199              		.loc 1 539 0
 2200 012c 85ED407A 		fsts	s14, [r5, #256]
 2201 0130 B8EEE67A 		fsitos	s14, s13
 2202              		.loc 1 540 0
 2203 0134 20F8986B 		strh	r6, [r0], #152	@ movhi
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2204              		.loc 1 539 0
 2205 0138 67EE277A 		fmuls	s15, s14, s15
 541:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 2206              		.loc 1 541 0
 2207 013c 05F1A401 		add	r1, r5, #164
 2208 0140 05F1FC02 		add	r2, r5, #252
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2209              		.loc 1 539 0
 2210 0144 C5ED417A 		fsts	s15, [r5, #260]
 2211              		.loc 1 541 0
 2212 0148 FFF7FEFF 		bl	ecef_of_ned_point_f
 2213              	.LVL156:
 542:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2214              		.loc 1 542 0
 2215 014c 2B88     		ldrh	r3, [r5]
 2216 014e 2846     		mov	r0, r5
 2217 0150 43F02003 		orr	r3, r3, #32
 2218 0154 20F88C3B 		strh	r3, [r0], #140	@ movhi
 543:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2219              		.loc 1 543 0
 2220 0158 05F19801 		add	r1, r5, #152
 2221 015c B4E7     		b	.L261
 2222              	.L244:
 544:state.c       ****   } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 2223              		.loc 1 544 0
 2224 015e B305     		lsls	r3, r6, #22
 2225 0160 04D5     		bpl	.L240
 545:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 2226              		.loc 1 545 0
 2227 0162 0D48     		ldr	r0, .L262+32
 2228 0164 A0F11401 		sub	r1, r0, #20
 2229 0168 FFF7FEFF 		bl	lla_of_utm_f
 2230              	.LVL157:
 2231              	.L240:
 546:state.c       ****   } else {
 547:state.c       ****     /* could not get this representation,  set errno */
 548:state.c       ****     //struct LlaCoor_f _lla_zero = {0.0};
 549:state.c       ****     //return _lla_zero;
 550:state.c       ****   }
 551:state.c       ****   /* set bit to indicate this representation is computed */
 552:state.c       ****   SetBit(state.pos_status, POS_LLA_F);
 2232              		.loc 1 552 0
 2233 016c 2388     		ldrh	r3, [r4]
 2234 016e 43F48073 		orr	r3, r3, #256
 2235 0172 2380     		strh	r3, [r4]	@ movhi
 2236              	.L237:
 2237 0174 70BD     		pop	{r4, r5, r6, pc}
 2238              	.L263:
 2239 0176 00BF     		.align	3
 2240              	.L262:
 2241 0178 399D52A2 		.word	-1571644103
 2242 017c 46DF913F 		.word	1066524486
 2243 0180 00000000 		.word	0
 2244 0184 D0126341 		.word	1097011920
 2245 0188 00000000 		.word	.LANCHOR0
 2246 018c 00007A44 		.word	1148846080
 2247 0190 00005940 		.word	1079574528
 2248 0194 0000803B 		.word	998244352
 2249 0198 8C000000 		.word	.LANCHOR0+140
 2250              		.cfi_endproc
 2251              	.LFE148:
 2253 019c AFF30080 		.section	.text.stateCalcSpeedNed_i,"ax",%progbits
 2254              		.align	1
 2255              		.global	stateCalcSpeedNed_i
 2256              		.thumb
 2257              		.thumb_func
 2259              	stateCalcSpeedNed_i:
 2260              	.LFB149:
 553:state.c       **** }
 554:state.c       **** /** @}*/
 555:state.c       **** 
 556:state.c       **** 
 557:state.c       **** 
 558:state.c       **** 
 559:state.c       **** 
 560:state.c       **** /******************************************************************************
 561:state.c       ****  *                                                                            *
 562:state.c       ****  * Transformation functions for the SPEED representations                     *
 563:state.c       ****  *                                                                            *
 564:state.c       ****  *****************************************************************************/
 565:state.c       **** /** @addtogroup state_velocity
 566:state.c       ****  *  @{ */
 567:state.c       **** /************************ Set functions ****************************/
 568:state.c       **** 
 569:state.c       **** void stateCalcSpeedNed_i(void)
 570:state.c       **** {
 2261              		.loc 1 570 0
 2262              		.cfi_startproc
 2263              		@ args = 0, pretend = 0, frame = 0
 2264              		@ frame_needed = 0, uses_anonymous_args = 0
 2265 0000 10B5     		push	{r4, lr}
 2266              		.cfi_def_cfa_offset 8
 2267              		.cfi_offset 4, -8
 2268              		.cfi_offset 14, -4
 571:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2269              		.loc 1 571 0
 2270 0002 4F4C     		ldr	r4, .L285
 2271 0004 B4F81431 		ldrh	r3, [r4, #276]
 2272 0008 9807     		lsls	r0, r3, #30
 2273 000a 00F19880 		bmi	.L264
 2274              	.LVL158:
 572:state.c       ****     return;
 573:state.c       ****   }
 574:state.c       **** 
 575:state.c       ****   int errno = 0;
 576:state.c       ****   if (state.ned_initialized_i) {
 2275              		.loc 1 576 0
 2276 000e 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 2277 0012 002A     		cmp	r2, #0
 2278 0014 59D0     		beq	.L266
 577:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2279              		.loc 1 577 0
 2280 0016 5906     		lsls	r1, r3, #25
 2281 0018 1AD5     		bpl	.L267
 2282              	.L272:
 578:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2283              		.loc 1 578 0
 2284 001a DFED4A7A 		flds	s15, .L285+4
 2285 001e 94ED547A 		flds	s14, [r4, #336]
 2286 0022 27EE277A 		fmuls	s14, s14, s15
 2287 0026 BDEEC77A 		ftosizs	s14, s14
 2288 002a 84ED497A 		fsts	s14, [r4, #292]	@ int
 2289 002e 94ED557A 		flds	s14, [r4, #340]
 2290 0032 27EE277A 		fmuls	s14, s14, s15
 2291 0036 BDEEC77A 		ftosizs	s14, s14
 2292 003a 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2293 003e 94ED567A 		flds	s14, [r4, #344]
 2294 0042 67EE277A 		fmuls	s15, s14, s15
 2295 0046 FDEEE77A 		ftosizs	s15, s15
 2296 004a C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2297 004e 70E0     		b	.L268
 2298              	.L267:
 579:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2299              		.loc 1 579 0
 2300 0050 5A07     		lsls	r2, r3, #29
 2301 0052 0DD5     		bpl	.L269
 2302              	.L273:
 580:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2303              		.loc 1 580 0
 2304 0054 D4F83431 		ldr	r3, [r4, #308]
 2305 0058 C4F82431 		str	r3, [r4, #292]
 2306 005c D4F83031 		ldr	r3, [r4, #304]
 2307 0060 C4F82831 		str	r3, [r4, #296]
 2308 0064 D4F83831 		ldr	r3, [r4, #312]
 2309 0068 5B42     		negs	r3, r3
 2310 006a C4F82C31 		str	r3, [r4, #300]
 2311 006e 60E0     		b	.L268
 2312              	.L269:
 581:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2313              		.loc 1 581 0
 2314 0070 1806     		lsls	r0, r3, #24
 2315 0072 33D4     		bmi	.L284
 582:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 583:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 584:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 585:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2316              		.loc 1 585 0
 2317 0074 D907     		lsls	r1, r3, #31
 2318 0076 1FD4     		bmi	.L283
 586:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 587:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2319              		.loc 1 587 0
 2320 0078 9A06     		lsls	r2, r3, #26
 2321 007a 5AD5     		bpl	.L268
 588:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
 589:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2322              		.loc 1 589 0
 2323 007c DFED317A 		flds	s15, .L285+4
 2324 0080 94ED517A 		flds	s14, [r4, #324]
 2325 0084 27EE277A 		fmuls	s14, s14, s15
 590:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2326              		.loc 1 590 0
 2327 0088 43F00103 		orr	r3, r3, #1
 589:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2328              		.loc 1 589 0
 2329 008c BDEEC77A 		ftosizs	s14, s14
 2330              		.loc 1 590 0
 2331 0090 A4F81431 		strh	r3, [r4, #276]	@ movhi
 589:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2332              		.loc 1 589 0
 2333 0094 84ED467A 		fsts	s14, [r4, #280]	@ int
 2334 0098 94ED527A 		flds	s14, [r4, #328]
 2335 009c 27EE277A 		fmuls	s14, s14, s15
 2336 00a0 BDEEC77A 		ftosizs	s14, s14
 2337 00a4 84ED477A 		fsts	s14, [r4, #284]	@ int
 2338 00a8 94ED537A 		flds	s14, [r4, #332]
 2339 00ac 67EE277A 		fmuls	s15, s14, s15
 2340 00b0 FDEEE77A 		ftosizs	s15, s15
 2341 00b4 C4ED487A 		fsts	s15, [r4, #288]	@ int
 2342              	.L283:
 591:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2343              		.loc 1 591 0
 2344 00b8 04F59270 		add	r0, r4, #292
 2345 00bc 04F11C01 		add	r1, r4, #28
 2346 00c0 04F58C72 		add	r2, r4, #280
 2347 00c4 FFF7FEFF 		bl	ned_of_ecef_vect_i
 2348              	.LVL159:
 2349 00c8 33E0     		b	.L268
 2350              	.L266:
 592:state.c       ****     } else { /* could not get this representation,  set errno */
 593:state.c       ****       errno = 1;
 594:state.c       ****     }
 595:state.c       ****   } else if (state.utm_initialized_f) {
 2351              		.loc 1 595 0
 2352 00ca 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 2353 00ce 82B3     		cbz	r2, .L268
 596:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2354              		.loc 1 596 0
 2355 00d0 5806     		lsls	r0, r3, #25
 2356 00d2 A2D4     		bmi	.L272
 597:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 598:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2357              		.loc 1 598 0
 2358 00d4 5907     		lsls	r1, r3, #29
 2359 00d6 BDD4     		bmi	.L273
 599:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 600:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2360              		.loc 1 600 0
 2361 00d8 1A06     		lsls	r2, r3, #24
 2362 00da 2AD5     		bpl	.L268
 2363              	.L284:
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2364              		.loc 1 601 0
 2365 00dc DFED197A 		flds	s15, .L285+4
 2366 00e0 94ED577A 		flds	s14, [r4, #348]
 2367 00e4 27EE277A 		fmuls	s14, s14, s15
 602:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 2368              		.loc 1 602 0
 2369 00e8 43F00403 		orr	r3, r3, #4
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2370              		.loc 1 601 0
 2371 00ec BDEEC77A 		ftosizs	s14, s14
 2372              		.loc 1 602 0
 2373 00f0 A4F81431 		strh	r3, [r4, #276]	@ movhi
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2374              		.loc 1 601 0
 2375 00f4 17EE101A 		fmrs	r1, s14	@ int
 2376 00f8 84ED4C7A 		fsts	s14, [r4, #304]	@ int
 2377 00fc 94ED587A 		flds	s14, [r4, #352]
 603:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2378              		.loc 1 603 0
 2379 0100 C4F82811 		str	r1, [r4, #296]
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2380              		.loc 1 601 0
 2381 0104 27EE277A 		fmuls	s14, s14, s15
 2382 0108 BDEEC77A 		ftosizs	s14, s14
 2383 010c 17EE100A 		fmrs	r0, s14	@ int
 2384 0110 84ED4D7A 		fsts	s14, [r4, #308]	@ int
 2385 0114 94ED597A 		flds	s14, [r4, #356]
 2386              		.loc 1 603 0
 2387 0118 C4F82401 		str	r0, [r4, #292]
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2388              		.loc 1 601 0
 2389 011c 67EE277A 		fmuls	s15, s14, s15
 2390 0120 FDEEE77A 		ftosizs	s15, s15
 2391 0124 17EE902A 		fmrs	r2, s15	@ int
 2392              		.loc 1 603 0
 2393 0128 5242     		negs	r2, r2
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2394              		.loc 1 601 0
 2395 012a C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 2396              		.loc 1 603 0
 2397 012e C4F82C21 		str	r2, [r4, #300]
 2398              	.L268:
 604:state.c       ****     } else { /* could not get this representation,  set errno */
 605:state.c       ****       errno = 2;
 606:state.c       ****     }
 607:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 608:state.c       ****     errno = 3;
 609:state.c       ****   }
 610:state.c       ****   if (errno) {
 611:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 612:state.c       ****     //return _ned_zero;
 613:state.c       ****   }
 614:state.c       ****   /* set bit to indicate this representation is computed */
 615:state.c       ****   SetBit(state.speed_status, SPEED_NED_I);
 2399              		.loc 1 615 0
 2400 0132 B4F81431 		ldrh	r3, [r4, #276]
 2401 0136 43F00203 		orr	r3, r3, #2
 2402 013a A4F81431 		strh	r3, [r4, #276]	@ movhi
 2403              	.LVL160:
 2404              	.L264:
 2405 013e 10BD     		pop	{r4, pc}
 2406              	.L286:
 2407              		.align	2
 2408              	.L285:
 2409 0140 00000000 		.word	.LANCHOR0
 2410 0144 00000049 		.word	1224736768
 2411              		.cfi_endproc
 2412              	.LFE149:
 2414              		.section	.text.stateCalcSpeedEnu_i,"ax",%progbits
 2415              		.align	1
 2416              		.global	stateCalcSpeedEnu_i
 2417              		.thumb
 2418              		.thumb_func
 2420              	stateCalcSpeedEnu_i:
 2421              	.LFB150:
 616:state.c       **** }
 617:state.c       **** 
 618:state.c       **** void stateCalcSpeedEnu_i(void)
 619:state.c       **** {
 2422              		.loc 1 619 0
 2423              		.cfi_startproc
 2424              		@ args = 0, pretend = 0, frame = 0
 2425              		@ frame_needed = 0, uses_anonymous_args = 0
 2426 0000 10B5     		push	{r4, lr}
 2427              		.cfi_def_cfa_offset 8
 2428              		.cfi_offset 4, -8
 2429              		.cfi_offset 14, -4
 620:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2430              		.loc 1 620 0
 2431 0002 564C     		ldr	r4, .L314
 2432 0004 B4F81431 		ldrh	r3, [r4, #276]
 2433 0008 5907     		lsls	r1, r3, #29
 2434 000a 00F1A580 		bmi	.L287
 2435              	.LVL161:
 621:state.c       ****     return;
 622:state.c       ****   }
 623:state.c       **** 
 624:state.c       ****   int errno = 0;
 625:state.c       ****   if (state.ned_initialized_i) {
 2436              		.loc 1 625 0
 2437 000e 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 2438 0012 002A     		cmp	r2, #0
 2439 0014 3DD0     		beq	.L289
 626:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2440              		.loc 1 626 0
 2441 0016 9A07     		lsls	r2, r3, #30
 2442 0018 0CD5     		bpl	.L290
 627:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2443              		.loc 1 627 0
 2444 001a D4F82821 		ldr	r2, [r4, #296]
 2445 001e C4F83021 		str	r2, [r4, #304]
 2446 0022 D4F82421 		ldr	r2, [r4, #292]
 2447 0026 C4F83421 		str	r2, [r4, #308]
 2448 002a D4F82C21 		ldr	r2, [r4, #300]
 2449 002e 5242     		negs	r2, r2
 2450 0030 C4F83821 		str	r2, [r4, #312]
 2451              	.L290:
 628:state.c       ****     }
 629:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2452              		.loc 1 629 0
 2453 0034 1806     		lsls	r0, r3, #24
 2454 0036 41D4     		bmi	.L311
 630:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 631:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2455              		.loc 1 631 0
 2456 0038 5906     		lsls	r1, r3, #25
 2457 003a 5CD4     		bmi	.L312
 632:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 633:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 634:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 635:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2458              		.loc 1 635 0
 2459 003c DA07     		lsls	r2, r3, #31
 2460 003e 20D4     		bmi	.L313
 636:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 637:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2461              		.loc 1 637 0
 2462 0040 9806     		lsls	r0, r3, #26
 2463 0042 40F18380 		bpl	.L292
 638:state.c       ****       /* transform ecef_f -> ecef_i -> enu_i , set status bits */
 639:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2464              		.loc 1 639 0
 2465 0046 DFED467A 		flds	s15, .L314+4
 2466 004a 94ED517A 		flds	s14, [r4, #324]
 2467 004e 27EE277A 		fmuls	s14, s14, s15
 640:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2468              		.loc 1 640 0
 2469 0052 43F00103 		orr	r3, r3, #1
 639:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2470              		.loc 1 639 0
 2471 0056 BDEEC77A 		ftosizs	s14, s14
 2472              		.loc 1 640 0
 2473 005a A4F81431 		strh	r3, [r4, #276]	@ movhi
 639:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2474              		.loc 1 639 0
 2475 005e 84ED467A 		fsts	s14, [r4, #280]	@ int
 2476 0062 94ED527A 		flds	s14, [r4, #328]
 2477 0066 27EE277A 		fmuls	s14, s14, s15
 2478 006a BDEEC77A 		ftosizs	s14, s14
 2479 006e 84ED477A 		fsts	s14, [r4, #284]	@ int
 2480 0072 94ED537A 		flds	s14, [r4, #332]
 2481 0076 67EE277A 		fmuls	s15, s14, s15
 2482 007a FDEEE77A 		ftosizs	s15, s15
 2483 007e C4ED487A 		fsts	s15, [r4, #288]	@ int
 2484              	.L313:
 641:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2485              		.loc 1 641 0
 2486 0082 3848     		ldr	r0, .L314+8
 2487 0084 A0F58A71 		sub	r1, r0, #276
 2488 0088 A0F11802 		sub	r2, r0, #24
 2489 008c FFF7FEFF 		bl	enu_of_ecef_vect_i
 2490              	.LVL162:
 2491 0090 5CE0     		b	.L292
 2492              	.L289:
 642:state.c       ****     } else { /* could not get this representation,  set errno */
 643:state.c       ****       errno = 1;
 644:state.c       ****     }
 645:state.c       ****   } else if (state.utm_initialized_f) {
 2493              		.loc 1 645 0
 2494 0092 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 2495 0096 002A     		cmp	r2, #0
 2496 0098 58D0     		beq	.L292
 646:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2497              		.loc 1 646 0
 2498 009a 9907     		lsls	r1, r3, #30
 2499 009c 0CD5     		bpl	.L297
 647:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2500              		.loc 1 647 0
 2501 009e D4F82821 		ldr	r2, [r4, #296]
 2502 00a2 C4F83021 		str	r2, [r4, #304]
 2503 00a6 D4F82421 		ldr	r2, [r4, #292]
 2504 00aa C4F83421 		str	r2, [r4, #308]
 2505 00ae D4F82C21 		ldr	r2, [r4, #300]
 2506 00b2 5242     		negs	r2, r2
 2507 00b4 C4F83821 		str	r2, [r4, #312]
 2508              	.L297:
 648:state.c       ****     }
 649:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2509              		.loc 1 649 0
 2510 00b8 1A06     		lsls	r2, r3, #24
 2511 00ba 1AD5     		bpl	.L298
 2512              	.L311:
 650:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2513              		.loc 1 650 0
 2514 00bc DFED2A7A 		flds	s15, .L314+12
 2515 00c0 94ED577A 		flds	s14, [r4, #348]
 2516 00c4 27EE277A 		fmuls	s14, s14, s15
 2517 00c8 BDEEC77A 		ftosizs	s14, s14
 2518 00cc 84ED4C7A 		fsts	s14, [r4, #304]	@ int
 2519 00d0 94ED587A 		flds	s14, [r4, #352]
 2520 00d4 27EE277A 		fmuls	s14, s14, s15
 2521 00d8 BDEEC77A 		ftosizs	s14, s14
 2522 00dc 84ED4D7A 		fsts	s14, [r4, #308]	@ int
 2523 00e0 94ED597A 		flds	s14, [r4, #356]
 2524 00e4 67EE277A 		fmuls	s15, s14, s15
 2525 00e8 FDEEE77A 		ftosizs	s15, s15
 2526 00ec C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 2527 00f0 2CE0     		b	.L292
 2528              	.L298:
 651:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2529              		.loc 1 651 0
 2530 00f2 5B06     		lsls	r3, r3, #25
 2531 00f4 2AD5     		bpl	.L292
 2532              	.L312:
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2533              		.loc 1 652 0
 2534 00f6 DFED1A7A 		flds	s15, .L314+4
 2535 00fa 94ED547A 		flds	s14, [r4, #336]
 653:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 2536              		.loc 1 653 0
 2537 00fe 2088     		ldrh	r0, [r4]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2538              		.loc 1 652 0
 2539 0100 27EE277A 		fmuls	s14, s14, s15
 2540              		.loc 1 653 0
 2541 0104 40F00200 		orr	r0, r0, #2
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2542              		.loc 1 652 0
 2543 0108 BDEEC77A 		ftosizs	s14, s14
 2544              		.loc 1 653 0
 2545 010c 2080     		strh	r0, [r4]	@ movhi
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2546              		.loc 1 652 0
 2547 010e 17EE102A 		fmrs	r2, s14	@ int
 2548 0112 84ED497A 		fsts	s14, [r4, #292]	@ int
 2549 0116 94ED557A 		flds	s14, [r4, #340]
 654:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2550              		.loc 1 654 0
 2551 011a C4F83421 		str	r2, [r4, #308]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2552              		.loc 1 652 0
 2553 011e 27EE277A 		fmuls	s14, s14, s15
 2554 0122 BDEEC77A 		ftosizs	s14, s14
 2555 0126 17EE101A 		fmrs	r1, s14	@ int
 2556 012a 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2557 012e 94ED567A 		flds	s14, [r4, #344]
 2558              		.loc 1 654 0
 2559 0132 C4F83011 		str	r1, [r4, #304]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2560              		.loc 1 652 0
 2561 0136 67EE277A 		fmuls	s15, s14, s15
 2562 013a FDEEE77A 		ftosizs	s15, s15
 2563 013e 17EE903A 		fmrs	r3, s15	@ int
 2564              		.loc 1 654 0
 2565 0142 5B42     		negs	r3, r3
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2566              		.loc 1 652 0
 2567 0144 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2568              		.loc 1 654 0
 2569 0148 C4F83831 		str	r3, [r4, #312]
 2570              	.L292:
 655:state.c       ****     } else { /* could not get this representation,  set errno */
 656:state.c       ****       errno = 2;
 657:state.c       ****     }
 658:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 659:state.c       ****     errno = 3;
 660:state.c       ****   }
 661:state.c       ****   if (errno) {
 662:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 663:state.c       ****     //return _enu_zero;
 664:state.c       ****   }
 665:state.c       ****   /* set bit to indicate this representation is computed */
 666:state.c       ****   SetBit(state.speed_status, SPEED_ENU_I);
 2571              		.loc 1 666 0
 2572 014c B4F81431 		ldrh	r3, [r4, #276]
 2573 0150 43F00403 		orr	r3, r3, #4
 2574 0154 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2575              	.LVL163:
 2576              	.L287:
 2577 0158 10BD     		pop	{r4, pc}
 2578              	.L315:
 2579 015a 00BF     		.align	2
 2580              	.L314:
 2581 015c 00000000 		.word	.LANCHOR0
 2582 0160 00000049 		.word	1224736768
 2583 0164 30010000 		.word	.LANCHOR0+304
 2584 0168 00008043 		.word	1132462080
 2585              		.cfi_endproc
 2586              	.LFE150:
 2588              		.section	.text.stateCalcSpeedEcef_i,"ax",%progbits
 2589              		.align	1
 2590              		.global	stateCalcSpeedEcef_i
 2591              		.thumb
 2592              		.thumb_func
 2594              	stateCalcSpeedEcef_i:
 2595              	.LFB151:
 667:state.c       **** }
 668:state.c       **** 
 669:state.c       **** void stateCalcSpeedEcef_i(void)
 670:state.c       **** {
 2596              		.loc 1 670 0
 2597              		.cfi_startproc
 2598              		@ args = 0, pretend = 0, frame = 0
 2599              		@ frame_needed = 0, uses_anonymous_args = 0
 2600 0000 10B5     		push	{r4, lr}
 2601              		.cfi_def_cfa_offset 8
 2602              		.cfi_offset 4, -8
 2603              		.cfi_offset 14, -4
 671:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2604              		.loc 1 671 0
 2605 0002 294C     		ldr	r4, .L325
 2606 0004 B4F81431 		ldrh	r3, [r4, #276]
 2607 0008 DA07     		lsls	r2, r3, #31
 2608 000a 4CD4     		bmi	.L316
 672:state.c       ****     return;
 673:state.c       ****   }
 674:state.c       **** 
 675:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2609              		.loc 1 675 0
 2610 000c 9806     		lsls	r0, r3, #26
 2611 000e 1AD5     		bpl	.L318
 676:state.c       ****     SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2612              		.loc 1 676 0
 2613 0010 DFED267A 		flds	s15, .L325+4
 2614 0014 94ED517A 		flds	s14, [r4, #324]
 2615 0018 27EE277A 		fmuls	s14, s14, s15
 2616 001c BDEEC77A 		ftosizs	s14, s14
 2617 0020 84ED467A 		fsts	s14, [r4, #280]	@ int
 2618 0024 94ED527A 		flds	s14, [r4, #328]
 2619 0028 27EE277A 		fmuls	s14, s14, s15
 2620 002c BDEEC77A 		ftosizs	s14, s14
 2621 0030 84ED477A 		fsts	s14, [r4, #284]	@ int
 2622 0034 94ED537A 		flds	s14, [r4, #332]
 2623 0038 67EE277A 		fmuls	s15, s14, s15
 2624 003c FDEEE77A 		ftosizs	s15, s15
 2625 0040 C4ED487A 		fsts	s15, [r4, #288]	@ int
 2626 0044 29E0     		b	.L319
 2627              	.L318:
 677:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2628              		.loc 1 677 0
 2629 0046 9907     		lsls	r1, r3, #30
 2630 0048 1FD4     		bmi	.L324
 678:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 679:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2631              		.loc 1 679 0
 2632 004a 5A06     		lsls	r2, r3, #25
 2633 004c 25D5     		bpl	.L319
 680:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 681:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2634              		.loc 1 681 0
 2635 004e DFED177A 		flds	s15, .L325+4
 2636 0052 94ED547A 		flds	s14, [r4, #336]
 2637 0056 27EE277A 		fmuls	s14, s14, s15
 682:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2638              		.loc 1 682 0
 2639 005a 43F00203 		orr	r3, r3, #2
 681:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2640              		.loc 1 681 0
 2641 005e BDEEC77A 		ftosizs	s14, s14
 2642              		.loc 1 682 0
 2643 0062 A4F81431 		strh	r3, [r4, #276]	@ movhi
 681:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2644              		.loc 1 681 0
 2645 0066 84ED497A 		fsts	s14, [r4, #292]	@ int
 2646 006a 94ED557A 		flds	s14, [r4, #340]
 2647 006e 27EE277A 		fmuls	s14, s14, s15
 2648 0072 BDEEC77A 		ftosizs	s14, s14
 2649 0076 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2650 007a 94ED567A 		flds	s14, [r4, #344]
 2651 007e 67EE277A 		fmuls	s15, s14, s15
 2652 0082 FDEEE77A 		ftosizs	s15, s15
 2653 0086 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2654              	.L324:
 683:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 2655              		.loc 1 683 0
 2656 008a 04F58C70 		add	r0, r4, #280
 2657 008e 04F11C01 		add	r1, r4, #28
 2658 0092 04F59272 		add	r2, r4, #292
 2659 0096 FFF7FEFF 		bl	ecef_of_ned_vect_i
 2660              	.LVL164:
 2661              	.L319:
 684:state.c       ****   } else {
 685:state.c       ****     /* could not get this representation,  set errno */
 686:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
 687:state.c       ****     //return _ecef_zero;
 688:state.c       ****   }
 689:state.c       ****   /* set bit to indicate this representation is computed */
 690:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_I);
 2662              		.loc 1 690 0
 2663 009a B4F81431 		ldrh	r3, [r4, #276]
 2664 009e 43F00103 		orr	r3, r3, #1
 2665 00a2 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2666              	.L316:
 2667 00a6 10BD     		pop	{r4, pc}
 2668              	.L326:
 2669              		.align	2
 2670              	.L325:
 2671 00a8 00000000 		.word	.LANCHOR0
 2672 00ac 00000049 		.word	1224736768
 2673              		.cfi_endproc
 2674              	.LFE151:
 2676              		.section	.text.stateCalcHorizontalSpeedNorm_i,"ax",%progbits
 2677              		.align	1
 2678              		.global	stateCalcHorizontalSpeedNorm_i
 2679              		.thumb
 2680              		.thumb_func
 2682              	stateCalcHorizontalSpeedNorm_i:
 2683              	.LFB152:
 691:state.c       **** }
 692:state.c       **** 
 693:state.c       **** void stateCalcHorizontalSpeedNorm_i(void)
 694:state.c       **** {
 2684              		.loc 1 694 0
 2685              		.cfi_startproc
 2686              		@ args = 0, pretend = 0, frame = 0
 2687              		@ frame_needed = 0, uses_anonymous_args = 0
 2688 0000 10B5     		push	{r4, lr}
 2689              		.cfi_def_cfa_offset 8
 2690              		.cfi_offset 4, -8
 2691              		.cfi_offset 14, -4
 695:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I)) {
 2692              		.loc 1 695 0
 2693 0002 384C     		ldr	r4, .L344
 2694 0004 B4F81431 		ldrh	r3, [r4, #276]
 2695 0008 1A07     		lsls	r2, r3, #28
 2696 000a 69D4     		bmi	.L327
 696:state.c       ****     return;
 697:state.c       ****   }
 698:state.c       **** 
 699:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F)) {
 2697              		.loc 1 699 0
 2698 000c D805     		lsls	r0, r3, #23
 2699 000e 04D5     		bpl	.L329
 700:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2700              		.loc 1 700 0
 2701 0010 94ED5A7A 		flds	s14, [r4, #360]
 2702 0014 DFED347A 		flds	s15, .L344+4
 2703 0018 56E0     		b	.L339
 2704              	.L329:
 701:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2705              		.loc 1 701 0
 2706 001a 9907     		lsls	r1, r3, #30
 2707 001c 1FD4     		bmi	.L340
 702:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 703:state.c       ****                    state.ned_speed_i.y * state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 704:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 705:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2708              		.loc 1 705 0
 2709 001e 5A06     		lsls	r2, r3, #25
 2710 0020 3AD4     		bmi	.L341
 706:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 707:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 708:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 709:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2711              		.loc 1 709 0
 2712 0022 5807     		lsls	r0, r3, #29
 2713 0024 04D5     		bpl	.L333
 2714              	.LBB2:
 710:state.c       ****     uint32_t n2 = (state.enu_speed_i.x * state.enu_speed_i.x +
 2715              		.loc 1 710 0
 2716 0026 D4F83001 		ldr	r0, [r4, #304]
 711:state.c       ****                    state.enu_speed_i.y * state.enu_speed_i.y) >> INT32_SPEED_FRAC;
 2717              		.loc 1 711 0
 2718 002a D4F83431 		ldr	r3, [r4, #308]
 2719              	.LVL165:
 2720 002e 1AE0     		b	.L343
 2721              	.LVL166:
 2722              	.L333:
 2723              	.LBE2:
 712:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 713:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2724              		.loc 1 713 0
 2725 0030 1906     		lsls	r1, r3, #24
 2726 0032 04D5     		bpl	.L334
 714:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 2727              		.loc 1 714 0
 2728 0034 D4ED577A 		flds	s15, [r4, #348]
 2729 0038 94ED587A 		flds	s14, [r4, #352]
 2730 003c 30E0     		b	.L342
 2731              	.L334:
 715:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 716:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 717:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2732              		.loc 1 717 0
 2733 003e DA07     		lsls	r2, r3, #31
 2734 0040 1AD5     		bpl	.L335
 2735              	.LBB3:
 718:state.c       ****     /* transform ecef speed to ned, set status bit, then compute norm */
 719:state.c       ****     ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2736              		.loc 1 719 0
 2737 0042 04F59270 		add	r0, r4, #292
 2738 0046 04F11C01 		add	r1, r4, #28
 2739 004a 04F58C72 		add	r2, r4, #280
 2740 004e FFF7FEFF 		bl	ned_of_ecef_vect_i
 2741              	.LVL167:
 720:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2742              		.loc 1 720 0
 2743 0052 B4F81431 		ldrh	r3, [r4, #276]
 2744 0056 43F00203 		orr	r3, r3, #2
 2745 005a A4F81431 		strh	r3, [r4, #276]	@ movhi
 2746              	.L340:
 721:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 2747              		.loc 1 721 0
 2748 005e D4F82401 		ldr	r0, [r4, #292]
 722:state.c       ****                    state.ned_speed_i.y * state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 2749              		.loc 1 722 0
 2750 0062 D4F82831 		ldr	r3, [r4, #296]
 2751              	.L343:
 2752              	.LVL168:
 2753 0066 5B43     		muls	r3, r3, r3
 2754              	.LVL169:
 721:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 2755              		.loc 1 721 0
 2756 0068 00FB0030 		mla	r0, r0, r0, r3
 723:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 2757              		.loc 1 723 0
 2758 006c C014     		asrs	r0, r0, #19
 2759              	.LVL170:
 2760 006e FFF7FEFF 		bl	int32_sqrt
 2761              	.LVL171:
 2762 0072 C4F83C01 		str	r0, [r4, #316]
 2763              	.LBE3:
 2764 0076 2DE0     		b	.L330
 2765              	.L335:
 724:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2766              		.loc 1 724 0
 2767 0078 9B06     		lsls	r3, r3, #26
 2768 007a 2BD5     		bpl	.L330
 725:state.c       ****     ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 2769              		.loc 1 725 0
 2770 007c 04F5A870 		add	r0, r4, #336
 2771 0080 04F1A401 		add	r1, r4, #164
 2772 0084 04F5A272 		add	r2, r4, #324
 2773 0088 FFF7FEFF 		bl	ned_of_ecef_vect_f
 2774              	.LVL172:
 726:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 2775              		.loc 1 726 0
 2776 008c B4F81431 		ldrh	r3, [r4, #276]
 2777 0090 43F04003 		orr	r3, r3, #64
 2778 0094 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2779              	.L341:
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2780              		.loc 1 727 0
 2781 0098 D4ED547A 		flds	s15, [r4, #336]
 2782 009c 94ED557A 		flds	s14, [r4, #340]
 2783              	.L342:
 2784 00a0 27EE077A 		fmuls	s14, s14, s14
 2785 00a4 A7EEA77A 		vfma.f32	s14, s15, s15
 2786 00a8 17EE100A 		fmrs	r0, s14
 2787 00ac FFF7FEFF 		bl	sqrtf
 2788              	.LVL173:
 728:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 2789              		.loc 1 728 0
 2790 00b0 B4F81431 		ldrh	r3, [r4, #276]
 729:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2791              		.loc 1 729 0
 2792 00b4 9FED0C7A 		flds	s14, .L344+4
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2793              		.loc 1 727 0
 2794 00b8 C4F86801 		str	r0, [r4, #360]	@ float
 728:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 2795              		.loc 1 728 0
 2796 00bc 43F48073 		orr	r3, r3, #256
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2797              		.loc 1 727 0
 2798 00c0 07EE900A 		fmsr	s15, r0
 728:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 2799              		.loc 1 728 0
 2800 00c4 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2801              	.L339:
 2802              		.loc 1 729 0
 2803 00c8 67EE877A 		fmuls	s15, s15, s14
 2804 00cc FCEEE77A 		ftouizs	s15, s15
 2805 00d0 C4ED4F7A 		fsts	s15, [r4, #316]	@ int
 2806              	.L330:
 730:state.c       ****   } else {
 731:state.c       ****     //int32_t _norm_zero = 0;
 732:state.c       ****     //return _norm_zero;
 733:state.c       ****   }
 734:state.c       ****   /* set bit to indicate this representation is computed */
 735:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_I);
 2807              		.loc 1 735 0
 2808 00d4 B4F81431 		ldrh	r3, [r4, #276]
 2809 00d8 43F00803 		orr	r3, r3, #8
 2810 00dc A4F81431 		strh	r3, [r4, #276]	@ movhi
 2811              	.L327:
 2812 00e0 10BD     		pop	{r4, pc}
 2813              	.L345:
 2814 00e2 00BF     		.align	2
 2815              	.L344:
 2816 00e4 00000000 		.word	.LANCHOR0
 2817 00e8 00000049 		.word	1224736768
 2818              		.cfi_endproc
 2819              	.LFE152:
 2821              		.section	.text.stateCalcHorizontalSpeedDir_i,"ax",%progbits
 2822              		.align	1
 2823              		.global	stateCalcHorizontalSpeedDir_i
 2824              		.thumb
 2825              		.thumb_func
 2827              	stateCalcHorizontalSpeedDir_i:
 2828              	.LFB153:
 736:state.c       **** }
 737:state.c       **** 
 738:state.c       **** void stateCalcHorizontalSpeedDir_i(void)
 739:state.c       **** {
 2829              		.loc 1 739 0
 2830              		.cfi_startproc
 2831              		@ args = 0, pretend = 0, frame = 0
 2832              		@ frame_needed = 0, uses_anonymous_args = 0
 2833 0000 10B5     		push	{r4, lr}
 2834              		.cfi_def_cfa_offset 8
 2835              		.cfi_offset 4, -8
 2836              		.cfi_offset 14, -4
 740:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I)) {
 2837              		.loc 1 740 0
 2838 0002 584C     		ldr	r4, .L374
 2839 0004 B4F81431 		ldrh	r3, [r4, #276]
 2840 0008 D806     		lsls	r0, r3, #27
 2841 000a 00F1AA80 		bmi	.L346
 741:state.c       ****     return;
 742:state.c       ****   }
 743:state.c       **** 
 744:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F)) {
 2842              		.loc 1 744 0
 2843 000e 9905     		lsls	r1, r3, #22
 2844 0010 0AD5     		bpl	.L348
 745:state.c       ****     state.h_speed_dir_i = SPEED_BFP_OF_REAL(state.h_speed_dir_f);
 2845              		.loc 1 745 0
 2846 0012 94ED5B7A 		flds	s14, [r4, #364]
 2847 0016 DFED547A 		flds	s15, .L374+4
 2848 001a 67EE277A 		fmuls	s15, s14, s15
 2849 001e FDEEE77A 		ftosizs	s15, s15
 2850 0022 C4ED507A 		fsts	s15, [r4, #320]	@ int
 2851 0026 96E0     		b	.L349
 2852              	.L348:
 746:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2853              		.loc 1 746 0
 2854 0028 9A07     		lsls	r2, r3, #30
 2855 002a 14D5     		bpl	.L350
 747:state.c       ****     state.h_speed_dir_i = int32_atan2(state.ned_speed_i.y, state.ned_speed_i.x);
 2856              		.loc 1 747 0
 2857 002c D4F82801 		ldr	r0, [r4, #296]
 2858 0030 D4F82411 		ldr	r1, [r4, #292]
 2859 0034 FFF7FEFF 		bl	int32_atan2
 2860              	.LVL174:
 2861              	.L351:
 748:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2862              		.loc 1 748 0 discriminator 1
 2863 0038 0028     		cmp	r0, #0
 2864 003a 03DA     		bge	.L353
 2865              		.loc 1 748 0 is_stmt 0 discriminator 2
 2866 003c 00F5C940 		add	r0, r0, #25728
 2867 0040 0730     		adds	r0, r0, #7
 2868 0042 F9E7     		b	.L351
 2869              	.L353:
 2870              		.loc 1 748 0 discriminator 1
 2871 0044 46F28643 		movw	r3, #25734
 2872 0048 9842     		cmp	r0, r3
 2873 004a 40F38280 		ble	.L373
 2874              		.loc 1 748 0 discriminator 2
 2875 004e A0F5C940 		sub	r0, r0, #25728
 2876 0052 0738     		subs	r0, r0, #7
 2877 0054 F6E7     		b	.L353
 2878              	.L350:
 749:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2879              		.loc 1 749 0 is_stmt 1
 2880 0056 5807     		lsls	r0, r3, #29
 2881 0058 13D5     		bpl	.L355
 750:state.c       ****     state.h_speed_dir_i = int32_atan2(state.enu_speed_i.x, state.enu_speed_i.y);
 2882              		.loc 1 750 0
 2883 005a D4F83001 		ldr	r0, [r4, #304]
 2884 005e D4F83411 		ldr	r1, [r4, #308]
 2885 0062 FFF7FEFF 		bl	int32_atan2
 2886              	.LVL175:
 2887              	.L356:
 751:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2888              		.loc 1 751 0 discriminator 1
 2889 0066 0028     		cmp	r0, #0
 2890 0068 03DA     		bge	.L358
 2891              		.loc 1 751 0 is_stmt 0 discriminator 2
 2892 006a 00F5C940 		add	r0, r0, #25728
 2893 006e 0730     		adds	r0, r0, #7
 2894 0070 F9E7     		b	.L356
 2895              	.L358:
 2896              		.loc 1 751 0 discriminator 1
 2897 0072 46F28643 		movw	r3, #25734
 2898 0076 9842     		cmp	r0, r3
 2899 0078 6BDD     		ble	.L373
 2900              		.loc 1 751 0 discriminator 2
 2901 007a A0F5C940 		sub	r0, r0, #25728
 2902 007e 0738     		subs	r0, r0, #7
 2903 0080 F7E7     		b	.L358
 2904              	.L355:
 752:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2905              		.loc 1 752 0 is_stmt 1
 2906 0082 5906     		lsls	r1, r3, #25
 2907 0084 31D5     		bpl	.L361
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2908              		.loc 1 753 0
 2909 0086 DFED387A 		flds	s15, .L374+4
 2910 008a 94ED547A 		flds	s14, [r4, #336]
 2911 008e 27EE277A 		fmuls	s14, s14, s15
 754:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2912              		.loc 1 754 0
 2913 0092 43F00203 		orr	r3, r3, #2
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2914              		.loc 1 753 0
 2915 0096 BDEEC77A 		ftosizs	s14, s14
 2916              		.loc 1 754 0
 2917 009a A4F81431 		strh	r3, [r4, #276]	@ movhi
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2918              		.loc 1 753 0
 2919 009e 17EE101A 		fmrs	r1, s14	@ int
 2920 00a2 84ED497A 		fsts	s14, [r4, #292]	@ int
 2921 00a6 94ED557A 		flds	s14, [r4, #340]
 2922 00aa 27EE277A 		fmuls	s14, s14, s15
 2923 00ae BDEEC77A 		ftosizs	s14, s14
 2924 00b2 17EE100A 		fmrs	r0, s14	@ int
 2925 00b6 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2926 00ba 94ED567A 		flds	s14, [r4, #344]
 2927 00be 67EE277A 		fmuls	s15, s14, s15
 2928 00c2 FDEEE77A 		ftosizs	s15, s15
 2929 00c6 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 755:state.c       ****     state.h_speed_dir_i = int32_atan2(state.ned_speed_i.y, state.ned_speed_i.x);
 2930              		.loc 1 755 0
 2931 00ca FFF7FEFF 		bl	int32_atan2
 2932              	.LVL176:
 2933              	.L362:
 756:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2934              		.loc 1 756 0 discriminator 1
 2935 00ce 0028     		cmp	r0, #0
 2936 00d0 03DA     		bge	.L364
 2937              		.loc 1 756 0 is_stmt 0 discriminator 2
 2938 00d2 00F5C940 		add	r0, r0, #25728
 2939 00d6 0730     		adds	r0, r0, #7
 2940 00d8 F9E7     		b	.L362
 2941              	.L364:
 2942              		.loc 1 756 0 discriminator 1
 2943 00da 46F28643 		movw	r3, #25734
 2944 00de 9842     		cmp	r0, r3
 2945 00e0 37DD     		ble	.L373
 2946              		.loc 1 756 0 discriminator 2
 2947 00e2 A0F5C940 		sub	r0, r0, #25728
 2948 00e6 0738     		subs	r0, r0, #7
 2949 00e8 F7E7     		b	.L364
 2950              	.L361:
 757:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2951              		.loc 1 757 0 is_stmt 1
 2952 00ea 1A06     		lsls	r2, r3, #24
 2953 00ec 33D5     		bpl	.L349
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2954              		.loc 1 758 0
 2955 00ee DFED1E7A 		flds	s15, .L374+4
 2956 00f2 94ED577A 		flds	s14, [r4, #348]
 2957 00f6 27EE277A 		fmuls	s14, s14, s15
 759:state.c       ****     SetBit(state.speed_status, SPEED_ENU_I);
 2958              		.loc 1 759 0
 2959 00fa 43F00403 		orr	r3, r3, #4
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2960              		.loc 1 758 0
 2961 00fe BDEEC77A 		ftosizs	s14, s14
 2962              		.loc 1 759 0
 2963 0102 A4F81431 		strh	r3, [r4, #276]	@ movhi
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2964              		.loc 1 758 0
 2965 0106 17EE100A 		fmrs	r0, s14	@ int
 2966 010a 84ED4C7A 		fsts	s14, [r4, #304]	@ int
 2967 010e 94ED587A 		flds	s14, [r4, #352]
 2968 0112 27EE277A 		fmuls	s14, s14, s15
 2969 0116 BDEEC77A 		ftosizs	s14, s14
 2970 011a 17EE101A 		fmrs	r1, s14	@ int
 2971 011e 84ED4D7A 		fsts	s14, [r4, #308]	@ int
 2972 0122 94ED597A 		flds	s14, [r4, #356]
 2973 0126 67EE277A 		fmuls	s15, s14, s15
 2974 012a FDEEE77A 		ftosizs	s15, s15
 2975 012e C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 760:state.c       ****     state.h_speed_dir_i = int32_atan2(state.enu_speed_i.x, state.enu_speed_i.y);
 2976              		.loc 1 760 0
 2977 0132 FFF7FEFF 		bl	int32_atan2
 2978              	.LVL177:
 2979              	.L366:
 761:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2980              		.loc 1 761 0 discriminator 1
 2981 0136 0028     		cmp	r0, #0
 2982 0138 03DA     		bge	.L368
 2983              		.loc 1 761 0 is_stmt 0 discriminator 2
 2984 013a 00F5C940 		add	r0, r0, #25728
 2985 013e 0730     		adds	r0, r0, #7
 2986 0140 F9E7     		b	.L366
 2987              	.L368:
 2988              		.loc 1 761 0 discriminator 1
 2989 0142 46F28643 		movw	r3, #25734
 2990 0146 9842     		cmp	r0, r3
 2991 0148 03DD     		ble	.L373
 2992              		.loc 1 761 0 discriminator 2
 2993 014a A0F5C940 		sub	r0, r0, #25728
 2994 014e 0738     		subs	r0, r0, #7
 2995 0150 F7E7     		b	.L368
 2996              	.L373:
 2997 0152 C4F84001 		str	r0, [r4, #320]
 2998              	.L349:
 762:state.c       ****   }
 763:state.c       ****   /* set bit to indicate this representation is computed */
 764:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_I);
 2999              		.loc 1 764 0 is_stmt 1
 3000 0156 B4F81431 		ldrh	r3, [r4, #276]
 3001 015a 43F01003 		orr	r3, r3, #16
 3002 015e A4F81431 		strh	r3, [r4, #276]	@ movhi
 3003              	.L346:
 3004 0162 10BD     		pop	{r4, pc}
 3005              	.L375:
 3006              		.align	2
 3007              	.L374:
 3008 0164 00000000 		.word	.LANCHOR0
 3009 0168 00000049 		.word	1224736768
 3010              		.cfi_endproc
 3011              	.LFE153:
 3013              		.section	.text.stateCalcSpeedNed_f,"ax",%progbits
 3014              		.align	1
 3015              		.global	stateCalcSpeedNed_f
 3016              		.thumb
 3017              		.thumb_func
 3019              	stateCalcSpeedNed_f:
 3020              	.LFB154:
 765:state.c       **** }
 766:state.c       **** 
 767:state.c       **** void stateCalcSpeedNed_f(void)
 768:state.c       **** {
 3021              		.loc 1 768 0
 3022              		.cfi_startproc
 3023              		@ args = 0, pretend = 0, frame = 0
 3024              		@ frame_needed = 0, uses_anonymous_args = 0
 3025 0000 10B5     		push	{r4, lr}
 3026              		.cfi_def_cfa_offset 8
 3027              		.cfi_offset 4, -8
 3028              		.cfi_offset 14, -4
 769:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3029              		.loc 1 769 0
 3030 0002 4D4C     		ldr	r4, .L399
 3031 0004 B4F81431 		ldrh	r3, [r4, #276]
 3032 0008 5806     		lsls	r0, r3, #25
 3033 000a 00F19380 		bmi	.L376
 3034              	.LVL178:
 770:state.c       ****     return;
 771:state.c       ****   }
 772:state.c       **** 
 773:state.c       ****   int errno = 0;
 774:state.c       ****   if (state.ned_initialized_f) {
 3035              		.loc 1 774 0
 3036 000e 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 3037 0012 002A     		cmp	r2, #0
 3038 0014 59D0     		beq	.L378
 775:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3039              		.loc 1 775 0
 3040 0016 9907     		lsls	r1, r3, #30
 3041 0018 18D5     		bpl	.L379
 3042              	.L384:
 776:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3043              		.loc 1 776 0
 3044 001a D4ED495A 		flds	s11, [r4, #292]	@ int
 3045 001e DFED477A 		flds	s15, .L399+4
 3046 0022 94ED4A6A 		flds	s12, [r4, #296]	@ int
 3047 0026 D4ED4B6A 		flds	s13, [r4, #300]	@ int
 3048 002a B8EEE57A 		fsitos	s14, s11
 3049 002e 27EE277A 		fmuls	s14, s14, s15
 3050 0032 84ED547A 		fsts	s14, [r4, #336]
 3051 0036 B8EEC67A 		fsitos	s14, s12
 3052 003a 27EE277A 		fmuls	s14, s14, s15
 3053 003e 84ED557A 		fsts	s14, [r4, #340]
 3054 0042 B8EEE67A 		fsitos	s14, s13
 3055 0046 67EE277A 		fmuls	s15, s14, s15
 3056 004a 6BE0     		b	.L396
 3057              	.L379:
 777:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3058              		.loc 1 777 0
 3059 004c 1A06     		lsls	r2, r3, #24
 3060 004e 0AD5     		bpl	.L381
 3061              	.L385:
 778:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 3062              		.loc 1 778 0
 3063 0050 D4F86031 		ldr	r3, [r4, #352]	@ float
 3064 0054 C4F85031 		str	r3, [r4, #336]	@ float
 3065 0058 D4F85C31 		ldr	r3, [r4, #348]	@ float
 3066 005c C4F85431 		str	r3, [r4, #340]	@ float
 3067 0060 D4ED597A 		flds	s15, [r4, #356]
 3068 0064 5CE0     		b	.L397
 3069              	.L381:
 779:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3070              		.loc 1 779 0
 3071 0066 5807     		lsls	r0, r3, #29
 3072 0068 04D5     		bpl	.L382
 780:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3073              		.loc 1 780 0
 3074 006a D4ED4C7A 		flds	s15, [r4, #304]	@ int
 3075 006e B8EEE77A 		fsitos	s14, s15
 3076 0072 37E0     		b	.L398
 3077              	.L382:
 781:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 782:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 783:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3078              		.loc 1 783 0
 3079 0074 9906     		lsls	r1, r3, #26
 3080 0076 1FD4     		bmi	.L395
 784:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 785:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3081              		.loc 1 785 0
 3082 0078 DA07     		lsls	r2, r3, #31
 3083 007a 55D5     		bpl	.L380
 786:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
 787:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3084              		.loc 1 787 0
 3085 007c 94ED466A 		flds	s12, [r4, #280]	@ int
 3086 0080 DFED2E7A 		flds	s15, .L399+4
 3087 0084 D4ED476A 		flds	s13, [r4, #284]	@ int
 3088 0088 D4ED485A 		flds	s11, [r4, #288]	@ int
 3089 008c B8EEC67A 		fsitos	s14, s12
 788:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3090              		.loc 1 788 0
 3091 0090 43F02003 		orr	r3, r3, #32
 787:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3092              		.loc 1 787 0
 3093 0094 27EE277A 		fmuls	s14, s14, s15
 3094              		.loc 1 788 0
 3095 0098 A4F81431 		strh	r3, [r4, #276]	@ movhi
 787:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3096              		.loc 1 787 0
 3097 009c 84ED517A 		fsts	s14, [r4, #324]
 3098 00a0 B8EEE67A 		fsitos	s14, s13
 3099 00a4 27EE277A 		fmuls	s14, s14, s15
 3100 00a8 84ED527A 		fsts	s14, [r4, #328]
 3101 00ac B8EEE57A 		fsitos	s14, s11
 3102 00b0 67EE277A 		fmuls	s15, s14, s15
 3103 00b4 C4ED537A 		fsts	s15, [r4, #332]
 3104              	.L395:
 789:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3105              		.loc 1 789 0
 3106 00b8 04F5A870 		add	r0, r4, #336
 3107 00bc 04F1A401 		add	r1, r4, #164
 3108 00c0 04F5A272 		add	r2, r4, #324
 3109 00c4 FFF7FEFF 		bl	ned_of_ecef_vect_f
 3110              	.LVL179:
 3111 00c8 2EE0     		b	.L380
 3112              	.L378:
 790:state.c       ****     } else { /* could not get this representation,  set errno */
 791:state.c       ****       errno = 1;
 792:state.c       ****     }
 793:state.c       ****   } else if (state.utm_initialized_f) {
 3113              		.loc 1 793 0
 3114 00ca 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 3115 00ce 5AB3     		cbz	r2, .L380
 794:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3116              		.loc 1 794 0
 3117 00d0 9807     		lsls	r0, r3, #30
 3118 00d2 A2D4     		bmi	.L384
 795:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 796:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3119              		.loc 1 796 0
 3120 00d4 1906     		lsls	r1, r3, #24
 3121 00d6 BBD4     		bmi	.L385
 797:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 798:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3122              		.loc 1 798 0
 3123 00d8 5A07     		lsls	r2, r3, #29
 3124 00da 25D5     		bpl	.L380
 799:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3125              		.loc 1 799 0
 3126 00dc 94ED4C6A 		flds	s12, [r4, #304]	@ int
 3127 00e0 B8EEC67A 		fsitos	s14, s12
 3128              	.L398:
 3129 00e4 D4ED4D5A 		flds	s11, [r4, #308]	@ int
 3130 00e8 DFED147A 		flds	s15, .L399+4
 3131 00ec F8EEE56A 		fsitos	s13, s11
 3132 00f0 D4ED4E5A 		flds	s11, [r4, #312]	@ int
 3133 00f4 B8EEE56A 		fsitos	s12, s11
 3134 00f8 27EE277A 		fmuls	s14, s14, s15
 3135 00fc 66EEA76A 		fmuls	s13, s13, s15
 3136 0100 66EE277A 		fmuls	s15, s12, s15
 800:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 3137              		.loc 1 800 0
 3138 0104 43F08003 		orr	r3, r3, #128
 799:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3139              		.loc 1 799 0
 3140 0108 84ED577A 		fsts	s14, [r4, #348]
 3141 010c C4ED586A 		fsts	s13, [r4, #352]
 3142 0110 C4ED597A 		fsts	s15, [r4, #356]
 3143              		.loc 1 800 0
 3144 0114 A4F81431 		strh	r3, [r4, #276]	@ movhi
 801:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 3145              		.loc 1 801 0
 3146 0118 C4ED546A 		fsts	s13, [r4, #336]
 3147 011c 84ED557A 		fsts	s14, [r4, #340]
 3148              	.L397:
 3149 0120 F1EE677A 		fnegs	s15, s15
 3150              	.L396:
 3151 0124 C4ED567A 		fsts	s15, [r4, #344]
 3152              	.L380:
 802:state.c       ****     } else { /* could not get this representation,  set errno */
 803:state.c       ****       errno = 2;
 804:state.c       ****     }
 805:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 806:state.c       ****     errno = 3;
 807:state.c       ****   }
 808:state.c       ****   if (errno) {
 809:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 810:state.c       ****     //return _ned_zero;
 811:state.c       ****   }
 812:state.c       ****   /* set bit to indicate this representation is computed */
 813:state.c       ****   SetBit(state.speed_status, SPEED_NED_F);
 3153              		.loc 1 813 0
 3154 0128 B4F81431 		ldrh	r3, [r4, #276]
 3155 012c 43F04003 		orr	r3, r3, #64
 3156 0130 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3157              	.LVL180:
 3158              	.L376:
 3159 0134 10BD     		pop	{r4, pc}
 3160              	.L400:
 3161 0136 00BF     		.align	2
 3162              	.L399:
 3163 0138 00000000 		.word	.LANCHOR0
 3164 013c 00000036 		.word	905969664
 3165              		.cfi_endproc
 3166              	.LFE154:
 3168              		.section	.text.stateCalcSpeedEnu_f,"ax",%progbits
 3169              		.align	1
 3170              		.global	stateCalcSpeedEnu_f
 3171              		.thumb
 3172              		.thumb_func
 3174              	stateCalcSpeedEnu_f:
 3175              	.LFB155:
 814:state.c       **** }
 815:state.c       **** 
 816:state.c       **** void stateCalcSpeedEnu_f(void)
 817:state.c       **** {
 3176              		.loc 1 817 0
 3177              		.cfi_startproc
 3178              		@ args = 0, pretend = 0, frame = 0
 3179              		@ frame_needed = 0, uses_anonymous_args = 0
 3180 0000 10B5     		push	{r4, lr}
 3181              		.cfi_def_cfa_offset 8
 3182              		.cfi_offset 4, -8
 3183              		.cfi_offset 14, -4
 818:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3184              		.loc 1 818 0
 3185 0002 4B4C     		ldr	r4, .L421
 3186 0004 B4F81431 		ldrh	r3, [r4, #276]
 3187 0008 1906     		lsls	r1, r3, #24
 3188 000a 00F18F80 		bmi	.L401
 3189              	.LVL181:
 819:state.c       ****     return;
 820:state.c       ****   }
 821:state.c       **** 
 822:state.c       ****   int errno = 0;
 823:state.c       ****   if (state.ned_initialized_f) {
 3190              		.loc 1 823 0
 3191 000e 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 3192 0012 002A     		cmp	r2, #0
 3193 0014 7BD0     		beq	.L403
 824:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3194              		.loc 1 824 0
 3195 0016 5A06     		lsls	r2, r3, #25
 3196 0018 0AD5     		bpl	.L404
 3197              	.L409:
 825:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3198              		.loc 1 825 0
 3199 001a D4F85431 		ldr	r3, [r4, #340]	@ float
 3200 001e C4F85C31 		str	r3, [r4, #348]	@ float
 3201 0022 D4F85031 		ldr	r3, [r4, #336]	@ float
 3202 0026 C4F86031 		str	r3, [r4, #352]	@ float
 3203 002a D4ED567A 		flds	s15, [r4, #344]
 3204 002e 3EE0     		b	.L418
 3205              	.L404:
 826:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3206              		.loc 1 826 0
 3207 0030 5807     		lsls	r0, r3, #29
 3208 0032 18D5     		bpl	.L406
 3209              	.L410:
 827:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3210              		.loc 1 827 0
 3211 0034 D4ED4C5A 		flds	s11, [r4, #304]	@ int
 3212 0038 DFED3E7A 		flds	s15, .L421+4
 3213 003c 94ED4D6A 		flds	s12, [r4, #308]	@ int
 3214 0040 D4ED4E6A 		flds	s13, [r4, #312]	@ int
 3215 0044 B8EEE57A 		fsitos	s14, s11
 3216 0048 27EE277A 		fmuls	s14, s14, s15
 3217 004c 84ED577A 		fsts	s14, [r4, #348]
 3218 0050 B8EEC67A 		fsitos	s14, s12
 3219 0054 27EE277A 		fmuls	s14, s14, s15
 3220 0058 84ED587A 		fsts	s14, [r4, #352]
 3221 005c B8EEE67A 		fsitos	s14, s13
 3222 0060 67EE277A 		fmuls	s15, s14, s15
 3223 0064 25E0     		b	.L420
 3224              	.L406:
 828:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3225              		.loc 1 828 0
 3226 0066 9907     		lsls	r1, r3, #30
 3227 0068 26D5     		bpl	.L407
 3228              	.L411:
 829:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3229              		.loc 1 829 0
 3230 006a D4ED4A5A 		flds	s11, [r4, #296]	@ int
 3231 006e D4ED497A 		flds	s15, [r4, #292]	@ int
 830:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 3232              		.loc 1 830 0
 3233 0072 2388     		ldrh	r3, [r4]
 829:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3234              		.loc 1 829 0
 3235 0074 F8EEE56A 		fsitos	s13, s11
 3236 0078 D4ED4B5A 		flds	s11, [r4, #300]	@ int
 3237 007c B8EEE77A 		fsitos	s14, s15
 3238 0080 B8EEE56A 		fsitos	s12, s11
 3239 0084 DFED2C7A 		flds	s15, .L421+8
 3240 0088 27EE277A 		fmuls	s14, s14, s15
 3241 008c 66EEA76A 		fmuls	s13, s13, s15
 3242 0090 66EE277A 		fmuls	s15, s12, s15
 3243              		.loc 1 830 0
 3244 0094 43F04003 		orr	r3, r3, #64
 829:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3245              		.loc 1 829 0
 3246 0098 84ED547A 		fsts	s14, [r4, #336]
 3247 009c C4ED556A 		fsts	s13, [r4, #340]
 3248 00a0 C4ED567A 		fsts	s15, [r4, #344]
 3249              		.loc 1 830 0
 3250 00a4 2380     		strh	r3, [r4]	@ movhi
 831:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3251              		.loc 1 831 0
 3252 00a6 C4ED576A 		fsts	s13, [r4, #348]
 3253 00aa 84ED587A 		fsts	s14, [r4, #352]
 3254              	.L418:
 3255 00ae F1EE677A 		fnegs	s15, s15
 3256              	.L420:
 3257 00b2 C4ED597A 		fsts	s15, [r4, #356]
 3258 00b6 33E0     		b	.L405
 3259              	.L407:
 832:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3260              		.loc 1 832 0
 3261 00b8 9A06     		lsls	r2, r3, #26
 3262 00ba 1FD4     		bmi	.L419
 833:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 834:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3263              		.loc 1 834 0
 3264 00bc D807     		lsls	r0, r3, #31
 3265 00be 2FD5     		bpl	.L405
 835:state.c       ****       /* transform ecef_I -> ecef_f -> enu_f , set status bits */
 836:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3266              		.loc 1 836 0
 3267 00c0 94ED466A 		flds	s12, [r4, #280]	@ int
 3268 00c4 DFED1C7A 		flds	s15, .L421+8
 3269 00c8 D4ED476A 		flds	s13, [r4, #284]	@ int
 3270 00cc D4ED485A 		flds	s11, [r4, #288]	@ int
 3271 00d0 B8EEC67A 		fsitos	s14, s12
 837:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3272              		.loc 1 837 0
 3273 00d4 43F02003 		orr	r3, r3, #32
 836:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3274              		.loc 1 836 0
 3275 00d8 27EE277A 		fmuls	s14, s14, s15
 3276              		.loc 1 837 0
 3277 00dc A4F81431 		strh	r3, [r4, #276]	@ movhi
 836:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3278              		.loc 1 836 0
 3279 00e0 84ED517A 		fsts	s14, [r4, #324]
 3280 00e4 B8EEE67A 		fsitos	s14, s13
 3281 00e8 27EE277A 		fmuls	s14, s14, s15
 3282 00ec 84ED527A 		fsts	s14, [r4, #328]
 3283 00f0 B8EEE57A 		fsitos	s14, s11
 3284 00f4 67EE277A 		fmuls	s15, s14, s15
 3285 00f8 C4ED537A 		fsts	s15, [r4, #332]
 3286              	.L419:
 838:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3287              		.loc 1 838 0
 3288 00fc 04F5AE70 		add	r0, r4, #348
 3289 0100 04F1A401 		add	r1, r4, #164
 3290 0104 04F5A272 		add	r2, r4, #324
 3291 0108 FFF7FEFF 		bl	enu_of_ecef_vect_f
 3292              	.LVL182:
 3293 010c 08E0     		b	.L405
 3294              	.L403:
 839:state.c       ****     } else { /* could not get this representation,  set errno */
 840:state.c       ****       errno = 1;
 841:state.c       ****     }
 842:state.c       ****   } else if (state.utm_initialized_f) {
 3295              		.loc 1 842 0
 3296 010e 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 3297 0112 2AB1     		cbz	r2, .L405
 843:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3298              		.loc 1 843 0
 3299 0114 5906     		lsls	r1, r3, #25
 3300 0116 80D4     		bmi	.L409
 844:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 845:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3301              		.loc 1 845 0
 3302 0118 5A07     		lsls	r2, r3, #29
 3303 011a 8BD4     		bmi	.L410
 846:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 847:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3304              		.loc 1 847 0
 3305 011c 9B07     		lsls	r3, r3, #30
 3306 011e A4D4     		bmi	.L411
 3307              	.L405:
 848:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 849:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 850:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 851:state.c       ****     } else { /* could not get this representation,  set errno */
 852:state.c       ****       errno = 2;
 853:state.c       ****     }
 854:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 855:state.c       ****     errno = 3;
 856:state.c       ****   }
 857:state.c       ****   if (errno) {
 858:state.c       ****     //struct EnuCoor_f _enu_zero = {0};
 859:state.c       ****     //return _enu_zero;
 860:state.c       ****   }
 861:state.c       ****   /* set bit to indicate this representation is computed */
 862:state.c       ****   SetBit(state.speed_status, SPEED_ENU_F);
 3308              		.loc 1 862 0
 3309 0120 B4F81431 		ldrh	r3, [r4, #276]
 3310 0124 43F08003 		orr	r3, r3, #128
 3311 0128 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3312              	.LVL183:
 3313              	.L401:
 3314 012c 10BD     		pop	{r4, pc}
 3315              	.L422:
 3316 012e 00BF     		.align	2
 3317              	.L421:
 3318 0130 00000000 		.word	.LANCHOR0
 3319 0134 0000803B 		.word	998244352
 3320 0138 00000036 		.word	905969664
 3321              		.cfi_endproc
 3322              	.LFE155:
 3324              		.section	.text.stateCalcSpeedEcef_f,"ax",%progbits
 3325              		.align	1
 3326              		.global	stateCalcSpeedEcef_f
 3327              		.thumb
 3328              		.thumb_func
 3330              	stateCalcSpeedEcef_f:
 3331              	.LFB156:
 863:state.c       **** }
 864:state.c       **** 
 865:state.c       **** void stateCalcSpeedEcef_f(void)
 866:state.c       **** {
 3332              		.loc 1 866 0
 3333              		.cfi_startproc
 3334              		@ args = 0, pretend = 0, frame = 0
 3335              		@ frame_needed = 0, uses_anonymous_args = 0
 3336 0000 10B5     		push	{r4, lr}
 3337              		.cfi_def_cfa_offset 8
 3338              		.cfi_offset 4, -8
 3339              		.cfi_offset 14, -4
 867:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3340              		.loc 1 867 0
 3341 0002 294C     		ldr	r4, .L432
 3342 0004 B4F81431 		ldrh	r3, [r4, #276]
 3343 0008 9A06     		lsls	r2, r3, #26
 3344 000a 4CD4     		bmi	.L423
 868:state.c       ****     return;
 869:state.c       ****   }
 870:state.c       **** 
 871:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3345              		.loc 1 871 0
 3346 000c D807     		lsls	r0, r3, #31
 3347 000e 1AD5     		bpl	.L425
 872:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ned_speed_i);
 3348              		.loc 1 872 0
 3349 0010 D4ED496A 		flds	s13, [r4, #292]	@ int
 3350 0014 DFED257A 		flds	s15, .L432+4
 3351 0018 B8EEE67A 		fsitos	s14, s13
 3352 001c D4ED4A6A 		flds	s13, [r4, #296]	@ int
 3353 0020 27EE277A 		fmuls	s14, s14, s15
 3354 0024 84ED517A 		fsts	s14, [r4, #324]
 3355 0028 B8EEE67A 		fsitos	s14, s13
 3356 002c D4ED4B6A 		flds	s13, [r4, #300]	@ int
 3357 0030 27EE277A 		fmuls	s14, s14, s15
 3358 0034 84ED527A 		fsts	s14, [r4, #328]
 3359 0038 B8EEE67A 		fsitos	s14, s13
 3360 003c 67EE277A 		fmuls	s15, s14, s15
 3361 0040 C4ED537A 		fsts	s15, [r4, #332]
 3362 0044 29E0     		b	.L426
 3363              	.L425:
 873:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3364              		.loc 1 873 0
 3365 0046 5906     		lsls	r1, r3, #25
 3366 0048 1FD4     		bmi	.L431
 874:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 875:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3367              		.loc 1 875 0
 3368 004a 9A07     		lsls	r2, r3, #30
 3369 004c 25D5     		bpl	.L426
 876:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 877:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3370              		.loc 1 877 0
 3371 004e D4ED497A 		flds	s15, [r4, #292]	@ int
 3372 0052 D4ED4A6A 		flds	s13, [r4, #296]	@ int
 3373 0056 B8EEE77A 		fsitos	s14, s15
 3374 005a DFED147A 		flds	s15, .L432+4
 3375 005e 27EE277A 		fmuls	s14, s14, s15
 878:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3376              		.loc 1 878 0
 3377 0062 43F04003 		orr	r3, r3, #64
 877:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3378              		.loc 1 877 0
 3379 0066 84ED547A 		fsts	s14, [r4, #336]
 3380 006a B8EEE67A 		fsitos	s14, s13
 3381 006e D4ED4B6A 		flds	s13, [r4, #300]	@ int
 3382              		.loc 1 878 0
 3383 0072 A4F81431 		strh	r3, [r4, #276]	@ movhi
 877:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3384              		.loc 1 877 0
 3385 0076 27EE277A 		fmuls	s14, s14, s15
 3386 007a 84ED557A 		fsts	s14, [r4, #340]
 3387 007e B8EEE67A 		fsitos	s14, s13
 3388 0082 67EE277A 		fmuls	s15, s14, s15
 3389 0086 C4ED567A 		fsts	s15, [r4, #344]
 3390              	.L431:
 879:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 3391              		.loc 1 879 0
 3392 008a 04F5A270 		add	r0, r4, #324
 3393 008e 04F1A401 		add	r1, r4, #164
 3394 0092 04F5A872 		add	r2, r4, #336
 3395 0096 FFF7FEFF 		bl	ecef_of_ned_vect_f
 3396              	.LVL184:
 3397              	.L426:
 880:state.c       ****   } else {
 881:state.c       ****     /* could not get this representation,  set errno */
 882:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 883:state.c       ****     //return _ecef_zero;
 884:state.c       ****   }
 885:state.c       ****   /* set bit to indicate this representation is computed */
 886:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_F);
 3398              		.loc 1 886 0
 3399 009a B4F81431 		ldrh	r3, [r4, #276]
 3400 009e 43F02003 		orr	r3, r3, #32
 3401 00a2 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3402              	.L423:
 3403 00a6 10BD     		pop	{r4, pc}
 3404              	.L433:
 3405              		.align	2
 3406              	.L432:
 3407 00a8 00000000 		.word	.LANCHOR0
 3408 00ac 00000036 		.word	905969664
 3409              		.cfi_endproc
 3410              	.LFE156:
 3412              		.section	.text.stateCalcHorizontalSpeedNorm_f,"ax",%progbits
 3413              		.align	1
 3414              		.global	stateCalcHorizontalSpeedNorm_f
 3415              		.thumb
 3416              		.thumb_func
 3418              	stateCalcHorizontalSpeedNorm_f:
 3419              	.LFB157:
 887:state.c       **** }
 888:state.c       **** 
 889:state.c       **** void stateCalcHorizontalSpeedNorm_f(void)
 890:state.c       **** {
 3420              		.loc 1 890 0
 3421              		.cfi_startproc
 3422              		@ args = 0, pretend = 0, frame = 0
 3423              		@ frame_needed = 0, uses_anonymous_args = 0
 3424 0000 10B5     		push	{r4, lr}
 3425              		.cfi_def_cfa_offset 8
 3426              		.cfi_offset 4, -8
 3427              		.cfi_offset 14, -4
 891:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F)) {
 3428              		.loc 1 891 0
 3429 0002 364C     		ldr	r4, .L446
 3430 0004 B4F81431 		ldrh	r3, [r4, #276]
 3431 0008 D805     		lsls	r0, r3, #23
 3432 000a 65D4     		bmi	.L434
 892:state.c       ****     return;
 893:state.c       ****   }
 894:state.c       **** 
 895:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I)) {
 3433              		.loc 1 895 0
 3434 000c 1907     		lsls	r1, r3, #28
 3435 000e 06D5     		bpl	.L436
 896:state.c       ****     state.h_speed_norm_f = SPEED_FLOAT_OF_BFP(state.h_speed_norm_i);
 3436              		.loc 1 896 0
 3437 0010 D4ED4F7A 		flds	s15, [r4, #316]	@ int
 3438 0014 FBEEE67A 		vcvt.f32.u32	s15, s15, #19
 3439 0018 C4ED5A7A 		fsts	s15, [r4, #360]
 3440 001c 56E0     		b	.L437
 3441              	.L436:
 897:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3442              		.loc 1 897 0
 3443 001e 5A06     		lsls	r2, r3, #25
 3444 0020 04D5     		bpl	.L438
 898:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 3445              		.loc 1 898 0
 3446 0022 D4ED547A 		flds	s15, [r4, #336]
 3447 0026 94ED557A 		flds	s14, [r4, #340]
 3448 002a 45E0     		b	.L444
 3449              	.L438:
 899:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3450              		.loc 1 899 0
 3451 002c 1806     		lsls	r0, r3, #24
 3452 002e 04D5     		bpl	.L439
 900:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 3453              		.loc 1 900 0
 3454 0030 D4ED577A 		flds	s15, [r4, #348]
 3455 0034 94ED587A 		flds	s14, [r4, #352]
 3456 0038 3EE0     		b	.L444
 3457              	.L439:
 901:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3458              		.loc 1 901 0
 3459 003a 9907     		lsls	r1, r3, #30
 3460 003c 1CD5     		bpl	.L440
 902:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3461              		.loc 1 902 0
 3462 003e D4ED495A 		flds	s11, [r4, #292]	@ int
 3463 0042 94ED4A6A 		flds	s12, [r4, #296]	@ int
 3464 0046 DFED266A 		flds	s13, .L446+4
 3465 004a F8EEE57A 		fsitos	s15, s11
 3466 004e D4ED4B5A 		flds	s11, [r4, #300]	@ int
 3467 0052 B8EEC67A 		fsitos	s14, s12
 3468 0056 B8EEE56A 		fsitos	s12, s11
 3469 005a 67EEA67A 		fmuls	s15, s15, s13
 3470 005e 27EE267A 		fmuls	s14, s14, s13
 3471 0062 66EE266A 		fmuls	s13, s12, s13
 3472 0066 C4ED547A 		fsts	s15, [r4, #336]
 3473 006a 84ED557A 		fsts	s14, [r4, #340]
 3474 006e C4ED566A 		fsts	s13, [r4, #344]
 903:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3475              		.loc 1 903 0
 3476 0072 43F04003 		orr	r3, r3, #64
 3477 0076 1DE0     		b	.L445
 3478              	.L440:
 904:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 905:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3479              		.loc 1 905 0
 3480 0078 5A07     		lsls	r2, r3, #29
 3481 007a 27D5     		bpl	.L437
 906:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3482              		.loc 1 906 0
 3483 007c D4ED4D5A 		flds	s11, [r4, #308]	@ int
 3484 0080 94ED4C6A 		flds	s12, [r4, #304]	@ int
 3485 0084 DFED166A 		flds	s13, .L446+4
 3486 0088 B8EEE57A 		fsitos	s14, s11
 3487 008c D4ED4E5A 		flds	s11, [r4, #312]	@ int
 3488 0090 F8EEC67A 		fsitos	s15, s12
 3489 0094 B8EEE56A 		fsitos	s12, s11
 3490 0098 67EEA67A 		fmuls	s15, s15, s13
 3491 009c 27EE267A 		fmuls	s14, s14, s13
 3492 00a0 66EE266A 		fmuls	s13, s12, s13
 3493 00a4 C4ED577A 		fsts	s15, [r4, #348]
 3494 00a8 84ED587A 		fsts	s14, [r4, #352]
 3495 00ac C4ED596A 		fsts	s13, [r4, #356]
 907:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3496              		.loc 1 907 0
 3497 00b0 43F08003 		orr	r3, r3, #128
 3498              	.L445:
 3499 00b4 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3500              	.L444:
 908:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 3501              		.loc 1 908 0
 3502 00b8 27EE077A 		fmuls	s14, s14, s14
 3503 00bc A7EEA77A 		vfma.f32	s14, s15, s15
 3504 00c0 17EE100A 		fmrs	r0, s14
 3505 00c4 FFF7FEFF 		bl	sqrtf
 3506              	.LVL185:
 3507 00c8 C4F86801 		str	r0, [r4, #360]	@ float
 3508              	.L437:
 909:state.c       ****   }
 910:state.c       ****   /* set bit to indicate this representation is computed */
 911:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_F);
 3509              		.loc 1 911 0
 3510 00cc B4F81431 		ldrh	r3, [r4, #276]
 3511 00d0 43F48073 		orr	r3, r3, #256
 3512 00d4 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3513              	.L434:
 3514 00d8 10BD     		pop	{r4, pc}
 3515              	.L447:
 3516 00da 00BF     		.align	2
 3517              	.L446:
 3518 00dc 00000000 		.word	.LANCHOR0
 3519 00e0 00000036 		.word	905969664
 3520              		.cfi_endproc
 3521              	.LFE157:
 3523              		.section	.text.stateCalcHorizontalSpeedDir_f,"ax",%progbits
 3524              		.align	1
 3525              		.global	stateCalcHorizontalSpeedDir_f
 3526              		.thumb
 3527              		.thumb_func
 3529              	stateCalcHorizontalSpeedDir_f:
 3530              	.LFB158:
 912:state.c       **** }
 913:state.c       **** 
 914:state.c       **** void stateCalcHorizontalSpeedDir_f(void)
 915:state.c       **** {
 3531              		.loc 1 915 0
 3532              		.cfi_startproc
 3533              		@ args = 0, pretend = 0, frame = 0
 3534              		@ frame_needed = 0, uses_anonymous_args = 0
 3535 0000 10B5     		push	{r4, lr}
 3536              		.cfi_def_cfa_offset 8
 3537              		.cfi_offset 4, -8
 3538              		.cfi_offset 14, -4
 916:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F)) {
 3539              		.loc 1 916 0
 3540 0002 354C     		ldr	r4, .L460
 3541 0004 B4F81431 		ldrh	r3, [r4, #276]
 3542 0008 9805     		lsls	r0, r3, #22
 3543 000a 63D4     		bmi	.L448
 917:state.c       ****     return;
 918:state.c       ****   }
 919:state.c       **** 
 920:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I)) {
 3544              		.loc 1 920 0
 3545 000c D906     		lsls	r1, r3, #27
 3546 000e 06D5     		bpl	.L450
 921:state.c       ****     state.h_speed_dir_f = SPEED_FLOAT_OF_BFP(state.h_speed_dir_i);
 3547              		.loc 1 921 0
 3548 0010 D4ED507A 		flds	s15, [r4, #320]	@ int
 3549 0014 FAEEE67A 		vcvt.f32.s32	s15, s15, #19
 3550 0018 C4ED5B7A 		fsts	s15, [r4, #364]
 3551 001c 54E0     		b	.L451
 3552              	.L450:
 922:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3553              		.loc 1 922 0
 3554 001e 5A06     		lsls	r2, r3, #25
 3555 0020 04D5     		bpl	.L452
 923:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
 3556              		.loc 1 923 0
 3557 0022 D4F85401 		ldr	r0, [r4, #340]	@ float
 3558 0026 D4F85011 		ldr	r1, [r4, #336]	@ float
 3559 002a 49E0     		b	.L458
 3560              	.L452:
 924:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3561              		.loc 1 924 0
 3562 002c 1806     		lsls	r0, r3, #24
 3563 002e 04D5     		bpl	.L453
 925:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3564              		.loc 1 925 0
 3565 0030 D4F85C01 		ldr	r0, [r4, #348]	@ float
 3566 0034 D4F86011 		ldr	r1, [r4, #352]	@ float
 3567 0038 42E0     		b	.L458
 3568              	.L453:
 926:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3569              		.loc 1 926 0
 3570 003a 9907     		lsls	r1, r3, #30
 3571 003c 1CD5     		bpl	.L454
 927:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3572              		.loc 1 927 0
 3573 003e D4ED495A 		flds	s11, [r4, #292]	@ int
 3574 0042 94ED4A6A 		flds	s12, [r4, #296]	@ int
 3575 0046 DFED257A 		flds	s15, .L460+4
 3576 004a B8EEE57A 		fsitos	s14, s11
 3577 004e D4ED4B5A 		flds	s11, [r4, #300]	@ int
 3578 0052 F8EEC66A 		fsitos	s13, s12
 3579 0056 B8EEE56A 		fsitos	s12, s11
 3580 005a 27EE277A 		fmuls	s14, s14, s15
 3581 005e 66EEA76A 		fmuls	s13, s13, s15
 3582 0062 66EE277A 		fmuls	s15, s12, s15
 3583 0066 84ED547A 		fsts	s14, [r4, #336]
 3584 006a C4ED556A 		fsts	s13, [r4, #340]
 3585 006e C4ED567A 		fsts	s15, [r4, #344]
 928:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3586              		.loc 1 928 0
 3587 0072 43F04003 		orr	r3, r3, #64
 3588 0076 1DE0     		b	.L459
 3589              	.L454:
 929:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
 930:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3590              		.loc 1 930 0
 3591 0078 5A07     		lsls	r2, r3, #29
 3592 007a 25D5     		bpl	.L451
 931:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3593              		.loc 1 931 0
 3594 007c D4ED4D5A 		flds	s11, [r4, #308]	@ int
 3595 0080 94ED4C6A 		flds	s12, [r4, #304]	@ int
 3596 0084 DFED157A 		flds	s15, .L460+4
 3597 0088 B8EEE57A 		fsitos	s14, s11
 3598 008c D4ED4E5A 		flds	s11, [r4, #312]	@ int
 3599 0090 F8EEC66A 		fsitos	s13, s12
 3600 0094 B8EEE56A 		fsitos	s12, s11
 3601 0098 66EEA76A 		fmuls	s13, s13, s15
 3602 009c 27EE277A 		fmuls	s14, s14, s15
 3603 00a0 66EE277A 		fmuls	s15, s12, s15
 3604 00a4 C4ED576A 		fsts	s13, [r4, #348]
 3605 00a8 84ED587A 		fsts	s14, [r4, #352]
 3606 00ac C4ED597A 		fsts	s15, [r4, #356]
 932:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3607              		.loc 1 932 0
 3608 00b0 43F08003 		orr	r3, r3, #128
 3609              	.L459:
 933:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3610              		.loc 1 933 0
 3611 00b4 16EE900A 		fmrs	r0, s13
 3612 00b8 17EE101A 		fmrs	r1, s14
 932:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3613              		.loc 1 932 0
 3614 00bc A4F81431 		strh	r3, [r4, #276]	@ movhi
 3615              	.L458:
 3616              		.loc 1 933 0
 3617 00c0 FFF7FEFF 		bl	atan2f
 3618              	.LVL186:
 3619 00c4 C4F86C01 		str	r0, [r4, #364]	@ float
 3620              	.L451:
 934:state.c       ****   }
 935:state.c       ****   /* set bit to indicate this representation is computed */
 936:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_F);
 3621              		.loc 1 936 0
 3622 00c8 B4F81431 		ldrh	r3, [r4, #276]
 3623 00cc 43F40073 		orr	r3, r3, #512
 3624 00d0 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3625              	.L448:
 3626 00d4 10BD     		pop	{r4, pc}
 3627              	.L461:
 3628 00d6 00BF     		.align	2
 3629              	.L460:
 3630 00d8 00000000 		.word	.LANCHOR0
 3631 00dc 00000036 		.word	905969664
 3632              		.cfi_endproc
 3633              	.LFE158:
 3635              		.section	.text.stateCalcAccelNed_i,"ax",%progbits
 3636              		.align	1
 3637              		.global	stateCalcAccelNed_i
 3638              		.thumb
 3639              		.thumb_func
 3641              	stateCalcAccelNed_i:
 3642              	.LFB159:
 937:state.c       **** }
 938:state.c       **** /** @}*/
 939:state.c       **** 
 940:state.c       **** 
 941:state.c       **** 
 942:state.c       **** /******************************************************************************
 943:state.c       ****  *                                                                            *
 944:state.c       ****  * Transformation functions for the ACCELERATION representations              *
 945:state.c       ****  *                                                                            *
 946:state.c       ****  *****************************************************************************/
 947:state.c       **** /** @addtogroup state_acceleration
 948:state.c       ****  *  @{ */
 949:state.c       **** 
 950:state.c       **** void stateCalcAccelNed_i(void)
 951:state.c       **** {
 3643              		.loc 1 951 0
 3644              		.cfi_startproc
 3645              		@ args = 0, pretend = 0, frame = 0
 3646              		@ frame_needed = 0, uses_anonymous_args = 0
 3647 0000 10B5     		push	{r4, lr}
 3648              		.cfi_def_cfa_offset 8
 3649              		.cfi_offset 4, -8
 3650              		.cfi_offset 14, -4
 952:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3651              		.loc 1 952 0
 3652 0002 2B4C     		ldr	r4, .L474
 3653 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3654 0008 9A07     		lsls	r2, r3, #30
 3655 000a 50D4     		bmi	.L462
 3656              	.LVL187:
 953:state.c       ****     return;
 954:state.c       ****   }
 955:state.c       **** 
 956:state.c       ****   int errno = 0;
 957:state.c       ****   if (state.ned_initialized_i) {
 3657              		.loc 1 957 0
 3658 000c 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 3659 0010 002A     		cmp	r2, #0
 3660 0012 46D0     		beq	.L464
 958:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3661              		.loc 1 958 0
 3662 0014 1807     		lsls	r0, r3, #28
 3663 0016 1AD5     		bpl	.L465
 959:state.c       ****       ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3664              		.loc 1 959 0
 3665 0018 DFED267A 		flds	s15, .L474+4
 3666 001c 94ED637A 		flds	s14, [r4, #396]
 3667 0020 27EE277A 		fmuls	s14, s14, s15
 3668 0024 BDEEC77A 		ftosizs	s14, s14
 3669 0028 84ED5D7A 		fsts	s14, [r4, #372]	@ int
 3670 002c 94ED647A 		flds	s14, [r4, #400]
 3671 0030 27EE277A 		fmuls	s14, s14, s15
 3672 0034 BDEEC77A 		ftosizs	s14, s14
 3673 0038 84ED5E7A 		fsts	s14, [r4, #376]	@ int
 3674 003c 94ED657A 		flds	s14, [r4, #404]
 3675 0040 67EE277A 		fmuls	s15, s14, s15
 3676 0044 FDEEE77A 		ftosizs	s15, s15
 3677 0048 C4ED5F7A 		fsts	s15, [r4, #380]	@ int
 3678 004c 29E0     		b	.L464
 3679              	.L465:
 960:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3680              		.loc 1 960 0
 3681 004e D907     		lsls	r1, r3, #31
 3682 0050 1FD4     		bmi	.L473
 961:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
 962:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3683              		.loc 1 962 0
 3684 0052 5A07     		lsls	r2, r3, #29
 3685 0054 25D5     		bpl	.L464
 963:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
 964:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3686              		.loc 1 964 0
 3687 0056 DFED177A 		flds	s15, .L474+4
 3688 005a 94ED667A 		flds	s14, [r4, #408]
 3689 005e 27EE277A 		fmuls	s14, s14, s15
 965:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_I);
 3690              		.loc 1 965 0
 3691 0062 43F00103 		orr	r3, r3, #1
 964:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3692              		.loc 1 964 0
 3693 0066 BDEEC77A 		ftosizs	s14, s14
 3694              		.loc 1 965 0
 3695 006a 84F87031 		strb	r3, [r4, #368]
 964:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3696              		.loc 1 964 0
 3697 006e 84ED607A 		fsts	s14, [r4, #384]	@ int
 3698 0072 94ED677A 		flds	s14, [r4, #412]
 3699 0076 27EE277A 		fmuls	s14, s14, s15
 3700 007a BDEEC77A 		ftosizs	s14, s14
 3701 007e 84ED617A 		fsts	s14, [r4, #388]	@ int
 3702 0082 94ED687A 		flds	s14, [r4, #416]
 3703 0086 67EE277A 		fmuls	s15, s14, s15
 3704 008a FDEEE77A 		ftosizs	s15, s15
 3705 008e C4ED627A 		fsts	s15, [r4, #392]	@ int
 3706              	.L473:
 966:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
 3707              		.loc 1 966 0
 3708 0092 04F5BA70 		add	r0, r4, #372
 3709 0096 04F11C01 		add	r1, r4, #28
 3710 009a 04F5C072 		add	r2, r4, #384
 3711 009e FFF7FEFF 		bl	ned_of_ecef_vect_i
 3712              	.LVL188:
 3713              	.L464:
 967:state.c       ****     } else { /* could not get this representation,  set errno */
 968:state.c       ****       errno = 1;
 969:state.c       ****     }
 970:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 971:state.c       ****     errno = 2;
 972:state.c       ****   }
 973:state.c       ****   if (errno) {
 974:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 975:state.c       ****     //return _ned_zero;
 976:state.c       ****   }
 977:state.c       ****   /* set bit to indicate this representation is computed */
 978:state.c       ****   SetBit(state.accel_status, ACCEL_NED_I);
 3714              		.loc 1 978 0
 3715 00a2 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3716 00a6 43F00203 		orr	r3, r3, #2
 3717 00aa 84F87031 		strb	r3, [r4, #368]
 3718              	.LVL189:
 3719              	.L462:
 3720 00ae 10BD     		pop	{r4, pc}
 3721              	.L475:
 3722              		.align	2
 3723              	.L474:
 3724 00b0 00000000 		.word	.LANCHOR0
 3725 00b4 00008044 		.word	1149239296
 3726              		.cfi_endproc
 3727              	.LFE159:
 3729              		.section	.text.stateCalcAccelEcef_i,"ax",%progbits
 3730              		.align	1
 3731              		.global	stateCalcAccelEcef_i
 3732              		.thumb
 3733              		.thumb_func
 3735              	stateCalcAccelEcef_i:
 3736              	.LFB160:
 979:state.c       **** }
 980:state.c       **** 
 981:state.c       **** void stateCalcAccelEcef_i(void)
 982:state.c       **** {
 3737              		.loc 1 982 0
 3738              		.cfi_startproc
 3739              		@ args = 0, pretend = 0, frame = 0
 3740              		@ frame_needed = 0, uses_anonymous_args = 0
 3741 0000 10B5     		push	{r4, lr}
 3742              		.cfi_def_cfa_offset 8
 3743              		.cfi_offset 4, -8
 3744              		.cfi_offset 14, -4
 983:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3745              		.loc 1 983 0
 3746 0002 294C     		ldr	r4, .L485
 3747 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3748 0008 DA07     		lsls	r2, r3, #31
 3749 000a 4CD4     		bmi	.L476
 984:state.c       ****     return;
 985:state.c       ****   }
 986:state.c       **** 
 987:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3750              		.loc 1 987 0
 3751 000c 5807     		lsls	r0, r3, #29
 3752 000e 1AD5     		bpl	.L478
 988:state.c       ****     ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3753              		.loc 1 988 0
 3754 0010 DFED267A 		flds	s15, .L485+4
 3755 0014 94ED667A 		flds	s14, [r4, #408]
 3756 0018 27EE277A 		fmuls	s14, s14, s15
 3757 001c BDEEC77A 		ftosizs	s14, s14
 3758 0020 84ED607A 		fsts	s14, [r4, #384]	@ int
 3759 0024 94ED677A 		flds	s14, [r4, #412]
 3760 0028 27EE277A 		fmuls	s14, s14, s15
 3761 002c BDEEC77A 		ftosizs	s14, s14
 3762 0030 84ED617A 		fsts	s14, [r4, #388]	@ int
 3763 0034 94ED687A 		flds	s14, [r4, #416]
 3764 0038 67EE277A 		fmuls	s15, s14, s15
 3765 003c FDEEE77A 		ftosizs	s15, s15
 3766 0040 C4ED627A 		fsts	s15, [r4, #392]	@ int
 3767 0044 29E0     		b	.L479
 3768              	.L478:
 989:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3769              		.loc 1 989 0
 3770 0046 9907     		lsls	r1, r3, #30
 3771 0048 1FD4     		bmi	.L484
 990:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
 991:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3772              		.loc 1 991 0
 3773 004a 1A07     		lsls	r2, r3, #28
 3774 004c 25D5     		bpl	.L479
 992:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 993:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3775              		.loc 1 993 0
 3776 004e DFED177A 		flds	s15, .L485+4
 3777 0052 94ED637A 		flds	s14, [r4, #396]
 3778 0056 27EE277A 		fmuls	s14, s14, s15
 994:state.c       ****     SetBit(state.accel_status, ACCEL_NED_I);
 3779              		.loc 1 994 0
 3780 005a 43F00203 		orr	r3, r3, #2
 993:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3781              		.loc 1 993 0
 3782 005e BDEEC77A 		ftosizs	s14, s14
 3783              		.loc 1 994 0
 3784 0062 84F87031 		strb	r3, [r4, #368]
 993:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3785              		.loc 1 993 0
 3786 0066 84ED5D7A 		fsts	s14, [r4, #372]	@ int
 3787 006a 94ED647A 		flds	s14, [r4, #400]
 3788 006e 27EE277A 		fmuls	s14, s14, s15
 3789 0072 BDEEC77A 		ftosizs	s14, s14
 3790 0076 84ED5E7A 		fsts	s14, [r4, #376]	@ int
 3791 007a 94ED657A 		flds	s14, [r4, #404]
 3792 007e 67EE277A 		fmuls	s15, s14, s15
 3793 0082 FDEEE77A 		ftosizs	s15, s15
 3794 0086 C4ED5F7A 		fsts	s15, [r4, #380]	@ int
 3795              	.L484:
 995:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
 3796              		.loc 1 995 0
 3797 008a 04F5C070 		add	r0, r4, #384
 3798 008e 04F11C01 		add	r1, r4, #28
 3799 0092 04F5BA72 		add	r2, r4, #372
 3800 0096 FFF7FEFF 		bl	ecef_of_ned_vect_i
 3801              	.LVL190:
 3802              	.L479:
 996:state.c       ****   } else {
 997:state.c       ****     /* could not get this representation,  set errno */
 998:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
 999:state.c       ****     //return _ecef_zero;
1000:state.c       ****   }
1001:state.c       ****   /* set bit to indicate this representation is computed */
1002:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_I);
 3803              		.loc 1 1002 0
 3804 009a 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3805 009e 43F00103 		orr	r3, r3, #1
 3806 00a2 84F87031 		strb	r3, [r4, #368]
 3807              	.L476:
 3808 00a6 10BD     		pop	{r4, pc}
 3809              	.L486:
 3810              		.align	2
 3811              	.L485:
 3812 00a8 00000000 		.word	.LANCHOR0
 3813 00ac 00008044 		.word	1149239296
 3814              		.cfi_endproc
 3815              	.LFE160:
 3817              		.section	.text.stateCalcAccelNed_f,"ax",%progbits
 3818              		.align	1
 3819              		.global	stateCalcAccelNed_f
 3820              		.thumb
 3821              		.thumb_func
 3823              	stateCalcAccelNed_f:
 3824              	.LFB161:
1003:state.c       **** }
1004:state.c       **** 
1005:state.c       **** void stateCalcAccelNed_f(void)
1006:state.c       **** {
 3825              		.loc 1 1006 0
 3826              		.cfi_startproc
 3827              		@ args = 0, pretend = 0, frame = 0
 3828              		@ frame_needed = 0, uses_anonymous_args = 0
 3829 0000 10B5     		push	{r4, lr}
 3830              		.cfi_def_cfa_offset 8
 3831              		.cfi_offset 4, -8
 3832              		.cfi_offset 14, -4
1007:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3833              		.loc 1 1007 0
 3834 0002 2B4C     		ldr	r4, .L499
 3835 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3836 0008 1A07     		lsls	r2, r3, #28
 3837 000a 50D4     		bmi	.L487
 3838              	.LVL191:
1008:state.c       ****     return;
1009:state.c       ****   }
1010:state.c       **** 
1011:state.c       ****   int errno = 0;
1012:state.c       ****   if (state.ned_initialized_f) {
 3839              		.loc 1 1012 0
 3840 000c 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 3841 0010 002A     		cmp	r2, #0
 3842 0012 46D0     		beq	.L489
1013:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3843              		.loc 1 1013 0
 3844 0014 9807     		lsls	r0, r3, #30
 3845 0016 1AD5     		bpl	.L490
1014:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3846              		.loc 1 1014 0
 3847 0018 D4ED5D6A 		flds	s13, [r4, #372]	@ int
 3848 001c DFED257A 		flds	s15, .L499+4
 3849 0020 B8EEE67A 		fsitos	s14, s13
 3850 0024 D4ED5E6A 		flds	s13, [r4, #376]	@ int
 3851 0028 27EE277A 		fmuls	s14, s14, s15
 3852 002c 84ED637A 		fsts	s14, [r4, #396]
 3853 0030 B8EEE67A 		fsitos	s14, s13
 3854 0034 D4ED5F6A 		flds	s13, [r4, #380]	@ int
 3855 0038 27EE277A 		fmuls	s14, s14, s15
 3856 003c 84ED647A 		fsts	s14, [r4, #400]
 3857 0040 B8EEE67A 		fsitos	s14, s13
 3858 0044 67EE277A 		fmuls	s15, s14, s15
 3859 0048 C4ED657A 		fsts	s15, [r4, #404]
 3860 004c 29E0     		b	.L489
 3861              	.L490:
1015:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3862              		.loc 1 1015 0
 3863 004e 5907     		lsls	r1, r3, #29
 3864 0050 1FD4     		bmi	.L498
1016:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
1017:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3865              		.loc 1 1017 0
 3866 0052 DA07     		lsls	r2, r3, #31
 3867 0054 25D5     		bpl	.L489
1018:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
1019:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 3868              		.loc 1 1019 0
 3869 0056 D4ED607A 		flds	s15, [r4, #384]	@ int
 3870 005a D4ED616A 		flds	s13, [r4, #388]	@ int
 3871 005e B8EEE77A 		fsitos	s14, s15
 3872 0062 DFED147A 		flds	s15, .L499+4
 3873 0066 27EE277A 		fmuls	s14, s14, s15
1020:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_F);
 3874              		.loc 1 1020 0
 3875 006a 43F00403 		orr	r3, r3, #4
1019:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 3876              		.loc 1 1019 0
 3877 006e 84ED667A 		fsts	s14, [r4, #408]
 3878 0072 B8EEE67A 		fsitos	s14, s13
 3879 0076 D4ED626A 		flds	s13, [r4, #392]	@ int
 3880              		.loc 1 1020 0
 3881 007a 84F87031 		strb	r3, [r4, #368]
1019:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 3882              		.loc 1 1019 0
 3883 007e 27EE277A 		fmuls	s14, s14, s15
 3884 0082 84ED677A 		fsts	s14, [r4, #412]
 3885 0086 B8EEE67A 		fsitos	s14, s13
 3886 008a 67EE277A 		fmuls	s15, s14, s15
 3887 008e C4ED687A 		fsts	s15, [r4, #416]
 3888              	.L498:
1021:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
 3889              		.loc 1 1021 0
 3890 0092 04F5C670 		add	r0, r4, #396
 3891 0096 04F1A401 		add	r1, r4, #164
 3892 009a 04F5CC72 		add	r2, r4, #408
 3893 009e FFF7FEFF 		bl	ned_of_ecef_vect_f
 3894              	.LVL192:
 3895              	.L489:
1022:state.c       ****     } else { /* could not get this representation,  set errno */
1023:state.c       ****       errno = 1;
1024:state.c       ****     }
1025:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
1026:state.c       ****     errno = 2;
1027:state.c       ****   }
1028:state.c       ****   if (errno) {
1029:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
1030:state.c       ****     //return _ned_zero;
1031:state.c       ****   }
1032:state.c       ****   /* set bit to indicate this representation is computed */
1033:state.c       ****   SetBit(state.accel_status, ACCEL_NED_F);
 3896              		.loc 1 1033 0
 3897 00a2 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3898 00a6 43F00803 		orr	r3, r3, #8
 3899 00aa 84F87031 		strb	r3, [r4, #368]
 3900              	.LVL193:
 3901              	.L487:
 3902 00ae 10BD     		pop	{r4, pc}
 3903              	.L500:
 3904              		.align	2
 3905              	.L499:
 3906 00b0 00000000 		.word	.LANCHOR0
 3907 00b4 0000803A 		.word	981467136
 3908              		.cfi_endproc
 3909              	.LFE161:
 3911              		.section	.text.stateCalcAccelEcef_f,"ax",%progbits
 3912              		.align	1
 3913              		.global	stateCalcAccelEcef_f
 3914              		.thumb
 3915              		.thumb_func
 3917              	stateCalcAccelEcef_f:
 3918              	.LFB162:
1034:state.c       **** }
1035:state.c       **** 
1036:state.c       **** void stateCalcAccelEcef_f(void)
1037:state.c       **** {
 3919              		.loc 1 1037 0
 3920              		.cfi_startproc
 3921              		@ args = 0, pretend = 0, frame = 0
 3922              		@ frame_needed = 0, uses_anonymous_args = 0
 3923 0000 10B5     		push	{r4, lr}
 3924              		.cfi_def_cfa_offset 8
 3925              		.cfi_offset 4, -8
 3926              		.cfi_offset 14, -4
1038:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3927              		.loc 1 1038 0
 3928 0002 294C     		ldr	r4, .L510
 3929 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3930 0008 5A07     		lsls	r2, r3, #29
 3931 000a 4CD4     		bmi	.L501
1039:state.c       ****     return;
1040:state.c       ****   }
1041:state.c       **** 
1042:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3932              		.loc 1 1042 0
 3933 000c D807     		lsls	r0, r3, #31
 3934 000e 1AD5     		bpl	.L503
1043:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ned_accel_i);
 3935              		.loc 1 1043 0
 3936 0010 D4ED5D6A 		flds	s13, [r4, #372]	@ int
 3937 0014 DFED257A 		flds	s15, .L510+4
 3938 0018 B8EEE67A 		fsitos	s14, s13
 3939 001c D4ED5E6A 		flds	s13, [r4, #376]	@ int
 3940 0020 27EE277A 		fmuls	s14, s14, s15
 3941 0024 84ED667A 		fsts	s14, [r4, #408]
 3942 0028 B8EEE67A 		fsitos	s14, s13
 3943 002c D4ED5F6A 		flds	s13, [r4, #380]	@ int
 3944 0030 27EE277A 		fmuls	s14, s14, s15
 3945 0034 84ED677A 		fsts	s14, [r4, #412]
 3946 0038 B8EEE67A 		fsitos	s14, s13
 3947 003c 67EE277A 		fmuls	s15, s14, s15
 3948 0040 C4ED687A 		fsts	s15, [r4, #416]
 3949 0044 29E0     		b	.L504
 3950              	.L503:
1044:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3951              		.loc 1 1044 0
 3952 0046 1907     		lsls	r1, r3, #28
 3953 0048 1FD4     		bmi	.L509
1045:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
1046:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3954              		.loc 1 1046 0
 3955 004a 9A07     		lsls	r2, r3, #30
 3956 004c 25D5     		bpl	.L504
1047:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
1048:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3957              		.loc 1 1048 0
 3958 004e D4ED5D7A 		flds	s15, [r4, #372]	@ int
 3959 0052 D4ED5E6A 		flds	s13, [r4, #376]	@ int
 3960 0056 B8EEE77A 		fsitos	s14, s15
 3961 005a DFED147A 		flds	s15, .L510+4
 3962 005e 27EE277A 		fmuls	s14, s14, s15
1049:state.c       ****     SetBit(state.accel_status, ACCEL_NED_F);
 3963              		.loc 1 1049 0
 3964 0062 43F00803 		orr	r3, r3, #8
1048:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3965              		.loc 1 1048 0
 3966 0066 84ED637A 		fsts	s14, [r4, #396]
 3967 006a B8EEE67A 		fsitos	s14, s13
 3968 006e D4ED5F6A 		flds	s13, [r4, #380]	@ int
 3969              		.loc 1 1049 0
 3970 0072 84F87031 		strb	r3, [r4, #368]
1048:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3971              		.loc 1 1048 0
 3972 0076 27EE277A 		fmuls	s14, s14, s15
 3973 007a 84ED647A 		fsts	s14, [r4, #400]
 3974 007e B8EEE67A 		fsitos	s14, s13
 3975 0082 67EE277A 		fmuls	s15, s14, s15
 3976 0086 C4ED657A 		fsts	s15, [r4, #404]
 3977              	.L509:
1050:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
 3978              		.loc 1 1050 0
 3979 008a 04F5CC70 		add	r0, r4, #408
 3980 008e 04F1A401 		add	r1, r4, #164
 3981 0092 04F5C672 		add	r2, r4, #396
 3982 0096 FFF7FEFF 		bl	ecef_of_ned_vect_f
 3983              	.LVL194:
 3984              	.L504:
1051:state.c       ****   } else {
1052:state.c       ****     /* could not get this representation,  set errno */
1053:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
1054:state.c       ****     //return _ecef_zero;
1055:state.c       ****   }
1056:state.c       ****   /* set bit to indicate this representation is computed */
1057:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_F);
 3985              		.loc 1 1057 0
 3986 009a 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3987 009e 43F00403 		orr	r3, r3, #4
 3988 00a2 84F87031 		strb	r3, [r4, #368]
 3989              	.L501:
 3990 00a6 10BD     		pop	{r4, pc}
 3991              	.L511:
 3992              		.align	2
 3993              	.L510:
 3994 00a8 00000000 		.word	.LANCHOR0
 3995 00ac 0000803A 		.word	981467136
 3996              		.cfi_endproc
 3997              	.LFE162:
 3999              		.section	.text.stateCalcBodyRates_i,"ax",%progbits
 4000              		.align	1
 4001              		.global	stateCalcBodyRates_i
 4002              		.thumb
 4003              		.thumb_func
 4005              	stateCalcBodyRates_i:
 4006              	.LFB163:
1058:state.c       **** }
1059:state.c       **** /** @}*/
1060:state.c       **** 
1061:state.c       **** /******************************************************************************
1062:state.c       ****  *                                                                            *
1063:state.c       ****  * Transformation functions for the ANGULAR RATE representations              *
1064:state.c       ****  *                                                                            *
1065:state.c       ****  *****************************************************************************/
1066:state.c       **** /** @addtogroup state_rate
1067:state.c       ****  *  @{ */
1068:state.c       **** 
1069:state.c       **** void stateCalcBodyRates_i(void)
1070:state.c       **** {
 4007              		.loc 1 1070 0
 4008              		.cfi_startproc
 4009              		@ args = 0, pretend = 0, frame = 0
 4010              		@ frame_needed = 0, uses_anonymous_args = 0
 4011              		@ link register save eliminated.
1071:state.c       ****   if (bit_is_set(state.rate_status, RATE_I)) {
 4012              		.loc 1 1071 0
 4013 0000 124B     		ldr	r3, .L518
 4014 0002 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4015 0006 D007     		lsls	r0, r2, #31
 4016 0008 1FD4     		bmi	.L512
1072:state.c       ****     return;
1073:state.c       ****   }
1074:state.c       **** 
1075:state.c       ****   if (bit_is_set(state.rate_status, RATE_F)) {
 4017              		.loc 1 1075 0
 4018 000a 9107     		lsls	r1, r2, #30
 4019 000c 19D5     		bpl	.L514
1076:state.c       ****     RATES_BFP_OF_REAL(state.body_rates_i, state.body_rates_f);
 4020              		.loc 1 1076 0
 4021 000e DFED107A 		flds	s15, .L518+4
 4022 0012 93ED8E7A 		flds	s14, [r3, #568]
 4023 0016 27EE277A 		fmuls	s14, s14, s15
 4024 001a BDEEC77A 		ftosizs	s14, s14
 4025 001e 83ED8B7A 		fsts	s14, [r3, #556]	@ int
 4026 0022 93ED8F7A 		flds	s14, [r3, #572]
 4027 0026 27EE277A 		fmuls	s14, s14, s15
 4028 002a BDEEC77A 		ftosizs	s14, s14
 4029 002e 83ED8C7A 		fsts	s14, [r3, #560]	@ int
 4030 0032 93ED907A 		flds	s14, [r3, #576]
 4031 0036 67EE277A 		fmuls	s15, s14, s15
 4032 003a FDEEE77A 		ftosizs	s15, s15
 4033 003e C3ED8D7A 		fsts	s15, [r3, #564]	@ int
 4034              	.L514:
1077:state.c       ****   }
1078:state.c       ****   /* set bit to indicate this representation is computed */
1079:state.c       ****   SetBit(state.rate_status, RATE_I);
 4035              		.loc 1 1079 0
 4036 0042 42F00102 		orr	r2, r2, #1
 4037 0046 83F82822 		strb	r2, [r3, #552]
 4038              	.L512:
 4039 004a 7047     		bx	lr
 4040              	.L519:
 4041              		.align	2
 4042              	.L518:
 4043 004c 00000000 		.word	.LANCHOR0
 4044 0050 00008045 		.word	1166016512
 4045              		.cfi_endproc
 4046              	.LFE163:
 4048              		.section	.text.stateCalcBodyRates_f,"ax",%progbits
 4049              		.align	1
 4050              		.global	stateCalcBodyRates_f
 4051              		.thumb
 4052              		.thumb_func
 4054              	stateCalcBodyRates_f:
 4055              	.LFB164:
1080:state.c       **** }
1081:state.c       **** 
1082:state.c       **** void stateCalcBodyRates_f(void)
1083:state.c       **** {
 4056              		.loc 1 1083 0
 4057              		.cfi_startproc
 4058              		@ args = 0, pretend = 0, frame = 0
 4059              		@ frame_needed = 0, uses_anonymous_args = 0
 4060              		@ link register save eliminated.
1084:state.c       ****   if (bit_is_set(state.rate_status, RATE_F)) {
 4061              		.loc 1 1084 0
 4062 0000 124B     		ldr	r3, .L526
 4063 0002 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4064 0006 9007     		lsls	r0, r2, #30
 4065 0008 1FD4     		bmi	.L520
1085:state.c       ****     return;
1086:state.c       ****   }
1087:state.c       **** 
1088:state.c       ****   if (bit_is_set(state.rate_status, RATE_I)) {
 4066              		.loc 1 1088 0
 4067 000a D107     		lsls	r1, r2, #31
 4068 000c 19D5     		bpl	.L522
1089:state.c       ****     RATES_FLOAT_OF_BFP(state.body_rates_f, state.body_rates_i);
 4069              		.loc 1 1089 0
 4070 000e D3ED8B6A 		flds	s13, [r3, #556]	@ int
 4071 0012 DFED0F7A 		flds	s15, .L526+4
 4072 0016 B8EEE67A 		fsitos	s14, s13
 4073 001a D3ED8C6A 		flds	s13, [r3, #560]	@ int
 4074 001e 27EE277A 		fmuls	s14, s14, s15
 4075 0022 83ED8E7A 		fsts	s14, [r3, #568]
 4076 0026 B8EEE67A 		fsitos	s14, s13
 4077 002a D3ED8D6A 		flds	s13, [r3, #564]	@ int
 4078 002e 27EE277A 		fmuls	s14, s14, s15
 4079 0032 83ED8F7A 		fsts	s14, [r3, #572]
 4080 0036 B8EEE67A 		fsitos	s14, s13
 4081 003a 67EE277A 		fmuls	s15, s14, s15
 4082 003e C3ED907A 		fsts	s15, [r3, #576]
 4083              	.L522:
1090:state.c       ****   }
1091:state.c       ****   /* set bit to indicate this representation is computed */
1092:state.c       ****   SetBit(state.rate_status, RATE_F);
 4084              		.loc 1 1092 0
 4085 0042 42F00202 		orr	r2, r2, #2
 4086 0046 83F82822 		strb	r2, [r3, #552]
 4087              	.L520:
 4088 004a 7047     		bx	lr
 4089              	.L527:
 4090              		.align	2
 4091              	.L526:
 4092 004c 00000000 		.word	.LANCHOR0
 4093 0050 00008039 		.word	964689920
 4094              		.cfi_endproc
 4095              	.LFE164:
 4097              		.section	.text.stateCalcHorizontalWindspeed_i,"ax",%progbits
 4098              		.align	1
 4099              		.global	stateCalcHorizontalWindspeed_i
 4100              		.thumb
 4101              		.thumb_func
 4103              	stateCalcHorizontalWindspeed_i:
 4104              	.LFB165:
1093:state.c       **** }
1094:state.c       **** 
1095:state.c       **** /** @}*/
1096:state.c       **** 
1097:state.c       **** 
1098:state.c       **** /******************************************************************************
1099:state.c       ****  *                                                                            *
1100:state.c       ****  * Transformation functions for the WIND- AND AIRSPEED representations        *
1101:state.c       ****  *                                                                            *
1102:state.c       ****  *****************************************************************************/
1103:state.c       **** /** @addtogroup state_wind_airspeed
1104:state.c       ****  *  @{ */
1105:state.c       **** 
1106:state.c       **** void stateCalcHorizontalWindspeed_i(void)
1107:state.c       **** {
 4105              		.loc 1 1107 0
 4106              		.cfi_startproc
 4107              		@ args = 0, pretend = 0, frame = 0
 4108              		@ frame_needed = 0, uses_anonymous_args = 0
 4109              		@ link register save eliminated.
1108:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I)) {
 4110              		.loc 1 1108 0
 4111 0000 0F4B     		ldr	r3, .L534
 4112 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4113 0006 D107     		lsls	r1, r2, #31
 4114 0008 19D4     		bmi	.L528
1109:state.c       ****     return;
1110:state.c       ****   }
1111:state.c       **** 
1112:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F)) {
 4115              		.loc 1 1112 0
 4116 000a 5207     		lsls	r2, r2, #29
 4117 000c 11D5     		bpl	.L530
1113:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4118              		.loc 1 1113 0
 4119 000e DFED0D7A 		flds	s15, .L534+4
 4120 0012 93ED957A 		flds	s14, [r3, #596]
 4121 0016 27EE277A 		fmuls	s14, s14, s15
 4122 001a BDEEC77A 		ftosizs	s14, s14
 4123 001e 83ED927A 		fsts	s14, [r3, #584]	@ int
1114:state.c       ****     state.h_windspeed_i.y = SPEED_BFP_OF_REAL(state.h_windspeed_f.y);
 4124              		.loc 1 1114 0
 4125 0022 93ED967A 		flds	s14, [r3, #600]
 4126 0026 67EE277A 		fmuls	s15, s14, s15
 4127 002a FDEEE77A 		ftosizs	s15, s15
 4128 002e C3ED937A 		fsts	s15, [r3, #588]	@ int
 4129              	.L530:
1115:state.c       ****   }
1116:state.c       ****   /* set bit to indicate this representation is computed */
1117:state.c       ****   SetBit(state.rate_status, WINDSPEED_I);
 4130              		.loc 1 1117 0
 4131 0032 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4132 0036 42F00102 		orr	r2, r2, #1
 4133 003a 83F82822 		strb	r2, [r3, #552]
 4134              	.L528:
 4135 003e 7047     		bx	lr
 4136              	.L535:
 4137              		.align	2
 4138              	.L534:
 4139 0040 00000000 		.word	.LANCHOR0
 4140 0044 00000049 		.word	1224736768
 4141              		.cfi_endproc
 4142              	.LFE165:
 4144              		.section	.text.stateCalcAirspeed_i,"ax",%progbits
 4145              		.align	1
 4146              		.global	stateCalcAirspeed_i
 4147              		.thumb
 4148              		.thumb_func
 4150              	stateCalcAirspeed_i:
 4151              	.LFB166:
1118:state.c       **** }
1119:state.c       **** 
1120:state.c       **** void stateCalcAirspeed_i(void)
1121:state.c       **** {
 4152              		.loc 1 1121 0
 4153              		.cfi_startproc
 4154              		@ args = 0, pretend = 0, frame = 0
 4155              		@ frame_needed = 0, uses_anonymous_args = 0
 4156              		@ link register save eliminated.
1122:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I)) {
 4157              		.loc 1 1122 0
 4158 0000 0A4B     		ldr	r3, .L542
 4159 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4160 0006 9007     		lsls	r0, r2, #30
 4161 0008 0FD4     		bmi	.L536
1123:state.c       ****     return;
1124:state.c       ****   }
1125:state.c       **** 
1126:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F)) {
 4162              		.loc 1 1126 0
 4163 000a 1107     		lsls	r1, r2, #28
 4164 000c 09D5     		bpl	.L538
1127:state.c       ****     state.airspeed_i = SPEED_BFP_OF_REAL(state.airspeed_f);
 4165              		.loc 1 1127 0
 4166 000e 93ED977A 		flds	s14, [r3, #604]
 4167 0012 DFED077A 		flds	s15, .L542+4
 4168 0016 67EE277A 		fmuls	s15, s14, s15
 4169 001a FDEEE77A 		ftosizs	s15, s15
 4170 001e C3ED947A 		fsts	s15, [r3, #592]	@ int
 4171              	.L538:
1128:state.c       ****   }
1129:state.c       ****   /* set bit to indicate this representation is computed */
1130:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_I);
 4172              		.loc 1 1130 0
 4173 0022 42F00202 		orr	r2, r2, #2
 4174 0026 83F84422 		strb	r2, [r3, #580]
 4175              	.L536:
 4176 002a 7047     		bx	lr
 4177              	.L543:
 4178              		.align	2
 4179              	.L542:
 4180 002c 00000000 		.word	.LANCHOR0
 4181 0030 00000049 		.word	1224736768
 4182              		.cfi_endproc
 4183              	.LFE166:
 4185              		.section	.text.stateCalcHorizontalWindspeed_f,"ax",%progbits
 4186              		.align	1
 4187              		.global	stateCalcHorizontalWindspeed_f
 4188              		.thumb
 4189              		.thumb_func
 4191              	stateCalcHorizontalWindspeed_f:
 4192              	.LFB167:
1131:state.c       **** }
1132:state.c       **** 
1133:state.c       **** void stateCalcHorizontalWindspeed_f(void)
1134:state.c       **** {
 4193              		.loc 1 1134 0
 4194              		.cfi_startproc
 4195              		@ args = 0, pretend = 0, frame = 0
 4196              		@ frame_needed = 0, uses_anonymous_args = 0
 4197              		@ link register save eliminated.
1135:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F)) {
 4198              		.loc 1 1135 0
 4199 0000 094B     		ldr	r3, .L550
 4200 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4201 0006 5107     		lsls	r1, r2, #29
 4202 0008 0DD4     		bmi	.L544
1136:state.c       ****     return;
1137:state.c       ****   }
1138:state.c       **** 
1139:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I)) {
 4203              		.loc 1 1139 0
 4204 000a D207     		lsls	r2, r2, #31
 4205 000c 05D5     		bpl	.L546
1140:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.x);
1141:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.y);
 4206              		.loc 1 1141 0
 4207 000e D3ED937A 		flds	s15, [r3, #588]	@ int
 4208 0012 FAEEE67A 		vcvt.f32.s32	s15, s15, #19
 4209 0016 C3ED957A 		fsts	s15, [r3, #596]
 4210              	.L546:
1142:state.c       ****   }
1143:state.c       ****   /* set bit to indicate this representation is computed */
1144:state.c       ****   SetBit(state.rate_status, WINDSPEED_F);
 4211              		.loc 1 1144 0
 4212 001a 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4213 001e 42F00402 		orr	r2, r2, #4
 4214 0022 83F82822 		strb	r2, [r3, #552]
 4215              	.L544:
 4216 0026 7047     		bx	lr
 4217              	.L551:
 4218              		.align	2
 4219              	.L550:
 4220 0028 00000000 		.word	.LANCHOR0
 4221              		.cfi_endproc
 4222              	.LFE167:
 4224              		.section	.text.stateCalcAirspeed_f,"ax",%progbits
 4225              		.align	1
 4226              		.global	stateCalcAirspeed_f
 4227              		.thumb
 4228              		.thumb_func
 4230              	stateCalcAirspeed_f:
 4231              	.LFB168:
1145:state.c       **** }
1146:state.c       **** 
1147:state.c       **** void stateCalcAirspeed_f(void)
1148:state.c       **** {
 4232              		.loc 1 1148 0
 4233              		.cfi_startproc
 4234              		@ args = 0, pretend = 0, frame = 0
 4235              		@ frame_needed = 0, uses_anonymous_args = 0
 4236              		@ link register save eliminated.
1149:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F)) {
 4237              		.loc 1 1149 0
 4238 0000 084B     		ldr	r3, .L558
 4239 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4240 0006 1007     		lsls	r0, r2, #28
 4241 0008 0BD4     		bmi	.L552
1150:state.c       ****     return;
1151:state.c       ****   }
1152:state.c       **** 
1153:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I)) {
 4242              		.loc 1 1153 0
 4243 000a 9107     		lsls	r1, r2, #30
 4244 000c 05D5     		bpl	.L554
1154:state.c       ****     state.airspeed_f = SPEED_FLOAT_OF_BFP(state.airspeed_i);
 4245              		.loc 1 1154 0
 4246 000e D3ED947A 		flds	s15, [r3, #592]	@ int
 4247 0012 FAEEE67A 		vcvt.f32.s32	s15, s15, #19
 4248 0016 C3ED977A 		fsts	s15, [r3, #604]
 4249              	.L554:
1155:state.c       ****   }
1156:state.c       ****   /* set bit to indicate this representation is computed */
1157:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_F);
 4250              		.loc 1 1157 0
 4251 001a 42F00802 		orr	r2, r2, #8
 4252 001e 83F84422 		strb	r2, [r3, #580]
 4253              	.L552:
 4254 0022 7047     		bx	lr
 4255              	.L559:
 4256              		.align	2
 4257              	.L558:
 4258 0024 00000000 		.word	.LANCHOR0
 4259              		.cfi_endproc
 4260              	.LFE168:
 4262              		.global	state
 4263              		.section	.bss.state,"aw",%nobits
 4264              		.align	2
 4265              		.set	.LANCHOR0,. + 0
 4268              	state:
 4269 0000 00000000 		.space	616
 4269      00000000 
 4269      00000000 
 4269      00000000 
 4269      00000000 
 4270              		.text
 4271              	.Letext0:
 4272              		.file 2 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 4273              		.file 3 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 4274              		.file 4 "/home/lsk/paparazzi/sw/include/std.h"
 4275              		.file 5 "math/pprz_algebra_int.h"
 4276              		.file 6 "math/pprz_algebra_float.h"
 4277              		.file 7 "math/pprz_geodetic_int.h"
 4278              		.file 8 "math/pprz_geodetic_float.h"
 4279              		.file 9 "math/pprz_orientation_conversion.h"
 4280              		.file 10 "state.h"
 4281              		.file 11 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
 4282              		.file 12 "./math/pprz_trig_int.h"
DEFINED SYMBOLS
                            *ABS*:00000000 state.c
     /tmp/cc5oknPH.s:20     .text.stateInit:00000000 $t
     /tmp/cc5oknPH.s:25     .text.stateInit:00000000 stateInit
     /tmp/cc5oknPH.s:57     .text.stateInit:00000028 $d
     /tmp/cc5oknPH.s:65     .text.stateCalcPositionEcef_i:00000000 $t
     /tmp/cc5oknPH.s:70     .text.stateCalcPositionEcef_i:00000000 stateCalcPositionEcef_i
     /tmp/cc5oknPH.s:220    .text.stateCalcPositionEcef_i:00000104 $d
     /tmp/cc5oknPH.s:230    .text.stateCalcPositionNed_i:00000000 $t
     /tmp/cc5oknPH.s:235    .text.stateCalcPositionNed_i:00000000 stateCalcPositionNed_i
     /tmp/cc5oknPH.s:518    .text.stateCalcPositionNed_i:00000258 $d
     /tmp/cc5oknPH.s:529    .text.stateCalcPositionEnu_i:00000000 $t
     /tmp/cc5oknPH.s:534    .text.stateCalcPositionEnu_i:00000000 stateCalcPositionEnu_i
     /tmp/cc5oknPH.s:813    .text.stateCalcPositionEnu_i:00000250 $d
     /tmp/cc5oknPH.s:824    .text.stateCalcPositionLla_i:00000000 $t
     /tmp/cc5oknPH.s:829    .text.stateCalcPositionLla_i:00000000 stateCalcPositionLla_i
     /tmp/cc5oknPH.s:1081   .text.stateCalcPositionLla_i:000001e0 $d
     /tmp/cc5oknPH.s:1094   .text.stateCalcPositionUtm_f:00000000 $t
     /tmp/cc5oknPH.s:1099   .text.stateCalcPositionUtm_f:00000000 stateCalcPositionUtm_f
     /tmp/cc5oknPH.s:1306   .text.stateCalcPositionUtm_f:000001d0 $d
     /tmp/cc5oknPH.s:1318   .text.stateCalcPositionEcef_f:00000000 $t
     /tmp/cc5oknPH.s:1323   .text.stateCalcPositionEcef_f:00000000 stateCalcPositionEcef_f
     /tmp/cc5oknPH.s:1471   .text.stateCalcPositionEcef_f:00000120 $d
     /tmp/cc5oknPH.s:1482   .text.stateCalcPositionNed_f:00000000 $t
     /tmp/cc5oknPH.s:1487   .text.stateCalcPositionNed_f:00000000 stateCalcPositionNed_f
     /tmp/cc5oknPH.s:1752   .text.stateCalcPositionNed_f:00000240 $d
     /tmp/cc5oknPH.s:1763   .text.stateCalcPositionEnu_f:00000000 $t
     /tmp/cc5oknPH.s:1768   .text.stateCalcPositionEnu_f:00000000 stateCalcPositionEnu_f
     /tmp/cc5oknPH.s:2034   .text.stateCalcPositionEnu_f:00000238 $d
     /tmp/cc5oknPH.s:2045   .text.stateCalcPositionLla_f:00000000 $t
     /tmp/cc5oknPH.s:2050   .text.stateCalcPositionLla_f:00000000 stateCalcPositionLla_f
     /tmp/cc5oknPH.s:2241   .text.stateCalcPositionLla_f:00000178 $d
     /tmp/cc5oknPH.s:2254   .text.stateCalcSpeedNed_i:00000000 $t
     /tmp/cc5oknPH.s:2259   .text.stateCalcSpeedNed_i:00000000 stateCalcSpeedNed_i
     /tmp/cc5oknPH.s:2409   .text.stateCalcSpeedNed_i:00000140 $d
     /tmp/cc5oknPH.s:2415   .text.stateCalcSpeedEnu_i:00000000 $t
     /tmp/cc5oknPH.s:2420   .text.stateCalcSpeedEnu_i:00000000 stateCalcSpeedEnu_i
     /tmp/cc5oknPH.s:2581   .text.stateCalcSpeedEnu_i:0000015c $d
     /tmp/cc5oknPH.s:2589   .text.stateCalcSpeedEcef_i:00000000 $t
     /tmp/cc5oknPH.s:2594   .text.stateCalcSpeedEcef_i:00000000 stateCalcSpeedEcef_i
     /tmp/cc5oknPH.s:2671   .text.stateCalcSpeedEcef_i:000000a8 $d
     /tmp/cc5oknPH.s:2677   .text.stateCalcHorizontalSpeedNorm_i:00000000 $t
     /tmp/cc5oknPH.s:2682   .text.stateCalcHorizontalSpeedNorm_i:00000000 stateCalcHorizontalSpeedNorm_i
     /tmp/cc5oknPH.s:2816   .text.stateCalcHorizontalSpeedNorm_i:000000e4 $d
     /tmp/cc5oknPH.s:2822   .text.stateCalcHorizontalSpeedDir_i:00000000 $t
     /tmp/cc5oknPH.s:2827   .text.stateCalcHorizontalSpeedDir_i:00000000 stateCalcHorizontalSpeedDir_i
     /tmp/cc5oknPH.s:3008   .text.stateCalcHorizontalSpeedDir_i:00000164 $d
     /tmp/cc5oknPH.s:3014   .text.stateCalcSpeedNed_f:00000000 $t
     /tmp/cc5oknPH.s:3019   .text.stateCalcSpeedNed_f:00000000 stateCalcSpeedNed_f
     /tmp/cc5oknPH.s:3163   .text.stateCalcSpeedNed_f:00000138 $d
     /tmp/cc5oknPH.s:3169   .text.stateCalcSpeedEnu_f:00000000 $t
     /tmp/cc5oknPH.s:3174   .text.stateCalcSpeedEnu_f:00000000 stateCalcSpeedEnu_f
     /tmp/cc5oknPH.s:3318   .text.stateCalcSpeedEnu_f:00000130 $d
     /tmp/cc5oknPH.s:3325   .text.stateCalcSpeedEcef_f:00000000 $t
     /tmp/cc5oknPH.s:3330   .text.stateCalcSpeedEcef_f:00000000 stateCalcSpeedEcef_f
     /tmp/cc5oknPH.s:3407   .text.stateCalcSpeedEcef_f:000000a8 $d
     /tmp/cc5oknPH.s:3413   .text.stateCalcHorizontalSpeedNorm_f:00000000 $t
     /tmp/cc5oknPH.s:3418   .text.stateCalcHorizontalSpeedNorm_f:00000000 stateCalcHorizontalSpeedNorm_f
     /tmp/cc5oknPH.s:3518   .text.stateCalcHorizontalSpeedNorm_f:000000dc $d
     /tmp/cc5oknPH.s:3524   .text.stateCalcHorizontalSpeedDir_f:00000000 $t
     /tmp/cc5oknPH.s:3529   .text.stateCalcHorizontalSpeedDir_f:00000000 stateCalcHorizontalSpeedDir_f
     /tmp/cc5oknPH.s:3630   .text.stateCalcHorizontalSpeedDir_f:000000d8 $d
     /tmp/cc5oknPH.s:3636   .text.stateCalcAccelNed_i:00000000 $t
     /tmp/cc5oknPH.s:3641   .text.stateCalcAccelNed_i:00000000 stateCalcAccelNed_i
     /tmp/cc5oknPH.s:3724   .text.stateCalcAccelNed_i:000000b0 $d
     /tmp/cc5oknPH.s:3730   .text.stateCalcAccelEcef_i:00000000 $t
     /tmp/cc5oknPH.s:3735   .text.stateCalcAccelEcef_i:00000000 stateCalcAccelEcef_i
     /tmp/cc5oknPH.s:3812   .text.stateCalcAccelEcef_i:000000a8 $d
     /tmp/cc5oknPH.s:3818   .text.stateCalcAccelNed_f:00000000 $t
     /tmp/cc5oknPH.s:3823   .text.stateCalcAccelNed_f:00000000 stateCalcAccelNed_f
     /tmp/cc5oknPH.s:3906   .text.stateCalcAccelNed_f:000000b0 $d
     /tmp/cc5oknPH.s:3912   .text.stateCalcAccelEcef_f:00000000 $t
     /tmp/cc5oknPH.s:3917   .text.stateCalcAccelEcef_f:00000000 stateCalcAccelEcef_f
     /tmp/cc5oknPH.s:3994   .text.stateCalcAccelEcef_f:000000a8 $d
     /tmp/cc5oknPH.s:4000   .text.stateCalcBodyRates_i:00000000 $t
     /tmp/cc5oknPH.s:4005   .text.stateCalcBodyRates_i:00000000 stateCalcBodyRates_i
     /tmp/cc5oknPH.s:4043   .text.stateCalcBodyRates_i:0000004c $d
     /tmp/cc5oknPH.s:4049   .text.stateCalcBodyRates_f:00000000 $t
     /tmp/cc5oknPH.s:4054   .text.stateCalcBodyRates_f:00000000 stateCalcBodyRates_f
     /tmp/cc5oknPH.s:4092   .text.stateCalcBodyRates_f:0000004c $d
     /tmp/cc5oknPH.s:4098   .text.stateCalcHorizontalWindspeed_i:00000000 $t
     /tmp/cc5oknPH.s:4103   .text.stateCalcHorizontalWindspeed_i:00000000 stateCalcHorizontalWindspeed_i
     /tmp/cc5oknPH.s:4139   .text.stateCalcHorizontalWindspeed_i:00000040 $d
     /tmp/cc5oknPH.s:4145   .text.stateCalcAirspeed_i:00000000 $t
     /tmp/cc5oknPH.s:4150   .text.stateCalcAirspeed_i:00000000 stateCalcAirspeed_i
     /tmp/cc5oknPH.s:4180   .text.stateCalcAirspeed_i:0000002c $d
     /tmp/cc5oknPH.s:4186   .text.stateCalcHorizontalWindspeed_f:00000000 $t
     /tmp/cc5oknPH.s:4191   .text.stateCalcHorizontalWindspeed_f:00000000 stateCalcHorizontalWindspeed_f
     /tmp/cc5oknPH.s:4220   .text.stateCalcHorizontalWindspeed_f:00000028 $d
     /tmp/cc5oknPH.s:4225   .text.stateCalcAirspeed_f:00000000 $t
     /tmp/cc5oknPH.s:4230   .text.stateCalcAirspeed_f:00000000 stateCalcAirspeed_f
     /tmp/cc5oknPH.s:4258   .text.stateCalcAirspeed_f:00000024 $d
     /tmp/cc5oknPH.s:4268   .bss.state:00000000 state
     /tmp/cc5oknPH.s:4264   .bss.state:00000000 $d
                     .debug_frame:00000010 $d
     /tmp/cc5oknPH.s:528    .text.stateCalcPositionNed_i:00000274 $t
     /tmp/cc5oknPH.s:823    .text.stateCalcPositionEnu_i:0000026c $t
     /tmp/cc5oknPH.s:1093   .text.stateCalcPositionLla_i:00000204 $t
     /tmp/cc5oknPH.s:1317   .text.stateCalcPositionUtm_f:000001ec $t
     /tmp/cc5oknPH.s:1481   .text.stateCalcPositionEcef_f:0000013c $t
     /tmp/cc5oknPH.s:1762   .text.stateCalcPositionNed_f:0000025c $t
     /tmp/cc5oknPH.s:2044   .text.stateCalcPositionEnu_f:00000254 $t
     /tmp/cc5oknPH.s:2253   .text.stateCalcPositionLla_f:0000019c $t
                           .group:00000000 wm4.0.61e172dafa1e7adfbd840ee8b103061f
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.4db40689d622c4d3b547b5801303bdae
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.13c5bec129ef04ad1bb0a1152b29c624
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.float.h.29.1cf88a0527b6b1225d49fbee2b32acb7
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.pprz_algebra.h.47.d249264ea6bacf2198e290d461cf6dbe
                           .group:00000000 wm4.pprz_trig_int.h.28.b756be608c9d9f3092a41321446e5fa2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:00000000 wm4.pprz_algebra_int.h.68.04ac162ae1e1d94f716d0bb402062624
                           .group:00000000 wm4.pprz_algebra_float.h.98.bb035bcbfa66bb186e7ea81143fd64bc
                           .group:00000000 wm4.pprz_geodetic.h.35.f7fdb5d11659b92d11c7ce67b6317005
                           .group:00000000 wm4.pprz_geodetic_int.h.127.8e737bed5ba4468e470311184b1fca7f
                           .group:00000000 wm4.pprz_orientation_conversion.h.69.5cce798fefad8bb761767fd414e61db5
                           .group:00000000 wm4.state.h.65.b18954aacb3801ec3e27b4e857d620d3

UNDEFINED SYMBOLS
__aeabi_f2d
__aeabi_dmul
__aeabi_d2iz
ecef_of_ned_pos_i
ecef_of_ned_point_f
ecef_of_lla_i
ecef_of_lla_f
__aeabi_ddiv
__aeabi_d2f
ned_of_ecef_pos_i
ned_of_ecef_point_f
ned_of_lla_point_i
utm_of_lla_f
enu_of_ecef_pos_i
enu_of_ecef_point_f
enu_of_lla_point_i
lla_of_ecef_i
ecef_of_enu_pos_i
lla_of_utm_f
__aeabi_i2d
ned_of_lla_point_f
enu_of_lla_point_f
lla_of_ecef_f
ned_of_ecef_vect_i
enu_of_ecef_vect_i
ecef_of_ned_vect_i
int32_sqrt
ned_of_ecef_vect_f
sqrtf
int32_atan2
enu_of_ecef_vect_f
ecef_of_ned_vect_f
atan2f
