   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"stabilization_attitude_rc_setpoint.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.get_sys_time_float,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	get_sys_time_float:
  25              	.LFB152:
  26              		.file 1 "./mcu_periph/sys_time.h"
   1:./mcu_periph/sys_time.h **** /*
   2:./mcu_periph/sys_time.h ****  *
   3:./mcu_periph/sys_time.h ****  * Copyright (C) 2009-2011 The Paparazzi Team
   4:./mcu_periph/sys_time.h ****  *
   5:./mcu_periph/sys_time.h ****  * This file is part of paparazzi.
   6:./mcu_periph/sys_time.h ****  *
   7:./mcu_periph/sys_time.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./mcu_periph/sys_time.h ****  * it under the terms of the GNU General Public License as published by
   9:./mcu_periph/sys_time.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./mcu_periph/sys_time.h ****  * any later version.
  11:./mcu_periph/sys_time.h ****  *
  12:./mcu_periph/sys_time.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./mcu_periph/sys_time.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./mcu_periph/sys_time.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./mcu_periph/sys_time.h ****  * GNU General Public License for more details.
  16:./mcu_periph/sys_time.h ****  *
  17:./mcu_periph/sys_time.h ****  * You should have received a copy of the GNU General Public License
  18:./mcu_periph/sys_time.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./mcu_periph/sys_time.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./mcu_periph/sys_time.h ****  * Boston, MA 02111-1307, USA.
  21:./mcu_periph/sys_time.h ****  *
  22:./mcu_periph/sys_time.h ****  */
  23:./mcu_periph/sys_time.h **** 
  24:./mcu_periph/sys_time.h **** /**
  25:./mcu_periph/sys_time.h ****  * @file mcu_periph/sys_time.h
  26:./mcu_periph/sys_time.h ****  * @brief Architecture independent timing functions.
  27:./mcu_periph/sys_time.h ****  *
  28:./mcu_periph/sys_time.h ****  */
  29:./mcu_periph/sys_time.h **** 
  30:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_H
  31:./mcu_periph/sys_time.h **** #define SYS_TIME_H
  32:./mcu_periph/sys_time.h **** 
  33:./mcu_periph/sys_time.h **** #include <inttypes.h>
  34:./mcu_periph/sys_time.h **** #include <stdlib.h>
  35:./mcu_periph/sys_time.h **** #include "std.h"
  36:./mcu_periph/sys_time.h **** 
  37:./mcu_periph/sys_time.h **** #include BOARD_CONFIG
  38:./mcu_periph/sys_time.h **** 
  39:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_NB_TIMER
  40:./mcu_periph/sys_time.h **** #define SYS_TIME_NB_TIMER 16
  41:./mcu_periph/sys_time.h **** #endif
  42:./mcu_periph/sys_time.h **** 
  43:./mcu_periph/sys_time.h **** 
  44:./mcu_periph/sys_time.h **** /**
  45:./mcu_periph/sys_time.h ****  * (Default) sys_time timer frequency in Hz.
  46:./mcu_periph/sys_time.h ****  * sys_time.resolution is set from this define.
  47:./mcu_periph/sys_time.h ****  */
  48:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_FREQUENCY
  49:./mcu_periph/sys_time.h **** #if defined PERIODIC_FREQUENCY
  50:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY (2 * PERIODIC_FREQUENCY)
  51:./mcu_periph/sys_time.h **** #else
  52:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY 1000
  53:./mcu_periph/sys_time.h **** #endif
  54:./mcu_periph/sys_time.h **** #endif
  55:./mcu_periph/sys_time.h **** 
  56:./mcu_periph/sys_time.h **** 
  57:./mcu_periph/sys_time.h **** typedef uint8_t tid_t; ///< sys_time timer id type
  58:./mcu_periph/sys_time.h **** typedef void (*sys_time_cb)(uint8_t id);
  59:./mcu_periph/sys_time.h **** 
  60:./mcu_periph/sys_time.h **** struct sys_time_timer {
  61:./mcu_periph/sys_time.h ****   bool_t          in_use;
  62:./mcu_periph/sys_time.h ****   sys_time_cb     cb;
  63:./mcu_periph/sys_time.h ****   volatile bool_t elapsed;
  64:./mcu_periph/sys_time.h ****   uint32_t        end_time; ///< in SYS_TIME_TICKS
  65:./mcu_periph/sys_time.h ****   uint32_t        duration; ///< in SYS_TIME_TICKS
  66:./mcu_periph/sys_time.h **** };
  67:./mcu_periph/sys_time.h **** 
  68:./mcu_periph/sys_time.h **** struct sys_time {
  69:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec;       ///< full seconds since startup
  70:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec_rem;   ///< remainder of seconds since startup in CPU_TICKS
  71:./mcu_periph/sys_time.h ****   volatile uint32_t nb_tick;      ///< SYS_TIME_TICKS since startup
  72:./mcu_periph/sys_time.h ****   struct sys_time_timer timer[SYS_TIME_NB_TIMER];
  73:./mcu_periph/sys_time.h **** 
  74:./mcu_periph/sys_time.h ****   float resolution;               ///< sys_time_timer resolution in seconds
  75:./mcu_periph/sys_time.h ****   uint32_t ticks_per_sec;         ///< sys_time ticks per second (SYS_TIME_FREQUENCY)
  76:./mcu_periph/sys_time.h ****   uint32_t resolution_cpu_ticks;  ///< sys_time_timer resolution in cpu ticks
  77:./mcu_periph/sys_time.h ****   uint32_t cpu_ticks_per_sec;     ///< cpu ticks per second
  78:./mcu_periph/sys_time.h **** };
  79:./mcu_periph/sys_time.h **** 
  80:./mcu_periph/sys_time.h **** extern struct sys_time sys_time;
  81:./mcu_periph/sys_time.h **** 
  82:./mcu_periph/sys_time.h **** 
  83:./mcu_periph/sys_time.h **** extern void sys_time_init(void);
  84:./mcu_periph/sys_time.h **** 
  85:./mcu_periph/sys_time.h **** /**
  86:./mcu_periph/sys_time.h ****  * Register a new system timer.
  87:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
  88:./mcu_periph/sys_time.h ****  * @param cb Callback function that is called from the ISR when timer elapses, or NULL
  89:./mcu_periph/sys_time.h ****  * @return -1 if it failed, the timer id otherwise
  90:./mcu_periph/sys_time.h ****  */
  91:./mcu_periph/sys_time.h **** extern int sys_time_register_timer(float duration, sys_time_cb cb);
  92:./mcu_periph/sys_time.h **** 
  93:./mcu_periph/sys_time.h **** /**
  94:./mcu_periph/sys_time.h ****  * Cancel a system timer by id.
  95:./mcu_periph/sys_time.h ****  * @param id Timer id.
  96:./mcu_periph/sys_time.h ****  */
  97:./mcu_periph/sys_time.h **** extern void sys_time_cancel_timer(tid_t id);
  98:./mcu_periph/sys_time.h **** 
  99:./mcu_periph/sys_time.h **** /**
 100:./mcu_periph/sys_time.h ****  * Update the duration until a timer elapses.
 101:./mcu_periph/sys_time.h ****  * @param id Timer id
 102:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
 103:./mcu_periph/sys_time.h ****  */
 104:./mcu_periph/sys_time.h **** extern void sys_time_update_timer(tid_t id, float duration);
 105:./mcu_periph/sys_time.h **** 
 106:./mcu_periph/sys_time.h **** /**
 107:./mcu_periph/sys_time.h ****  * Check if timer has elapsed.
 108:./mcu_periph/sys_time.h ****  * @param id Timer id
 109:./mcu_periph/sys_time.h ****  * @return TRUE if timer has elapsed
 110:./mcu_periph/sys_time.h ****  */
 111:./mcu_periph/sys_time.h **** static inline bool_t sys_time_check_and_ack_timer(tid_t id)
 112:./mcu_periph/sys_time.h **** {
 113:./mcu_periph/sys_time.h ****   if (sys_time.timer[id].elapsed) {
 114:./mcu_periph/sys_time.h ****     sys_time.timer[id].elapsed = FALSE;
 115:./mcu_periph/sys_time.h ****     return TRUE;
 116:./mcu_periph/sys_time.h ****   }
 117:./mcu_periph/sys_time.h ****   return FALSE;
 118:./mcu_periph/sys_time.h **** }
 119:./mcu_periph/sys_time.h **** 
 120:./mcu_periph/sys_time.h **** /**
 121:./mcu_periph/sys_time.h ****  * Get the time in seconds since startup.
 122:./mcu_periph/sys_time.h ****  * @return current system time as float with sys_time.resolution
 123:./mcu_periph/sys_time.h ****  */
 124:./mcu_periph/sys_time.h **** static inline float get_sys_time_float(void)
 125:./mcu_periph/sys_time.h **** {
  27              		.loc 1 125 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
 126:./mcu_periph/sys_time.h ****   return (float)(sys_time.nb_sec + (float)(sys_time.nb_sec_rem) / sys_time.cpu_ticks_per_sec);
  32              		.loc 1 126 0
  33 0000 084B     		ldr	r3, .L2
  34 0002 93ED000A 		flds	s0, [r3]	@ int
  35 0006 D3ED567A 		flds	s15, [r3, #344]	@ int
  36 000a 93ED017A 		flds	s14, [r3, #4]	@ int
  37 000e F8EE677A 		fuitos	s15, s15
  38 0012 B8EE477A 		fuitos	s14, s14
  39 0016 B8EE400A 		fuitos	s0, s0
  40 001a C7EE277A 		fdivs	s15, s14, s15
 127:./mcu_periph/sys_time.h **** }
  41              		.loc 1 127 0
  42 001e 30EE270A 		fadds	s0, s0, s15
  43 0022 7047     		bx	lr
  44              	.L3:
  45              		.align	2
  46              	.L2:
  47 0024 00000000 		.word	sys_time
  48              		.cfi_endproc
  49              	.LFE152:
  51              		.section	.text.float_quat_normalize,"ax",%progbits
  52              		.align	1
  53              		.thumb
  54              		.thumb_func
  56              	float_quat_normalize:
  57              	.LFB18:
  58              		.file 2 "./math/pprz_algebra_float.h"
   1:./math/pprz_algebra_float.h **** /*
   2:./math/pprz_algebra_float.h ****  * Copyright (C) 2008-2014 The Paparazzi Team
   3:./math/pprz_algebra_float.h ****  *
   4:./math/pprz_algebra_float.h ****  * This file is part of paparazzi.
   5:./math/pprz_algebra_float.h ****  *
   6:./math/pprz_algebra_float.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_algebra_float.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_algebra_float.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_algebra_float.h ****  * any later version.
  10:./math/pprz_algebra_float.h ****  *
  11:./math/pprz_algebra_float.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_algebra_float.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_algebra_float.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_algebra_float.h ****  * GNU General Public License for more details.
  15:./math/pprz_algebra_float.h ****  *
  16:./math/pprz_algebra_float.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_algebra_float.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_algebra_float.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_algebra_float.h ****  */
  20:./math/pprz_algebra_float.h **** 
  21:./math/pprz_algebra_float.h **** /**
  22:./math/pprz_algebra_float.h ****  * @file pprz_algebra_float.h
  23:./math/pprz_algebra_float.h ****  * @brief Paparazzi floating point algebra.
  24:./math/pprz_algebra_float.h ****  *
  25:./math/pprz_algebra_float.h ****  * @addtogroup math_algebra
  26:./math/pprz_algebra_float.h ****  * @{
  27:./math/pprz_algebra_float.h ****  * @defgroup math_algebra_float Float Algebra
  28:./math/pprz_algebra_float.h ****  * @{
  29:./math/pprz_algebra_float.h ****  */
  30:./math/pprz_algebra_float.h **** 
  31:./math/pprz_algebra_float.h **** #ifndef PPRZ_ALGEBRA_FLOAT_H
  32:./math/pprz_algebra_float.h **** #define PPRZ_ALGEBRA_FLOAT_H
  33:./math/pprz_algebra_float.h **** 
  34:./math/pprz_algebra_float.h **** #ifdef __cplusplus
  35:./math/pprz_algebra_float.h **** extern "C" {
  36:./math/pprz_algebra_float.h **** #endif
  37:./math/pprz_algebra_float.h **** 
  38:./math/pprz_algebra_float.h **** #include "pprz_algebra.h"
  39:./math/pprz_algebra_float.h **** 
  40:./math/pprz_algebra_float.h **** #include <math.h>
  41:./math/pprz_algebra_float.h **** #include <float.h> // for FLT_MIN
  42:./math/pprz_algebra_float.h **** 
  43:./math/pprz_algebra_float.h **** /* this seems to be missing for some arch */
  44:./math/pprz_algebra_float.h **** #ifndef M_SQRT2
  45:./math/pprz_algebra_float.h **** #define M_SQRT2         1.41421356237309504880
  46:./math/pprz_algebra_float.h **** #endif
  47:./math/pprz_algebra_float.h **** 
  48:./math/pprz_algebra_float.h **** struct FloatVect2 {
  49:./math/pprz_algebra_float.h ****   float x;
  50:./math/pprz_algebra_float.h ****   float y;
  51:./math/pprz_algebra_float.h **** };
  52:./math/pprz_algebra_float.h **** 
  53:./math/pprz_algebra_float.h **** struct FloatVect3 {
  54:./math/pprz_algebra_float.h ****   float x;
  55:./math/pprz_algebra_float.h ****   float y;
  56:./math/pprz_algebra_float.h ****   float z;
  57:./math/pprz_algebra_float.h **** };
  58:./math/pprz_algebra_float.h **** 
  59:./math/pprz_algebra_float.h **** /**
  60:./math/pprz_algebra_float.h ****  * @brief Roation quaternion
  61:./math/pprz_algebra_float.h ****  */
  62:./math/pprz_algebra_float.h **** struct FloatQuat {
  63:./math/pprz_algebra_float.h ****   float qi;
  64:./math/pprz_algebra_float.h ****   float qx;
  65:./math/pprz_algebra_float.h ****   float qy;
  66:./math/pprz_algebra_float.h ****   float qz;
  67:./math/pprz_algebra_float.h **** };
  68:./math/pprz_algebra_float.h **** 
  69:./math/pprz_algebra_float.h **** struct FloatMat33 {
  70:./math/pprz_algebra_float.h ****   float m[3 * 3];
  71:./math/pprz_algebra_float.h **** };
  72:./math/pprz_algebra_float.h **** 
  73:./math/pprz_algebra_float.h **** /**
  74:./math/pprz_algebra_float.h ****  * @brief rotation matrix
  75:./math/pprz_algebra_float.h ****  */
  76:./math/pprz_algebra_float.h **** struct FloatRMat {
  77:./math/pprz_algebra_float.h ****   float m[3 * 3];
  78:./math/pprz_algebra_float.h **** };
  79:./math/pprz_algebra_float.h **** 
  80:./math/pprz_algebra_float.h **** /**
  81:./math/pprz_algebra_float.h ****  * @brief euler angles
  82:./math/pprz_algebra_float.h ****  * @details Units: radians */
  83:./math/pprz_algebra_float.h **** struct FloatEulers {
  84:./math/pprz_algebra_float.h ****   float phi; ///< in radians
  85:./math/pprz_algebra_float.h ****   float theta; ///< in radians
  86:./math/pprz_algebra_float.h ****   float psi; ///< in radians
  87:./math/pprz_algebra_float.h **** };
  88:./math/pprz_algebra_float.h **** 
  89:./math/pprz_algebra_float.h **** /**
  90:./math/pprz_algebra_float.h ****  * @brief angular rates
  91:./math/pprz_algebra_float.h ****  * @details Units: rad/s */
  92:./math/pprz_algebra_float.h **** struct FloatRates {
  93:./math/pprz_algebra_float.h ****   float p; ///< in rad/s
  94:./math/pprz_algebra_float.h ****   float q; ///< in rad/s
  95:./math/pprz_algebra_float.h ****   float r; ///< in rad/s
  96:./math/pprz_algebra_float.h **** };
  97:./math/pprz_algebra_float.h **** 
  98:./math/pprz_algebra_float.h **** #define FLOAT_ANGLE_NORMALIZE(_a) {             \
  99:./math/pprz_algebra_float.h ****     while (_a >  M_PI) _a -= (2.*M_PI);             \
 100:./math/pprz_algebra_float.h ****     while (_a < -M_PI) _a += (2.*M_PI);             \
 101:./math/pprz_algebra_float.h ****   }
 102:./math/pprz_algebra_float.h **** 
 103:./math/pprz_algebra_float.h **** //
 104:./math/pprz_algebra_float.h **** //
 105:./math/pprz_algebra_float.h **** // Vector algebra
 106:./math/pprz_algebra_float.h **** //
 107:./math/pprz_algebra_float.h **** //
 108:./math/pprz_algebra_float.h **** 
 109:./math/pprz_algebra_float.h **** 
 110:./math/pprz_algebra_float.h **** /*
 111:./math/pprz_algebra_float.h ****  * Dimension 2 Vectors
 112:./math/pprz_algebra_float.h ****  */
 113:./math/pprz_algebra_float.h **** 
 114:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_ZERO(_v) VECT2_ASSIGN(_v, 0., 0.)
 115:./math/pprz_algebra_float.h **** 
 116:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect2, but a different struct with x,y members */
 117:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORM(_v) sqrtf(VECT2_NORM2(_v))
 118:./math/pprz_algebra_float.h **** 
 119:./math/pprz_algebra_float.h **** static inline float float_vect2_norm2(struct FloatVect2 *v)
 120:./math/pprz_algebra_float.h **** {
 121:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y;
 122:./math/pprz_algebra_float.h **** }
 123:./math/pprz_algebra_float.h **** 
 124:./math/pprz_algebra_float.h **** static inline float float_vect2_norm(struct FloatVect2 *v)
 125:./math/pprz_algebra_float.h **** {
 126:./math/pprz_algebra_float.h ****   return sqrtf(float_vect2_norm2(v));
 127:./math/pprz_algebra_float.h **** }
 128:./math/pprz_algebra_float.h **** 
 129:./math/pprz_algebra_float.h **** /** normalize 2D vector in place */
 130:./math/pprz_algebra_float.h **** static inline void float_vect2_normalize(struct FloatVect2 *v)
 131:./math/pprz_algebra_float.h **** {
 132:./math/pprz_algebra_float.h ****   const float n = float_vect2_norm(v);
 133:./math/pprz_algebra_float.h ****   if (n > 0) {
 134:./math/pprz_algebra_float.h ****     v->x /= n;
 135:./math/pprz_algebra_float.h ****     v->y /= n;
 136:./math/pprz_algebra_float.h ****   }
 137:./math/pprz_algebra_float.h **** }
 138:./math/pprz_algebra_float.h **** 
 139:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORMALIZE(_v) float_vect2_normalize(&(_v))
 140:./math/pprz_algebra_float.h **** 
 141:./math/pprz_algebra_float.h **** 
 142:./math/pprz_algebra_float.h **** /*
 143:./math/pprz_algebra_float.h ****  * Dimension 3 Vectors
 144:./math/pprz_algebra_float.h ****  */
 145:./math/pprz_algebra_float.h **** 
 146:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0., 0., 0.)
 147:./math/pprz_algebra_float.h **** 
 148:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect3, but a different struct with x,y,z members */
 149:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORM(_v) sqrtf(VECT3_NORM2(_v))
 150:./math/pprz_algebra_float.h **** 
 151:./math/pprz_algebra_float.h **** static inline float float_vect3_norm2(struct FloatVect3 *v)
 152:./math/pprz_algebra_float.h **** {
 153:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y + v->z * v->z;
 154:./math/pprz_algebra_float.h **** }
 155:./math/pprz_algebra_float.h **** 
 156:./math/pprz_algebra_float.h **** static inline float float_vect3_norm(struct FloatVect3 *v)
 157:./math/pprz_algebra_float.h **** {
 158:./math/pprz_algebra_float.h ****   return sqrtf(float_vect3_norm2(v));
 159:./math/pprz_algebra_float.h **** }
 160:./math/pprz_algebra_float.h **** 
 161:./math/pprz_algebra_float.h **** /** normalize 3D vector in place */
 162:./math/pprz_algebra_float.h **** static inline void float_vect3_normalize(struct FloatVect3 *v)
 163:./math/pprz_algebra_float.h **** {
 164:./math/pprz_algebra_float.h ****   const float n = float_vect3_norm(v);
 165:./math/pprz_algebra_float.h ****   if (n > 0) {
 166:./math/pprz_algebra_float.h ****     v->x /= n;
 167:./math/pprz_algebra_float.h ****     v->y /= n;
 168:./math/pprz_algebra_float.h ****     v->z /= n;
 169:./math/pprz_algebra_float.h ****   }
 170:./math/pprz_algebra_float.h **** }
 171:./math/pprz_algebra_float.h **** 
 172:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORMALIZE(_v) float_vect3_normalize(&(_v))
 173:./math/pprz_algebra_float.h **** 
 174:./math/pprz_algebra_float.h **** 
 175:./math/pprz_algebra_float.h **** 
 176:./math/pprz_algebra_float.h **** #define FLOAT_RATES_ZERO(_r) {          \
 177:./math/pprz_algebra_float.h ****     RATES_ASSIGN(_r, 0., 0., 0.);       \
 178:./math/pprz_algebra_float.h ****   }
 179:./math/pprz_algebra_float.h **** 
 180:./math/pprz_algebra_float.h **** #define FLOAT_RATES_NORM(_v) (sqrtf((_v).p*(_v).p + (_v).q*(_v).q + (_v).r*(_v).r))
 181:./math/pprz_algebra_float.h **** 
 182:./math/pprz_algebra_float.h **** #define FLOAT_RATES_LIN_CMB(_ro, _r1, _s1, _r2, _s2) {          \
 183:./math/pprz_algebra_float.h ****     _ro.p = _s1 * _r1.p + _s2 * _r2.p;                  \
 184:./math/pprz_algebra_float.h ****     _ro.q = _s1 * _r1.q + _s2 * _r2.q;                  \
 185:./math/pprz_algebra_float.h ****     _ro.r = _s1 * _r1.r + _s2 * _r2.r;                  \
 186:./math/pprz_algebra_float.h ****   }
 187:./math/pprz_algebra_float.h **** 
 188:./math/pprz_algebra_float.h **** 
 189:./math/pprz_algebra_float.h **** extern void float_vect3_integrate_fi(struct FloatVect3 *vec, struct FloatVect3 *dv,
 190:./math/pprz_algebra_float.h ****                                      float dt);
 191:./math/pprz_algebra_float.h **** 
 192:./math/pprz_algebra_float.h **** extern void float_rates_integrate_fi(struct FloatRates *r, struct FloatRates *dr,
 193:./math/pprz_algebra_float.h ****                                      float dt);
 194:./math/pprz_algebra_float.h **** 
 195:./math/pprz_algebra_float.h **** extern void float_rates_of_euler_dot(struct FloatRates *r, struct FloatEulers *e,
 196:./math/pprz_algebra_float.h ****                                      struct FloatEulers *edot);
 197:./math/pprz_algebra_float.h **** 
 198:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 199:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_INTEGRATE_FI(_vo, _dv, _dt) float_vect3_integrate_fi(&(_vo), &(_dv), _dt)
 200:./math/pprz_algebra_float.h **** #define FLOAT_RATES_INTEGRATE_FI(_ra, _racc, _dt) float_rates_integrate_fi(&(_ra), &(_racc), _dt)
 201:./math/pprz_algebra_float.h **** #define FLOAT_RATES_OF_EULER_DOT(_ra, _e, _ed) float_rates_of_euler_dot(&(_ra), &(_e), &(_ed))
 202:./math/pprz_algebra_float.h **** 
 203:./math/pprz_algebra_float.h **** 
 204:./math/pprz_algebra_float.h **** /*
 205:./math/pprz_algebra_float.h ****  * 3x3 matrices
 206:./math/pprz_algebra_float.h ****  */
 207:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_ZERO(_m) {                      \
 208:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = 0.;                      \
 209:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 210:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 211:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 212:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = 0.;                      \
 213:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 214:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 215:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 216:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = 0.;                      \
 217:./math/pprz_algebra_float.h ****   }
 218:./math/pprz_algebra_float.h **** 
 219:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_DIAG(_m, _d00, _d11, _d22) {    \
 220:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = _d00;                    \
 221:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 222:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 223:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 224:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = _d11;                    \
 225:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 226:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 227:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 228:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = _d22;                    \
 229:./math/pprz_algebra_float.h ****   }
 230:./math/pprz_algebra_float.h **** 
 231:./math/pprz_algebra_float.h **** 
 232:./math/pprz_algebra_float.h **** //
 233:./math/pprz_algebra_float.h **** //
 234:./math/pprz_algebra_float.h **** // Rotation Matrices
 235:./math/pprz_algebra_float.h **** //
 236:./math/pprz_algebra_float.h **** //
 237:./math/pprz_algebra_float.h **** 
 238:./math/pprz_algebra_float.h **** 
 239:./math/pprz_algebra_float.h **** /** initialises a rotation matrix to identity */
 240:./math/pprz_algebra_float.h **** static inline void float_rmat_identity(struct FloatRMat *rm)
 241:./math/pprz_algebra_float.h **** {
 242:./math/pprz_algebra_float.h ****   FLOAT_MAT33_DIAG(*rm, 1., 1., 1.);
 243:./math/pprz_algebra_float.h **** }
 244:./math/pprz_algebra_float.h **** 
 245:./math/pprz_algebra_float.h **** /** Inverse/transpose of a rotation matrix.
 246:./math/pprz_algebra_float.h ****  * m_b2a = inv(_m_a2b) = transp(_m_a2b)
 247:./math/pprz_algebra_float.h ****  */
 248:./math/pprz_algebra_float.h **** extern void float_rmat_inv(struct FloatRMat *m_b2a, struct FloatRMat *m_a2b);
 249:./math/pprz_algebra_float.h **** 
 250:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 251:./math/pprz_algebra_float.h ****  * m_a2c = m_a2b comp m_b2c , aka  m_a2c = m_b2c * m_a2b
 252:./math/pprz_algebra_float.h ****  */
 253:./math/pprz_algebra_float.h **** extern void float_rmat_comp(struct FloatRMat *m_a2c, struct FloatRMat *m_a2b,
 254:./math/pprz_algebra_float.h ****                             struct FloatRMat *m_b2c);
 255:./math/pprz_algebra_float.h **** 
 256:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 257:./math/pprz_algebra_float.h ****  * m_a2b = m_a2c comp_inv m_b2c , aka  m_a2b = inv(_m_b2c) * m_a2c
 258:./math/pprz_algebra_float.h ****  */
 259:./math/pprz_algebra_float.h **** extern void float_rmat_comp_inv(struct FloatRMat *m_a2b, struct FloatRMat *m_a2c,
 260:./math/pprz_algebra_float.h ****                                 struct FloatRMat *m_b2c);
 261:./math/pprz_algebra_float.h **** 
 262:./math/pprz_algebra_float.h **** /// Norm of a rotation matrix.
 263:./math/pprz_algebra_float.h **** extern float float_rmat_norm(struct FloatRMat *rm);
 264:./math/pprz_algebra_float.h **** 
 265:./math/pprz_algebra_float.h **** /** rotate 3D vector by rotation matrix.
 266:./math/pprz_algebra_float.h ****  * vb = m_a2b * va
 267:./math/pprz_algebra_float.h ****  */
 268:./math/pprz_algebra_float.h **** extern void float_rmat_vmult(struct FloatVect3 *vb, struct FloatRMat *m_a2b,
 269:./math/pprz_algebra_float.h ****                              struct FloatVect3 *va);
 270:./math/pprz_algebra_float.h **** 
 271:./math/pprz_algebra_float.h **** /** rotate 3D vector by transposed rotation matrix.
 272:./math/pprz_algebra_float.h ****  * vb = m_b2a^T * va
 273:./math/pprz_algebra_float.h ****  */
 274:./math/pprz_algebra_float.h **** extern void float_rmat_transp_vmult(struct FloatVect3 *vb, struct FloatRMat *m_b2a,
 275:./math/pprz_algebra_float.h ****                                     struct FloatVect3 *va);
 276:./math/pprz_algebra_float.h **** 
 277:./math/pprz_algebra_float.h **** /** rotate anglular rates by rotation matrix.
 278:./math/pprz_algebra_float.h ****  * rb = m_a2b * ra
 279:./math/pprz_algebra_float.h ****  */
 280:./math/pprz_algebra_float.h **** extern void float_rmat_ratemult(struct FloatRates *rb, struct FloatRMat *m_a2b,
 281:./math/pprz_algebra_float.h ****                                 struct FloatRates *ra);
 282:./math/pprz_algebra_float.h **** 
 283:./math/pprz_algebra_float.h **** /** rotate anglular rates by transposed rotation matrix.
 284:./math/pprz_algebra_float.h ****  * rb = m_b2a^T * ra
 285:./math/pprz_algebra_float.h ****  */
 286:./math/pprz_algebra_float.h **** extern void float_rmat_transp_ratemult(struct FloatRates *rb, struct FloatRMat *m_b2a,
 287:./math/pprz_algebra_float.h ****                                        struct FloatRates *ra);
 288:./math/pprz_algebra_float.h **** 
 289:./math/pprz_algebra_float.h **** /** initialises a rotation matrix from unit vector axis and angle */
 290:./math/pprz_algebra_float.h **** extern void float_rmat_of_axis_angle(struct FloatRMat *rm, struct FloatVect3 *uv, float angle);
 291:./math/pprz_algebra_float.h **** 
 292:./math/pprz_algebra_float.h **** /** Rotation matrix from 321 Euler angles (float).
 293:./math/pprz_algebra_float.h ****  * The Euler angles are interpreted as zy'x'' (intrinsic) rotation.
 294:./math/pprz_algebra_float.h ****  * First rotate around z with psi, then around the new y' with theta,
 295:./math/pprz_algebra_float.h ****  * then around new x'' with phi.
 296:./math/pprz_algebra_float.h ****  * This is the same as a xyz (extrinsic) rotation,
 297:./math/pprz_algebra_float.h ****  * rotating around the fixed x, then y then z axis.
 298:./math/pprz_algebra_float.h ****  * - psi range: -pi < psi <= pi
 299:./math/pprz_algebra_float.h ****  * - theta range: -pi/2 <= theta <= pi/2
 300:./math/pprz_algebra_float.h ****  * - phi range: -pi < phi <= pi
 301:./math/pprz_algebra_float.h ****  * @param[out] rm pointer to rotation matrix
 302:./math/pprz_algebra_float.h ****  * @param[in]  e pointer to Euler angles
 303:./math/pprz_algebra_float.h ****  */
 304:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_321(struct FloatRMat *rm, struct FloatEulers *e);
 305:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_312(struct FloatRMat *rm, struct FloatEulers *e);
 306:./math/pprz_algebra_float.h **** #define float_rmat_of_eulers float_rmat_of_eulers_321
 307:./math/pprz_algebra_float.h **** 
 308:./math/pprz_algebra_float.h **** extern void float_rmat_of_quat(struct FloatRMat *rm, struct FloatQuat *q);
 309:./math/pprz_algebra_float.h **** /** in place first order integration of a rotation matrix */
 310:./math/pprz_algebra_float.h **** extern void float_rmat_integrate_fi(struct FloatRMat *rm, struct FloatRates *omega, float dt);
 311:./math/pprz_algebra_float.h **** extern float float_rmat_reorthogonalize(struct FloatRMat *rm);
 312:./math/pprz_algebra_float.h **** 
 313:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 314:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INV(_m_b2a, _m_a2b) float_rmat_inv(&(_m_b2a), &(_m_a2b))
 315:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_NORM(_m) float_rmat_norm(&(_m))
 316:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP(_m_a2c, _m_a2b, _m_b2c) float_rmat_comp(&(_m_a2c), &(_m_a2b), &(_m_b2c))
 317:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP_INV(_m_a2b, _m_a2c, _m_b2c) float_rmat_comp_inv(&(_m_a2b), &(_m_a2c), &(_m_
 318:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_VMULT(_vb, _m_a2b, _va) float_rmat_vmult(&(_vb), &(_m_a2b), &(_va))
 319:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_VMULT(_vb, _m_b2a, _va) float_rmat_transp_vmult(&(_vb), &(_m_b2a), &(_va)
 320:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_RATEMULT(_rb, _m_a2b, _ra) float_rmat_ratemult(&(_rb), &(_m_a2b), &(_ra))
 321:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_RATEMULT(_rb, _m_b2a, _ra) float_rmat_ratemult(&(_rb), &(_m_b2a), &(_ra))
 322:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_AXIS_ANGLE(_rm, _uv, _an) float_rmat_of_axis_angle(&(_rm), &(_uv), _an)
 323:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS(_rm, _e)     float_rmat_of_eulers_321(&(_rm), &(_e))
 324:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_321(_rm, _e) float_rmat_of_eulers_321(&(_rm), &(_e))
 325:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_312(_rm, _e) float_rmat_of_eulers_312(&(_rm), &(_e))
 326:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_QUAT(_rm, _q)       float_rmat_of_quat(&(_rm), &(_q))
 327:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INTEGRATE_FI(_rm, _omega, _dt) float_rmat_integrate_fi(&(_rm), &(_omega), &(_dt)
 328:./math/pprz_algebra_float.h **** 
 329:./math/pprz_algebra_float.h **** 
 330:./math/pprz_algebra_float.h **** 
 331:./math/pprz_algebra_float.h **** //
 332:./math/pprz_algebra_float.h **** //
 333:./math/pprz_algebra_float.h **** // Quaternion algebras
 334:./math/pprz_algebra_float.h **** //
 335:./math/pprz_algebra_float.h **** //
 336:./math/pprz_algebra_float.h **** 
 337:./math/pprz_algebra_float.h **** /** initialises a quaternion to identity */
 338:./math/pprz_algebra_float.h **** static inline void float_quat_identity(struct FloatQuat *q)
 339:./math/pprz_algebra_float.h **** {
 340:./math/pprz_algebra_float.h ****   q->qi = 1.0;
 341:./math/pprz_algebra_float.h ****   q->qx = 0;
 342:./math/pprz_algebra_float.h ****   q->qy = 0;
 343:./math/pprz_algebra_float.h ****   q->qz = 0;
 344:./math/pprz_algebra_float.h **** }
 345:./math/pprz_algebra_float.h **** 
 346:./math/pprz_algebra_float.h **** #define FLOAT_QUAT_NORM2(_q) (SQUARE((_q).qi) + SQUARE((_q).qx) + SQUARE((_q).qy) + SQUARE((_q).qz)
 347:./math/pprz_algebra_float.h **** 
 348:./math/pprz_algebra_float.h **** static inline float float_quat_norm(struct FloatQuat *q)
 349:./math/pprz_algebra_float.h **** {
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
 351:./math/pprz_algebra_float.h **** }
 352:./math/pprz_algebra_float.h **** 
 353:./math/pprz_algebra_float.h **** static inline void float_quat_normalize(struct FloatQuat *q)
 354:./math/pprz_algebra_float.h **** {
  59              		.loc 2 354 0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              	.LVL0:
  64              	.LBB4:
  65              	.LBB5:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  66              		.loc 2 350 0
  67 0000 D0ED017A 		flds	s15, [r0, #4]
  68 0004 90ED006A 		flds	s12, [r0]
  69 0008 D0ED026A 		flds	s13, [r0, #8]
  70 000c 90ED037A 		flds	s14, [r0, #12]
  71 0010 67EEA77A 		fmuls	s15, s15, s15
  72              	.LBE5:
  73              	.LBE4:
  74              		.loc 2 354 0
  75 0014 10B5     		push	{r4, lr}
  76              		.cfi_def_cfa_offset 8
  77              		.cfi_offset 4, -8
  78              		.cfi_offset 14, -4
  79              	.LBB9:
  80              	.LBB6:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  81              		.loc 2 350 0
  82 0016 E6EE067A 		vfma.f32	s15, s12, s12
  83              	.LBE6:
  84              	.LBE9:
  85              		.loc 2 354 0
  86 001a 0446     		mov	r4, r0
  87              	.LBB10:
  88              	.LBB7:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  89              		.loc 2 350 0
  90 001c E6EEA67A 		vfma.f32	s15, s13, s13
  91 0020 E7EE077A 		vfma.f32	s15, s14, s14
  92 0024 17EE900A 		fmrs	r0, s15
  93              	.LVL1:
  94 0028 FFF7FEFF 		bl	sqrtf
  95              	.LVL2:
  96              	.LBE7:
  97              	.LBE10:
 355:./math/pprz_algebra_float.h ****   float qnorm = float_quat_norm(q);
 356:./math/pprz_algebra_float.h ****   if (qnorm > FLT_MIN) {
  98              		.loc 2 356 0
  99 002c 9FED107A 		flds	s14, .L9
 100              	.LBB11:
 101              	.LBB8:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
 102              		.loc 2 350 0
 103 0030 07EE900A 		fmsr	s15, r0
 104              	.LBE8:
 105              	.LBE11:
 106              		.loc 2 356 0
 107 0034 F4EEC77A 		fcmpes	s15, s14
 108 0038 F1EE10FA 		fmstat
 109 003c 17DD     		ble	.L4
 357:./math/pprz_algebra_float.h ****     q->qi = q->qi / qnorm;
 110              		.loc 2 357 0
 111 003e 94ED007A 		flds	s14, [r4]
 112 0042 87EE277A 		fdivs	s14, s14, s15
 113 0046 84ED007A 		fsts	s14, [r4]
 358:./math/pprz_algebra_float.h ****     q->qx = q->qx / qnorm;
 114              		.loc 2 358 0
 115 004a 94ED017A 		flds	s14, [r4, #4]
 116 004e 87EE277A 		fdivs	s14, s14, s15
 117 0052 84ED017A 		fsts	s14, [r4, #4]
 359:./math/pprz_algebra_float.h ****     q->qy = q->qy / qnorm;
 118              		.loc 2 359 0
 119 0056 94ED027A 		flds	s14, [r4, #8]
 120 005a 87EE277A 		fdivs	s14, s14, s15
 121 005e 84ED027A 		fsts	s14, [r4, #8]
 360:./math/pprz_algebra_float.h ****     q->qz = q->qz / qnorm;
 122              		.loc 2 360 0
 123 0062 94ED037A 		flds	s14, [r4, #12]
 124 0066 C7EE277A 		fdivs	s15, s14, s15
 125 006a C4ED037A 		fsts	s15, [r4, #12]
 126              	.L4:
 127 006e 10BD     		pop	{r4, pc}
 128              	.LVL3:
 129              	.L10:
 130              		.align	2
 131              	.L9:
 132 0070 00008000 		.word	8388608
 133              		.cfi_endproc
 134              	.LFE18:
 136              		.section	.text.orientationGetEulers_f.constprop.0,"ax",%progbits
 137              		.align	1
 138              		.thumb
 139              		.thumb_func
 141              	orientationGetEulers_f.constprop.0:
 142              	.LFB185:
 143              		.file 3 "./math/pprz_orientation_conversion.h"
   1:./math/pprz_orientation_conversion.h **** /*
   2:./math/pprz_orientation_conversion.h ****  * Copyright (C) 2011-2012 The Paparazzi Team
   3:./math/pprz_orientation_conversion.h ****  *
   4:./math/pprz_orientation_conversion.h ****  * This file is part of paparazzi.
   5:./math/pprz_orientation_conversion.h ****  *
   6:./math/pprz_orientation_conversion.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_orientation_conversion.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_orientation_conversion.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_orientation_conversion.h ****  * any later version.
  10:./math/pprz_orientation_conversion.h ****  *
  11:./math/pprz_orientation_conversion.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_orientation_conversion.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_orientation_conversion.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_orientation_conversion.h ****  * GNU General Public License for more details.
  15:./math/pprz_orientation_conversion.h ****  *
  16:./math/pprz_orientation_conversion.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_orientation_conversion.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_orientation_conversion.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_orientation_conversion.h ****  */
  20:./math/pprz_orientation_conversion.h **** 
  21:./math/pprz_orientation_conversion.h **** /**
  22:./math/pprz_orientation_conversion.h ****  * @file math/pprz_orientation_conversion.h
  23:./math/pprz_orientation_conversion.h ****  * Generic orientation representation and conversions.
  24:./math/pprz_orientation_conversion.h ****  *
  25:./math/pprz_orientation_conversion.h ****  * This file contains the functions to automatically convert between
  26:./math/pprz_orientation_conversion.h ****  * the different representations. They should normally not be used
  27:./math/pprz_orientation_conversion.h ****  * directly and instead the stateGet/Set interfaces used.
  28:./math/pprz_orientation_conversion.h ****  * Also see the @ref math_orientation_representation "Generic Orientation Representation" page.
  29:./math/pprz_orientation_conversion.h ****  *
  30:./math/pprz_orientation_conversion.h ****  * @author Felix Ruess <felix.ruess@gmail.com>
  31:./math/pprz_orientation_conversion.h ****  */
  32:./math/pprz_orientation_conversion.h **** 
  33:./math/pprz_orientation_conversion.h **** /**
  34:./math/pprz_orientation_conversion.h ****  * @addtogroup math
  35:./math/pprz_orientation_conversion.h ****  * @{
  36:./math/pprz_orientation_conversion.h ****  */
  37:./math/pprz_orientation_conversion.h **** 
  38:./math/pprz_orientation_conversion.h **** /**
  39:./math/pprz_orientation_conversion.h ****  * This generic orientation representation consists of a struct, containing the 6 orientation
  40:./math/pprz_orientation_conversion.h ****  * representations, and a status variable. The bits in the status variable indicate  which
  41:./math/pprz_orientation_conversion.h ****  * representations of the orientation are up-to-date.
  42:./math/pprz_orientation_conversion.h ****  *
  43:./math/pprz_orientation_conversion.h ****  * When a getter is used to get a certain representation, the status bit is checked to see if
  44:./math/pprz_orientation_conversion.h ****  * the current value is already available in the desired orientation representation.
  45:./math/pprz_orientation_conversion.h ****  * If the desired representation is not available, it will be calculated.
  46:./math/pprz_orientation_conversion.h ****  *
  47:./math/pprz_orientation_conversion.h ****  * When a setter is used to set a representation, all status bits are cleared, and only the
  48:./math/pprz_orientation_conversion.h ****  * status bit for the set representation is set to one.
  49:./math/pprz_orientation_conversion.h ****  */
  50:./math/pprz_orientation_conversion.h **** 
  51:./math/pprz_orientation_conversion.h **** /**
  52:./math/pprz_orientation_conversion.h ****  * @defgroup math_orientation_representation Generic Orientation Representations
  53:./math/pprz_orientation_conversion.h ****  * @{
  54:./math/pprz_orientation_conversion.h ****  */
  55:./math/pprz_orientation_conversion.h **** 
  56:./math/pprz_orientation_conversion.h **** #ifndef PPRZ_ORIENTATION_CONVERSION_H
  57:./math/pprz_orientation_conversion.h **** #define PPRZ_ORIENTATION_CONVERSION_H
  58:./math/pprz_orientation_conversion.h **** 
  59:./math/pprz_orientation_conversion.h **** #ifdef __cplusplus
  60:./math/pprz_orientation_conversion.h **** extern "C" {
  61:./math/pprz_orientation_conversion.h **** #endif
  62:./math/pprz_orientation_conversion.h **** 
  63:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_int.h"
  64:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_float.h"
  65:./math/pprz_orientation_conversion.h **** 
  66:./math/pprz_orientation_conversion.h **** #include "std.h"
  67:./math/pprz_orientation_conversion.h **** 
  68:./math/pprz_orientation_conversion.h **** 
  69:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_I  0  ///< Quaternion (BFP int)
  70:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_I 1  ///< zyx Euler (BFP int)
  71:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_I  2  ///< Rotation Matrix (BFP int)
  72:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_F  3  ///< Quaternion (float)
  73:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_F 4  ///< zyx Euler (float)
  74:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_F  5  ///< Rotation Matrix (float)
  75:./math/pprz_orientation_conversion.h **** 
  76:./math/pprz_orientation_conversion.h **** /*
  77:./math/pprz_orientation_conversion.h ****  * @brief Struct with euler/rmat/quaternion orientation representations in BFP int and float
  78:./math/pprz_orientation_conversion.h ****  */
  79:./math/pprz_orientation_conversion.h **** struct OrientationReps {
  80:./math/pprz_orientation_conversion.h ****   /**
  81:./math/pprz_orientation_conversion.h ****    * Holds the status bits for all orientation representations.
  82:./math/pprz_orientation_conversion.h ****    * When the corresponding bit is set, the representation
  83:./math/pprz_orientation_conversion.h ****    * is already computed.
  84:./math/pprz_orientation_conversion.h ****    */
  85:./math/pprz_orientation_conversion.h ****   uint8_t status;
  86:./math/pprz_orientation_conversion.h **** 
  87:./math/pprz_orientation_conversion.h ****   /**
  88:./math/pprz_orientation_conversion.h ****    * Orientation quaternion.
  89:./math/pprz_orientation_conversion.h ****    * Units: #INT32_QUAT_FRAC
  90:./math/pprz_orientation_conversion.h ****    */
  91:./math/pprz_orientation_conversion.h ****   struct Int32Quat quat_i;
  92:./math/pprz_orientation_conversion.h **** 
  93:./math/pprz_orientation_conversion.h ****   /**
  94:./math/pprz_orientation_conversion.h ****    * Orientation in zyx euler angles.
  95:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_ANGLE_FRAC
  96:./math/pprz_orientation_conversion.h ****    */
  97:./math/pprz_orientation_conversion.h ****   struct Int32Eulers eulers_i;
  98:./math/pprz_orientation_conversion.h **** 
  99:./math/pprz_orientation_conversion.h ****   /**
 100:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 101:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_TRIG_FRAC
 102:./math/pprz_orientation_conversion.h ****    */
 103:./math/pprz_orientation_conversion.h ****   struct Int32RMat rmat_i;
 104:./math/pprz_orientation_conversion.h **** 
 105:./math/pprz_orientation_conversion.h ****   /**
 106:./math/pprz_orientation_conversion.h ****    * Orientation as quaternion.
 107:./math/pprz_orientation_conversion.h ****    * Units: unit length quaternion
 108:./math/pprz_orientation_conversion.h ****    */
 109:./math/pprz_orientation_conversion.h ****   struct FloatQuat quat_f;
 110:./math/pprz_orientation_conversion.h **** 
 111:./math/pprz_orientation_conversion.h ****   /**
 112:./math/pprz_orientation_conversion.h ****    * Orienation in zyx euler angles.
 113:./math/pprz_orientation_conversion.h ****    * Units: rad
 114:./math/pprz_orientation_conversion.h ****    */
 115:./math/pprz_orientation_conversion.h ****   struct FloatEulers eulers_f;
 116:./math/pprz_orientation_conversion.h **** 
 117:./math/pprz_orientation_conversion.h ****   /**
 118:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 119:./math/pprz_orientation_conversion.h ****    * Units: rad
 120:./math/pprz_orientation_conversion.h ****    */
 121:./math/pprz_orientation_conversion.h ****   struct FloatRMat   rmat_f;
 122:./math/pprz_orientation_conversion.h **** };
 123:./math/pprz_orientation_conversion.h **** 
 124:./math/pprz_orientation_conversion.h **** /************* declaration of transformation functions ************/
 125:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_i(struct OrientationReps *orientation);
 126:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_i(struct OrientationReps *orientation);
 127:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_i(struct OrientationReps *orientation);
 128:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_f(struct OrientationReps *orientation);
 129:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_f(struct OrientationReps *orientation);
 130:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_f(struct OrientationReps *orientation);
 131:./math/pprz_orientation_conversion.h **** 
 132:./math/pprz_orientation_conversion.h **** 
 133:./math/pprz_orientation_conversion.h **** /*********************** validity test functions ******************/
 134:./math/pprz_orientation_conversion.h **** /// Test if orientations are valid.
 135:./math/pprz_orientation_conversion.h **** static inline bool_t orienationCheckValid(struct OrientationReps *orientation)
 136:./math/pprz_orientation_conversion.h **** {
 137:./math/pprz_orientation_conversion.h ****   return (orientation->status);
 138:./math/pprz_orientation_conversion.h **** }
 139:./math/pprz_orientation_conversion.h **** 
 140:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (int).
 141:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_i(struct OrientationReps *orientation, struct Int32Quat *quat
 142:./math/pprz_orientation_conversion.h **** {
 143:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_i, *quat);
 144:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 145:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_I);
 146:./math/pprz_orientation_conversion.h **** }
 147:./math/pprz_orientation_conversion.h **** 
 148:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (int).
 149:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_i(struct OrientationReps *orientation, struct Int32RMat *rmat
 150:./math/pprz_orientation_conversion.h **** {
 151:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_i, *rmat);
 152:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 153:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_I);
 154:./math/pprz_orientation_conversion.h **** }
 155:./math/pprz_orientation_conversion.h **** 
 156:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (int).
 157:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_i(struct OrientationReps *orientation, struct Int32Eulers *
 158:./math/pprz_orientation_conversion.h **** {
 159:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_i, *eulers);
 160:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 161:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_I);
 162:./math/pprz_orientation_conversion.h **** }
 163:./math/pprz_orientation_conversion.h **** 
 164:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (float).
 165:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_f(struct OrientationReps *orientation, struct FloatQuat *quat
 166:./math/pprz_orientation_conversion.h **** {
 167:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_f, *quat);
 168:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 169:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_F);
 170:./math/pprz_orientation_conversion.h **** }
 171:./math/pprz_orientation_conversion.h **** 
 172:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (float).
 173:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_f(struct OrientationReps *orientation, struct FloatRMat *rmat
 174:./math/pprz_orientation_conversion.h **** {
 175:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_f, *rmat);
 176:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 177:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_F);
 178:./math/pprz_orientation_conversion.h **** }
 179:./math/pprz_orientation_conversion.h **** 
 180:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (float).
 181:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_f(struct OrientationReps *orientation, struct FloatEulers *
 182:./math/pprz_orientation_conversion.h **** {
 183:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_f, *eulers);
 184:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 185:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_F);
 186:./math/pprz_orientation_conversion.h **** }
 187:./math/pprz_orientation_conversion.h **** 
 188:./math/pprz_orientation_conversion.h **** 
 189:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (int).
 190:./math/pprz_orientation_conversion.h **** static inline struct Int32Quat *orientationGetQuat_i(struct OrientationReps *orientation)
 191:./math/pprz_orientation_conversion.h **** {
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 194:./math/pprz_orientation_conversion.h ****   }
 195:./math/pprz_orientation_conversion.h ****   return &orientation->quat_i;
 196:./math/pprz_orientation_conversion.h **** }
 197:./math/pprz_orientation_conversion.h **** 
 198:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude rotation matrix (int).
 199:./math/pprz_orientation_conversion.h **** static inline struct Int32RMat *orientationGetRMat_i(struct OrientationReps *orientation)
 200:./math/pprz_orientation_conversion.h **** {
 201:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_RMAT_I)) {
 202:./math/pprz_orientation_conversion.h ****     orientationCalcRMat_i(orientation);
 203:./math/pprz_orientation_conversion.h ****   }
 204:./math/pprz_orientation_conversion.h ****   return &orientation->rmat_i;
 205:./math/pprz_orientation_conversion.h **** }
 206:./math/pprz_orientation_conversion.h **** 
 207:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude euler angles (int).
 208:./math/pprz_orientation_conversion.h **** static inline struct Int32Eulers *orientationGetEulers_i(struct OrientationReps *orientation)
 209:./math/pprz_orientation_conversion.h **** {
 210:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_I)) {
 211:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_i(orientation);
 212:./math/pprz_orientation_conversion.h ****   }
 213:./math/pprz_orientation_conversion.h ****   return &orientation->eulers_i;
 214:./math/pprz_orientation_conversion.h **** }
 215:./math/pprz_orientation_conversion.h **** 
 216:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (float).
 217:./math/pprz_orientation_conversion.h **** static inline struct FloatQuat *orientationGetQuat_f(struct OrientationReps *orientation)
 218:./math/pprz_orientation_conversion.h **** {
 219:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_F)) {
 220:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_f(orientation);
 221:./math/pprz_orientation_conversion.h ****   }
 222:./math/pprz_orientation_conversion.h ****   return &orientation->quat_f;
 223:./math/pprz_orientation_conversion.h **** }
 224:./math/pprz_orientation_conversion.h **** 
 225:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude rotation matrix (float).
 226:./math/pprz_orientation_conversion.h **** static inline struct FloatRMat *orientationGetRMat_f(struct OrientationReps *orientation)
 227:./math/pprz_orientation_conversion.h **** {
 228:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_RMAT_F)) {
 229:./math/pprz_orientation_conversion.h ****     orientationCalcRMat_f(orientation);
 230:./math/pprz_orientation_conversion.h ****   }
 231:./math/pprz_orientation_conversion.h ****   return &orientation->rmat_f;
 232:./math/pprz_orientation_conversion.h **** }
 233:./math/pprz_orientation_conversion.h **** 
 234:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude euler angles (float).
 235:./math/pprz_orientation_conversion.h **** static inline struct FloatEulers *orientationGetEulers_f(struct OrientationReps *orientation)
 144              		.loc 3 235 0
 145              		.cfi_startproc
 146              		@ args = 0, pretend = 0, frame = 0
 147              		@ frame_needed = 0, uses_anonymous_args = 0
 148              	.LVL4:
 149 0000 08B5     		push	{r3, lr}
 150              		.cfi_def_cfa_offset 8
 151              		.cfi_offset 3, -8
 152              		.cfi_offset 14, -4
 236:./math/pprz_orientation_conversion.h **** {
 237:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_F)) {
 153              		.loc 3 237 0
 154 0002 0548     		ldr	r0, .L13
 155 0004 90F8A431 		ldrb	r3, [r0, #420]	@ zero_extendqisi2
 156 0008 DB06     		lsls	r3, r3, #27
 157 000a 03D4     		bmi	.L12
 238:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_f(orientation);
 158              		.loc 3 238 0
 159 000c 00F5D270 		add	r0, r0, #420
 160 0010 FFF7FEFF 		bl	orientationCalcEulers_f
 161              	.LVL5:
 162              	.L12:
 239:./math/pprz_orientation_conversion.h ****   }
 240:./math/pprz_orientation_conversion.h ****   return &orientation->eulers_f;
 241:./math/pprz_orientation_conversion.h **** }
 163              		.loc 3 241 0
 164 0014 0148     		ldr	r0, .L13+4
 165 0016 08BD     		pop	{r3, pc}
 166              	.L14:
 167              		.align	2
 168              	.L13:
 169 0018 00000000 		.word	state
 170 001c F8010000 		.word	state+504
 171              		.cfi_endproc
 172              	.LFE185:
 174              		.section	.text.stabilization_attitude_reset_care_free_heading,"ax",%progbits
 175              		.align	1
 176              		.global	stabilization_attitude_reset_care_free_heading
 177              		.thumb
 178              		.thumb_func
 180              	stabilization_attitude_reset_care_free_heading:
 181              	.LFB175:
 182              		.file 4 "firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c"
   1:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /*
   2:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * Copyright (C) 2012-2013 Felix Ruess <felix.ruess@gmail.com>
   3:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  *
   4:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * This file is part of paparazzi.
   5:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  *
   6:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * it under the terms of the GNU General Public License as published by
   8:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * any later version.
  10:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  *
  11:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * GNU General Public License for more details.
  15:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  *
  16:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * You should have received a copy of the GNU General Public License
  17:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * Boston, MA 02111-1307, USA.
  20:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
  21:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  22:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /** @file stabilization_attitude_rc_setpoint.c
  23:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  *  Read an attitude setpoint from the RC.
  24:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
  25:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  26:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.h"
  27:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "generated/airframe.h"
  28:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  29:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "subsystems/radio_control.h"
  30:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "state.h"
  31:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "firmwares/rotorcraft/guidance/guidance_h.h"
  32:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "firmwares/rotorcraft/stabilization/stabilization_attitude.h"
  33:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "firmwares/rotorcraft/autopilot_rc_helpers.h"
  34:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #include "mcu_periph/sys_time.h"
  35:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  36:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #ifndef STABILIZATION_ATTITUDE_DEADBAND_A
  37:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #define STABILIZATION_ATTITUDE_DEADBAND_A 0
  38:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
  39:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  40:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #ifndef STABILIZATION_ATTITUDE_DEADBAND_E
  41:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #define STABILIZATION_ATTITUDE_DEADBAND_E 0
  42:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
  43:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  44:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #define YAW_DEADBAND_EXCEEDED()                                         \
  45:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   (radio_control.values[RADIO_YAW] >  STABILIZATION_ATTITUDE_DEADBAND_R || \
  46:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****    radio_control.values[RADIO_YAW] < -STABILIZATION_ATTITUDE_DEADBAND_R)
  47:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  48:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** float care_free_heading = 0;
  49:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  50:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  51:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static int32_t get_rc_roll(void)
  52:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
  53:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const int32_t max_rc_phi = (int32_t) ANGLE_BFP_OF_REAL(STABILIZATION_ATTITUDE_SP_MAX_PHI);
  54:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
  55:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if STABILIZATION_ATTITUDE_DEADBAND_A
  56:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(roll, STABILIZATION_ATTITUDE_DEADBAND_A);
  57:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * max_rc_phi / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_A);
  58:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
  59:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * max_rc_phi / MAX_PPRZ;
  60:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
  61:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
  62:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  63:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static int32_t get_rc_pitch(void)
  64:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
  65:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const int32_t max_rc_theta = (int32_t) ANGLE_BFP_OF_REAL(STABILIZATION_ATTITUDE_SP_MAX_THETA);
  66:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t pitch = radio_control.values[RADIO_PITCH];
  67:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if STABILIZATION_ATTITUDE_DEADBAND_E
  68:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(pitch, STABILIZATION_ATTITUDE_DEADBAND_E);
  69:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * max_rc_theta / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_E);
  70:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
  71:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * max_rc_theta / MAX_PPRZ;
  72:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
  73:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
  74:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  75:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static int32_t get_rc_yaw(void)
  76:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
  77:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const int32_t max_rc_r = (int32_t) ANGLE_BFP_OF_REAL(STABILIZATION_ATTITUDE_SP_MAX_R);
  78:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t yaw = radio_control.values[RADIO_YAW];
  79:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
  80:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return yaw * max_rc_r / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_R);
  81:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
  82:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  83:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static float get_rc_roll_f(void)
  84:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
  85:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
  86:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if STABILIZATION_ATTITUDE_DEADBAND_A
  87:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(roll, STABILIZATION_ATTITUDE_DEADBAND_A);
  88:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_A);
  89:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
  90:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / MAX_PPRZ;
  91:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
  92:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
  93:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
  94:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static float get_rc_pitch_f(void)
  95:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
  96:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t pitch = radio_control.values[RADIO_PITCH];
  97:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if STABILIZATION_ATTITUDE_DEADBAND_E
  98:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(pitch, STABILIZATION_ATTITUDE_DEADBAND_E);
  99:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_
 100:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 102:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 103:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 104:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 105:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** static inline float get_rc_yaw_f(void)
 106:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 107:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t yaw = radio_control.values[RADIO_YAW];
 108:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
 109:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return yaw * STABILIZATION_ATTITUDE_SP_MAX_R / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_R);
 110:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 111:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 112:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /// reset the heading for care-free mode to current heading
 113:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_reset_care_free_heading(void)
 114:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 183              		.loc 4 114 0
 184              		.cfi_startproc
 185              		@ args = 0, pretend = 0, frame = 0
 186              		@ frame_needed = 0, uses_anonymous_args = 0
 187 0000 08B5     		push	{r3, lr}
 188              		.cfi_def_cfa_offset 8
 189              		.cfi_offset 3, -8
 190              		.cfi_offset 14, -4
 191              	.LBB14:
 192              	.LBB15:
 193              		.file 5 "./state.h"
   1:./state.h     **** /*
   2:./state.h     ****  * Copyright (C) 2011-2012 Felix Ruess <felix.ruess@gmail.com>
   3:./state.h     ****  *
   4:./state.h     ****  * This file is part of paparazzi.
   5:./state.h     ****  *
   6:./state.h     ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./state.h     ****  * it under the terms of the GNU General Public License as published by
   8:./state.h     ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./state.h     ****  * any later version.
  10:./state.h     ****  *
  11:./state.h     ****  * paparazzi is distributed in the hope that it will be useful,
  12:./state.h     ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./state.h     ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./state.h     ****  * GNU General Public License for more details.
  15:./state.h     ****  *
  16:./state.h     ****  * You should have received a copy of the GNU General Public License
  17:./state.h     ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./state.h     ****  * <http://www.gnu.org/licenses/>.
  19:./state.h     ****  */
  20:./state.h     **** 
  21:./state.h     **** /**
  22:./state.h     ****  * @file state.h
  23:./state.h     ****  *
  24:./state.h     ****  * API to get/set the generic vehicle states.
  25:./state.h     ****  *
  26:./state.h     ****  * Also see the @ref state_interface "State Interface" page.
  27:./state.h     ****  *
  28:./state.h     ****  * @author Felix Ruess <felix.ruess@gmail.com>
  29:./state.h     ****  */
  30:./state.h     **** 
  31:./state.h     **** #ifndef STATE_H
  32:./state.h     **** #define STATE_H
  33:./state.h     **** 
  34:./state.h     **** #include "math/pprz_algebra_int.h"
  35:./state.h     **** #include "math/pprz_algebra_float.h"
  36:./state.h     **** #include "math/pprz_geodetic_int.h"
  37:./state.h     **** #include "math/pprz_geodetic_float.h"
  38:./state.h     **** #include "math/pprz_orientation_conversion.h"
  39:./state.h     **** 
  40:./state.h     **** #include "std.h"
  41:./state.h     **** #include <string.h>
  42:./state.h     **** 
  43:./state.h     **** /**
  44:./state.h     ****  * This general state interface holds all the most important vehicle states like
  45:./state.h     ****  * position, velocity, attitude, etc. It handles coordinate system and
  46:./state.h     ****  * fixed-/floating-point conversion on the fly when needed.
  47:./state.h     ****  *
  48:./state.h     ****  * You can set e.g. the position in any coordinate system you wish:
  49:./state.h     ****  * stateSetPositionNed_i() to set the position in fixed-point NED coordinates.
  50:./state.h     ****  * If you need to read the position somewhere else in a different representation,
  51:./state.h     ****  * call: stateGetPositionLla_f() and only then the LLA float position representation
  52:./state.h     ****  * is calculated on the fly and returned. It's also only calculated once,
  53:./state.h     ****  * until a new position is set which invalidates all the other representations again.
  54:./state.h     ****  */
  55:./state.h     **** 
  56:./state.h     **** /**
  57:./state.h     ****  * @defgroup state_interface State interface
  58:./state.h     ****  * @{
  59:./state.h     ****  */
  60:./state.h     **** 
  61:./state.h     **** /**
  62:./state.h     ****  * @defgroup state_position Position representations
  63:./state.h     ****  * @{
  64:./state.h     ****  */
  65:./state.h     **** #define POS_ECEF_I 0
  66:./state.h     **** #define POS_NED_I  1
  67:./state.h     **** #define POS_ENU_I  2
  68:./state.h     **** #define POS_LLA_I  3
  69:./state.h     **** #define POS_UTM_I  4
  70:./state.h     **** #define POS_ECEF_F 5
  71:./state.h     **** #define POS_NED_F  6
  72:./state.h     **** #define POS_ENU_F  7
  73:./state.h     **** #define POS_LLA_F  8
  74:./state.h     **** #define POS_UTM_F  9
  75:./state.h     **** #define POS_LOCAL_COORD ((1<<POS_NED_I)|(1<<POS_NED_F)|(1<<POS_ENU_I)|(1<<POS_ENU_F))
  76:./state.h     **** #define POS_GLOBAL_COORD ((1<<POS_ECEF_I)|(1<<POS_ECEF_F)|(1<<POS_LLA_I)|(1<<POS_LLA_F)|(1<<POS_UTM
  77:./state.h     **** /**@}*/
  78:./state.h     **** 
  79:./state.h     **** /**
  80:./state.h     ****  * @defgroup state_velocity Speed representations
  81:./state.h     ****  * @{
  82:./state.h     ****  */
  83:./state.h     **** #define SPEED_ECEF_I  0
  84:./state.h     **** #define SPEED_NED_I   1
  85:./state.h     **** #define SPEED_ENU_I   2
  86:./state.h     **** #define SPEED_HNORM_I 3
  87:./state.h     **** #define SPEED_HDIR_I  4
  88:./state.h     **** #define SPEED_ECEF_F  5
  89:./state.h     **** #define SPEED_NED_F   6
  90:./state.h     **** #define SPEED_ENU_F   7
  91:./state.h     **** #define SPEED_HNORM_F 8
  92:./state.h     **** #define SPEED_HDIR_F  9
  93:./state.h     **** #define SPEED_LOCAL_COORD ((1<<SPEED_NED_I)|(1<<SPEED_ENU_I)|(1<<SPEED_NED_F)|(1<<SPEED_ENU_F))
  94:./state.h     **** /**@}*/
  95:./state.h     **** 
  96:./state.h     **** /**
  97:./state.h     ****  * @defgroup state_acceleration Acceleration representations
  98:./state.h     ****  * @{
  99:./state.h     ****  */
 100:./state.h     **** #define ACCEL_ECEF_I 0
 101:./state.h     **** #define ACCEL_NED_I  1
 102:./state.h     **** #define ACCEL_ECEF_F 2
 103:./state.h     **** #define ACCEL_NED_F  3
 104:./state.h     **** /**@}*/
 105:./state.h     **** 
 106:./state.h     **** /**
 107:./state.h     ****  * @defgroup state_rate Angular rate representations
 108:./state.h     ****  * @{
 109:./state.h     ****  */
 110:./state.h     **** #define RATE_I 0
 111:./state.h     **** #define RATE_F 1
 112:./state.h     **** /**@}*/
 113:./state.h     **** 
 114:./state.h     **** /**
 115:./state.h     ****  * @defgroup state_wind_airspeed Wind- and airspeed representations
 116:./state.h     ****  * @{
 117:./state.h     ****  */
 118:./state.h     **** #define WINDSPEED_I 0
 119:./state.h     **** #define AIRSPEED_I  1
 120:./state.h     **** #define WINDSPEED_F 2
 121:./state.h     **** #define AIRSPEED_F  3
 122:./state.h     **** #define AOA_F       4
 123:./state.h     **** #define SIDESLIP_F  5
 124:./state.h     **** /**@}*/
 125:./state.h     **** 
 126:./state.h     **** 
 127:./state.h     **** /**
 128:./state.h     ****  * Structure holding vehicle state data.
 129:./state.h     ****  */
 130:./state.h     **** struct State {
 131:./state.h     **** 
 132:./state.h     ****   /** @addtogroup state_position
 133:./state.h     ****    *  @{ */
 134:./state.h     **** 
 135:./state.h     ****   /**
 136:./state.h     ****    * Holds the status bits for all position representations.
 137:./state.h     ****    * When the corresponding bit is set the representation
 138:./state.h     ****    * is already computed.
 139:./state.h     ****    */
 140:./state.h     ****   uint16_t pos_status;
 141:./state.h     **** 
 142:./state.h     ****   /**
 143:./state.h     ****    * Position in EarthCenteredEarthFixed coordinates.
 144:./state.h     ****    * Units: centimeters
 145:./state.h     ****    */
 146:./state.h     ****   struct EcefCoor_i ecef_pos_i;
 147:./state.h     **** 
 148:./state.h     ****   /**
 149:./state.h     ****    * Position in Latitude, Longitude and Altitude.
 150:./state.h     ****    * Units lat,lon: degrees*1e7
 151:./state.h     ****    * Units alt: milimeters above reference ellipsoid
 152:./state.h     ****    */
 153:./state.h     ****   struct LlaCoor_i lla_pos_i;
 154:./state.h     **** 
 155:./state.h     ****   /**
 156:./state.h     ****    * Definition of the local (flat earth) coordinate system.
 157:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 158:./state.h     ****    * in ECEF (EarthCenteredEarthFixed) and LLA (LatitudeLongitudeAlt)
 159:./state.h     ****    * coordinates and the roation matrix from ECEF to local frame.
 160:./state.h     ****    * (int version)
 161:./state.h     ****    */
 162:./state.h     ****   struct LtpDef_i ned_origin_i;
 163:./state.h     **** 
 164:./state.h     ****   /**
 165:./state.h     ****    * true if local int coordinate frame is initialsed
 166:./state.h     ****    */
 167:./state.h     ****   bool_t ned_initialized_i;
 168:./state.h     **** 
 169:./state.h     ****   /**
 170:./state.h     ****    * Position in North East Down coordinates.
 171:./state.h     ****    * with respect to ned_origin_i (flat earth)
 172:./state.h     ****    * Units: m in BFP with INT32_POS_FRAC
 173:./state.h     ****    */
 174:./state.h     ****   struct NedCoor_i ned_pos_i;
 175:./state.h     **** 
 176:./state.h     ****   /**
 177:./state.h     ****    * Position in East North Up coordinates.
 178:./state.h     ****    * with respect to ned_origin_i (flat earth)
 179:./state.h     ****    * Units: m in BFP with INT32_POS_FRAC
 180:./state.h     ****    */
 181:./state.h     ****   struct EnuCoor_i enu_pos_i;
 182:./state.h     **** 
 183:./state.h     ****   /**
 184:./state.h     ****    * Position in UTM coordinates.
 185:./state.h     ****    * Units x,y: meters.
 186:./state.h     ****    * Units z: meters above MSL
 187:./state.h     ****    */
 188:./state.h     ****   struct UtmCoor_f utm_pos_f;
 189:./state.h     **** 
 190:./state.h     ****   /**
 191:./state.h     ****    * Altitude above ground level.
 192:./state.h     ****    * Unit: meters
 193:./state.h     ****    */
 194:./state.h     ****   float alt_agl_f;
 195:./state.h     **** 
 196:./state.h     ****   /**
 197:./state.h     ****    * Position in Latitude, Longitude and Altitude.
 198:./state.h     ****    * Units lat,lon: radians
 199:./state.h     ****    * Units alt: meters above reference ellipsoid
 200:./state.h     ****    */
 201:./state.h     ****   struct LlaCoor_f lla_pos_f;
 202:./state.h     **** 
 203:./state.h     ****   /**
 204:./state.h     ****    * Position in EarthCenteredEarthFixed coordinates.
 205:./state.h     ****    * Units: meters
 206:./state.h     ****    */
 207:./state.h     ****   struct EcefCoor_f ecef_pos_f;
 208:./state.h     **** 
 209:./state.h     ****   /**
 210:./state.h     ****    * Definition of the local (flat earth) coordinate system.
 211:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 212:./state.h     ****    * in ECEF (EarthCenteredEarthFixed) and LLA (LatitudeLongitudeAlt)
 213:./state.h     ****    * coordinates and the roation matrix from ECEF to local frame.
 214:./state.h     ****    * (float version)
 215:./state.h     ****    */
 216:./state.h     ****   struct LtpDef_f ned_origin_f;
 217:./state.h     **** 
 218:./state.h     ****   /// True if local float coordinate frame is initialsed
 219:./state.h     ****   bool_t ned_initialized_f;
 220:./state.h     **** 
 221:./state.h     ****   /**
 222:./state.h     ****    * Definition of the origin of Utm coordinate system.
 223:./state.h     ****    * Defines the origin of the local NorthEastDown coordinate system
 224:./state.h     ****    * in UTM coordinates, used as a reference when ned_origin is not
 225:./state.h     ****    * initialized.
 226:./state.h     ****    * (float version)
 227:./state.h     ****    */
 228:./state.h     ****   struct UtmCoor_f utm_origin_f;
 229:./state.h     **** 
 230:./state.h     ****   /// True if utm origin (float) coordinate frame is initialsed
 231:./state.h     ****   bool_t utm_initialized_f;
 232:./state.h     **** 
 233:./state.h     ****   /**
 234:./state.h     ****    * Position in North East Down coordinates.
 235:./state.h     ****    * with respect to ned_origin_i (flat earth)
 236:./state.h     ****    * Units: meters
 237:./state.h     ****    */
 238:./state.h     ****   struct NedCoor_f ned_pos_f;
 239:./state.h     **** 
 240:./state.h     ****   /**
 241:./state.h     ****    * Position in East North Up coordinates.
 242:./state.h     ****    * with respect to ned_origin_i (flat earth)
 243:./state.h     ****    * Units: meters
 244:./state.h     ****    */
 245:./state.h     ****   struct EnuCoor_f enu_pos_f;
 246:./state.h     ****   /** @}*/
 247:./state.h     **** 
 248:./state.h     **** 
 249:./state.h     ****   /** @addtogroup state_velocity
 250:./state.h     ****    *  @{ */
 251:./state.h     ****   /**
 252:./state.h     ****    * Holds the status bits for all ground speed representations.
 253:./state.h     ****    * When the corresponding bit is one the representation
 254:./state.h     ****    * is already computed.
 255:./state.h     ****    */
 256:./state.h     ****   uint16_t speed_status;
 257:./state.h     **** 
 258:./state.h     ****   /**
 259:./state.h     ****    * Velocity in EarthCenteredEarthFixed coordinates.
 260:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 261:./state.h     ****    */
 262:./state.h     ****   struct EcefCoor_i ecef_speed_i;
 263:./state.h     **** 
 264:./state.h     ****   /**
 265:./state.h     ****    * Velocity in North East Down coordinates.
 266:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 267:./state.h     ****    */
 268:./state.h     ****   struct NedCoor_i ned_speed_i;
 269:./state.h     **** 
 270:./state.h     ****   /**
 271:./state.h     ****    * Velocity in East North Up coordinates.
 272:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 273:./state.h     ****    */
 274:./state.h     ****   struct EnuCoor_i enu_speed_i;
 275:./state.h     **** 
 276:./state.h     ****   /**
 277:./state.h     ****    * Norm of horizontal ground speed.
 278:./state.h     ****    * Unit: m/s in BFP with #INT32_SPEED_FRAC
 279:./state.h     ****    */
 280:./state.h     ****   uint32_t h_speed_norm_i;
 281:./state.h     **** 
 282:./state.h     ****   /**
 283:./state.h     ****    * Direction of horizontal ground speed.
 284:./state.h     ****    * Unit: rad in BFP with #INT32_ANGLE_FRAC
 285:./state.h     ****    * (clockwise, zero=north)
 286:./state.h     ****    */
 287:./state.h     ****   int32_t h_speed_dir_i;
 288:./state.h     **** 
 289:./state.h     ****   /**
 290:./state.h     ****    * Velocity in EarthCenteredEarthFixed coordinates.
 291:./state.h     ****    * Units: m/s
 292:./state.h     ****    */
 293:./state.h     ****   struct EcefCoor_f ecef_speed_f;
 294:./state.h     **** 
 295:./state.h     ****   /**
 296:./state.h     ****    * @brief speed in North East Down coordinates
 297:./state.h     ****    * @details Units: m/s */
 298:./state.h     ****   struct NedCoor_f ned_speed_f;
 299:./state.h     **** 
 300:./state.h     ****   /**
 301:./state.h     ****    * Velocity in East North Up coordinates.
 302:./state.h     ****    * Units: m/s
 303:./state.h     ****    */
 304:./state.h     ****   struct EnuCoor_f enu_speed_f;
 305:./state.h     **** 
 306:./state.h     ****   /**
 307:./state.h     ****    * Norm of horizontal ground speed.
 308:./state.h     ****    * Unit: m/s
 309:./state.h     ****    */
 310:./state.h     ****   float h_speed_norm_f;
 311:./state.h     **** 
 312:./state.h     ****   /**
 313:./state.h     ****    * Direction of horizontal ground speed.
 314:./state.h     ****    * Unit: rad (clockwise, zero=north)
 315:./state.h     ****    */
 316:./state.h     ****   float h_speed_dir_f;
 317:./state.h     ****   /** @}*/
 318:./state.h     **** 
 319:./state.h     **** 
 320:./state.h     ****   /** @addtogroup state_acceleration
 321:./state.h     ****    *  @{ */
 322:./state.h     ****   /**
 323:./state.h     ****    * Holds the status bits for all acceleration representations.
 324:./state.h     ****    * When the corresponding bit is one the representation
 325:./state.h     ****    * is already computed.
 326:./state.h     ****    */
 327:./state.h     ****   uint8_t accel_status;
 328:./state.h     **** 
 329:./state.h     ****   /**
 330:./state.h     ****    * Acceleration in North East Down coordinates.
 331:./state.h     ****    * Units: m/s^2 in BFP with #INT32_ACCEL_FRAC
 332:./state.h     ****    */
 333:./state.h     ****   struct NedCoor_i ned_accel_i;
 334:./state.h     **** 
 335:./state.h     ****   /**
 336:./state.h     ****    * Acceleration in EarthCenteredEarthFixed coordinates.
 337:./state.h     ****    * Units: m/s^2 in BFP with INT32_ACCEL_FRAC
 338:./state.h     ****    */
 339:./state.h     ****   struct EcefCoor_i ecef_accel_i;
 340:./state.h     **** 
 341:./state.h     ****   /**
 342:./state.h     ****    * Acceleration in North East Down coordinates.
 343:./state.h     ****    * Units: m/s^2
 344:./state.h     ****    */
 345:./state.h     ****   struct NedCoor_f ned_accel_f;
 346:./state.h     **** 
 347:./state.h     ****   /**
 348:./state.h     ****    * Acceleration in EarthCenteredEarthFixed coordinates.
 349:./state.h     ****    * Units: m/s^2
 350:./state.h     ****    */
 351:./state.h     ****   struct EcefCoor_f ecef_accel_f;
 352:./state.h     ****   /** @}*/
 353:./state.h     **** 
 354:./state.h     **** 
 355:./state.h     ****   /** @defgroup state_attitude Attitude representations
 356:./state.h     ****    */
 357:./state.h     ****   struct OrientationReps ned_to_body_orientation;
 358:./state.h     **** 
 359:./state.h     **** 
 360:./state.h     ****   /** @addtogroup state_rate
 361:./state.h     ****    *  @{ */
 362:./state.h     ****   /**
 363:./state.h     ****    * Holds the status bits for all angular rate representations.
 364:./state.h     ****    * When the corresponding bit is one the representation
 365:./state.h     ****    * is already computed.
 366:./state.h     ****    */
 367:./state.h     ****   uint8_t rate_status;
 368:./state.h     **** 
 369:./state.h     ****   /**
 370:./state.h     ****    * Angular rates in body frame.
 371:./state.h     ****    * Units: rad/s in BFP with #INT32_RATE_FRAC
 372:./state.h     ****    */
 373:./state.h     ****   struct Int32Rates  body_rates_i;
 374:./state.h     **** 
 375:./state.h     ****   /**
 376:./state.h     ****    * Angular rates in body frame.
 377:./state.h     ****    * Units: rad/s
 378:./state.h     ****    */
 379:./state.h     ****   struct FloatRates  body_rates_f;
 380:./state.h     ****   /** @}*/
 381:./state.h     **** 
 382:./state.h     **** 
 383:./state.h     ****   /** @addtogroup state_wind_airspeed
 384:./state.h     ****    *  @{ */
 385:./state.h     ****   /**
 386:./state.h     ****    * Holds the status bits for all wind- and airspeed representations.
 387:./state.h     ****    * When the corresponding bit is one the representation
 388:./state.h     ****    * is already computed.
 389:./state.h     ****    */
 390:./state.h     ****   uint8_t wind_air_status;
 391:./state.h     **** 
 392:./state.h     ****   /**
 393:./state.h     ****    * Horizontal windspeed in north/east.
 394:./state.h     ****    * Units: m/s in BFP with #INT32_SPEED_FRAC
 395:./state.h     ****    */
 396:./state.h     ****   struct Int32Vect2 h_windspeed_i;
 397:./state.h     **** 
 398:./state.h     ****   /**
 399:./state.h     ****    * Norm of horizontal ground speed.
 400:./state.h     ****    * @details Unit: m/s in BFP with #INT32_SPEED_FRAC
 401:./state.h     ****    */
 402:./state.h     ****   int32_t airspeed_i;
 403:./state.h     **** 
 404:./state.h     ****   /**
 405:./state.h     ****    * Horizontal windspeed.
 406:./state.h     ****    * Units: m/s with x=north, y=east
 407:./state.h     ****    */
 408:./state.h     ****   struct FloatVect2 h_windspeed_f;
 409:./state.h     **** 
 410:./state.h     ****   /**
 411:./state.h     ****    * Norm of relative air speed.
 412:./state.h     ****    * Unit: m/s
 413:./state.h     ****    */
 414:./state.h     ****   float airspeed_f;
 415:./state.h     **** 
 416:./state.h     ****   /**
 417:./state.h     ****    * Angle of attack
 418:./state.h     ****    * Unit: rad
 419:./state.h     ****    */
 420:./state.h     ****   float angle_of_attack_f;
 421:./state.h     **** 
 422:./state.h     ****   /**
 423:./state.h     ****    * Sideslip angle
 424:./state.h     ****    * Unit: rad
 425:./state.h     ****    */
 426:./state.h     ****   float sideslip_f;
 427:./state.h     **** 
 428:./state.h     ****   /** @}*/
 429:./state.h     **** 
 430:./state.h     **** };
 431:./state.h     **** 
 432:./state.h     **** extern struct State state;
 433:./state.h     **** 
 434:./state.h     **** extern void stateInit(void);
 435:./state.h     **** 
 436:./state.h     **** /** @addtogroup state_position
 437:./state.h     ****  *  @{ */
 438:./state.h     **** 
 439:./state.h     **** /// Set the local (flat earth) coordinate frame origin (int).
 440:./state.h     **** static inline void stateSetLocalOrigin_i(struct LtpDef_i *ltp_def)
 441:./state.h     **** {
 442:./state.h     ****   memcpy(&state.ned_origin_i, ltp_def, sizeof(struct LtpDef_i));
 443:./state.h     ****   /* convert to float */
 444:./state.h     ****   ECEF_FLOAT_OF_BFP(state.ned_origin_f.ecef, state.ned_origin_i.ecef);
 445:./state.h     ****   LLA_FLOAT_OF_BFP(state.ned_origin_f.lla, state.ned_origin_i.lla);
 446:./state.h     ****   HIGH_RES_RMAT_FLOAT_OF_BFP(state.ned_origin_f.ltp_of_ecef, state.ned_origin_i.ltp_of_ecef);
 447:./state.h     ****   state.ned_origin_f.hmsl = M_OF_MM(state.ned_origin_i.hmsl);
 448:./state.h     **** 
 449:./state.h     ****   /* clear bits for all local frame representations */
 450:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 451:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 452:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_I);
 453:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 454:./state.h     **** 
 455:./state.h     ****   state.ned_initialized_i = TRUE;
 456:./state.h     ****   state.ned_initialized_f = TRUE;
 457:./state.h     **** }
 458:./state.h     **** 
 459:./state.h     **** /// Set the local (flat earth) coordinate frame origin from UTM (float).
 460:./state.h     **** static inline void stateSetLocalUtmOrigin_f(struct UtmCoor_f *utm_def)
 461:./state.h     **** {
 462:./state.h     ****   memcpy(&state.utm_origin_f, utm_def, sizeof(struct UtmCoor_f));
 463:./state.h     ****   state.utm_initialized_f = TRUE;
 464:./state.h     **** 
 465:./state.h     ****   /* clear bits for all local frame representations */
 466:./state.h     ****   state.pos_status &= ~(POS_LOCAL_COORD);
 467:./state.h     ****   state.speed_status &= ~(SPEED_LOCAL_COORD);
 468:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_I);
 469:./state.h     ****   ClearBit(state.accel_status, ACCEL_NED_F);
 470:./state.h     **** }
 471:./state.h     **** /*******************************************************************************
 472:./state.h     ****  *                                                                             *
 473:./state.h     ****  * Set and Get functions for the POSITION representations                      *
 474:./state.h     ****  *                                                                             *
 475:./state.h     ****  ******************************************************************************/
 476:./state.h     **** 
 477:./state.h     **** /************* declaration of transformation functions ************/
 478:./state.h     **** extern void stateCalcPositionEcef_i(void);
 479:./state.h     **** extern void stateCalcPositionNed_i(void);
 480:./state.h     **** extern void stateCalcPositionEnu_i(void);
 481:./state.h     **** extern void stateCalcPositionLla_i(void);
 482:./state.h     **** extern void stateCalcPositionUtm_f(void);
 483:./state.h     **** extern void stateCalcPositionEcef_f(void);
 484:./state.h     **** extern void stateCalcPositionNed_f(void);
 485:./state.h     **** extern void stateCalcPositionEnu_f(void);
 486:./state.h     **** extern void stateCalcPositionLla_f(void);
 487:./state.h     **** 
 488:./state.h     **** /*********************** validity test functions ******************/
 489:./state.h     **** 
 490:./state.h     **** /// Test if local coordinates are valid.
 491:./state.h     **** static inline bool_t stateIsLocalCoordinateValid(void)
 492:./state.h     **** {
 493:./state.h     ****   return ((state.ned_initialized_i || state.ned_initialized_f || state.utm_initialized_f)
 494:./state.h     ****           && (state.pos_status & (POS_LOCAL_COORD)));
 495:./state.h     **** }
 496:./state.h     **** 
 497:./state.h     **** /// Test if global coordinates are valid.
 498:./state.h     **** static inline bool_t stateIsGlobalCoordinateValid(void)
 499:./state.h     **** {
 500:./state.h     ****   return ((state.pos_status & (POS_GLOBAL_COORD)) || stateIsLocalCoordinateValid());
 501:./state.h     **** }
 502:./state.h     **** 
 503:./state.h     **** /************************ Set functions ****************************/
 504:./state.h     **** 
 505:./state.h     **** /// Set position from ECEF coordinates (int).
 506:./state.h     **** static inline void stateSetPositionEcef_i(struct EcefCoor_i *ecef_pos)
 507:./state.h     **** {
 508:./state.h     ****   VECT3_COPY(state.ecef_pos_i, *ecef_pos);
 509:./state.h     ****   /* clear bits for all position representations and only set the new one */
 510:./state.h     ****   state.pos_status = (1 << POS_ECEF_I);
 511:./state.h     **** }
 512:./state.h     **** 
 513:./state.h     **** /// Set position from local NED coordinates (int).
 514:./state.h     **** static inline void stateSetPositionNed_i(struct NedCoor_i *ned_pos)
 515:./state.h     **** {
 516:./state.h     ****   VECT3_COPY(state.ned_pos_i, *ned_pos);
 517:./state.h     ****   /* clear bits for all position representations and only set the new one */
 518:./state.h     ****   state.pos_status = (1 << POS_NED_I);
 519:./state.h     **** }
 520:./state.h     **** 
 521:./state.h     **** /// Set position from local ENU coordinates (int).
 522:./state.h     **** static inline void stateSetPositionEnu_i(struct EnuCoor_i *enu_pos)
 523:./state.h     **** {
 524:./state.h     ****   VECT3_COPY(state.enu_pos_i, *enu_pos);
 525:./state.h     ****   /* clear bits for all position representations and only set the new one */
 526:./state.h     ****   state.pos_status = (1 << POS_ENU_I);
 527:./state.h     **** }
 528:./state.h     **** 
 529:./state.h     **** /// Set position from LLA coordinates (int).
 530:./state.h     **** static inline void stateSetPositionLla_i(struct LlaCoor_i *lla_pos)
 531:./state.h     **** {
 532:./state.h     ****   LLA_COPY(state.lla_pos_i, *lla_pos);
 533:./state.h     ****   /* clear bits for all position representations and only set the new one */
 534:./state.h     ****   state.pos_status = (1 << POS_LLA_I);
 535:./state.h     **** }
 536:./state.h     **** 
 537:./state.h     **** /// Set multiple position coordinates (int).
 538:./state.h     **** static inline void stateSetPosition_i(
 539:./state.h     ****   struct EcefCoor_i *ecef_pos,
 540:./state.h     ****   struct NedCoor_i *ned_pos,
 541:./state.h     ****   struct EnuCoor_i *enu_pos,
 542:./state.h     ****   struct LlaCoor_i *lla_pos)
 543:./state.h     **** {
 544:./state.h     ****   /* clear all status bit */
 545:./state.h     ****   state.pos_status = 0;
 546:./state.h     ****   if (ecef_pos != NULL) {
 547:./state.h     ****     VECT3_COPY(state.ecef_pos_i, *ecef_pos);
 548:./state.h     ****     state.pos_status |= (1 << POS_ECEF_I);
 549:./state.h     ****   }
 550:./state.h     ****   if (ned_pos != NULL) {
 551:./state.h     ****     VECT3_COPY(state.ned_pos_i, *ned_pos);
 552:./state.h     ****     state.pos_status |= (1 << POS_NED_I);
 553:./state.h     ****   }
 554:./state.h     ****   if (enu_pos != NULL) {
 555:./state.h     ****     VECT3_COPY(state.enu_pos_i, *enu_pos);
 556:./state.h     ****     state.pos_status |= (1 << POS_ENU_I);
 557:./state.h     ****   }
 558:./state.h     ****   if (lla_pos != NULL) {
 559:./state.h     ****     LLA_COPY(state.lla_pos_i, *lla_pos);
 560:./state.h     ****     state.pos_status |= (1 << POS_LLA_I);
 561:./state.h     ****   }
 562:./state.h     **** }
 563:./state.h     **** 
 564:./state.h     **** /// Set position from UTM coordinates (float).
 565:./state.h     **** static inline void stateSetPositionUtm_f(struct UtmCoor_f *utm_pos)
 566:./state.h     **** {
 567:./state.h     ****   memcpy(&state.utm_pos_f, utm_pos, sizeof(struct UtmCoor_f));
 568:./state.h     ****   /* clear bits for all position representations and only set the new one */
 569:./state.h     ****   state.pos_status = (1 << POS_UTM_F);
 570:./state.h     **** }
 571:./state.h     **** 
 572:./state.h     **** /// Set position from ECEF coordinates (float).
 573:./state.h     **** static inline void stateSetPositionEcef_f(struct EcefCoor_f *ecef_pos)
 574:./state.h     **** {
 575:./state.h     ****   VECT3_COPY(state.ecef_pos_f, *ecef_pos);
 576:./state.h     ****   /* clear bits for all position representations and only set the new one */
 577:./state.h     ****   state.pos_status = (1 << POS_ECEF_F);
 578:./state.h     **** }
 579:./state.h     **** 
 580:./state.h     **** /// Set position from local NED coordinates (float).
 581:./state.h     **** static inline void stateSetPositionNed_f(struct NedCoor_f *ned_pos)
 582:./state.h     **** {
 583:./state.h     ****   VECT3_COPY(state.ned_pos_f, *ned_pos);
 584:./state.h     ****   /* clear bits for all position representations and only set the new one */
 585:./state.h     ****   state.pos_status = (1 << POS_NED_F);
 586:./state.h     **** }
 587:./state.h     **** 
 588:./state.h     **** /// Set position from local ENU coordinates (float).
 589:./state.h     **** static inline void stateSetPositionEnu_f(struct EnuCoor_f *enu_pos)
 590:./state.h     **** {
 591:./state.h     ****   VECT3_COPY(state.enu_pos_f, *enu_pos);
 592:./state.h     ****   /* clear bits for all position representations and only set the new one */
 593:./state.h     ****   state.pos_status = (1 << POS_ENU_F);
 594:./state.h     **** }
 595:./state.h     **** 
 596:./state.h     **** /// Set position from LLA coordinates (float).
 597:./state.h     **** static inline void stateSetPositionLla_f(struct LlaCoor_f *lla_pos)
 598:./state.h     **** {
 599:./state.h     ****   LLA_COPY(state.lla_pos_f, *lla_pos);
 600:./state.h     ****   /* clear bits for all position representations and only set the new one */
 601:./state.h     ****   state.pos_status = (1 << POS_LLA_F);
 602:./state.h     **** }
 603:./state.h     **** 
 604:./state.h     **** /// Set multiple position coordinates (float).
 605:./state.h     **** static inline void stateSetPosition_f(
 606:./state.h     ****   struct EcefCoor_f *ecef_pos,
 607:./state.h     ****   struct NedCoor_f *ned_pos,
 608:./state.h     ****   struct EnuCoor_f *enu_pos,
 609:./state.h     ****   struct LlaCoor_f *lla_pos,
 610:./state.h     ****   struct UtmCoor_f *utm_pos)
 611:./state.h     **** {
 612:./state.h     ****   /* clear all status bit */
 613:./state.h     ****   state.pos_status = 0;
 614:./state.h     ****   if (ecef_pos != NULL) {
 615:./state.h     ****     VECT3_COPY(state.ecef_pos_f, *ecef_pos);
 616:./state.h     ****     state.pos_status |= (1 << POS_ECEF_F);
 617:./state.h     ****   }
 618:./state.h     ****   if (ned_pos != NULL) {
 619:./state.h     ****     VECT3_COPY(state.ned_pos_f, *ned_pos);
 620:./state.h     ****     state.pos_status |= (1 << POS_NED_F);
 621:./state.h     ****   }
 622:./state.h     ****   if (enu_pos != NULL) {
 623:./state.h     ****     VECT3_COPY(state.enu_pos_f, *enu_pos);
 624:./state.h     ****     state.pos_status |= (1 << POS_ENU_F);
 625:./state.h     ****   }
 626:./state.h     ****   if (lla_pos != NULL) {
 627:./state.h     ****     LLA_COPY(state.lla_pos_f, *lla_pos);
 628:./state.h     ****     state.pos_status |= (1 << POS_LLA_F);
 629:./state.h     ****   }
 630:./state.h     ****   if (utm_pos != NULL) {
 631:./state.h     ****     memcpy(&state.utm_pos_f, utm_pos, sizeof(struct UtmCoor_f));
 632:./state.h     ****     state.pos_status |= (1 << POS_UTM_F);
 633:./state.h     ****   }
 634:./state.h     **** }
 635:./state.h     **** 
 636:./state.h     **** /************************ Get functions ****************************/
 637:./state.h     **** 
 638:./state.h     **** /// Get position in ECEF coordinates (int).
 639:./state.h     **** static inline struct EcefCoor_i *stateGetPositionEcef_i(void)
 640:./state.h     **** {
 641:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ECEF_I)) {
 642:./state.h     ****     stateCalcPositionEcef_i();
 643:./state.h     ****   }
 644:./state.h     ****   return &state.ecef_pos_i;
 645:./state.h     **** }
 646:./state.h     **** 
 647:./state.h     **** /// Get position in local NED coordinates (int).
 648:./state.h     **** static inline struct NedCoor_i *stateGetPositionNed_i(void)
 649:./state.h     **** {
 650:./state.h     ****   if (!bit_is_set(state.pos_status, POS_NED_I)) {
 651:./state.h     ****     stateCalcPositionNed_i();
 652:./state.h     ****   }
 653:./state.h     ****   return &state.ned_pos_i;
 654:./state.h     **** }
 655:./state.h     **** 
 656:./state.h     **** /// Get position in local ENU coordinates (int).
 657:./state.h     **** static inline struct EnuCoor_i *stateGetPositionEnu_i(void)
 658:./state.h     **** {
 659:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ENU_I)) {
 660:./state.h     ****     stateCalcPositionEnu_i();
 661:./state.h     ****   }
 662:./state.h     ****   return &state.enu_pos_i;
 663:./state.h     **** }
 664:./state.h     **** 
 665:./state.h     **** /// Get position in LLA coordinates (int).
 666:./state.h     **** static inline struct LlaCoor_i *stateGetPositionLla_i(void)
 667:./state.h     **** {
 668:./state.h     ****   if (!bit_is_set(state.pos_status, POS_LLA_I)) {
 669:./state.h     ****     stateCalcPositionLla_i();
 670:./state.h     ****   }
 671:./state.h     ****   return &state.lla_pos_i;
 672:./state.h     **** }
 673:./state.h     **** 
 674:./state.h     **** /// Get position in UTM coordinates (float).
 675:./state.h     **** static inline struct UtmCoor_f *stateGetPositionUtm_f(void)
 676:./state.h     **** {
 677:./state.h     ****   if (!bit_is_set(state.pos_status, POS_UTM_F)) {
 678:./state.h     ****     stateCalcPositionUtm_f();
 679:./state.h     ****   }
 680:./state.h     ****   return &state.utm_pos_f;
 681:./state.h     **** }
 682:./state.h     **** 
 683:./state.h     **** /// Get position in ECEF coordinates (float).
 684:./state.h     **** static inline struct EcefCoor_f *stateGetPositionEcef_f(void)
 685:./state.h     **** {
 686:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ECEF_F)) {
 687:./state.h     ****     stateCalcPositionEcef_f();
 688:./state.h     ****   }
 689:./state.h     ****   return &state.ecef_pos_f;
 690:./state.h     **** }
 691:./state.h     **** 
 692:./state.h     **** /// Get position in local NED coordinates (float).
 693:./state.h     **** static inline struct NedCoor_f *stateGetPositionNed_f(void)
 694:./state.h     **** {
 695:./state.h     ****   if (!bit_is_set(state.pos_status, POS_NED_F)) {
 696:./state.h     ****     stateCalcPositionNed_f();
 697:./state.h     ****   }
 698:./state.h     ****   return &state.ned_pos_f;
 699:./state.h     **** }
 700:./state.h     **** 
 701:./state.h     **** /// Get position in local ENU coordinates (float).
 702:./state.h     **** static inline struct EnuCoor_f *stateGetPositionEnu_f(void)
 703:./state.h     **** {
 704:./state.h     ****   if (!bit_is_set(state.pos_status, POS_ENU_F)) {
 705:./state.h     ****     stateCalcPositionEnu_f();
 706:./state.h     ****   }
 707:./state.h     ****   return &state.enu_pos_f;
 708:./state.h     **** }
 709:./state.h     **** 
 710:./state.h     **** /// Get position in LLA coordinates (float).
 711:./state.h     **** static inline struct LlaCoor_f *stateGetPositionLla_f(void)
 712:./state.h     **** {
 713:./state.h     ****   if (!bit_is_set(state.pos_status, POS_LLA_F)) {
 714:./state.h     ****     stateCalcPositionLla_f();
 715:./state.h     ****   }
 716:./state.h     ****   return &state.lla_pos_f;
 717:./state.h     **** }
 718:./state.h     **** 
 719:./state.h     **** /** @}*/
 720:./state.h     **** 
 721:./state.h     **** 
 722:./state.h     **** 
 723:./state.h     **** /******************************************************************************
 724:./state.h     ****  *                                                                            *
 725:./state.h     ****  * Set and Get functions for the SPEED representations                        *
 726:./state.h     ****  *                                                                            *
 727:./state.h     ****  *****************************************************************************/
 728:./state.h     **** /** @addtogroup state_velocity
 729:./state.h     ****  *  @{ */
 730:./state.h     **** 
 731:./state.h     **** /************* declaration of transformation functions ************/
 732:./state.h     **** extern void stateCalcSpeedNed_i(void);
 733:./state.h     **** extern void stateCalcSpeedEnu_i(void);
 734:./state.h     **** extern void stateCalcSpeedEcef_i(void);
 735:./state.h     **** extern void stateCalcHorizontalSpeedNorm_i(void);
 736:./state.h     **** extern void stateCalcHorizontalSpeedDir_i(void);
 737:./state.h     **** extern void stateCalcSpeedNed_f(void);
 738:./state.h     **** extern void stateCalcSpeedEnu_f(void);
 739:./state.h     **** extern void stateCalcSpeedEcef_f(void);
 740:./state.h     **** extern void stateCalcHorizontalSpeedNorm_f(void);
 741:./state.h     **** extern void stateCalcHorizontalSpeedDir_f(void);
 742:./state.h     **** 
 743:./state.h     **** /************************ Set functions ****************************/
 744:./state.h     **** 
 745:./state.h     **** /// Set ground speed in local NED coordinates (int).
 746:./state.h     **** static inline void stateSetSpeedNed_i(struct NedCoor_i *ned_speed)
 747:./state.h     **** {
 748:./state.h     ****   VECT3_COPY(state.ned_speed_i, *ned_speed);
 749:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 750:./state.h     ****   state.speed_status = (1 << SPEED_NED_I);
 751:./state.h     **** }
 752:./state.h     **** 
 753:./state.h     **** /// Set ground speed in local ENU coordinates (int).
 754:./state.h     **** static inline void stateSetSpeedEnu_i(struct EnuCoor_i *enu_speed)
 755:./state.h     **** {
 756:./state.h     ****   VECT3_COPY(state.enu_speed_i, *enu_speed);
 757:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 758:./state.h     ****   state.speed_status = (1 << SPEED_ENU_I);
 759:./state.h     **** }
 760:./state.h     **** 
 761:./state.h     **** /// Set ground speed in ECEF coordinates (int).
 762:./state.h     **** static inline void stateSetSpeedEcef_i(struct EcefCoor_i *ecef_speed)
 763:./state.h     **** {
 764:./state.h     ****   VECT3_COPY(state.ecef_speed_i, *ecef_speed);
 765:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 766:./state.h     ****   state.speed_status = (1 << SPEED_ECEF_I);
 767:./state.h     **** }
 768:./state.h     **** 
 769:./state.h     **** /// Set multiple speed coordinates (int).
 770:./state.h     **** static inline void stateSetSpeed_i(
 771:./state.h     ****   struct EcefCoor_i *ecef_speed,
 772:./state.h     ****   struct NedCoor_i *ned_speed,
 773:./state.h     ****   struct EnuCoor_i *enu_speed)
 774:./state.h     **** {
 775:./state.h     ****   /* clear all status bit */
 776:./state.h     ****   state.speed_status = 0;
 777:./state.h     ****   if (ecef_speed != NULL) {
 778:./state.h     ****     VECT3_COPY(state.ecef_speed_i, *ecef_speed);
 779:./state.h     ****     state.speed_status |= (1 << SPEED_ECEF_I);
 780:./state.h     ****   }
 781:./state.h     ****   if (ned_speed != NULL) {
 782:./state.h     ****     VECT3_COPY(state.ned_speed_i, *ned_speed);
 783:./state.h     ****     state.speed_status |= (1 << SPEED_NED_I);
 784:./state.h     ****   }
 785:./state.h     ****   if (enu_speed != NULL) {
 786:./state.h     ****     VECT3_COPY(state.enu_speed_i, *enu_speed);
 787:./state.h     ****     state.speed_status |= (1 << SPEED_ENU_I);
 788:./state.h     ****   }
 789:./state.h     **** }
 790:./state.h     **** 
 791:./state.h     **** /// Set ground speed in local NED coordinates (float).
 792:./state.h     **** static inline void stateSetSpeedNed_f(struct NedCoor_f *ned_speed)
 793:./state.h     **** {
 794:./state.h     ****   VECT3_COPY(state.ned_speed_f, *ned_speed);
 795:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 796:./state.h     ****   state.speed_status = (1 << SPEED_NED_F);
 797:./state.h     **** }
 798:./state.h     **** 
 799:./state.h     **** /// Set ground speed in local ENU coordinates (float).
 800:./state.h     **** static inline void stateSetSpeedEnu_f(struct EnuCoor_f *enu_speed)
 801:./state.h     **** {
 802:./state.h     ****   VECT3_COPY(state.enu_speed_f, *enu_speed);
 803:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 804:./state.h     ****   state.speed_status = (1 << SPEED_ENU_F);
 805:./state.h     **** }
 806:./state.h     **** 
 807:./state.h     **** /// Set ground speed in ECEF coordinates (float).
 808:./state.h     **** static inline void stateSetSpeedEcef_f(struct EcefCoor_f *ecef_speed)
 809:./state.h     **** {
 810:./state.h     ****   VECT3_COPY(state.ecef_speed_f, *ecef_speed);
 811:./state.h     ****   /* clear bits for all speed representations and only set the new one */
 812:./state.h     ****   state.speed_status = (1 << SPEED_ECEF_F);
 813:./state.h     **** }
 814:./state.h     **** 
 815:./state.h     **** /// Set multiple speed coordinates (float).
 816:./state.h     **** static inline void stateSetSpeed_f(
 817:./state.h     ****   struct EcefCoor_f *ecef_speed,
 818:./state.h     ****   struct NedCoor_f *ned_speed,
 819:./state.h     ****   struct EnuCoor_f *enu_speed)
 820:./state.h     **** {
 821:./state.h     ****   /* clear all status bit */
 822:./state.h     ****   state.speed_status = 0;
 823:./state.h     ****   if (ecef_speed != NULL) {
 824:./state.h     ****     VECT3_COPY(state.ecef_speed_f, *ecef_speed);
 825:./state.h     ****     state.speed_status |= (1 << SPEED_ECEF_F);
 826:./state.h     ****   }
 827:./state.h     ****   if (ned_speed != NULL) {
 828:./state.h     ****     VECT3_COPY(state.ned_speed_f, *ned_speed);
 829:./state.h     ****     state.speed_status |= (1 << SPEED_NED_F);
 830:./state.h     ****   }
 831:./state.h     ****   if (enu_speed != NULL) {
 832:./state.h     ****     VECT3_COPY(state.enu_speed_f, *enu_speed);
 833:./state.h     ****     state.speed_status |= (1 << SPEED_ENU_F);
 834:./state.h     ****   }
 835:./state.h     **** }
 836:./state.h     **** 
 837:./state.h     **** /************************ Get functions ****************************/
 838:./state.h     **** 
 839:./state.h     **** /// Get ground speed in local NED coordinates (int).
 840:./state.h     **** static inline struct NedCoor_i *stateGetSpeedNed_i(void)
 841:./state.h     **** {
 842:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_NED_I)) {
 843:./state.h     ****     stateCalcSpeedNed_i();
 844:./state.h     ****   }
 845:./state.h     ****   return &state.ned_speed_i;
 846:./state.h     **** }
 847:./state.h     **** 
 848:./state.h     **** /// Get ground speed in local ENU coordinates (int).
 849:./state.h     **** static inline struct EnuCoor_i *stateGetSpeedEnu_i(void)
 850:./state.h     **** {
 851:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ENU_I)) {
 852:./state.h     ****     stateCalcSpeedEnu_i();
 853:./state.h     ****   }
 854:./state.h     ****   return &state.enu_speed_i;
 855:./state.h     **** }
 856:./state.h     **** 
 857:./state.h     **** /// Get ground speed in ECEF coordinates (int).
 858:./state.h     **** static inline struct EcefCoor_i *stateGetSpeedEcef_i(void)
 859:./state.h     **** {
 860:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 861:./state.h     ****     stateCalcSpeedEcef_i();
 862:./state.h     ****   }
 863:./state.h     ****   return &state.ecef_speed_i;
 864:./state.h     **** }
 865:./state.h     **** 
 866:./state.h     **** /// Get norm of horizontal ground speed (int).
 867:./state.h     **** static inline uint32_t *stateGetHorizontalSpeedNorm_i(void)
 868:./state.h     **** {
 869:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HNORM_I)) {
 870:./state.h     ****     stateCalcHorizontalSpeedNorm_i();
 871:./state.h     ****   }
 872:./state.h     ****   return &state.h_speed_norm_i;
 873:./state.h     **** }
 874:./state.h     **** 
 875:./state.h     **** /// Get dir of horizontal ground speed (int).
 876:./state.h     **** static inline int32_t *stateGetHorizontalSpeedDir_i(void)
 877:./state.h     **** {
 878:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HDIR_I)) {
 879:./state.h     ****     stateCalcHorizontalSpeedDir_i();
 880:./state.h     ****   }
 881:./state.h     ****   return &state.h_speed_dir_i;
 882:./state.h     **** }
 883:./state.h     **** 
 884:./state.h     **** /// Get ground speed in local NED coordinates (float).
 885:./state.h     **** static inline struct NedCoor_f *stateGetSpeedNed_f(void)
 886:./state.h     **** {
 887:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_NED_F)) {
 888:./state.h     ****     stateCalcSpeedNed_f();
 889:./state.h     ****   }
 890:./state.h     ****   return &state.ned_speed_f;
 891:./state.h     **** }
 892:./state.h     **** 
 893:./state.h     **** /// Get ground speed in local ENU coordinates (float).
 894:./state.h     **** static inline struct EnuCoor_f *stateGetSpeedEnu_f(void)
 895:./state.h     **** {
 896:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ENU_F)) {
 897:./state.h     ****     stateCalcSpeedEnu_f();
 898:./state.h     ****   }
 899:./state.h     ****   return &state.enu_speed_f;
 900:./state.h     **** }
 901:./state.h     **** 
 902:./state.h     **** /// Get ground speed in ECEF coordinates (float).
 903:./state.h     **** static inline struct EcefCoor_f *stateGetSpeedEcef_f(void)
 904:./state.h     **** {
 905:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 906:./state.h     ****     stateCalcSpeedEcef_f();
 907:./state.h     ****   }
 908:./state.h     ****   return &state.ecef_speed_f;
 909:./state.h     **** }
 910:./state.h     **** 
 911:./state.h     **** /// Get norm of horizontal ground speed (float).
 912:./state.h     **** static inline float *stateGetHorizontalSpeedNorm_f(void)
 913:./state.h     **** {
 914:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HNORM_F)) {
 915:./state.h     ****     stateCalcHorizontalSpeedNorm_f();
 916:./state.h     ****   }
 917:./state.h     ****   return &state.h_speed_norm_f;
 918:./state.h     **** }
 919:./state.h     **** 
 920:./state.h     **** /// Get dir of horizontal ground speed (float).
 921:./state.h     **** static inline float *stateGetHorizontalSpeedDir_f(void)
 922:./state.h     **** {
 923:./state.h     ****   if (!bit_is_set(state.speed_status, SPEED_HDIR_F)) {
 924:./state.h     ****     stateCalcHorizontalSpeedDir_f();
 925:./state.h     ****   }
 926:./state.h     ****   return &state.h_speed_dir_f;
 927:./state.h     **** }
 928:./state.h     **** /** @}*/
 929:./state.h     **** 
 930:./state.h     **** 
 931:./state.h     **** 
 932:./state.h     **** /******************************************************************************
 933:./state.h     ****  *                                                                            *
 934:./state.h     ****  * Set and Get functions for the ACCELERATION representations                 *
 935:./state.h     ****  *                                                                            *
 936:./state.h     ****  *****************************************************************************/
 937:./state.h     **** /** @addtogroup state_acceleration
 938:./state.h     ****  *  @{ */
 939:./state.h     **** 
 940:./state.h     **** /************* declaration of transformation functions ************/
 941:./state.h     **** extern void stateCalcAccelNed_i(void);
 942:./state.h     **** extern void stateCalcAccelEcef_i(void);
 943:./state.h     **** extern void stateCalcAccelNed_f(void);
 944:./state.h     **** extern void stateCalcAccelEcef_f(void);
 945:./state.h     **** 
 946:./state.h     **** /*********************** validity test functions ******************/
 947:./state.h     **** 
 948:./state.h     **** /// Test if accelerations are valid.
 949:./state.h     **** static inline bool_t stateIsAccelValid(void)
 950:./state.h     **** {
 951:./state.h     ****   return (state.accel_status);
 952:./state.h     **** }
 953:./state.h     **** 
 954:./state.h     **** /************************ Set functions ****************************/
 955:./state.h     **** 
 956:./state.h     **** /// Set acceleration in NED coordinates (int).
 957:./state.h     **** static inline void stateSetAccelNed_i(struct NedCoor_i *ned_accel)
 958:./state.h     **** {
 959:./state.h     ****   VECT3_COPY(state.ned_accel_i, *ned_accel);
 960:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 961:./state.h     ****   state.accel_status = (1 << ACCEL_NED_I);
 962:./state.h     **** }
 963:./state.h     **** 
 964:./state.h     **** /// Set acceleration in ECEF coordinates (int).
 965:./state.h     **** static inline void stateSetAccelEcef_i(struct EcefCoor_i *ecef_accel)
 966:./state.h     **** {
 967:./state.h     ****   VECT3_COPY(state.ecef_accel_i, *ecef_accel);
 968:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 969:./state.h     ****   state.accel_status = (1 << ACCEL_ECEF_I);
 970:./state.h     **** }
 971:./state.h     **** 
 972:./state.h     **** /// Set acceleration in NED coordinates (float).
 973:./state.h     **** static inline void stateSetAccelNed_f(struct NedCoor_f *ned_accel)
 974:./state.h     **** {
 975:./state.h     ****   VECT3_COPY(state.ned_accel_f, *ned_accel);
 976:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 977:./state.h     ****   state.accel_status = (1 << ACCEL_NED_F);
 978:./state.h     **** }
 979:./state.h     **** 
 980:./state.h     **** /// Set acceleration in ECEF coordinates (float).
 981:./state.h     **** static inline void stateSetAccelEcef_f(struct EcefCoor_f *ecef_accel)
 982:./state.h     **** {
 983:./state.h     ****   VECT3_COPY(state.ecef_accel_f, *ecef_accel);
 984:./state.h     ****   /* clear bits for all accel representations and only set the new one */
 985:./state.h     ****   state.accel_status = (1 << ACCEL_ECEF_F);
 986:./state.h     **** }
 987:./state.h     **** 
 988:./state.h     **** /************************ Get functions ****************************/
 989:./state.h     **** 
 990:./state.h     **** /// Get acceleration in NED coordinates (int).
 991:./state.h     **** static inline struct NedCoor_i *stateGetAccelNed_i(void)
 992:./state.h     **** {
 993:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_NED_I)) {
 994:./state.h     ****     stateCalcAccelNed_i();
 995:./state.h     ****   }
 996:./state.h     ****   return &state.ned_accel_i;
 997:./state.h     **** }
 998:./state.h     **** 
 999:./state.h     **** /// Get acceleration in ECEF coordinates (int).
1000:./state.h     **** static inline struct EcefCoor_i *stateGetAccelEcef_i(void)
1001:./state.h     **** {
1002:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
1003:./state.h     ****     stateCalcAccelEcef_i();
1004:./state.h     ****   }
1005:./state.h     ****   return &state.ecef_accel_i;
1006:./state.h     **** }
1007:./state.h     **** 
1008:./state.h     **** /// Get acceleration in NED coordinates (float).
1009:./state.h     **** static inline struct NedCoor_f *stateGetAccelNed_f(void)
1010:./state.h     **** {
1011:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_NED_F)) {
1012:./state.h     ****     stateCalcAccelNed_f();
1013:./state.h     ****   }
1014:./state.h     ****   return &state.ned_accel_f;
1015:./state.h     **** }
1016:./state.h     **** 
1017:./state.h     **** /// Get acceleration in ECEF coordinates (float).
1018:./state.h     **** static inline struct EcefCoor_f *stateGetAccelEcef_f(void)
1019:./state.h     **** {
1020:./state.h     ****   if (!bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
1021:./state.h     ****     stateCalcAccelEcef_f();
1022:./state.h     ****   }
1023:./state.h     ****   return &state.ecef_accel_f;
1024:./state.h     **** }
1025:./state.h     **** /** @}*/
1026:./state.h     **** 
1027:./state.h     **** /******************************************************************************
1028:./state.h     **** *                                                                             *
1029:./state.h     **** * Set and Get functions for the ATTITUDE representations                      *
1030:./state.h     **** * (Calls the functions in math/pprz_orientation_conversion)                   *
1031:./state.h     **** *                                                                             *
1032:./state.h     **** *****************************************************************************/
1033:./state.h     **** /** @addtogroup state_attitude
1034:./state.h     **** * @{ */
1035:./state.h     **** /*********************** validity test functions ******************/
1036:./state.h     **** 
1037:./state.h     **** /// Test if attitudes are valid.
1038:./state.h     **** static inline bool_t stateIsAttitudeValid(void)
1039:./state.h     **** {
1040:./state.h     ****   return (orienationCheckValid(&state.ned_to_body_orientation));
1041:./state.h     **** }
1042:./state.h     **** 
1043:./state.h     **** /************************ Set functions ****************************/
1044:./state.h     **** 
1045:./state.h     **** /// Set vehicle body attitude from quaternion (int).
1046:./state.h     **** static inline void stateSetNedToBodyQuat_i(struct Int32Quat *ned_to_body_quat)
1047:./state.h     **** {
1048:./state.h     ****   orientationSetQuat_i(&state.ned_to_body_orientation, ned_to_body_quat);
1049:./state.h     **** }
1050:./state.h     **** 
1051:./state.h     **** /// Set vehicle body attitude from rotation matrix (int).
1052:./state.h     **** static inline void stateSetNedToBodyRMat_i(struct Int32RMat *ned_to_body_rmat)
1053:./state.h     **** {
1054:./state.h     ****   orientationSetRMat_i(&state.ned_to_body_orientation, ned_to_body_rmat);
1055:./state.h     **** }
1056:./state.h     **** 
1057:./state.h     **** /// Set vehicle body attitude from euler angles (int).
1058:./state.h     **** static inline void stateSetNedToBodyEulers_i(struct Int32Eulers *ned_to_body_eulers)
1059:./state.h     **** {
1060:./state.h     ****   orientationSetEulers_i(&state.ned_to_body_orientation, ned_to_body_eulers);
1061:./state.h     **** }
1062:./state.h     **** 
1063:./state.h     **** /// Set vehicle body attitude from quaternion (float).
1064:./state.h     **** static inline void stateSetNedToBodyQuat_f(struct FloatQuat *ned_to_body_quat)
1065:./state.h     **** {
1066:./state.h     ****   orientationSetQuat_f(&state.ned_to_body_orientation, ned_to_body_quat);
1067:./state.h     **** }
1068:./state.h     **** 
1069:./state.h     **** /// Set vehicle body attitude from rotation matrix (float).
1070:./state.h     **** static inline void stateSetNedToBodyRMat_f(struct FloatRMat *ned_to_body_rmat)
1071:./state.h     **** {
1072:./state.h     ****   orientationSetRMat_f(&state.ned_to_body_orientation, ned_to_body_rmat);
1073:./state.h     **** }
1074:./state.h     **** 
1075:./state.h     **** /// Set vehicle body attitude from euler angles (float).
1076:./state.h     **** static inline void stateSetNedToBodyEulers_f(struct FloatEulers *ned_to_body_eulers)
1077:./state.h     **** {
1078:./state.h     ****   orientationSetEulers_f(&state.ned_to_body_orientation, ned_to_body_eulers);
1079:./state.h     **** }
1080:./state.h     **** 
1081:./state.h     **** /************************ Get functions ****************************/
1082:./state.h     **** 
1083:./state.h     **** /// Get vehicle body attitude quaternion (int).
1084:./state.h     **** static inline struct Int32Quat *stateGetNedToBodyQuat_i(void)
1085:./state.h     **** {
1086:./state.h     ****   return orientationGetQuat_i(&state.ned_to_body_orientation);
1087:./state.h     **** }
1088:./state.h     **** 
1089:./state.h     **** /// Get vehicle body attitude rotation matrix (int).
1090:./state.h     **** static inline struct Int32RMat *stateGetNedToBodyRMat_i(void)
1091:./state.h     **** {
1092:./state.h     ****   return orientationGetRMat_i(&state.ned_to_body_orientation);
1093:./state.h     **** }
1094:./state.h     **** 
1095:./state.h     **** /// Get vehicle body attitude euler angles (int).
1096:./state.h     **** static inline struct Int32Eulers *stateGetNedToBodyEulers_i(void)
1097:./state.h     **** {
1098:./state.h     ****   return orientationGetEulers_i(&state.ned_to_body_orientation);
1099:./state.h     **** }
1100:./state.h     **** 
1101:./state.h     **** /// Get vehicle body attitude quaternion (float).
1102:./state.h     **** static inline struct FloatQuat *stateGetNedToBodyQuat_f(void)
1103:./state.h     **** {
1104:./state.h     ****   return orientationGetQuat_f(&state.ned_to_body_orientation);
1105:./state.h     **** }
1106:./state.h     **** 
1107:./state.h     **** /// Get vehicle body attitude rotation matrix (float).
1108:./state.h     **** static inline struct FloatRMat *stateGetNedToBodyRMat_f(void)
1109:./state.h     **** {
1110:./state.h     ****   return orientationGetRMat_f(&state.ned_to_body_orientation);
1111:./state.h     **** }
1112:./state.h     **** 
1113:./state.h     **** /// Get vehicle body attitude euler angles (float).
1114:./state.h     **** static inline struct FloatEulers *stateGetNedToBodyEulers_f(void)
1115:./state.h     **** {
1116:./state.h     ****   return orientationGetEulers_f(&state.ned_to_body_orientation);
 194              		.loc 5 1116 0
 195 0002 FFF7FEFF 		bl	orientationGetEulers_f.constprop.0
 196              	.LVL6:
 197              	.LBE15:
 198              	.LBE14:
 115:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   care_free_heading = stateGetNedToBodyEulers_f()->psi;
 199              		.loc 4 115 0
 200 0006 024B     		ldr	r3, .L16
 201 0008 8268     		ldr	r2, [r0, #8]	@ float
 202 000a 1A60     		str	r2, [r3]	@ float
 203 000c 08BD     		pop	{r3, pc}
 204              	.L17:
 205 000e 00BF     		.align	2
 206              	.L16:
 207 0010 00000000 		.word	.LANCHOR0
 208              		.cfi_endproc
 209              	.LFE175:
 211              		.section	.text.stabilization_attitude_get_heading_i,"ax",%progbits
 212              		.align	1
 213              		.global	stabilization_attitude_get_heading_i
 214              		.thumb
 215              		.thumb_func
 217              	stabilization_attitude_get_heading_i:
 218              	.LFB176:
 116:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 117:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 118:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /*   This is a different way to obtain yaw. It will not switch when going beyond 90 degrees pitch.
 119:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****      However, when rolling more then 90 degrees in combination with pitch it switches. For a
 120:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****      transition vehicle this is better as 90 degrees pitch will occur, but more than 90 degrees rol
 121:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** int32_t stabilization_attitude_get_heading_i(void)
 122:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 219              		.loc 4 122 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 0
 222              		@ frame_needed = 0, uses_anonymous_args = 0
 223              	.LVL7:
 224 0000 38B5     		push	{r3, r4, r5, lr}
 225              		.cfi_def_cfa_offset 16
 226              		.cfi_offset 3, -16
 227              		.cfi_offset 4, -12
 228              		.cfi_offset 5, -8
 229              		.cfi_offset 14, -4
 230              	.LBB21:
 231              	.LBB22:
 232              	.LBB23:
 210:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_I)) {
 233              		.loc 3 210 0
 234 0002 164D     		ldr	r5, .L26
 235 0004 95F8A431 		ldrb	r3, [r5, #420]	@ zero_extendqisi2
 236 0008 9B07     		lsls	r3, r3, #30
 237 000a 03D4     		bmi	.L19
 211:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_i(orientation);
 238              		.loc 3 211 0
 239 000c 05F5D270 		add	r0, r5, #420
 240 0010 FFF7FEFF 		bl	orientationCalcEulers_i
 241              	.LVL8:
 242              	.L19:
 243              	.LBE23:
 244              	.LBE22:
 245              	.LBE21:
 123:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct Int32Eulers *att = stateGetNedToBodyEulers_i();
 124:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 125:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t heading;
 126:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 127:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (abs(att->phi) < INT32_ANGLE_PI_2) {
 246              		.loc 4 127 0
 247 0014 D5F8B831 		ldr	r3, [r5, #440]
 248 0018 104C     		ldr	r4, .L26
 249 001a 03F5C952 		add	r2, r3, #6432
 250 001e B2F5495F 		cmp	r2, #12864
 251 0022 0BD8     		bhi	.L20
 252              	.LBB24:
 128:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     int32_t sin_theta;
 129:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     PPRZ_ITRIG_SIN(sin_theta, att->theta);
 253              		.loc 4 129 0
 254 0024 D4F8BC01 		ldr	r0, [r4, #444]
 255 0028 FFF7FEFF 		bl	pprz_itrig_sin
 256              	.LVL9:
 130:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi - INT_MULT_RSHIFT(sin_theta, att->phi, INT32_TRIG_FRAC);
 257              		.loc 4 130 0
 258 002c D4F8B831 		ldr	r3, [r4, #440]
 259 0030 5843     		muls	r0, r3, r0
 260              	.LVL10:
 261 0032 D4F8C031 		ldr	r3, [r4, #448]
 262 0036 A3EBA030 		sub	r0, r3, r0, asr #14
 263              	.LVL11:
 264              	.LBE24:
 265 003a 38BD     		pop	{r3, r4, r5, pc}
 266              	.LVL12:
 267              	.L20:
 131:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else if (ANGLE_FLOAT_OF_BFP(att->theta) > 0) {
 268              		.loc 4 131 0
 269 003c D4ED6F7A 		flds	s15, [r4, #444]	@ int
 132:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi - att->phi;
 270              		.loc 4 132 0
 271 0040 D4F8C001 		ldr	r0, [r4, #448]
 131:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else if (ANGLE_FLOAT_OF_BFP(att->theta) > 0) {
 272              		.loc 4 131 0
 273 0044 FAEECA7A 		vcvt.f32.s32	s15, s15, #12
 274 0048 F5EEC07A 		fcmpezs	s15
 275 004c F1EE10FA 		fmstat
 276              		.loc 4 132 0
 277 0050 CCBF     		ite	gt
 278 0052 C3EB0000 		rsbgt	r0, r3, r0
 279              	.LVL13:
 133:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else {
 134:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi + att->phi;
 280              		.loc 4 134 0
 281 0056 C018     		addle	r0, r0, r3
 282              	.LVL14:
 135:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 136:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 137:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return heading;
 138:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 283              		.loc 4 138 0
 284 0058 38BD     		pop	{r3, r4, r5, pc}
 285              	.L27:
 286 005a 00BF     		.align	2
 287              	.L26:
 288 005c 00000000 		.word	state
 289              		.cfi_endproc
 290              	.LFE176:
 292              		.global	__aeabi_i2d
 293              		.global	__aeabi_dcmplt
 294              		.section	.text.stabilization_attitude_get_heading_f,"ax",%progbits
 295              		.align	1
 296              		.global	stabilization_attitude_get_heading_f
 297              		.thumb
 298              		.thumb_func
 300              	stabilization_attitude_get_heading_f:
 301              	.LFB177:
 139:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 140:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** float stabilization_attitude_get_heading_f(void)
 141:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 302              		.loc 4 141 0
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 0
 305              		@ frame_needed = 0, uses_anonymous_args = 0
 306 0000 10B5     		push	{r4, lr}
 307              		.cfi_def_cfa_offset 8
 308              		.cfi_offset 4, -8
 309              		.cfi_offset 14, -4
 310 0002 2DED028B 		fstmfdd	sp!, {d8}
 311              		.cfi_def_cfa_offset 16
 312              		.cfi_offset 80, -16
 313              	.LBB27:
 314              	.LBB28:
 315              		.loc 5 1116 0
 316 0006 FFF7FEFF 		bl	orientationGetEulers_f.constprop.0
 317              	.LVL15:
 318              	.LBE28:
 319              	.LBE27:
 142:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatEulers *att = stateGetNedToBodyEulers_f();
 143:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 144:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float heading;
 145:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 146:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (abs(att->phi) < M_PI / 2) {
 320              		.loc 4 146 0
 321 000a 90ED008A 		flds	s16, [r0]
 322 000e FDEEC87A 		ftosizs	s15, s16
 323              	.LBB30:
 324              	.LBB29:
 325              		.loc 5 1116 0
 326 0012 0446     		mov	r4, r0
 327              	.LBE29:
 328              	.LBE30:
 329              		.loc 4 146 0
 330 0014 17EE900A 		fmrs	r0, s15	@ int
 331 0018 0028     		cmp	r0, #0
 332 001a B8BF     		it	lt
 333 001c 4042     		rsblt	r0, r0, #0
 334 001e FFF7FEFF 		bl	__aeabi_i2d
 335              	.LVL16:
 336 0022 11A3     		adr	r3, .L38
 337 0024 D3E90023 		ldrd	r2, [r3]
 338 0028 FFF7FEFF 		bl	__aeabi_dcmplt
 339              	.LVL17:
 340 002c D4ED028A 		flds	s17, [r4, #8]
 341 0030 38B1     		cbz	r0, .L36
 147:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi - sinf(att->theta) * att->phi;
 342              		.loc 4 147 0
 343 0032 6068     		ldr	r0, [r4, #4]	@ float
 344 0034 FFF7FEFF 		bl	sinf
 345              	.LVL18:
 346 0038 07EE900A 		fmsr	s15, r0
 347 003c E7EEC88A 		vfms.f32	s17, s15, s16
 348              	.LVL19:
 349 0040 0AE0     		b	.L31
 350              	.LVL20:
 351              	.L36:
 148:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else if (att->theta > 0) {
 352              		.loc 4 148 0
 353 0042 D4ED017A 		flds	s15, [r4, #4]
 354 0046 F5EEC07A 		fcmpezs	s15
 355 004a F1EE10FA 		fmstat
 149:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi - att->phi;
 356              		.loc 4 149 0
 357 004e CCBF     		ite	gt
 358 0050 78EEC88A 		fsubsgt	s17, s17, s16
 359              	.LVL21:
 150:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else {
 151:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     heading = att->psi + att->phi;
 360              		.loc 4 151 0
 361 0054 78EE288A 		faddsle	s17, s16, s17
 362              	.LVL22:
 363              	.L31:
 152:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 153:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 154:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return heading;
 155:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 364              		.loc 4 155 0
 365 0058 18EE900A 		fmrs	r0, s17
 366 005c BDEC028B 		fldmfdd	sp!, {d8}
 367 0060 10BD     		pop	{r4, pc}
 368              	.L39:
 369 0062 00BFAFF3 		.align	3
 369      0080
 370              	.L38:
 371 0068 182D4454 		.word	1413754136
 372 006c FB21F93F 		.word	1073291771
 373              		.cfi_endproc
 374              	.LFE177:
 376              		.global	__aeabi_f2d
 377              		.global	__aeabi_dmul
 378              		.global	__aeabi_d2iz
 379              		.section	.text.stabilization_attitude_read_rc_setpoint_eulers,"ax",%progbits
 380              		.align	1
 381              		.global	stabilization_attitude_read_rc_setpoint_eulers
 382              		.thumb
 383              		.thumb_func
 385              	stabilization_attitude_read_rc_setpoint_eulers:
 386              	.LFB178:
 156:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 157:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 158:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /** Read attitude setpoint from RC as euler angles
 159:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  coordinated_turn  true if in horizontal mode forward
 160:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  in_carefree       true if in carefree mode
 161:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  in_flight         true if in flight
 162:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[out] sp                attitude setpoint as euler angles
 163:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
 164:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_setpoint_eulers(struct Int32Eulers *sp, bool_t in_flight, bool_
 165:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     bool_t coordinated_turn)
 166:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 387              		.loc 4 166 0
 388              		.cfi_startproc
 389              		@ args = 0, pretend = 0, frame = 0
 390              		@ frame_needed = 0, uses_anonymous_args = 0
 391              	.LVL23:
 392 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 393              		.cfi_def_cfa_offset 24
 394              		.cfi_offset 4, -24
 395              		.cfi_offset 5, -20
 396              		.cfi_offset 6, -16
 397              		.cfi_offset 7, -12
 398              		.cfi_offset 8, -8
 399              		.cfi_offset 14, -4
 400 0004 0446     		mov	r4, r0
 401              	.LBB44:
 402              	.LBB45:
  54:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
 403              		.loc 4 54 0
 404 0006 8048     		ldr	r0, .L69+16
 405              	.LVL24:
 406              	.LBE45:
 407              	.LBE44:
 408              		.loc 4 166 0
 409 0008 1F46     		mov	r7, r3
 410              	.LBB48:
 411              	.LBB46:
  54:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
 412              		.loc 4 54 0
 413 000a C388     		ldrh	r3, [r0, #6]
 414              	.LVL25:
  59:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * max_rc_phi / MAX_PPRZ;
 415              		.loc 4 59 0
 416 000c 4FF44966 		mov	r6, #3216
 417 0010 13FB06F3 		smulbb	r3, r3, r6
 418              	.LVL26:
 419              	.LBE46:
 420              	.LBE48:
 421              		.loc 4 166 0
 422 0014 1546     		mov	r5, r2
 423              	.LBB49:
 424              	.LBB47:
  59:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * max_rc_phi / MAX_PPRZ;
 425              		.loc 4 59 0
 426 0016 4FF41652 		mov	r2, #9600
 427              	.LVL27:
 428 001a 93FBF2F3 		sdiv	r3, r3, r2
 429              	.LBE47:
 430              	.LBE49:
 167:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* last time this function was called, used to calculate yaw setpoint update */
 168:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   static float last_ts = 0.f;
 169:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 170:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   sp->phi = get_rc_roll();
 431              		.loc 4 170 0
 432 001e 2360     		str	r3, [r4]
 433              	.LVL28:
 434              	.LBB50:
 435              	.LBB51:
  66:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t pitch = radio_control.values[RADIO_PITCH];
 436              		.loc 4 66 0
 437 0020 0389     		ldrh	r3, [r0, #8]
 438              	.LVL29:
  71:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * max_rc_theta / MAX_PPRZ;
 439              		.loc 4 71 0
 440 0022 13FB06F6 		smulbb	r6, r3, r6
 441 0026 96FBF2F2 		sdiv	r2, r6, r2
 442              	.LBE51:
 443              	.LBE50:
 166:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 444              		.loc 4 166 0
 445 002a 2DED028B 		fstmfdd	sp!, {d8}
 446              		.cfi_def_cfa_offset 32
 447              		.cfi_offset 80, -32
 171:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   sp->theta = get_rc_pitch();
 448              		.loc 4 171 0
 449 002e 6260     		str	r2, [r4, #4]
 450 0030 8046     		mov	r8, r0
 451 0032 764E     		ldr	r6, .L69+20
 172:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 173:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (in_flight) {
 452              		.loc 4 173 0
 453 0034 0029     		cmp	r1, #0
 454 0036 00F0CB80 		beq	.L41
 455              	.LBB52:
 174:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* calculate dt for yaw integration */
 175:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float dt = get_sys_time_float() - last_ts;
 456              		.loc 4 175 0
 457 003a FFF7FEFF 		bl	get_sys_time_float
 458              	.LVL30:
 459 003e 96ED008A 		flds	s16, [r6]
 460 0042 30EE488A 		fsubs	s16, s0, s16
 461              	.LVL31:
 176:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* make sure nothing drastically weird happens, bound dt to 0.5sec */
 177:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     Bound(dt, 0, 0.5);
 462              		.loc 4 177 0
 463 0046 F6EE007A 		fconsts	s15, #96
 464 004a B4EEE78A 		fcmpes	s16, s15
 465 004e F1EE10FA 		fmstat
 466 0052 09DC     		bgt	.L61
 467              		.loc 4 177 0 is_stmt 0 discriminator 2
 468 0054 B5EE408A 		fcmpzs	s16
 469 0058 DFED6D7A 		flds	s15, .L69+24
 470 005c F1EE10FA 		fmstat
 471 0060 48BF     		it	mi
 472 0062 B0EE678A 		fcpysmi	s16, s15
 473              	.LVL32:
 474 0066 01E0     		b	.L42
 475              	.LVL33:
 476              	.L61:
 477              		.loc 4 177 0
 478 0068 B0EE678A 		fcpys	s16, s15
 479              	.LVL34:
 480              	.L42:
 178:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 179:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* do not advance yaw setpoint if within a small deadband around stick center or if throttle is
 180:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (YAW_DEADBAND_EXCEEDED() && !THROTTLE_STICK_DOWN()) {
 481              		.loc 4 180 0 is_stmt 1
 482 006c B8F80C10 		ldrh	r1, [r8, #12]
 483 0070 01F1FA03 		add	r3, r1, #250
 484 0074 9BB2     		uxth	r3, r3
 485 0076 B3F5FA7F 		cmp	r3, #500
 486 007a 02D8     		bhi	.L43
 487              	.L46:
 181:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw() * dt;
 182:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(sp->psi);
 183:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 184:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (coordinated_turn) {
 488              		.loc 4 184 0
 489 007c 002F     		cmp	r7, #0
 490 007e 38D1     		bne	.L44
 491 0080 6EE0     		b	.L45
 492              	.L43:
 180:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (YAW_DEADBAND_EXCEEDED() && !THROTTLE_STICK_DOWN()) {
 493              		.loc 4 180 0 discriminator 1
 494 0082 614B     		ldr	r3, .L69+16
 495 0084 B3F90A30 		ldrsh	r3, [r3, #10]
 496 0088 B3F5F07F 		cmp	r3, #480
 497 008c F6DB     		blt	.L46
 181:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw() * dt;
 498              		.loc 4 181 0
 499 008e D4ED026A 		flds	s13, [r4, #8]	@ int
 500              	.LBB53:
 501              	.LBB54:
  78:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t yaw = radio_control.values[RADIO_YAW];
 502              		.loc 4 78 0
 503 0092 09B2     		sxth	r1, r1
  79:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
 504              		.loc 4 79 0
 505 0094 FA29     		cmp	r1, #250
 506              	.LBE54:
 507              	.LBE53:
 181:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw() * dt;
 508              		.loc 4 181 0
 509 0096 F8EEE67A 		fsitos	s15, s13
 510              	.LVL35:
 511              	.LBB56:
 512              	.LBB55:
  79:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
 513              		.loc 4 79 0
 514 009a 01DD     		ble	.L47
 515 009c FA39     		subs	r1, r1, #250
 516              	.LVL36:
 517 009e 04E0     		b	.L48
 518              	.L47:
 519 00a0 11F1FA0F 		cmn	r1, #250
 520 00a4 B4BF     		ite	lt
 521 00a6 FA31     		addlt	r1, r1, #250
 522              	.LVL37:
 523 00a8 0021     		movge	r1, #0
 524              	.LVL38:
 525              	.L48:
  80:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return yaw * max_rc_r / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_R);
 526              		.loc 4 80 0
 527 00aa 41F62113 		movw	r3, #6433
 528 00ae 5943     		muls	r1, r3, r1
 529              	.LVL39:
 530 00b0 42F28643 		movw	r3, #9350
 531 00b4 91FBF3F1 		sdiv	r1, r1, r3
 532              	.LBE55:
 533              	.LBE56:
 181:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw() * dt;
 534              		.loc 4 181 0
 535 00b8 06EE901A 		fmsr	s13, r1	@ int
 536 00bc B8EEE67A 		fsitos	s14, s13
 537 00c0 E7EE087A 		vfma.f32	s15, s14, s16
 538 00c4 FDEEE77A 		ftosizs	s15, s15
 539 00c8 C4ED027A 		fsts	s15, [r4, #8]	@ int
 540              	.L49:
 182:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(sp->psi);
 541              		.loc 4 182 0 discriminator 1
 542 00cc A268     		ldr	r2, [r4, #8]
 543 00ce 43F24323 		movw	r3, #12867
 544 00d2 9A42     		cmp	r2, r3
 545 00d4 04DD     		ble	.L51
 182:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(sp->psi);
 546              		.loc 4 182 0 is_stmt 0 discriminator 2
 547 00d6 A2F5C942 		sub	r2, r2, #25728
 548 00da 073A     		subs	r2, r2, #7
 549 00dc A260     		str	r2, [r4, #8]
 550 00de F5E7     		b	.L49
 551              	.L51:
 182:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(sp->psi);
 552              		.loc 4 182 0 discriminator 1
 553 00e0 A168     		ldr	r1, [r4, #8]
 554 00e2 4C4B     		ldr	r3, .L69+28
 555 00e4 9942     		cmp	r1, r3
 556 00e6 C9DA     		bge	.L46
 182:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(sp->psi);
 557              		.loc 4 182 0 discriminator 2
 558 00e8 01F5C941 		add	r1, r1, #25728
 559 00ec 0731     		adds	r1, r1, #7
 560 00ee A160     		str	r1, [r4, #8]
 561 00f0 F6E7     		b	.L51
 562              	.LVL40:
 563              	.L44:
 564              	.LBB57:
 185:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //Coordinated turn
 186:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //feedforward estimate angular rotation omega = g*tan(phi)/v
 187:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //Take v = 9.81/1.3 m/s
 188:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       int32_t omega;
 189:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       const int32_t max_phi = ANGLE_BFP_OF_REAL(RadOfDeg(85.0));
 190:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       if (abs(sp->phi) < max_phi) {
 565              		.loc 4 190 0 is_stmt 1
 566 00f2 2068     		ldr	r0, [r4]
 567 00f4 00F5BD53 		add	r3, r0, #6048
 568 00f8 1B33     		adds	r3, r3, #27
 569 00fa 42F67672 		movw	r2, #12150
 570 00fe 9342     		cmp	r3, r2
 571 0100 0DD8     		bhi	.L53
 191:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****         omega = ANGLE_BFP_OF_REAL(1.3 * tanf(ANGLE_FLOAT_OF_BFP(sp->phi)));
 572              		.loc 4 191 0
 573 0102 07EE100A 		fmsr	s14, r0	@ int
 574 0106 BAEECA7A 		vcvt.f32.s32	s14, s14, #12
 575 010a 17EE100A 		fmrs	r0, s14
 576 010e FFF7FEFF 		bl	tanf
 577              	.LVL41:
 578 0112 FFF7FEFF 		bl	__aeabi_f2d
 579              	.LVL42:
 580 0116 38A3     		adr	r3, .L69
 581 0118 D3E90023 		ldrd	r2, [r3]
 582 011c 0AE0     		b	.L67
 583              	.L53:
 192:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       } else { //max 60 degrees roll, then take constant omega
 193:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****         omega = ANGLE_BFP_OF_REAL(1.3 * 1.72305 * ((sp->phi > 0) - (sp->phi < 0)));
 584              		.loc 4 193 0
 585 011e C30F     		lsrs	r3, r0, #31
 586 0120 0028     		cmp	r0, #0
 587 0122 D4BF     		ite	le
 588 0124 5842     		rsble	r0, r3, #0
 589 0126 C3F10100 		rsbgt	r0, r3, #1
 590 012a FFF7FEFF 		bl	__aeabi_i2d
 591              	.LVL43:
 592 012e 34A3     		adr	r3, .L69+8
 593 0130 D3E90023 		ldrd	r2, [r3]
 594              	.L67:
 595 0134 FFF7FEFF 		bl	__aeabi_dmul
 596              	.LVL44:
 597 0138 0022     		movs	r2, #0
 598 013a 374B     		ldr	r3, .L69+32
 599 013c FFF7FEFF 		bl	__aeabi_dmul
 600              	.LVL45:
 601 0140 FFF7FEFF 		bl	__aeabi_d2iz
 602              	.LVL46:
 194:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       }
 195:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 196:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += omega * dt;
 603              		.loc 4 196 0
 604 0144 D4ED026A 		flds	s13, [r4, #8]	@ int
 605 0148 07EE900A 		fmsr	s15, r0	@ int
 606 014c B8EEE77A 		fsitos	s14, s15
 607 0150 F8EEE67A 		fsitos	s15, s13
 608 0154 E7EE087A 		vfma.f32	s15, s14, s16
 609 0158 FDEEE77A 		ftosizs	s15, s15
 610 015c C4ED027A 		fsts	s15, [r4, #8]	@ int
 611              	.LVL47:
 612              	.L45:
 613              	.LBE57:
 197:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 198:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #ifdef STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT
 199:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     // Make sure the yaw setpoint does not differ too much from the real yaw
 200:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     // to prevent a sudden switch at 180 deg
 201:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     const int32_t delta_limit = ANGLE_BFP_OF_REAL(STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT);
 202:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 203:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     int32_t heading = stabilization_attitude_get_heading_i();
 204:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 205:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     int32_t delta_psi = sp->psi - heading;
 206:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     INT32_ANGLE_NORMALIZE(delta_psi);
 207:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (delta_psi > delta_limit) {
 208:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi = heading + delta_limit;
 209:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     } else if (delta_psi < -delta_limit) {
 210:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi = heading - delta_limit;
 211:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 212:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     INT32_ANGLE_NORMALIZE(sp->psi);
 213:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 214:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     //Care Free mode
 215:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (in_carefree) {
 614              		.loc 4 215 0
 615 0160 002D     		cmp	r5, #0
 616 0162 41D0     		beq	.L55
 617              	.LBB58:
 216:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //care_free_heading has been set to current psi when entering care free mode.
 217:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       int32_t cos_psi;
 218:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       int32_t sin_psi;
 219:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       int32_t temp_theta;
 220:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       int32_t care_free_delta_psi_i;
 221:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 222:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       care_free_delta_psi_i = sp->psi - ANGLE_BFP_OF_REAL(care_free_heading);
 618              		.loc 4 222 0
 619 0164 94ED027A 		flds	s14, [r4, #8]	@ int
 620 0168 2C4B     		ldr	r3, .L69+36
 621 016a F8EEC77A 		fsitos	s15, s14
 622 016e D3ED006A 		flds	s13, [r3]
 623 0172 9FED2B7A 		flds	s14, .L69+40
 624 0176 E6EEC77A 		vfms.f32	s15, s13, s14
 625 017a FDEEE77A 		ftosizs	s15, s15
 626 017e 17EE905A 		fmrs	r5, s15	@ int
 627              	.LVL48:
 628              	.L56:
 223:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 224:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       INT32_ANGLE_NORMALIZE(care_free_delta_psi_i);
 629              		.loc 4 224 0 discriminator 1
 630 0182 43F24323 		movw	r3, #12867
 631 0186 9D42     		cmp	r5, r3
 632 0188 03DD     		ble	.L58
 633              		.loc 4 224 0 is_stmt 0 discriminator 2
 634 018a A5F5C945 		sub	r5, r5, #25728
 635              	.LVL49:
 636 018e 073D     		subs	r5, r5, #7
 637              	.LVL50:
 638 0190 F7E7     		b	.L56
 639              	.L58:
 640              		.loc 4 224 0 discriminator 1
 641 0192 204B     		ldr	r3, .L69+28
 642 0194 9D42     		cmp	r5, r3
 643 0196 03DA     		bge	.L68
 644              		.loc 4 224 0 discriminator 2
 645 0198 05F5C945 		add	r5, r5, #25728
 646              	.LVL51:
 647 019c 0735     		adds	r5, r5, #7
 648              	.LVL52:
 649 019e F8E7     		b	.L58
 650              	.L68:
 225:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 226:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       PPRZ_ITRIG_SIN(sin_psi, care_free_delta_psi_i);
 651              		.loc 4 226 0 is_stmt 1
 652 01a0 2846     		mov	r0, r5
 653 01a2 FFF7FEFF 		bl	pprz_itrig_sin
 654              	.LVL53:
 655 01a6 0746     		mov	r7, r0
 656              	.LVL54:
 227:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       PPRZ_ITRIG_COS(cos_psi, care_free_delta_psi_i);
 657              		.loc 4 227 0
 658 01a8 2846     		mov	r0, r5
 659              	.LVL55:
 660 01aa FFF7FEFF 		bl	pprz_itrig_cos
 661              	.LVL56:
 228:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 229:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = INT_MULT_RSHIFT(cos_psi, sp->theta, INT32_ANGLE_FRAC) - INT_MULT_RSHIFT(sin_psi,
 662              		.loc 4 229 0
 663 01ae 6268     		ldr	r2, [r4, #4]
 664 01b0 2368     		ldr	r3, [r4]
 665              	.LVL57:
 230:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****                    INT32_ANGLE_FRAC);
 231:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->phi = INT_MULT_RSHIFT(cos_psi, sp->phi, INT32_ANGLE_FRAC) - INT_MULT_RSHIFT(sin_psi, sp->
 666              		.loc 4 231 0
 667 01b2 02FB07F1 		mul	r1, r2, r7
 668 01b6 03FB00F5 		mul	r5, r3, r0
 669              	.LVL58:
 229:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = INT_MULT_RSHIFT(cos_psi, sp->theta, INT32_ANGLE_FRAC) - INT_MULT_RSHIFT(sin_psi,
 670              		.loc 4 229 0
 671 01ba 7B43     		muls	r3, r7, r3
 672              	.LVL59:
 673              		.loc 4 231 0
 674 01bc 0913     		asrs	r1, r1, #12
 229:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = INT_MULT_RSHIFT(cos_psi, sp->theta, INT32_ANGLE_FRAC) - INT_MULT_RSHIFT(sin_psi,
 675              		.loc 4 229 0
 676 01be 4243     		muls	r2, r0, r2
 677              	.LVL60:
 678 01c0 1B13     		asrs	r3, r3, #12
 679              		.loc 4 231 0
 680 01c2 C1EB2531 		rsb	r1, r1, r5, asr #12
 229:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = INT_MULT_RSHIFT(cos_psi, sp->theta, INT32_ANGLE_FRAC) - INT_MULT_RSHIFT(sin_psi,
 681              		.loc 4 229 0
 682 01c6 C3EB2232 		rsb	r2, r3, r2, asr #12
 683              	.LVL61:
 684              		.loc 4 231 0
 685 01ca 2160     		str	r1, [r4]
 232:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 233:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->theta = temp_theta;
 686              		.loc 4 233 0
 687 01cc 6260     		str	r2, [r4, #4]
 688 01ce 0BE0     		b	.L55
 689              	.LVL62:
 690              	.L41:
 691              	.LBE58:
 692              	.LBE52:
 693              	.LBB59:
 694              	.LBB60:
 695              	.LBB61:
 210:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_I)) {
 696              		.loc 3 210 0
 697 01d0 144D     		ldr	r5, .L69+44
 698 01d2 95F8A431 		ldrb	r3, [r5, #420]	@ zero_extendqisi2
 699              	.LVL63:
 700 01d6 9B07     		lsls	r3, r3, #30
 701 01d8 03D4     		bmi	.L60
 211:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_i(orientation);
 702              		.loc 3 211 0
 703 01da 05F5D270 		add	r0, r5, #420
 704              	.LVL64:
 705 01de FFF7FEFF 		bl	orientationCalcEulers_i
 706              	.LVL65:
 707              	.L60:
 708              	.LBE61:
 709              	.LBE60:
 710              	.LBE59:
 234:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 235:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else { /* if not flying, use current yaw as setpoint */
 236:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     sp->psi = stateGetNedToBodyEulers_i()->psi;
 711              		.loc 4 236 0
 712 01e2 D5F8C031 		ldr	r3, [r5, #448]
 713 01e6 A360     		str	r3, [r4, #8]
 714              	.LVL66:
 715              	.L55:
 237:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 238:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 239:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* update timestamp for dt calculation */
 240:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   last_ts = get_sys_time_float();
 716              		.loc 4 240 0
 717 01e8 FFF7FEFF 		bl	get_sys_time_float
 718              	.LVL67:
 241:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 719              		.loc 4 241 0
 720 01ec BDEC028B 		fldmfdd	sp!, {d8}
 240:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   last_ts = get_sys_time_float();
 721              		.loc 4 240 0
 722 01f0 86ED000A 		fsts	s0, [r6]
 723              		.loc 4 241 0
 724 01f4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 725              	.LVL68:
 726              	.L70:
 727              		.align	3
 728              	.L69:
 729 01f8 CDCCCCCC 		.word	-858993459
 730 01fc CCCCF43F 		.word	1073007820
 731 0200 257A19C5 		.word	-988186075
 732 0204 72EB0140 		.word	1073867634
 733 0208 00000000 		.word	radio_control
 734 020c 00000000 		.word	.LANCHOR1
 735 0210 00000000 		.word	0
 736 0214 BDCDFFFF 		.word	-12867
 737 0218 0000B040 		.word	1085276160
 738 021c 00000000 		.word	.LANCHOR0
 739 0220 00008045 		.word	1166016512
 740 0224 00000000 		.word	state
 741              		.cfi_endproc
 742              	.LFE178:
 744              		.global	__aeabi_ddiv
 745              		.global	__aeabi_d2f
 746              		.global	__aeabi_dsub
 747              		.global	__aeabi_dcmpgt
 748              		.global	__aeabi_dadd
 749              		.section	.text.stabilization_attitude_read_rc_setpoint_eulers_f,"ax",%progbits
 750              		.align	1
 751              		.global	stabilization_attitude_read_rc_setpoint_eulers_f
 752              		.thumb
 753              		.thumb_func
 755              	stabilization_attitude_read_rc_setpoint_eulers_f:
 756              	.LFB179:
 242:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 243:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 244:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_setpoint_eulers_f(struct FloatEulers *sp, bool_t in_flight, boo
 245:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     bool_t coordinated_turn)
 246:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 757              		.loc 4 246 0
 758              		.cfi_startproc
 759              		@ args = 0, pretend = 0, frame = 0
 760              		@ frame_needed = 0, uses_anonymous_args = 0
 761              	.LVL69:
 762 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 763              		.cfi_def_cfa_offset 32
 764              		.cfi_offset 3, -32
 765              		.cfi_offset 4, -28
 766              		.cfi_offset 5, -24
 767              		.cfi_offset 6, -20
 768              		.cfi_offset 7, -16
 769              		.cfi_offset 8, -12
 770              		.cfi_offset 9, -8
 771              		.cfi_offset 14, -4
 772              	.LBB73:
 773              	.LBB74:
  85:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
 774              		.loc 4 85 0
 775 0004 AE4C     		ldr	r4, .L102+64
 776 0006 AF4F     		ldr	r7, .L102+68
 777              	.LBE74:
 778              	.LBE73:
 779              		.loc 4 246 0
 780 0008 2DED028B 		fstmfdd	sp!, {d8}
 781              		.cfi_def_cfa_offset 40
 782              		.cfi_offset 80, -40
 783              		.loc 4 246 0
 784 000c 0646     		mov	r6, r0
 785              	.LBB77:
 786              	.LBB75:
  90:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / MAX_PPRZ;
 787              		.loc 4 90 0
 788 000e B4F90600 		ldrsh	r0, [r4, #6]
 789              	.LVL70:
 790              	.LBE75:
 791              	.LBE77:
 792              		.loc 4 246 0
 793 0012 9046     		mov	r8, r2
 794 0014 9946     		mov	r9, r3
 795 0016 0D46     		mov	r5, r1
 796              	.LBB78:
 797              	.LBB76:
  90:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / MAX_PPRZ;
 798              		.loc 4 90 0
 799 0018 FFF7FEFF 		bl	__aeabi_i2d
 800              	.LVL71:
 801 001c 98A3     		adr	r3, .L102
 802 001e D3E90023 		ldrd	r2, [r3]
 803 0022 FFF7FEFF 		bl	__aeabi_dmul
 804              	.LVL72:
 805 0026 0022     		movs	r2, #0
 806 0028 A74B     		ldr	r3, .L102+72
 807 002a FFF7FEFF 		bl	__aeabi_ddiv
 808              	.LVL73:
 809 002e FFF7FEFF 		bl	__aeabi_d2f
 810              	.LVL74:
 811 0032 3060     		str	r0, [r6]	@ float
 812              	.LVL75:
 813              	.LBE76:
 814              	.LBE78:
 815              	.LBB79:
 816              	.LBB80:
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 817              		.loc 4 101 0
 818 0034 B4F90800 		ldrsh	r0, [r4, #8]
 819 0038 FFF7FEFF 		bl	__aeabi_i2d
 820              	.LVL76:
 821 003c 90A3     		adr	r3, .L102
 822 003e D3E90023 		ldrd	r2, [r3]
 823 0042 FFF7FEFF 		bl	__aeabi_dmul
 824              	.LVL77:
 825 0046 0022     		movs	r2, #0
 826 0048 9F4B     		ldr	r3, .L102+72
 827 004a FFF7FEFF 		bl	__aeabi_ddiv
 828              	.LVL78:
 829 004e FFF7FEFF 		bl	__aeabi_d2f
 830              	.LVL79:
 831 0052 7060     		str	r0, [r6, #4]	@ float
 832              	.LBE80:
 833              	.LBE79:
 247:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* last time this function was called, used to calculate yaw setpoint update */
 248:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   static float last_ts = 0.f;
 249:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 250:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   sp->phi = get_rc_roll_f();
 251:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   sp->theta = get_rc_pitch_f();
 252:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 253:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (in_flight) {
 834              		.loc 4 253 0
 835 0054 002D     		cmp	r5, #0
 836 0056 00F00681 		beq	.L72
 837              	.LBB81:
 254:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* calculate dt for yaw integration */
 255:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float dt = get_sys_time_float() - last_ts;
 838              		.loc 4 255 0
 839 005a FFF7FEFF 		bl	get_sys_time_float
 840              	.LVL80:
 841 005e 97ED008A 		flds	s16, [r7]
 842 0062 30EE488A 		fsubs	s16, s0, s16
 843              	.LVL81:
 256:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* make sure nothing drastically weird happens, bound dt to 0.5sec */
 257:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     Bound(dt, 0, 0.5);
 844              		.loc 4 257 0
 845 0066 F6EE007A 		fconsts	s15, #96
 846 006a B4EEE78A 		fcmpes	s16, s15
 847 006e F1EE10FA 		fmstat
 848 0072 09DC     		bgt	.L92
 849              		.loc 4 257 0 is_stmt 0 discriminator 2
 850 0074 B5EE408A 		fcmpzs	s16
 851 0078 DFED947A 		flds	s15, .L102+76
 852 007c F1EE10FA 		fmstat
 853 0080 48BF     		it	mi
 854 0082 B0EE678A 		fcpysmi	s16, s15
 855              	.LVL82:
 856 0086 01E0     		b	.L73
 857              	.LVL83:
 858              	.L92:
 859              		.loc 4 257 0
 860 0088 B0EE678A 		fcpys	s16, s15
 861              	.LVL84:
 862              	.L73:
 258:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 259:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* do not advance yaw setpoint if within a small deadband around stick center or if throttle is
 260:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (YAW_DEADBAND_EXCEEDED() && !THROTTLE_STICK_DOWN()) {
 863              		.loc 4 260 0 is_stmt 1
 864 008c A089     		ldrh	r0, [r4, #12]
 865 008e 00F1FA03 		add	r3, r0, #250
 866 0092 9BB2     		uxth	r3, r3
 867 0094 B3F5FA7F 		cmp	r3, #500
 868 0098 03D8     		bhi	.L74
 869              	.L77:
 261:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw_f() * dt;
 262:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(sp->psi);
 263:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 264:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (coordinated_turn) {
 870              		.loc 4 264 0
 871 009a B9F1000F 		cmp	r9, #0
 872 009e 53D1     		bne	.L75
 873 00a0 8AE0     		b	.L76
 874              	.L74:
 260:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (YAW_DEADBAND_EXCEEDED() && !THROTTLE_STICK_DOWN()) {
 875              		.loc 4 260 0 discriminator 1
 876 00a2 874B     		ldr	r3, .L102+64
 877 00a4 B3F90A30 		ldrsh	r3, [r3, #10]
 878 00a8 B3F5F07F 		cmp	r3, #480
 879 00ac F5DB     		blt	.L77
 880              	.LBB82:
 881              	.LBB83:
 107:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t yaw = radio_control.values[RADIO_YAW];
 882              		.loc 4 107 0
 883 00ae 00B2     		sxth	r0, r0
 884              	.LVL85:
 108:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
 885              		.loc 4 108 0
 886 00b0 FA28     		cmp	r0, #250
 887              	.LBE83:
 888              	.LBE82:
 261:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw_f() * dt;
 889              		.loc 4 261 0
 890 00b2 D6ED028A 		flds	s17, [r6, #8]
 891              	.LBB85:
 892              	.LBB84:
 108:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   DeadBand(yaw, STABILIZATION_ATTITUDE_DEADBAND_R);
 893              		.loc 4 108 0
 894 00b6 01DD     		ble	.L78
 895 00b8 FA38     		subs	r0, r0, #250
 896              	.LVL86:
 897 00ba 04E0     		b	.L79
 898              	.L78:
 899 00bc 10F1FA0F 		cmn	r0, #250
 900 00c0 B4BF     		ite	lt
 901 00c2 FA30     		addlt	r0, r0, #250
 902              	.LVL87:
 903 00c4 0020     		movge	r0, #0
 904              	.LVL88:
 905              	.L79:
 109:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return yaw * STABILIZATION_ATTITUDE_SP_MAX_R / (MAX_PPRZ - STABILIZATION_ATTITUDE_DEADBAND_R);
 906              		.loc 4 109 0
 907 00c6 FFF7FEFF 		bl	__aeabi_i2d
 908              	.LVL89:
 909 00ca 6FA3     		adr	r3, .L102+8
 910 00cc D3E90023 		ldrd	r2, [r3]
 911 00d0 FFF7FEFF 		bl	__aeabi_dmul
 912              	.LVL90:
 913 00d4 6EA3     		adr	r3, .L102+16
 914 00d6 D3E90023 		ldrd	r2, [r3]
 915 00da FFF7FEFF 		bl	__aeabi_ddiv
 916              	.LVL91:
 917 00de FFF7FEFF 		bl	__aeabi_d2f
 918              	.LVL92:
 919              	.LBE84:
 920              	.LBE85:
 261:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += get_rc_yaw_f() * dt;
 921              		.loc 4 261 0
 922 00e2 07EE900A 		fmsr	s15, r0
 923 00e6 E7EE888A 		vfma.f32	s17, s15, s16
 924 00ea C6ED028A 		fsts	s17, [r6, #8]
 925              	.L80:
 262:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(sp->psi);
 926              		.loc 4 262 0 discriminator 1
 927 00ee B068     		ldr	r0, [r6, #8]	@ float
 928 00f0 FFF7FEFF 		bl	__aeabi_f2d
 929              	.LVL93:
 930 00f4 68A3     		adr	r3, .L102+24
 931 00f6 D3E90023 		ldrd	r2, [r3]
 932 00fa 0446     		mov	r4, r0
 933 00fc 0D46     		mov	r5, r1
 934 00fe FFF7FEFF 		bl	__aeabi_dcmpgt
 935              	.LVL94:
 936 0102 50B1     		cbz	r0, .L82
 262:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(sp->psi);
 937              		.loc 4 262 0 is_stmt 0 discriminator 2
 938 0104 66A3     		adr	r3, .L102+32
 939 0106 D3E90023 		ldrd	r2, [r3]
 940 010a 2046     		mov	r0, r4
 941 010c 2946     		mov	r1, r5
 942 010e FFF7FEFF 		bl	__aeabi_dsub
 943              	.LVL95:
 944 0112 FFF7FEFF 		bl	__aeabi_d2f
 945              	.LVL96:
 946 0116 B060     		str	r0, [r6, #8]	@ float
 947 0118 E9E7     		b	.L80
 948              	.L82:
 262:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(sp->psi);
 949              		.loc 4 262 0 discriminator 1
 950 011a B068     		ldr	r0, [r6, #8]	@ float
 951 011c FFF7FEFF 		bl	__aeabi_f2d
 952              	.LVL97:
 953 0120 61A3     		adr	r3, .L102+40
 954 0122 D3E90023 		ldrd	r2, [r3]
 955 0126 0446     		mov	r4, r0
 956 0128 0D46     		mov	r5, r1
 957 012a FFF7FEFF 		bl	__aeabi_dcmplt
 958              	.LVL98:
 959 012e 0028     		cmp	r0, #0
 960 0130 B3D0     		beq	.L77
 262:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(sp->psi);
 961              		.loc 4 262 0 discriminator 2
 962 0132 5BA3     		adr	r3, .L102+32
 963 0134 D3E90023 		ldrd	r2, [r3]
 964 0138 2046     		mov	r0, r4
 965 013a 2946     		mov	r1, r5
 966 013c FFF7FEFF 		bl	__aeabi_dadd
 967              	.LVL99:
 968 0140 FFF7FEFF 		bl	__aeabi_d2f
 969              	.LVL100:
 970 0144 B060     		str	r0, [r6, #8]	@ float
 971 0146 E8E7     		b	.L82
 972              	.L75:
 973              	.LVL101:
 974              	.LBB86:
 265:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //Coordinated turn
 266:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //feedforward estimate angular rotation omega = g*tan(phi)/v
 267:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //Take v = 9.81/1.3 m/s
 268:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       float omega;
 269:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       const float max_phi = RadOfDeg(85.0);
 270:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       if (abs(sp->phi) < max_phi) {
 975              		.loc 4 270 0 is_stmt 1
 976 0148 D6ED007A 		flds	s15, [r6]
 977 014c 9FED607A 		flds	s14, .L102+80
 978 0150 FDEEE76A 		ftosizs	s13, s15
 979 0154 16EE903A 		fmrs	r3, s13	@ int
 980 0158 002B     		cmp	r3, #0
 981 015a B8BF     		it	lt
 982 015c 5B42     		rsblt	r3, r3, #0
 983 015e 06EE903A 		fmsr	s13, r3	@ int
 984 0162 F8EEE66A 		fsitos	s13, s13
 985 0166 F4EEC76A 		fcmpes	s13, s14
 986 016a F1EE10FA 		fmstat
 987 016e 09D5     		bpl	.L99
 271:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****         omega = 1.3 * tanf(sp->phi);
 988              		.loc 4 271 0
 989 0170 17EE900A 		fmrs	r0, s15
 990 0174 FFF7FEFF 		bl	tanf
 991              	.LVL102:
 992 0178 FFF7FEFF 		bl	__aeabi_f2d
 993              	.LVL103:
 994 017c 4CA3     		adr	r3, .L102+48
 995 017e D3E90023 		ldrd	r2, [r3]
 996 0182 0DE0     		b	.L100
 997              	.L99:
 272:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       } else { //max 60 degrees roll, then take constant omega
 273:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****         omega = 1.3 * 1.72305 * ((sp->phi > 0) - (sp->phi < 0));
 998              		.loc 4 273 0
 999 0184 F5EEC07A 		fcmpezs	s15
 1000 0188 F1EE10FA 		fmstat
 1001 018c D4BF     		ite	le
 1002 018e 0020     		movle	r0, #0
 1003 0190 0120     		movgt	r0, #1
 1004 0192 48BF     		it	mi
 1005 0194 0138     		submi	r0, r0, #1
 1006 0196 FFF7FEFF 		bl	__aeabi_i2d
 1007              	.LVL104:
 1008 019a 47A3     		adr	r3, .L102+56
 1009 019c D3E90023 		ldrd	r2, [r3]
 1010              	.L100:
 1011 01a0 FFF7FEFF 		bl	__aeabi_dmul
 1012              	.LVL105:
 1013 01a4 FFF7FEFF 		bl	__aeabi_d2f
 1014              	.LVL106:
 274:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       }
 275:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 276:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi += omega * dt;
 1015              		.loc 4 276 0
 1016 01a8 D6ED027A 		flds	s15, [r6, #8]
 273:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****         omega = 1.3 * 1.72305 * ((sp->phi > 0) - (sp->phi < 0));
 1017              		.loc 4 273 0
 1018 01ac 07EE100A 		fmsr	s14, r0
 1019              	.LVL107:
 1020              		.loc 4 276 0
 1021 01b0 E7EE087A 		vfma.f32	s15, s14, s16
 1022 01b4 C6ED027A 		fsts	s15, [r6, #8]
 1023              	.LVL108:
 1024              	.L76:
 1025              	.LBE86:
 277:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 278:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #ifdef STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT
 279:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     // Make sure the yaw setpoint does not differ too much from the real yaw
 280:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     // to prevent a sudden switch at 180 deg
 281:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float heading = stabilization_attitude_get_heading_f();
 282:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 283:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float delta_psi = sp->psi - heading;
 284:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     FLOAT_ANGLE_NORMALIZE(delta_psi);
 285:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (delta_psi > STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT) {
 286:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi = heading + STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT;
 287:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     } else if (delta_psi < -STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT) {
 288:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->psi = heading - STABILIZATION_ATTITUDE_SP_PSI_DELTA_LIMIT;
 289:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 290:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     FLOAT_ANGLE_NORMALIZE(sp->psi);
 291:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 292:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     //Care Free mode
 293:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     if (in_carefree) {
 1026              		.loc 4 293 0
 1027 01b8 B8F1000F 		cmp	r8, #0
 1028 01bc 57D0     		beq	.L87
 1029              	.LBB87:
 294:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       //care_free_heading has been set to current psi when entering care free mode.
 295:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       float cos_psi;
 296:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       float sin_psi;
 297:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       float temp_theta;
 298:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 299:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       float care_free_delta_psi_f = sp->psi - care_free_heading;
 1030              		.loc 4 299 0
 1031 01be 454B     		ldr	r3, .L102+84
 1032 01c0 96ED028A 		flds	s16, [r6, #8]
 1033              	.LVL109:
 1034 01c4 D3ED007A 		flds	s15, [r3]
 1035 01c8 38EE678A 		fsubs	s16, s16, s15
 1036              	.LVL110:
 1037              	.L88:
 300:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 301:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       FLOAT_ANGLE_NORMALIZE(care_free_delta_psi_f);
 1038              		.loc 4 301 0 discriminator 1
 1039 01cc 18EE100A 		fmrs	r0, s16
 1040 01d0 FFF7FEFF 		bl	__aeabi_f2d
 1041              	.LVL111:
 1042 01d4 30A3     		adr	r3, .L102+24
 1043 01d6 D3E90023 		ldrd	r2, [r3]
 1044 01da 0446     		mov	r4, r0
 1045 01dc 0D46     		mov	r5, r1
 1046 01de FFF7FEFF 		bl	__aeabi_dcmpgt
 1047              	.LVL112:
 1048 01e2 58B1     		cbz	r0, .L90
 1049              		.loc 4 301 0 is_stmt 0 discriminator 2
 1050 01e4 2EA3     		adr	r3, .L102+32
 1051 01e6 D3E90023 		ldrd	r2, [r3]
 1052 01ea 2046     		mov	r0, r4
 1053 01ec 2946     		mov	r1, r5
 1054 01ee FFF7FEFF 		bl	__aeabi_dsub
 1055              	.LVL113:
 1056 01f2 FFF7FEFF 		bl	__aeabi_d2f
 1057              	.LVL114:
 1058 01f6 08EE100A 		fmsr	s16, r0
 1059              	.LVL115:
 1060 01fa E7E7     		b	.L88
 1061              	.LVL116:
 1062              	.L90:
 1063              		.loc 4 301 0 discriminator 1
 1064 01fc 18EE100A 		fmrs	r0, s16
 1065 0200 FFF7FEFF 		bl	__aeabi_f2d
 1066              	.LVL117:
 1067 0204 28A3     		adr	r3, .L102+40
 1068 0206 D3E90023 		ldrd	r2, [r3]
 1069 020a 0446     		mov	r4, r0
 1070 020c 0D46     		mov	r5, r1
 1071 020e FFF7FEFF 		bl	__aeabi_dcmplt
 1072              	.LVL118:
 1073 0212 58B1     		cbz	r0, .L101
 1074              		.loc 4 301 0 discriminator 2
 1075 0214 22A3     		adr	r3, .L102+32
 1076 0216 D3E90023 		ldrd	r2, [r3]
 1077 021a 2046     		mov	r0, r4
 1078 021c 2946     		mov	r1, r5
 1079 021e FFF7FEFF 		bl	__aeabi_dadd
 1080              	.LVL119:
 1081 0222 FFF7FEFF 		bl	__aeabi_d2f
 1082              	.LVL120:
 1083 0226 08EE100A 		fmsr	s16, r0
 1084              	.LVL121:
 1085 022a E7E7     		b	.L90
 1086              	.LVL122:
 1087              	.L101:
 302:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 303:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sin_psi = sinf(care_free_delta_psi_f);
 1088              		.loc 4 303 0 is_stmt 1
 1089 022c 18EE100A 		fmrs	r0, s16
 1090 0230 FFF7FEFF 		bl	sinf
 1091              	.LVL123:
 1092 0234 08EE900A 		fmsr	s17, r0
 1093              	.LVL124:
 304:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       cos_psi = cosf(care_free_delta_psi_f);
 1094              		.loc 4 304 0
 1095 0238 18EE100A 		fmrs	r0, s16
 1096              	.LVL125:
 1097 023c FFF7FEFF 		bl	cosf
 1098              	.LVL126:
 305:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 306:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = cos_psi * sp->theta - sin_psi * sp->phi;
 1099              		.loc 4 306 0
 1100 0240 D6ED016A 		flds	s13, [r6, #4]
 1101 0244 D6ED007A 		flds	s15, [r6]
 304:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       cos_psi = cosf(care_free_delta_psi_f);
 1102              		.loc 4 304 0
 1103 0248 06EE100A 		fmsr	s12, r0
 1104              	.LVL127:
 1105 024c 26EEE87A 		fnmuls	s14, s13, s17
 307:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->phi = cos_psi * sp->phi - sin_psi * sp->theta;
 1106              		.loc 4 307 0
 1107 0250 A6EE277A 		vfma.f32	s14, s12, s15
 1108 0254 67EEE87A 		fnmuls	s15, s15, s17
 1109              	.LVL128:
 1110 0258 86ED007A 		fsts	s14, [r6]
 1111              	.LVL129:
 306:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       temp_theta = cos_psi * sp->theta - sin_psi * sp->phi;
 1112              		.loc 4 306 0
 1113 025c E6EE267A 		vfma.f32	s15, s12, s13
 1114              	.LVL130:
 308:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 309:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****       sp->theta = temp_theta;
 1115              		.loc 4 309 0
 1116 0260 C6ED017A 		fsts	s15, [r6, #4]
 1117 0264 03E0     		b	.L87
 1118              	.LVL131:
 1119              	.L72:
 1120              	.LBE87:
 1121              	.LBE81:
 1122              	.LBB88:
 1123              	.LBB89:
 1124              		.loc 5 1116 0
 1125 0266 FFF7FEFF 		bl	orientationGetEulers_f.constprop.0
 1126              	.LVL132:
 1127              	.LBE89:
 1128              	.LBE88:
 310:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     }
 311:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else { /* if not flying, use current yaw as setpoint */
 312:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     sp->psi = stateGetNedToBodyEulers_f()->psi;
 1129              		.loc 4 312 0
 1130 026a 8368     		ldr	r3, [r0, #8]	@ float
 1131 026c B360     		str	r3, [r6, #8]	@ float
 1132              	.L87:
 313:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 314:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 315:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* update timestamp for dt calculation */
 316:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   last_ts = get_sys_time_float();
 1133              		.loc 4 316 0
 1134 026e FFF7FEFF 		bl	get_sys_time_float
 1135              	.LVL133:
 317:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 1136              		.loc 4 317 0
 1137 0272 BDEC028B 		fldmfdd	sp!, {d8}
 316:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   last_ts = get_sys_time_float();
 1138              		.loc 4 316 0
 1139 0276 87ED000A 		fsts	s0, [r7]
 1140              		.loc 4 317 0
 1141 027a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1142              	.LVL134:
 1143              	.L103:
 1144 027e 00BF     		.align	3
 1145              	.L102:
 1146 0280 F1D4C853 		.word	1405670641
 1147 0284 FB21E93F 		.word	1072243195
 1148 0288 F1D4C853 		.word	1405670641
 1149 028c FB21F93F 		.word	1073291771
 1150 0290 00000000 		.word	0
 1151 0294 0043C240 		.word	1086472960
 1152 0298 182D4454 		.word	1413754136
 1153 029c FB210940 		.word	1074340347
 1154 02a0 182D4454 		.word	1413754136
 1155 02a4 FB211940 		.word	1075388923
 1156 02a8 182D4454 		.word	1413754136
 1157 02ac FB2109C0 		.word	-1073143301
 1158 02b0 CDCCCCCC 		.word	-858993459
 1159 02b4 CCCCF43F 		.word	1073007820
 1160 02b8 257A19C5 		.word	-988186075
 1161 02bc 72EB0140 		.word	1073867634
 1162 02c0 00000000 		.word	radio_control
 1163 02c4 00000000 		.word	.LANCHOR2
 1164 02c8 00C0C240 		.word	1086504960
 1165 02cc 00000000 		.word	0
 1166 02d0 4EE4BD3F 		.word	1069409358
 1167 02d4 00000000 		.word	.LANCHOR0
 1168              		.cfi_endproc
 1169              	.LFE179:
 1171              		.section	.text.stabilization_attitude_read_rc_roll_pitch_quat_f,"ax",%progbits
 1172              		.align	1
 1173              		.global	stabilization_attitude_read_rc_roll_pitch_quat_f
 1174              		.thumb
 1175              		.thumb_func
 1177              	stabilization_attitude_read_rc_roll_pitch_quat_f:
 1178              	.LFB180:
 318:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 319:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 320:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /** Read roll/pitch command from RC as quaternion.
 321:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * Interprets the stick positions as axes.
 322:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[out] q quaternion representing the RC roll/pitch input
 323:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
 324:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_roll_pitch_quat_f(struct FloatQuat *q)
 325:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1179              		.loc 4 325 0
 1180              		.cfi_startproc
 1181              		@ args = 0, pretend = 0, frame = 16
 1182              		@ frame_needed = 0, uses_anonymous_args = 0
 1183              	.LVL135:
 1184 0000 30B5     		push	{r4, r5, lr}
 1185              		.cfi_def_cfa_offset 12
 1186              		.cfi_offset 4, -12
 1187              		.cfi_offset 5, -8
 1188              		.cfi_offset 14, -4
 1189              	.LBB94:
 1190              	.LBB95:
  85:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
 1191              		.loc 4 85 0
 1192 0002 174C     		ldr	r4, .L105+8
 1193              	.LBE95:
 1194              	.LBE94:
 1195              		.loc 4 325 0
 1196 0004 85B0     		sub	sp, sp, #20
 1197              		.cfi_def_cfa_offset 32
 1198              		.loc 4 325 0
 1199 0006 0546     		mov	r5, r0
 1200              	.LBB97:
 1201              	.LBB96:
  90:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / MAX_PPRZ;
 1202              		.loc 4 90 0
 1203 0008 B4F90600 		ldrsh	r0, [r4, #6]
 1204              	.LVL136:
 1205 000c FFF7FEFF 		bl	__aeabi_i2d
 1206              	.LVL137:
 1207 0010 11A3     		adr	r3, .L105
 1208 0012 D3E90023 		ldrd	r2, [r3]
 1209 0016 FFF7FEFF 		bl	__aeabi_dmul
 1210              	.LVL138:
 1211 001a 0022     		movs	r2, #0
 1212 001c 114B     		ldr	r3, .L105+12
 1213 001e FFF7FEFF 		bl	__aeabi_ddiv
 1214              	.LVL139:
 1215 0022 FFF7FEFF 		bl	__aeabi_d2f
 1216              	.LVL140:
 1217 0026 0190     		str	r0, [sp, #4]	@ float
 1218              	.LVL141:
 1219              	.LBE96:
 1220              	.LBE97:
 1221              	.LBB98:
 1222              	.LBB99:
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 1223              		.loc 4 101 0
 1224 0028 B4F90800 		ldrsh	r0, [r4, #8]
 1225 002c FFF7FEFF 		bl	__aeabi_i2d
 1226              	.LVL142:
 1227 0030 09A3     		adr	r3, .L105
 1228 0032 D3E90023 		ldrd	r2, [r3]
 1229 0036 FFF7FEFF 		bl	__aeabi_dmul
 1230              	.LVL143:
 1231 003a 0022     		movs	r2, #0
 1232 003c 094B     		ldr	r3, .L105+12
 1233 003e FFF7FEFF 		bl	__aeabi_ddiv
 1234              	.LVL144:
 1235 0042 FFF7FEFF 		bl	__aeabi_d2f
 1236              	.LVL145:
 1237              	.LBE99:
 1238              	.LBE98:
 326:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* orientation vector describing simultaneous rotation of roll/pitch */
 327:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatVect3 ov;
 328:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   ov.x = get_rc_roll_f();
 329:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   ov.y = get_rc_pitch_f();
 330:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   ov.z = 0.0;
 1239              		.loc 4 330 0
 1240 0046 0023     		movs	r3, #0
 1241              	.LBB101:
 1242              	.LBB100:
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 1243              		.loc 4 101 0
 1244 0048 0290     		str	r0, [sp, #8]	@ float
 1245              	.LBE100:
 1246              	.LBE101:
 331:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 332:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* quaternion from that orientation vector */
 333:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float_quat_of_orientation_vect(q, &ov);
 1247              		.loc 4 333 0
 1248 004a 01A9     		add	r1, sp, #4
 1249 004c 2846     		mov	r0, r5
 330:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   ov.z = 0.0;
 1250              		.loc 4 330 0
 1251 004e 0393     		str	r3, [sp, #12]	@ float
 1252              		.loc 4 333 0
 1253 0050 FFF7FEFF 		bl	float_quat_of_orientation_vect
 1254              	.LVL146:
 334:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 1255              		.loc 4 334 0
 1256 0054 05B0     		add	sp, sp, #20
 1257              		@ sp needed
 1258 0056 30BD     		pop	{r4, r5, pc}
 1259              	.LVL147:
 1260              	.L106:
 1261              		.align	3
 1262              	.L105:
 1263 0058 F1D4C853 		.word	1405670641
 1264 005c FB21E93F 		.word	1072243195
 1265 0060 00000000 		.word	radio_control
 1266 0064 00C0C240 		.word	1086504960
 1267              		.cfi_endproc
 1268              	.LFE180:
 1270              		.section	.text.stabilization_attitude_read_rc_roll_pitch_earth_quat_f,"ax",%progbits
 1271              		.align	1
 1272              		.global	stabilization_attitude_read_rc_roll_pitch_earth_quat_f
 1273              		.thumb
 1274              		.thumb_func
 1276              	stabilization_attitude_read_rc_roll_pitch_earth_quat_f:
 1277              	.LFB181:
 335:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 336:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /** Read roll/pitch command from RC as quaternion.
 337:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * Both angles are are interpreted relative to to the horizontal plane (earth bound).
 338:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[out] q quaternion representing the RC roll/pitch input
 339:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
 340:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_roll_pitch_earth_quat_f(struct FloatQuat *q)
 341:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1278              		.loc 4 341 0
 1279              		.cfi_startproc
 1280              		@ args = 0, pretend = 0, frame = 0
 1281              		@ frame_needed = 0, uses_anonymous_args = 0
 1282              	.LVL148:
 1283 0000 38B5     		push	{r3, r4, r5, lr}
 1284              		.cfi_def_cfa_offset 16
 1285              		.cfi_offset 3, -16
 1286              		.cfi_offset 4, -12
 1287              		.cfi_offset 5, -8
 1288              		.cfi_offset 14, -4
 1289              	.LBB106:
 1290              	.LBB107:
  85:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   int32_t roll = radio_control.values[RADIO_ROLL];
 1291              		.loc 4 85 0
 1292 0002 334D     		ldr	r5, .L108+8
 1293              	.LBE107:
 1294              	.LBE106:
 1295              		.loc 4 341 0
 1296 0004 2DED048B 		fstmfdd	sp!, {d8, d9}
 1297              		.cfi_def_cfa_offset 32
 1298              		.cfi_offset 80, -32
 1299              		.cfi_offset 82, -24
 1300              		.loc 4 341 0
 1301 0008 0446     		mov	r4, r0
 1302              	.LBB109:
 1303              	.LBB108:
  90:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return roll * STABILIZATION_ATTITUDE_SP_MAX_PHI / MAX_PPRZ;
 1304              		.loc 4 90 0
 1305 000a B5F90600 		ldrsh	r0, [r5, #6]
 1306              	.LVL149:
 1307 000e FFF7FEFF 		bl	__aeabi_i2d
 1308              	.LVL150:
 1309 0012 2DA3     		adr	r3, .L108
 1310 0014 D3E90023 		ldrd	r2, [r3]
 1311 0018 FFF7FEFF 		bl	__aeabi_dmul
 1312              	.LVL151:
 1313 001c 0022     		movs	r2, #0
 1314 001e 2D4B     		ldr	r3, .L108+12
 1315 0020 FFF7FEFF 		bl	__aeabi_ddiv
 1316              	.LVL152:
 1317 0024 FFF7FEFF 		bl	__aeabi_d2f
 1318              	.LVL153:
 1319              	.LBE108:
 1320              	.LBE109:
 342:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* only non-zero entries for roll quaternion */
 343:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float roll2 = get_rc_roll_f() / 2.0f;
 1321              		.loc 4 343 0
 1322 0028 07EE100A 		fmsr	s14, r0
 1323 002c B6EE008A 		fconsts	s16, #96
 1324 0030 27EE089A 		fmuls	s18, s14, s16
 1325              	.LVL154:
 344:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float qx_roll = sinf(roll2);
 1326              		.loc 4 344 0
 1327 0034 19EE100A 		fmrs	r0, s18
 1328 0038 FFF7FEFF 		bl	sinf
 1329              	.LVL155:
 1330 003c 08EE900A 		fmsr	s17, r0
 1331              	.LVL156:
 345:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float qi_roll = cosf(roll2);
 1332              		.loc 4 345 0
 1333 0040 19EE100A 		fmrs	r0, s18
 1334              	.LVL157:
 1335 0044 FFF7FEFF 		bl	cosf
 1336              	.LVL158:
 346:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 347:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   //An offset is added if in forward mode
 348:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* only non-zero entries for pitch quaternion */
 349:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float pitch2 = (ANGLE_FLOAT_OF_BFP(transition_theta_offset) + get_rc_pitch_f()) / 2.0f;
 1337              		.loc 4 349 0
 1338 0048 234B     		ldr	r3, .L108+16
 345:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float qi_roll = cosf(roll2);
 1339              		.loc 4 345 0
 1340 004a 09EE100A 		fmsr	s18, r0
 1341              	.LVL159:
 1342              	.LBB110:
 1343              	.LBB111:
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 1344              		.loc 4 101 0
 1345 004e B5F90800 		ldrsh	r0, [r5, #8]
 1346              	.LVL160:
 1347              	.LBE111:
 1348              	.LBE110:
 1349              		.loc 4 349 0
 1350 0052 D3ED009A 		flds	s19, [r3]	@ int
 1351              	.LBB113:
 1352              	.LBB112:
 101:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   return pitch * STABILIZATION_ATTITUDE_SP_MAX_THETA / MAX_PPRZ;
 1353              		.loc 4 101 0
 1354 0056 FFF7FEFF 		bl	__aeabi_i2d
 1355              	.LVL161:
 1356 005a 1BA3     		adr	r3, .L108
 1357 005c D3E90023 		ldrd	r2, [r3]
 1358 0060 FFF7FEFF 		bl	__aeabi_dmul
 1359              	.LVL162:
 1360 0064 0022     		movs	r2, #0
 1361 0066 1B4B     		ldr	r3, .L108+12
 1362 0068 FFF7FEFF 		bl	__aeabi_ddiv
 1363              	.LVL163:
 1364 006c FFF7FEFF 		bl	__aeabi_d2f
 1365              	.LVL164:
 1366              	.LBE112:
 1367              	.LBE113:
 1368              		.loc 4 349 0
 1369 0070 F8EEE99A 		fsitos	s19, s19
 1370 0074 DFED197A 		flds	s15, .L108+20
 1371 0078 07EE100A 		fmsr	s14, r0
 1372 007c A9EEA77A 		vfma.f32	s14, s19, s15
 1373 0080 67EE089A 		fmuls	s19, s14, s16
 1374              	.LVL165:
 350:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float qy_pitch = sinf(pitch2);
 1375              		.loc 4 350 0
 1376 0084 19EE900A 		fmrs	r0, s19
 1377 0088 FFF7FEFF 		bl	sinf
 1378              	.LVL166:
 1379 008c 08EE100A 		fmsr	s16, r0
 1380              	.LVL167:
 351:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float qi_pitch = cosf(pitch2);
 1381              		.loc 4 351 0
 1382 0090 19EE900A 		fmrs	r0, s19
 1383              	.LVL168:
 1384 0094 FFF7FEFF 		bl	cosf
 1385              	.LVL169:
 1386 0098 07EE900A 		fmsr	s15, r0
 1387              	.LVL170:
 352:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 353:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* only multiply non-zero entries of float_quat_comp(q, &q_roll, &q_pitch) */
 354:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qi = qi_roll * qi_pitch;
 1388              		.loc 4 354 0
 1389 009c 29EE277A 		fmuls	s14, s18, s15
 355:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qx = qx_roll * qi_pitch;
 356:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qy = qi_roll * qy_pitch;
 1390              		.loc 4 356 0
 1391 00a0 29EE089A 		fmuls	s18, s18, s16
 1392              	.LVL171:
 357:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qz = qx_roll * qy_pitch;
 1393              		.loc 4 357 0
 1394 00a4 28EE888A 		fmuls	s16, s17, s16
 1395              	.LVL172:
 355:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qx = qx_roll * qi_pitch;
 1396              		.loc 4 355 0
 1397 00a8 68EEA77A 		fmuls	s15, s17, s15
 356:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qy = qi_roll * qy_pitch;
 1398              		.loc 4 356 0
 1399 00ac 84ED029A 		fsts	s18, [r4, #8]
 1400              		.loc 4 357 0
 1401 00b0 84ED038A 		fsts	s16, [r4, #12]
 358:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 1402              		.loc 4 358 0
 1403 00b4 BDEC048B 		fldmfdd	sp!, {d8-d9}
 354:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qi = qi_roll * qi_pitch;
 1404              		.loc 4 354 0
 1405 00b8 84ED007A 		fsts	s14, [r4]
 355:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   q->qx = qx_roll * qi_pitch;
 1406              		.loc 4 355 0
 1407 00bc C4ED017A 		fsts	s15, [r4, #4]
 1408              		.loc 4 358 0
 1409 00c0 38BD     		pop	{r3, r4, r5, pc}
 1410              	.LVL173:
 1411              	.L109:
 1412 00c2 00BFAFF3 		.align	3
 1412      0080
 1413              	.L108:
 1414 00c8 F1D4C853 		.word	1405670641
 1415 00cc FB21E93F 		.word	1072243195
 1416 00d0 00000000 		.word	radio_control
 1417 00d4 00C0C240 		.word	1086504960
 1418 00d8 00000000 		.word	transition_theta_offset
 1419 00dc 00008039 		.word	964689920
 1420              		.cfi_endproc
 1421              	.LFE181:
 1423              		.section	.text.stabilization_attitude_read_rc_setpoint_quat_f,"ax",%progbits
 1424              		.align	1
 1425              		.global	stabilization_attitude_read_rc_setpoint_quat_f
 1426              		.thumb
 1427              		.thumb_func
 1429              	stabilization_attitude_read_rc_setpoint_quat_f:
 1430              	.LFB182:
 359:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 360:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** /** Read attitude setpoint from RC as quaternion
 361:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * Interprets the stick positions as axes.
 362:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  coordinated_turn  true if in horizontal mode forward
 363:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  in_carefree       true if in carefree mode
 364:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[in]  in_flight         true if in flight
 365:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  * @param[out] q_sp              attitude setpoint as quaternion
 366:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****  */
 367:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_setpoint_quat_f(struct FloatQuat *q_sp, bool_t in_flight, bool_
 368:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     bool_t coordinated_turn)
 369:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1431              		.loc 4 369 0
 1432              		.cfi_startproc
 1433              		@ args = 0, pretend = 0, frame = 96
 1434              		@ frame_needed = 0, uses_anonymous_args = 0
 1435              	.LVL174:
 1436 0000 70B5     		push	{r4, r5, r6, lr}
 1437              		.cfi_def_cfa_offset 16
 1438              		.cfi_offset 4, -16
 1439              		.cfi_offset 5, -12
 1440              		.cfi_offset 6, -8
 1441              		.cfi_offset 14, -4
 1442 0002 0446     		mov	r4, r0
 1443 0004 98B0     		sub	sp, sp, #96
 1444              		.cfi_def_cfa_offset 112
 370:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 371:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   // FIXME: remove me, do in quaternion directly
 372:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   // is currently still needed, since the yaw setpoint integration is done in eulers
 373:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if defined STABILIZATION_ATTITUDE_TYPE_INT
 374:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_setpoint_eulers(&stab_att_sp_euler, in_flight, in_carefree, coordi
 1445              		.loc 4 374 0
 1446 0006 2348     		ldr	r0, .L116
 1447              	.LVL175:
 369:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1448              		.loc 4 369 0
 1449 0008 0D46     		mov	r5, r1
 1450 000a 1646     		mov	r6, r2
 1451              		.loc 4 374 0
 1452 000c FFF7FEFF 		bl	stabilization_attitude_read_rc_setpoint_eulers
 1453              	.LVL176:
 375:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
 376:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_setpoint_eulers_f(&stab_att_sp_euler, in_flight, in_carefree, coor
 377:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 378:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 379:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatQuat q_rp_cmd;
 380:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_roll_pitch_quat_f(&q_rp_cmd);
 1454              		.loc 4 380 0
 1455 0010 04A8     		add	r0, sp, #16
 1456 0012 FFF7FEFF 		bl	stabilization_attitude_read_rc_roll_pitch_quat_f
 1457              	.LVL177:
 381:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 382:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* get current heading */
 383:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const struct FloatVect3 zaxis = {0., 0., 1.};
 1458              		.loc 4 383 0
 1459 0016 0023     		movs	r3, #0
 1460 0018 0193     		str	r3, [sp, #4]	@ float
 1461 001a 0293     		str	r3, [sp, #8]	@ float
 1462 001c 4FF07E53 		mov	r3, #1065353216
 1463 0020 0393     		str	r3, [sp, #12]	@ float
 384:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatQuat q_yaw;
 385:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 386:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   //Care Free mode
 387:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (in_carefree) {
 1464              		.loc 4 387 0
 1465 0022 26B1     		cbz	r6, .L111
 388:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     //care_free_heading has been set to current psi when entering care free mode.
 389:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw, &zaxis, care_free_heading);
 1466              		.loc 4 389 0
 1467 0024 1C4B     		ldr	r3, .L116+4
 1468 0026 08A8     		add	r0, sp, #32
 1469 0028 01A9     		add	r1, sp, #4
 1470 002a 1A68     		ldr	r2, [r3]	@ float
 1471 002c 05E0     		b	.L115
 1472              	.L111:
 1473              	.LBB117:
 1474              	.LBB118:
 1475              		.loc 5 1116 0
 1476 002e FFF7FEFF 		bl	orientationGetEulers_f.constprop.0
 1477              	.LVL178:
 1478 0032 0346     		mov	r3, r0
 1479              	.LBE118:
 1480              	.LBE117:
 390:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else {
 391:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw, &zaxis, stateGetNedToBodyEulers_f()->psi);
 1481              		.loc 4 391 0
 1482 0034 01A9     		add	r1, sp, #4
 1483 0036 9A68     		ldr	r2, [r3, #8]	@ float
 1484 0038 08A8     		add	r0, sp, #32
 1485              	.L115:
 1486 003a FFF7FEFF 		bl	float_quat_of_axis_angle
 1487              	.LVL179:
 392:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 393:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 394:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   /* roll/pitch commands applied to to current heading */
 395:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatQuat q_rp_sp;
 396:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float_quat_comp(&q_rp_sp, &q_yaw, &q_rp_cmd);
 1488              		.loc 4 396 0
 1489 003e 0CA8     		add	r0, sp, #48
 1490 0040 08A9     		add	r1, sp, #32
 1491 0042 04AA     		add	r2, sp, #16
 1492 0044 FFF7FEFF 		bl	float_quat_comp
 1493              	.LVL180:
 397:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   float_quat_normalize(&q_rp_sp);
 1494              		.loc 4 397 0
 1495 0048 0CA8     		add	r0, sp, #48
 1496 004a FFF7FEFF 		bl	float_quat_normalize
 1497              	.LVL181:
 398:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 399:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (in_flight) {
 1498              		.loc 4 399 0
 1499 004e B5B1     		cbz	r5, .L113
 1500              	.LBB119:
 400:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* get current heading setpoint */
 401:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     struct FloatQuat q_yaw_sp;
 402:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if defined STABILIZATION_ATTITUDE_TYPE_INT
 403:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw_sp, &zaxis, ANGLE_FLOAT_OF_BFP(stab_att_sp_euler.psi));
 1501              		.loc 4 403 0
 1502 0050 104B     		ldr	r3, .L116
 1503 0052 9A68     		ldr	r2, [r3, #8]
 1504 0054 07EE902A 		fmsr	s15, r2	@ int
 1505 0058 FAEECA7A 		vcvt.f32.s32	s15, s15, #12
 1506 005c 10A8     		add	r0, sp, #64
 1507 005e 17EE902A 		fmrs	r2, s15
 1508 0062 01A9     		add	r1, sp, #4
 1509 0064 FFF7FEFF 		bl	float_quat_of_axis_angle
 1510              	.LVL182:
 404:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
 405:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw_sp, &zaxis, stab_att_sp_euler.psi);
 406:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 407:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 408:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* rotation between current yaw and yaw setpoint */
 409:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     struct FloatQuat q_yaw_diff;
 410:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_comp_inv(&q_yaw_diff, &q_yaw_sp, &q_yaw);
 1511              		.loc 4 410 0
 1512 0068 14A8     		add	r0, sp, #80
 1513 006a 10A9     		add	r1, sp, #64
 1514 006c 08AA     		add	r2, sp, #32
 1515 006e FFF7FEFF 		bl	float_quat_comp_inv
 1516              	.LVL183:
 411:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 412:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* compute final setpoint with yaw */
 413:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_comp_norm_shortest(q_sp, &q_rp_sp, &q_yaw_diff);
 1517              		.loc 4 413 0
 1518 0072 2046     		mov	r0, r4
 1519 0074 0CA9     		add	r1, sp, #48
 1520 0076 14AA     		add	r2, sp, #80
 1521 0078 FFF7FEFF 		bl	float_quat_comp_norm_shortest
 1522              	.LVL184:
 1523              	.LBE119:
 1524 007c 07E0     		b	.L110
 1525              	.L113:
 414:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else {
 415:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     QUAT_COPY(*q_sp, q_rp_sp);
 1526              		.loc 4 415 0
 1527 007e 0C9B     		ldr	r3, [sp, #48]	@ float
 1528 0080 2360     		str	r3, [r4]	@ float
 1529 0082 0D9B     		ldr	r3, [sp, #52]	@ float
 1530 0084 6360     		str	r3, [r4, #4]	@ float
 1531 0086 0E9B     		ldr	r3, [sp, #56]	@ float
 1532 0088 A360     		str	r3, [r4, #8]	@ float
 1533 008a 0F9B     		ldr	r3, [sp, #60]	@ float
 1534 008c E360     		str	r3, [r4, #12]	@ float
 1535              	.L110:
 416:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 417:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 1536              		.loc 4 417 0
 1537 008e 18B0     		add	sp, sp, #96
 1538              		@ sp needed
 1539 0090 70BD     		pop	{r4, r5, r6, pc}
 1540              	.LVL185:
 1541              	.L117:
 1542 0092 00BF     		.align	2
 1543              	.L116:
 1544 0094 00000000 		.word	stab_att_sp_euler
 1545 0098 00000000 		.word	.LANCHOR0
 1546              		.cfi_endproc
 1547              	.LFE182:
 1549              		.section	.text.stabilization_attitude_read_rc_setpoint_quat_earth_bound_f,"ax",%progbits
 1550              		.align	1
 1551              		.global	stabilization_attitude_read_rc_setpoint_quat_earth_bound_f
 1552              		.thumb
 1553              		.thumb_func
 1555              	stabilization_attitude_read_rc_setpoint_quat_earth_bound_f:
 1556              	.LFB183:
 418:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 419:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** //Function that reads the rc setpoint in an earth bound frame
 420:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** void stabilization_attitude_read_rc_setpoint_quat_earth_bound_f(struct FloatQuat *q_sp, bool_t in_f
 421:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     bool_t in_carefree, bool_t coordinated_turn)
 422:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1557              		.loc 4 422 0
 1558              		.cfi_startproc
 1559              		@ args = 0, pretend = 0, frame = 64
 1560              		@ frame_needed = 0, uses_anonymous_args = 0
 1561              	.LVL186:
 1562 0000 70B5     		push	{r4, r5, r6, lr}
 1563              		.cfi_def_cfa_offset 16
 1564              		.cfi_offset 4, -16
 1565              		.cfi_offset 5, -12
 1566              		.cfi_offset 6, -8
 1567              		.cfi_offset 14, -4
 423:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   // FIXME: remove me, do in quaternion directly
 424:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   // is currently still needed, since the yaw setpoint integration is done in eulers
 425:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if defined STABILIZATION_ATTITUDE_TYPE_INT
 426:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_setpoint_eulers(&stab_att_sp_euler, in_flight, in_carefree, coordi
 1568              		.loc 4 426 0
 1569 0002 1E4D     		ldr	r5, .L121
 422:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1570              		.loc 4 422 0
 1571 0004 90B0     		sub	sp, sp, #64
 1572              		.cfi_def_cfa_offset 80
 422:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1573              		.loc 4 422 0
 1574 0006 0446     		mov	r4, r0
 1575              		.loc 4 426 0
 1576 0008 2846     		mov	r0, r5
 1577              	.LVL187:
 422:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** {
 1578              		.loc 4 422 0
 1579 000a 0E46     		mov	r6, r1
 1580              		.loc 4 426 0
 1581 000c FFF7FEFF 		bl	stabilization_attitude_read_rc_setpoint_eulers
 1582              	.LVL188:
 427:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
 428:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_setpoint_eulers_f(&stab_att_sp_euler, in_flight, in_carefree, coor
 429:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 430:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 431:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const struct FloatVect3 zaxis = {0., 0., 1.};
 1583              		.loc 4 431 0
 1584 0010 0023     		movs	r3, #0
 1585 0012 0193     		str	r3, [sp, #4]	@ float
 1586 0014 0293     		str	r3, [sp, #8]	@ float
 432:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 433:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   struct FloatQuat q_rp_cmd;
 434:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   stabilization_attitude_read_rc_roll_pitch_earth_quat_f(&q_rp_cmd);
 1587              		.loc 4 434 0
 1588 0016 04A8     		add	r0, sp, #16
 431:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   const struct FloatVect3 zaxis = {0., 0., 1.};
 1589              		.loc 4 431 0
 1590 0018 4FF07E53 		mov	r3, #1065353216
 1591 001c 0393     		str	r3, [sp, #12]	@ float
 1592              		.loc 4 434 0
 1593 001e FFF7FEFF 		bl	stabilization_attitude_read_rc_roll_pitch_earth_quat_f
 1594              	.LVL189:
 435:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 436:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   if (in_flight) {
 1595              		.loc 4 436 0
 1596 0022 86B1     		cbz	r6, .L119
 1597              	.LBB124:
 437:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* get current heading setpoint */
 438:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     struct FloatQuat q_yaw_sp;
 439:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 440:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #if defined STABILIZATION_ATTITUDE_TYPE_INT
 441:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw_sp, &zaxis, ANGLE_FLOAT_OF_BFP(stab_att_sp_euler.psi));
 1598              		.loc 4 441 0
 1599 0024 AA68     		ldr	r2, [r5, #8]
 1600 0026 07EE902A 		fmsr	s15, r2	@ int
 1601 002a FAEECA7A 		vcvt.f32.s32	s15, s15, #12
 1602 002e 0CA8     		add	r0, sp, #48
 1603 0030 01A9     		add	r1, sp, #4
 1604 0032 17EE902A 		fmrs	r2, s15
 1605 0036 FFF7FEFF 		bl	float_quat_of_axis_angle
 1606              	.LVL190:
 442:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #else
 443:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw_sp, &zaxis, stab_att_sp_euler.psi);
 444:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** #endif
 445:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 446:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_comp(q_sp, &q_yaw_sp, &q_rp_cmd);
 1607              		.loc 4 446 0
 1608 003a 2046     		mov	r0, r4
 1609 003c 0CA9     		add	r1, sp, #48
 1610 003e 04AA     		add	r2, sp, #16
 1611 0040 FFF7FEFF 		bl	float_quat_comp
 1612              	.LVL191:
 1613              	.LBE124:
 1614 0044 17E0     		b	.L118
 1615              	.L119:
 1616              	.LBB125:
 1617              	.LBB126:
 1618              	.LBB127:
 1619              		.loc 5 1116 0
 1620 0046 FFF7FEFF 		bl	orientationGetEulers_f.constprop.0
 1621              	.LVL192:
 1622 004a 0346     		mov	r3, r0
 1623              	.LBE127:
 1624              	.LBE126:
 447:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   } else {
 448:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     struct FloatQuat q_yaw;
 449:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_of_axis_angle(&q_yaw, &zaxis, stateGetNedToBodyEulers_f()->psi);
 1625              		.loc 4 449 0
 1626 004c 01A9     		add	r1, sp, #4
 1627 004e 9A68     		ldr	r2, [r3, #8]	@ float
 1628 0050 08A8     		add	r0, sp, #32
 1629 0052 FFF7FEFF 		bl	float_quat_of_axis_angle
 1630              	.LVL193:
 450:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 451:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     /* roll/pitch commands applied to to current heading */
 452:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     struct FloatQuat q_rp_sp;
 453:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_comp(&q_rp_sp, &q_yaw, &q_rp_cmd);
 1631              		.loc 4 453 0
 1632 0056 0CA8     		add	r0, sp, #48
 1633 0058 08A9     		add	r1, sp, #32
 1634 005a 04AA     		add	r2, sp, #16
 1635 005c FFF7FEFF 		bl	float_quat_comp
 1636              	.LVL194:
 454:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     float_quat_normalize(&q_rp_sp);
 1637              		.loc 4 454 0
 1638 0060 0CA8     		add	r0, sp, #48
 1639 0062 FFF7FEFF 		bl	float_quat_normalize
 1640              	.LVL195:
 455:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** 
 456:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****     QUAT_COPY(*q_sp, q_rp_sp);
 1641              		.loc 4 456 0
 1642 0066 0C9B     		ldr	r3, [sp, #48]	@ float
 1643 0068 2360     		str	r3, [r4]	@ float
 1644 006a 0D9B     		ldr	r3, [sp, #52]	@ float
 1645 006c 6360     		str	r3, [r4, #4]	@ float
 1646 006e 0E9B     		ldr	r3, [sp, #56]	@ float
 1647 0070 A360     		str	r3, [r4, #8]	@ float
 1648 0072 0F9B     		ldr	r3, [sp, #60]	@ float
 1649 0074 E360     		str	r3, [r4, #12]	@ float
 1650              	.L118:
 1651              	.LBE125:
 457:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c ****   }
 458:firmwares/rotorcraft/stabilization/stabilization_attitude_rc_setpoint.c **** }
 1652              		.loc 4 458 0
 1653 0076 10B0     		add	sp, sp, #64
 1654              		@ sp needed
 1655 0078 70BD     		pop	{r4, r5, r6, pc}
 1656              	.LVL196:
 1657              	.L122:
 1658 007a 00BF     		.align	2
 1659              	.L121:
 1660 007c 00000000 		.word	stab_att_sp_euler
 1661              		.cfi_endproc
 1662              	.LFE183:
 1664              		.global	care_free_heading
 1665              		.section	.bss.last_ts.7402,"aw",%nobits
 1666              		.align	2
 1667              		.set	.LANCHOR2,. + 0
 1670              	last_ts.7402:
 1671 0000 00000000 		.space	4
 1672              		.section	.bss.last_ts.7376,"aw",%nobits
 1673              		.align	2
 1674              		.set	.LANCHOR1,. + 0
 1677              	last_ts.7376:
 1678 0000 00000000 		.space	4
 1679              		.section	.bss.care_free_heading,"aw",%nobits
 1680              		.align	2
 1681              		.set	.LANCHOR0,. + 0
 1684              	care_free_heading:
 1685 0000 00000000 		.space	4
 1686              		.text
 1687              	.Letext0:
 1688              		.file 6 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 1689              		.file 7 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 1690              		.file 8 "/home/lsk/paparazzi/sw/include/std.h"
 1691              		.file 9 "./math/pprz_algebra_int.h"
 1692              		.file 10 "./paparazzi.h"
 1693              		.file 11 "./subsystems/radio_control.h"
 1694              		.file 12 "./math/pprz_geodetic_int.h"
 1695              		.file 13 "./math/pprz_geodetic_float.h"
 1696              		.file 14 "./firmwares/rotorcraft/guidance/guidance_h.h"
 1697              		.file 15 "./firmwares/rotorcraft/stabilization/stabilization_attitude_ref_int.h"
 1698              		.file 16 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
 1699              		.file 17 "./math/pprz_trig_int.h"
 1700              		.file 18 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stabilization_attitude_rc_setpoint.c
     /tmp/ccnRTZY1.s:20     .text.get_sys_time_float:00000000 $t
     /tmp/ccnRTZY1.s:24     .text.get_sys_time_float:00000000 get_sys_time_float
     /tmp/ccnRTZY1.s:47     .text.get_sys_time_float:00000024 $d
     /tmp/ccnRTZY1.s:52     .text.float_quat_normalize:00000000 $t
     /tmp/ccnRTZY1.s:56     .text.float_quat_normalize:00000000 float_quat_normalize
     /tmp/ccnRTZY1.s:132    .text.float_quat_normalize:00000070 $d
     /tmp/ccnRTZY1.s:137    .text.orientationGetEulers_f.constprop.0:00000000 $t
     /tmp/ccnRTZY1.s:141    .text.orientationGetEulers_f.constprop.0:00000000 orientationGetEulers_f.constprop.0
     /tmp/ccnRTZY1.s:169    .text.orientationGetEulers_f.constprop.0:00000018 $d
     /tmp/ccnRTZY1.s:175    .text.stabilization_attitude_reset_care_free_heading:00000000 $t
     /tmp/ccnRTZY1.s:180    .text.stabilization_attitude_reset_care_free_heading:00000000 stabilization_attitude_reset_care_free_heading
     /tmp/ccnRTZY1.s:207    .text.stabilization_attitude_reset_care_free_heading:00000010 $d
     /tmp/ccnRTZY1.s:212    .text.stabilization_attitude_get_heading_i:00000000 $t
     /tmp/ccnRTZY1.s:217    .text.stabilization_attitude_get_heading_i:00000000 stabilization_attitude_get_heading_i
     /tmp/ccnRTZY1.s:288    .text.stabilization_attitude_get_heading_i:0000005c $d
     /tmp/ccnRTZY1.s:295    .text.stabilization_attitude_get_heading_f:00000000 $t
     /tmp/ccnRTZY1.s:300    .text.stabilization_attitude_get_heading_f:00000000 stabilization_attitude_get_heading_f
     /tmp/ccnRTZY1.s:371    .text.stabilization_attitude_get_heading_f:00000068 $d
     /tmp/ccnRTZY1.s:380    .text.stabilization_attitude_read_rc_setpoint_eulers:00000000 $t
     /tmp/ccnRTZY1.s:385    .text.stabilization_attitude_read_rc_setpoint_eulers:00000000 stabilization_attitude_read_rc_setpoint_eulers
     /tmp/ccnRTZY1.s:729    .text.stabilization_attitude_read_rc_setpoint_eulers:000001f8 $d
     /tmp/ccnRTZY1.s:750    .text.stabilization_attitude_read_rc_setpoint_eulers_f:00000000 $t
     /tmp/ccnRTZY1.s:755    .text.stabilization_attitude_read_rc_setpoint_eulers_f:00000000 stabilization_attitude_read_rc_setpoint_eulers_f
     /tmp/ccnRTZY1.s:1146   .text.stabilization_attitude_read_rc_setpoint_eulers_f:00000280 $d
     /tmp/ccnRTZY1.s:1172   .text.stabilization_attitude_read_rc_roll_pitch_quat_f:00000000 $t
     /tmp/ccnRTZY1.s:1177   .text.stabilization_attitude_read_rc_roll_pitch_quat_f:00000000 stabilization_attitude_read_rc_roll_pitch_quat_f
     /tmp/ccnRTZY1.s:1263   .text.stabilization_attitude_read_rc_roll_pitch_quat_f:00000058 $d
     /tmp/ccnRTZY1.s:1271   .text.stabilization_attitude_read_rc_roll_pitch_earth_quat_f:00000000 $t
     /tmp/ccnRTZY1.s:1276   .text.stabilization_attitude_read_rc_roll_pitch_earth_quat_f:00000000 stabilization_attitude_read_rc_roll_pitch_earth_quat_f
     /tmp/ccnRTZY1.s:1414   .text.stabilization_attitude_read_rc_roll_pitch_earth_quat_f:000000c8 $d
     /tmp/ccnRTZY1.s:1424   .text.stabilization_attitude_read_rc_setpoint_quat_f:00000000 $t
     /tmp/ccnRTZY1.s:1429   .text.stabilization_attitude_read_rc_setpoint_quat_f:00000000 stabilization_attitude_read_rc_setpoint_quat_f
     /tmp/ccnRTZY1.s:1544   .text.stabilization_attitude_read_rc_setpoint_quat_f:00000094 $d
     /tmp/ccnRTZY1.s:1550   .text.stabilization_attitude_read_rc_setpoint_quat_earth_bound_f:00000000 $t
     /tmp/ccnRTZY1.s:1555   .text.stabilization_attitude_read_rc_setpoint_quat_earth_bound_f:00000000 stabilization_attitude_read_rc_setpoint_quat_earth_bound_f
     /tmp/ccnRTZY1.s:1660   .text.stabilization_attitude_read_rc_setpoint_quat_earth_bound_f:0000007c $d
     /tmp/ccnRTZY1.s:1684   .bss.care_free_heading:00000000 care_free_heading
     /tmp/ccnRTZY1.s:1666   .bss.last_ts.7402:00000000 $d
     /tmp/ccnRTZY1.s:1670   .bss.last_ts.7402:00000000 last_ts.7402
     /tmp/ccnRTZY1.s:1673   .bss.last_ts.7376:00000000 $d
     /tmp/ccnRTZY1.s:1677   .bss.last_ts.7376:00000000 last_ts.7376
     /tmp/ccnRTZY1.s:1680   .bss.care_free_heading:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.61e172dafa1e7adfbd840ee8b103061f
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.4db40689d622c4d3b547b5801303bdae
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.13c5bec129ef04ad1bb0a1152b29c624
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.float.h.29.1cf88a0527b6b1225d49fbee2b32acb7
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.pprz_algebra.h.47.d249264ea6bacf2198e290d461cf6dbe
                           .group:00000000 wm4.pprz_trig_int.h.28.b756be608c9d9f3092a41321446e5fa2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:00000000 wm4.pprz_algebra_int.h.68.04ac162ae1e1d94f716d0bb402062624
                           .group:00000000 wm4.pprz_algebra_float.h.98.bb035bcbfa66bb186e7ea81143fd64bc
                           .group:00000000 wm4.airframe.h.5.1b65f22e2c90217dfc42bdae27fe483a
                           .group:00000000 wm4.krooz_sd.h.2.013366a614baabbe44cc2bbd3205e3d1
                           .group:00000000 wm4.actuators_pwm_arch.h.41.fa66469024778df593e0e3d83e4a3c37
                           .group:00000000 wm4.airframe.h.14.f46e30d413878b482f16a5abf2127a4b
                           .group:00000000 wm4.common.h.21.22efaac882611267214d0a36f6f15e74
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.led_hw.h.40.8014fb3594847a9d275099fc6ed94641
                           .group:00000000 wm4.led.h.99.0116146560b22524df8538874a4f60bf
                           .group:00000000 wm4.paparazzi.h.2.903792c4429b74b43ba66cc0d2531abd
                           .group:00000000 wm4.ppm_arch.h.30.0c8951ed5389d834f3146640146f52ff
                           .group:00000000 wm4.radio.h.5.656a6ddaf975d68fb12fc1808da140b2
                           .group:00000000 wm4.ppm.h.47.0149fce522ef0e315e524566a6409a2a
                           .group:00000000 wm4.radio_control.h.42.d43f9142844e08da852d6ed343ba2de3
                           .group:00000000 wm4.pprz_geodetic.h.35.f7fdb5d11659b92d11c7ce67b6317005
                           .group:00000000 wm4.pprz_geodetic_int.h.127.8e737bed5ba4468e470311184b1fca7f
                           .group:00000000 wm4.pprz_orientation_conversion.h.57.c0c8f5187bc056807e507011653281f4
                           .group:00000000 wm4.state.h.65.b18954aacb3801ec3e27b4e857d620d3
                           .group:00000000 wm4.guidance_h_ref.h.28.02975291fcd9050282c105dc881ca473
                           .group:00000000 wm4.guidance_h.h.52.9fa60ffd20b98f37d2a6446e3103ac47
                           .group:00000000 wm4.stabilization_attitude_ref_int.h.28.ff95e62d0525988a53078c57e1f59bd1
                           .group:00000000 wm4.autopilot_rc_helpers.h.29.556d35c42feaf63fcd5365af9f4c1c63
                           .group:00000000 wm4.sys_time.h.31.454ffebb4f6baf6e87ab8a60104a5808
                           .group:00000000 wm4.systick.h.44.34e759e1f218a187b07e9a617cb1d556
                           .group:00000000 wm4.sys_time.h.213.4ee43452c5934214134db56488f53299

UNDEFINED SYMBOLS
sys_time
sqrtf
orientationCalcEulers_f
state
orientationCalcEulers_i
pprz_itrig_sin
__aeabi_i2d
__aeabi_dcmplt
sinf
__aeabi_f2d
__aeabi_dmul
__aeabi_d2iz
tanf
pprz_itrig_cos
radio_control
__aeabi_ddiv
__aeabi_d2f
__aeabi_dsub
__aeabi_dcmpgt
__aeabi_dadd
cosf
float_quat_of_orientation_vect
transition_theta_offset
float_quat_of_axis_angle
float_quat_comp
float_quat_comp_inv
float_quat_comp_norm_shortest
stab_att_sp_euler
