   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"i2c_arch.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.PPRZ_I2C_SEND_START,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	PPRZ_I2C_SEND_START:
  25              	.LFB9:
  26              		.file 1 "arch/stm32/mcu_periph/i2c_arch.c"
   1:arch/stm32/mcu_periph/i2c_arch.c **** /*
   2:arch/stm32/mcu_periph/i2c_arch.c ****  * Copyright (C) 2009-2012 The Paparazzi Team
   3:arch/stm32/mcu_periph/i2c_arch.c ****  *
   4:arch/stm32/mcu_periph/i2c_arch.c ****  * This file is part of paparazzi.
   5:arch/stm32/mcu_periph/i2c_arch.c ****  *
   6:arch/stm32/mcu_periph/i2c_arch.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:arch/stm32/mcu_periph/i2c_arch.c ****  * it under the terms of the GNU General Public License as published by
   8:arch/stm32/mcu_periph/i2c_arch.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:arch/stm32/mcu_periph/i2c_arch.c ****  * any later version.
  10:arch/stm32/mcu_periph/i2c_arch.c ****  *
  11:arch/stm32/mcu_periph/i2c_arch.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:arch/stm32/mcu_periph/i2c_arch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:arch/stm32/mcu_periph/i2c_arch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:arch/stm32/mcu_periph/i2c_arch.c ****  * GNU General Public License for more details.
  15:arch/stm32/mcu_periph/i2c_arch.c ****  *
  16:arch/stm32/mcu_periph/i2c_arch.c ****  * You should have received a copy of the GNU General Public License
  17:arch/stm32/mcu_periph/i2c_arch.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:arch/stm32/mcu_periph/i2c_arch.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:arch/stm32/mcu_periph/i2c_arch.c ****  * Boston, MA 02111-1307, USA.
  20:arch/stm32/mcu_periph/i2c_arch.c ****  *
  21:arch/stm32/mcu_periph/i2c_arch.c ****  */
  22:arch/stm32/mcu_periph/i2c_arch.c **** 
  23:arch/stm32/mcu_periph/i2c_arch.c **** /**
  24:arch/stm32/mcu_periph/i2c_arch.c ****  * @file arch/stm32/mcu_periph/i2c_arch.c
  25:arch/stm32/mcu_periph/i2c_arch.c ****  * @ingroup stm32_arch
  26:arch/stm32/mcu_periph/i2c_arch.c ****  * Handling of I2C hardware for STM32.
  27:arch/stm32/mcu_periph/i2c_arch.c ****  */
  28:arch/stm32/mcu_periph/i2c_arch.c **** 
  29:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/i2c.h"
  30:arch/stm32/mcu_periph/i2c_arch.c **** 
  31:arch/stm32/mcu_periph/i2c_arch.c **** #include BOARD_CONFIG
  32:arch/stm32/mcu_periph/i2c_arch.c **** 
  33:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/stm32/rcc.h>
  34:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/stm32/gpio.h>
  35:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/cm3/nvic.h>
  36:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/cm3/scb.h>
  37:arch/stm32/mcu_periph/i2c_arch.c **** 
  38:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/gpio.h"
  39:arch/stm32/mcu_periph/i2c_arch.c **** 
  40:arch/stm32/mcu_periph/i2c_arch.c **** 
  41:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
  42:arch/stm32/mcu_periph/i2c_arch.c **** #include "i2c_debug_led.h"
  43:arch/stm32/mcu_periph/i2c_arch.c **** #endif // I2C_DEBUG_LED
  44:arch/stm32/mcu_periph/i2c_arch.c **** 
  45:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////////////////////////////////////
  46:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////////////////////////////////////
  47:arch/stm32/mcu_periph/i2c_arch.c **** 
  48:arch/stm32/mcu_periph/i2c_arch.c **** 
  49:arch/stm32/mcu_periph/i2c_arch.c **** // Error bit mask
  50:arch/stm32/mcu_periph/i2c_arch.c **** // XXX: consider moving this define into libopencm3
  51:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C_SR1_ERR_MASK (I2C_SR1_SMBALERT | \
  52:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_TIMEOUT |  \
  53:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_PECERR |   \
  54:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_OVR |      \
  55:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_AF |       \
  56:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_ARLO |     \
  57:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_BERR)
  58:arch/stm32/mcu_periph/i2c_arch.c **** 
  59:arch/stm32/mcu_periph/i2c_arch.c **** // Bit Control
  60:arch/stm32/mcu_periph/i2c_arch.c **** 
  61:arch/stm32/mcu_periph/i2c_arch.c **** #define BIT_X_IS_SET_IN_REG(X,REG)  (((REG) & (X)) == (X))
  62:arch/stm32/mcu_periph/i2c_arch.c **** 
  63:arch/stm32/mcu_periph/i2c_arch.c **** // disable and enable irq functions are not implemented in libopencm3 defining them here
  64:arch/stm32/mcu_periph/i2c_arch.c **** // XXX: consider moving this definitions into libopencm3
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
  67:arch/stm32/mcu_periph/i2c_arch.c **** 
  68:arch/stm32/mcu_periph/i2c_arch.c **** // Critical Zones
  69:arch/stm32/mcu_periph/i2c_arch.c **** 
  70:arch/stm32/mcu_periph/i2c_arch.c **** #define __I2C_REG_CRITICAL_ZONE_START __disable_irq();
  71:arch/stm32/mcu_periph/i2c_arch.c **** #define __I2C_REG_CRITICAL_ZONE_STOP  __enable_irq();
  72:arch/stm32/mcu_periph/i2c_arch.c **** 
  73:arch/stm32/mcu_periph/i2c_arch.c **** 
  74:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef NVIC_I2C_IRQ_PRIO
  75:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C1_IRQ_PRIO 0
  76:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C2_IRQ_PRIO 0
  77:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C3_IRQ_PRIO 0
  78:arch/stm32/mcu_periph/i2c_arch.c **** #else
  79:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C1_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  80:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C2_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  81:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C3_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  82:arch/stm32/mcu_periph/i2c_arch.c **** #endif
  83:arch/stm32/mcu_periph/i2c_arch.c **** 
  84:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1 || USE_I2C2 || USE_I2C3
  85:arch/stm32/mcu_periph/i2c_arch.c **** #if defined(STM32F1)
  86:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_setup_gpio(uint32_t i2c)
  87:arch/stm32/mcu_periph/i2c_arch.c **** {
  88:arch/stm32/mcu_periph/i2c_arch.c ****   switch (i2c) {
  89:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
  90:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C1:
  91:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C1_GPIO_PORT);
  92:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_mode(I2C1_GPIO_PORT, GPIO_MODE_OUTPUT_2_MHZ,
  93:arch/stm32/mcu_periph/i2c_arch.c ****                     GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN,
  94:arch/stm32/mcu_periph/i2c_arch.c ****                     I2C1_GPIO_SCL | I2C1_GPIO_SDA);
  95:arch/stm32/mcu_periph/i2c_arch.c ****       break;
  96:arch/stm32/mcu_periph/i2c_arch.c **** #endif
  97:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
  98:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C2:
  99:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C2_GPIO_PORT);
 100:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_mode(I2C2_GPIO_PORT, GPIO_MODE_OUTPUT_2_MHZ,
 101:arch/stm32/mcu_periph/i2c_arch.c ****                     GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN,
 102:arch/stm32/mcu_periph/i2c_arch.c ****                     I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 103:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 104:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 105:arch/stm32/mcu_periph/i2c_arch.c ****     default:
 106:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 107:arch/stm32/mcu_periph/i2c_arch.c ****   }
 108:arch/stm32/mcu_periph/i2c_arch.c **** }
 109:arch/stm32/mcu_periph/i2c_arch.c **** 
 110:arch/stm32/mcu_periph/i2c_arch.c **** #elif defined(STM32F4)
 111:arch/stm32/mcu_periph/i2c_arch.c **** 
 112:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_setup_gpio(uint32_t i2c)
 113:arch/stm32/mcu_periph/i2c_arch.c **** {
 114:arch/stm32/mcu_periph/i2c_arch.c ****   switch (i2c) {
 115:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 116:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C1:
 117:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C1_GPIO_PORT);
 118:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C1_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 119:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 120:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(GPIOB, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 121:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 122:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C1_GPIO_PORT, GPIO_AF4, I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 123:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 124:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 125:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
 126:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C2:
 127:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C2_GPIO_PORT);
 128:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C2_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 129:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 130:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C2_GPIO_PORT, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 131:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 132:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C2_GPIO_PORT, GPIO_AF4,
 133:arch/stm32/mcu_periph/i2c_arch.c ****                   I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 134:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 135:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 136:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
 137:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C3:
 138:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C3_GPIO_PORT_SCL);
 139:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C3_GPIO_PORT_SCL, GPIO_MODE_AF, GPIO_PUPD_NONE, I2C3_GPIO_SCL);
 140:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C3_GPIO_PORT_SCL, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 141:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C3_GPIO_SCL);
 142:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C3_GPIO_PORT_SCL, GPIO_AF4, I2C3_GPIO_SCL);
 143:arch/stm32/mcu_periph/i2c_arch.c **** 
 144:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C3_GPIO_PORT_SDA);
 145:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C3_GPIO_PORT_SDA, GPIO_MODE_AF, GPIO_PUPD_NONE, I2C3_GPIO_SDA);
 146:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C3_GPIO_PORT_SDA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 147:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C3_GPIO_SDA);
 148:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C3_GPIO_PORT_SDA, GPIO_AF4, I2C3_GPIO_SDA);
 149:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 150:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 151:arch/stm32/mcu_periph/i2c_arch.c ****     default:
 152:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 153:arch/stm32/mcu_periph/i2c_arch.c ****   }
 154:arch/stm32/mcu_periph/i2c_arch.c **** }
 155:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 156:arch/stm32/mcu_periph/i2c_arch.c **** #endif // USE_I2Cx
 157:arch/stm32/mcu_periph/i2c_arch.c **** 
 158:arch/stm32/mcu_periph/i2c_arch.c **** static inline void PPRZ_I2C_SEND_STOP(uint32_t i2c)
 159:arch/stm32/mcu_periph/i2c_arch.c **** {
 160:arch/stm32/mcu_periph/i2c_arch.c ****   // Man: p722:  Stop generation after the current byte transfer or after the current Start conditi
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 162:arch/stm32/mcu_periph/i2c_arch.c **** 
 163:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 164:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_ON();
 165:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 166:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 167:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_OFF();
 168:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 169:arch/stm32/mcu_periph/i2c_arch.c **** }
 170:arch/stm32/mcu_periph/i2c_arch.c **** 
 171:arch/stm32/mcu_periph/i2c_arch.c **** // (RE)START
 172:arch/stm32/mcu_periph/i2c_arch.c **** 
 173:arch/stm32/mcu_periph/i2c_arch.c **** static inline void PPRZ_I2C_SEND_START(struct i2c_periph *periph)
 174:arch/stm32/mcu_periph/i2c_arch.c **** {
  27              		.loc 1 174 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 38B5     		push	{r3, r4, r5, lr}
  33              		.cfi_def_cfa_offset 16
  34              		.cfi_offset 3, -16
  35              		.cfi_offset 4, -12
  36              		.cfi_offset 5, -8
  37              		.cfi_offset 14, -4
 175:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
  38              		.loc 1 175 0
  39 0002 446A     		ldr	r4, [r0, #36]
  40              	.LVL1:
 176:arch/stm32/mcu_periph/i2c_arch.c **** 
 177:arch/stm32/mcu_periph/i2c_arch.c ****   // Reset the buffer pointer to the first byte
 178:arch/stm32/mcu_periph/i2c_arch.c ****   periph->idx_buf = 0;
  41              		.loc 1 178 0
  42 0004 0023     		movs	r3, #0
  43 0006 80F82330 		strb	r3, [r0, #35]
 174:arch/stm32/mcu_periph/i2c_arch.c **** {
  44              		.loc 1 174 0
  45 000a 0546     		mov	r5, r0
 179:arch/stm32/mcu_periph/i2c_arch.c **** 
 180:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 181:arch/stm32/mcu_periph/i2c_arch.c ****   LED_SHOW_ACTIVE_BITS(regs);
 182:arch/stm32/mcu_periph/i2c_arch.c **** 
 183:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_ON();
 184:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 185:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 186:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 187:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 188:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 189:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 190:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_OFF();
 191:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 192:arch/stm32/mcu_periph/i2c_arch.c **** 
 193:arch/stm32/mcu_periph/i2c_arch.c ****   // Enable Error IRQ, Event IRQ but disable Buffer IRQ
 194:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
  46              		.loc 1 194 0
  47 000c 4FF48071 		mov	r1, #256
  48 0010 2046     		mov	r0, r4
  49              	.LVL2:
  50 0012 FFF7FEFF 		bl	i2c_enable_interrupt
  51              	.LVL3:
 195:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
  52              		.loc 1 195 0
  53 0016 2046     		mov	r0, r4
  54 0018 4FF40071 		mov	r1, #512
  55 001c FFF7FEFF 		bl	i2c_enable_interrupt
  56              	.LVL4:
 196:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
  57              		.loc 1 196 0
  58 0020 4FF48061 		mov	r1, #1024
  59 0024 2046     		mov	r0, r4
  60 0026 FFF7FEFF 		bl	i2c_disable_interrupt
  61              	.LVL5:
 197:arch/stm32/mcu_periph/i2c_arch.c **** 
 198:arch/stm32/mcu_periph/i2c_arch.c ****   // Issue a new start
 199:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_nack_current(i2c);
  62              		.loc 1 199 0
  63 002a 2046     		mov	r0, r4
  64 002c FFF7FEFF 		bl	i2c_nack_current
  65              	.LVL6:
 200:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_ack(i2c);
  66              		.loc 1 200 0
  67 0030 2046     		mov	r0, r4
  68 0032 FFF7FEFF 		bl	i2c_disable_ack
  69              	.LVL7:
 201:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_clear_stop(i2c);
  70              		.loc 1 201 0
  71 0036 2046     		mov	r0, r4
  72 0038 FFF7FEFF 		bl	i2c_clear_stop
  73              	.LVL8:
 202:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(i2c);
  74              		.loc 1 202 0
  75 003c 2046     		mov	r0, r4
  76 003e FFF7FEFF 		bl	i2c_peripheral_enable
  77              	.LVL9:
 203:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_start(i2c);
  78              		.loc 1 203 0
  79 0042 2046     		mov	r0, r4
  80 0044 FFF7FEFF 		bl	i2c_send_start
  81              	.LVL10:
 204:arch/stm32/mcu_periph/i2c_arch.c ****   periph->status = I2CStartRequested;
  82              		.loc 1 204 0
  83 0048 0123     		movs	r3, #1
  84 004a 85F82230 		strb	r3, [r5, #34]
  85 004e 38BD     		pop	{r3, r4, r5, pc}
  86              		.cfi_endproc
  87              	.LFE9:
  89              		.section	.text.get_sys_time_usec,"ax",%progbits
  90              		.align	1
  91              		.thumb
  92              		.thumb_func
  94              	get_sys_time_usec:
  95              	.LFB39:
  96              		.file 2 "/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h"
   1:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /*
   2:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   3:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Copyright (C) 2009-2011 The Paparazzi Team
   4:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   5:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * This file is part of paparazzi.
   6:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   7:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * it under the terms of the GNU General Public License as published by
   9:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * any later version.
  11:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  12:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * GNU General Public License for more details.
  16:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  17:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * You should have received a copy of the GNU General Public License
  18:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Boston, MA 02111-1307, USA.
  21:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  22:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  23:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  24:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /**
  25:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @file arch/stm32/mcu_periph/sys_time_arch.h
  26:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @ingroup stm32_arch
  27:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  28:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * STM32 timing functions.
  29:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  30:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  31:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  32:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifndef SYS_TIME_ARCH_H
  33:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #define SYS_TIME_ARCH_H
  34:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  35:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "mcu_periph/sys_time.h"
  36:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  37:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/stm32/gpio.h>
  38:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/stm32/rcc.h>
  39:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/cm3/systick.h>
  40:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "std.h"
  41:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifdef RTOS_IS_CHIBIOS
  42:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "chibios_stub.h"
  43:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "chconf.h"
  44:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #endif
  45:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  46:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /**
  47:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Get the time in microseconds since startup.
  48:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * WARNING: overflows after 70min!
  49:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @return microseconds since startup as uint32_t
  50:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  51:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** static inline uint32_t get_sys_time_usec(void)
  52:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** {
  97              		.loc 2 52 0
  98              		.cfi_startproc
  99              		@ args = 0, pretend = 0, frame = 0
 100              		@ frame_needed = 0, uses_anonymous_args = 0
 101 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 102              		.cfi_def_cfa_offset 24
 103              		.cfi_offset 3, -24
 104              		.cfi_offset 4, -20
 105              		.cfi_offset 5, -16
 106              		.cfi_offset 6, -12
 107              		.cfi_offset 7, -8
 108              		.cfi_offset 14, -4
  53:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifdef RTOS_IS_CHIBIOS
  54:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****   return (chibios_chTimeNow() * (1000000 / CH_FREQUENCY));
  55:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #else
  56:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****   return sys_time.nb_sec * 1000000 +
 109              		.loc 2 56 0
 110 0002 0D4C     		ldr	r4, .L3
 111              	.LBB68:
 112              	.LBB69:
 113              		.file 3 "./mcu_periph/sys_time.h"
   1:./mcu_periph/sys_time.h **** /*
   2:./mcu_periph/sys_time.h ****  *
   3:./mcu_periph/sys_time.h ****  * Copyright (C) 2009-2011 The Paparazzi Team
   4:./mcu_periph/sys_time.h ****  *
   5:./mcu_periph/sys_time.h ****  * This file is part of paparazzi.
   6:./mcu_periph/sys_time.h ****  *
   7:./mcu_periph/sys_time.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./mcu_periph/sys_time.h ****  * it under the terms of the GNU General Public License as published by
   9:./mcu_periph/sys_time.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./mcu_periph/sys_time.h ****  * any later version.
  11:./mcu_periph/sys_time.h ****  *
  12:./mcu_periph/sys_time.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./mcu_periph/sys_time.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./mcu_periph/sys_time.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./mcu_periph/sys_time.h ****  * GNU General Public License for more details.
  16:./mcu_periph/sys_time.h ****  *
  17:./mcu_periph/sys_time.h ****  * You should have received a copy of the GNU General Public License
  18:./mcu_periph/sys_time.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./mcu_periph/sys_time.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./mcu_periph/sys_time.h ****  * Boston, MA 02111-1307, USA.
  21:./mcu_periph/sys_time.h ****  *
  22:./mcu_periph/sys_time.h ****  */
  23:./mcu_periph/sys_time.h **** 
  24:./mcu_periph/sys_time.h **** /**
  25:./mcu_periph/sys_time.h ****  * @file mcu_periph/sys_time.h
  26:./mcu_periph/sys_time.h ****  * @brief Architecture independent timing functions.
  27:./mcu_periph/sys_time.h ****  *
  28:./mcu_periph/sys_time.h ****  */
  29:./mcu_periph/sys_time.h **** 
  30:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_H
  31:./mcu_periph/sys_time.h **** #define SYS_TIME_H
  32:./mcu_periph/sys_time.h **** 
  33:./mcu_periph/sys_time.h **** #include <inttypes.h>
  34:./mcu_periph/sys_time.h **** #include <stdlib.h>
  35:./mcu_periph/sys_time.h **** #include "std.h"
  36:./mcu_periph/sys_time.h **** 
  37:./mcu_periph/sys_time.h **** #include BOARD_CONFIG
  38:./mcu_periph/sys_time.h **** 
  39:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_NB_TIMER
  40:./mcu_periph/sys_time.h **** #define SYS_TIME_NB_TIMER 16
  41:./mcu_periph/sys_time.h **** #endif
  42:./mcu_periph/sys_time.h **** 
  43:./mcu_periph/sys_time.h **** 
  44:./mcu_periph/sys_time.h **** /**
  45:./mcu_periph/sys_time.h ****  * (Default) sys_time timer frequency in Hz.
  46:./mcu_periph/sys_time.h ****  * sys_time.resolution is set from this define.
  47:./mcu_periph/sys_time.h ****  */
  48:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_FREQUENCY
  49:./mcu_periph/sys_time.h **** #if defined PERIODIC_FREQUENCY
  50:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY (2 * PERIODIC_FREQUENCY)
  51:./mcu_periph/sys_time.h **** #else
  52:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY 1000
  53:./mcu_periph/sys_time.h **** #endif
  54:./mcu_periph/sys_time.h **** #endif
  55:./mcu_periph/sys_time.h **** 
  56:./mcu_periph/sys_time.h **** 
  57:./mcu_periph/sys_time.h **** typedef uint8_t tid_t; ///< sys_time timer id type
  58:./mcu_periph/sys_time.h **** typedef void (*sys_time_cb)(uint8_t id);
  59:./mcu_periph/sys_time.h **** 
  60:./mcu_periph/sys_time.h **** struct sys_time_timer {
  61:./mcu_periph/sys_time.h ****   bool_t          in_use;
  62:./mcu_periph/sys_time.h ****   sys_time_cb     cb;
  63:./mcu_periph/sys_time.h ****   volatile bool_t elapsed;
  64:./mcu_periph/sys_time.h ****   uint32_t        end_time; ///< in SYS_TIME_TICKS
  65:./mcu_periph/sys_time.h ****   uint32_t        duration; ///< in SYS_TIME_TICKS
  66:./mcu_periph/sys_time.h **** };
  67:./mcu_periph/sys_time.h **** 
  68:./mcu_periph/sys_time.h **** struct sys_time {
  69:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec;       ///< full seconds since startup
  70:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec_rem;   ///< remainder of seconds since startup in CPU_TICKS
  71:./mcu_periph/sys_time.h ****   volatile uint32_t nb_tick;      ///< SYS_TIME_TICKS since startup
  72:./mcu_periph/sys_time.h ****   struct sys_time_timer timer[SYS_TIME_NB_TIMER];
  73:./mcu_periph/sys_time.h **** 
  74:./mcu_periph/sys_time.h ****   float resolution;               ///< sys_time_timer resolution in seconds
  75:./mcu_periph/sys_time.h ****   uint32_t ticks_per_sec;         ///< sys_time ticks per second (SYS_TIME_FREQUENCY)
  76:./mcu_periph/sys_time.h ****   uint32_t resolution_cpu_ticks;  ///< sys_time_timer resolution in cpu ticks
  77:./mcu_periph/sys_time.h ****   uint32_t cpu_ticks_per_sec;     ///< cpu ticks per second
  78:./mcu_periph/sys_time.h **** };
  79:./mcu_periph/sys_time.h **** 
  80:./mcu_periph/sys_time.h **** extern struct sys_time sys_time;
  81:./mcu_periph/sys_time.h **** 
  82:./mcu_periph/sys_time.h **** 
  83:./mcu_periph/sys_time.h **** extern void sys_time_init(void);
  84:./mcu_periph/sys_time.h **** 
  85:./mcu_periph/sys_time.h **** /**
  86:./mcu_periph/sys_time.h ****  * Register a new system timer.
  87:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
  88:./mcu_periph/sys_time.h ****  * @param cb Callback function that is called from the ISR when timer elapses, or NULL
  89:./mcu_periph/sys_time.h ****  * @return -1 if it failed, the timer id otherwise
  90:./mcu_periph/sys_time.h ****  */
  91:./mcu_periph/sys_time.h **** extern int sys_time_register_timer(float duration, sys_time_cb cb);
  92:./mcu_periph/sys_time.h **** 
  93:./mcu_periph/sys_time.h **** /**
  94:./mcu_periph/sys_time.h ****  * Cancel a system timer by id.
  95:./mcu_periph/sys_time.h ****  * @param id Timer id.
  96:./mcu_periph/sys_time.h ****  */
  97:./mcu_periph/sys_time.h **** extern void sys_time_cancel_timer(tid_t id);
  98:./mcu_periph/sys_time.h **** 
  99:./mcu_periph/sys_time.h **** /**
 100:./mcu_periph/sys_time.h ****  * Update the duration until a timer elapses.
 101:./mcu_periph/sys_time.h ****  * @param id Timer id
 102:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
 103:./mcu_periph/sys_time.h ****  */
 104:./mcu_periph/sys_time.h **** extern void sys_time_update_timer(tid_t id, float duration);
 105:./mcu_periph/sys_time.h **** 
 106:./mcu_periph/sys_time.h **** /**
 107:./mcu_periph/sys_time.h ****  * Check if timer has elapsed.
 108:./mcu_periph/sys_time.h ****  * @param id Timer id
 109:./mcu_periph/sys_time.h ****  * @return TRUE if timer has elapsed
 110:./mcu_periph/sys_time.h ****  */
 111:./mcu_periph/sys_time.h **** static inline bool_t sys_time_check_and_ack_timer(tid_t id)
 112:./mcu_periph/sys_time.h **** {
 113:./mcu_periph/sys_time.h ****   if (sys_time.timer[id].elapsed) {
 114:./mcu_periph/sys_time.h ****     sys_time.timer[id].elapsed = FALSE;
 115:./mcu_periph/sys_time.h ****     return TRUE;
 116:./mcu_periph/sys_time.h ****   }
 117:./mcu_periph/sys_time.h ****   return FALSE;
 118:./mcu_periph/sys_time.h **** }
 119:./mcu_periph/sys_time.h **** 
 120:./mcu_periph/sys_time.h **** /**
 121:./mcu_periph/sys_time.h ****  * Get the time in seconds since startup.
 122:./mcu_periph/sys_time.h ****  * @return current system time as float with sys_time.resolution
 123:./mcu_periph/sys_time.h ****  */
 124:./mcu_periph/sys_time.h **** static inline float get_sys_time_float(void)
 125:./mcu_periph/sys_time.h **** {
 126:./mcu_periph/sys_time.h ****   return (float)(sys_time.nb_sec + (float)(sys_time.nb_sec_rem) / sys_time.cpu_ticks_per_sec);
 127:./mcu_periph/sys_time.h **** }
 128:./mcu_periph/sys_time.h **** 
 129:./mcu_periph/sys_time.h **** 
 130:./mcu_periph/sys_time.h **** /*
 131:./mcu_periph/sys_time.h ****  * Convenience functions to convert between seconds and sys_time ticks.
 132:./mcu_periph/sys_time.h ****  */
 133:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_sec(float seconds)
 134:./mcu_periph/sys_time.h **** {
 135:./mcu_periph/sys_time.h ****   return (uint32_t)(seconds * sys_time.ticks_per_sec + 0.5);
 136:./mcu_periph/sys_time.h **** }
 137:./mcu_periph/sys_time.h **** 
 138:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_msec(uint32_t msec)
 139:./mcu_periph/sys_time.h **** {
 140:./mcu_periph/sys_time.h ****   return msec * sys_time.ticks_per_sec / 1000;
 141:./mcu_periph/sys_time.h **** }
 142:./mcu_periph/sys_time.h **** 
 143:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_usec(uint32_t usec)
 144:./mcu_periph/sys_time.h **** {
 145:./mcu_periph/sys_time.h ****   return usec * sys_time.ticks_per_sec / 1000000;
 146:./mcu_periph/sys_time.h **** }
 147:./mcu_periph/sys_time.h **** 
 148:./mcu_periph/sys_time.h **** static inline float sec_of_sys_time_ticks(uint32_t ticks)
 149:./mcu_periph/sys_time.h **** {
 150:./mcu_periph/sys_time.h ****   return (float)ticks * sys_time.resolution;
 151:./mcu_periph/sys_time.h **** }
 152:./mcu_periph/sys_time.h **** 
 153:./mcu_periph/sys_time.h **** static inline uint32_t msec_of_sys_time_ticks(uint32_t ticks)
 154:./mcu_periph/sys_time.h **** {
 155:./mcu_periph/sys_time.h ****   return ticks * 1000 / sys_time.ticks_per_sec;
 156:./mcu_periph/sys_time.h **** }
 157:./mcu_periph/sys_time.h **** 
 158:./mcu_periph/sys_time.h **** static inline uint32_t usec_of_sys_time_ticks(uint32_t ticks)
 159:./mcu_periph/sys_time.h **** {
 160:./mcu_periph/sys_time.h ****   return ticks * 1000 / sys_time.ticks_per_sec * 1000;
 161:./mcu_periph/sys_time.h **** }
 162:./mcu_periph/sys_time.h **** 
 163:./mcu_periph/sys_time.h **** 
 164:./mcu_periph/sys_time.h **** 
 165:./mcu_periph/sys_time.h **** /*
 166:./mcu_periph/sys_time.h ****  * Convenience functions to convert between seconds and CPU ticks.
 167:./mcu_periph/sys_time.h ****  */
 168:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_sec(float seconds)
 169:./mcu_periph/sys_time.h **** {
 170:./mcu_periph/sys_time.h ****   return (uint32_t)(seconds * sys_time.cpu_ticks_per_sec + 0.5);
 171:./mcu_periph/sys_time.h **** }
 172:./mcu_periph/sys_time.h **** 
 173:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_usec(uint32_t usec)
 174:./mcu_periph/sys_time.h **** {
 175:./mcu_periph/sys_time.h ****   return usec * (sys_time.cpu_ticks_per_sec / 1000000);
 176:./mcu_periph/sys_time.h **** }
 177:./mcu_periph/sys_time.h **** 
 178:./mcu_periph/sys_time.h **** static inline int32_t signed_cpu_ticks_of_usec(int32_t usec)
 179:./mcu_periph/sys_time.h **** {
 180:./mcu_periph/sys_time.h ****   return usec * ((int32_t)sys_time.cpu_ticks_per_sec / 1000000);
 181:./mcu_periph/sys_time.h **** }
 182:./mcu_periph/sys_time.h **** 
 183:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_nsec(uint32_t nsec)
 184:./mcu_periph/sys_time.h **** {
 185:./mcu_periph/sys_time.h ****   return nsec * (sys_time.cpu_ticks_per_sec / 1000000) / 1000;
 186:./mcu_periph/sys_time.h **** }
 187:./mcu_periph/sys_time.h **** 
 188:./mcu_periph/sys_time.h **** static inline uint32_t msec_of_cpu_ticks(uint32_t cpu_ticks)
 189:./mcu_periph/sys_time.h **** {
 190:./mcu_periph/sys_time.h ****   return cpu_ticks / (sys_time.cpu_ticks_per_sec / 1000);
 191:./mcu_periph/sys_time.h **** }
 192:./mcu_periph/sys_time.h **** 
 193:./mcu_periph/sys_time.h **** static inline uint32_t usec_of_cpu_ticks(uint32_t cpu_ticks)
 194:./mcu_periph/sys_time.h **** {
 195:./mcu_periph/sys_time.h ****   return cpu_ticks / (sys_time.cpu_ticks_per_sec / 1000000);
 114              		.loc 3 195 0
 115 0004 0D4D     		ldr	r5, .L3+4
 116 0006 D4F85831 		ldr	r3, [r4, #344]
 117              	.LBE69:
 118              	.LBE68:
 119              		.loc 2 56 0
 120 000a 2668     		ldr	r6, [r4]
  57:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****          usec_of_cpu_ticks(sys_time.nb_sec_rem) +
 121              		.loc 2 57 0
 122 000c 6268     		ldr	r2, [r4, #4]
 123              	.LVL11:
 124              	.LBB71:
 125              	.LBB70:
 126              		.loc 3 195 0
 127 000e B3FBF5F3 		udiv	r3, r3, r5
 128 0012 B2FBF3F3 		udiv	r3, r2, r3
 129              	.LBE70:
 130              	.LBE71:
  56:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****   return sys_time.nb_sec * 1000000 +
 131              		.loc 2 56 0
 132 0016 05FB0636 		mla	r6, r5, r6, r3
  58:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****          usec_of_cpu_ticks(systick_get_reload() - systick_get_value());
 133              		.loc 2 58 0
 134 001a FFF7FEFF 		bl	systick_get_reload
 135              	.LVL12:
 136 001e 0746     		mov	r7, r0
 137 0020 FFF7FEFF 		bl	systick_get_value
 138              	.LVL13:
 139 0024 381A     		subs	r0, r7, r0
 140              	.LVL14:
 141              	.LBB72:
 142              	.LBB73:
 143              		.loc 3 195 0
 144 0026 D4F85871 		ldr	r7, [r4, #344]
 145 002a B7FBF5F5 		udiv	r5, r7, r5
 146 002e B0FBF5F0 		udiv	r0, r0, r5
 147              	.LVL15:
 148              	.LBE73:
 149              	.LBE72:
  59:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #endif
  60:/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** }
 150              		.loc 2 60 0
 151 0032 3044     		add	r0, r0, r6
 152 0034 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 153              	.L4:
 154 0036 00BF     		.align	2
 155              	.L3:
 156 0038 00000000 		.word	sys_time
 157 003c 40420F00 		.word	1000000
 158              		.cfi_endproc
 159              	.LFE39:
 161              		.section	.text.i2c_setup_gpio.part.0,"ax",%progbits
 162              		.align	1
 163              		.thumb
 164              		.thumb_func
 166              	i2c_setup_gpio.part.0:
 167              	.LFB45:
 112:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_setup_gpio(uint32_t i2c)
 168              		.loc 1 112 0
 169              		.cfi_startproc
 170              		@ args = 0, pretend = 0, frame = 0
 171              		@ frame_needed = 0, uses_anonymous_args = 0
 172              	.LVL16:
 173 0000 10B5     		push	{r4, lr}
 174              		.cfi_def_cfa_offset 8
 175              		.cfi_offset 4, -8
 176              		.cfi_offset 14, -4
 127:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C2_GPIO_PORT);
 177              		.loc 1 127 0
 178 0002 0D4C     		ldr	r4, .L6
 179 0004 2046     		mov	r0, r4
 180 0006 FFF7FEFF 		bl	gpio_enable_clock
 181              	.LVL17:
 128:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C2_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 182              		.loc 1 128 0
 183 000a 2046     		mov	r0, r4
 184 000c 0221     		movs	r1, #2
 185 000e 0022     		movs	r2, #0
 186 0010 4FF44063 		mov	r3, #3072
 187 0014 FFF7FEFF 		bl	gpio_mode_setup
 188              	.LVL18:
 130:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C2_GPIO_PORT, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 189              		.loc 1 130 0
 190 0018 0121     		movs	r1, #1
 191 001a 2046     		mov	r0, r4
 192 001c 0A46     		mov	r2, r1
 193 001e 4FF44063 		mov	r3, #3072
 194 0022 FFF7FEFF 		bl	gpio_set_output_options
 195              	.LVL19:
 132:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C2_GPIO_PORT, GPIO_AF4,
 196              		.loc 1 132 0
 197 0026 2046     		mov	r0, r4
 198 0028 0421     		movs	r1, #4
 199 002a 4FF44062 		mov	r2, #3072
 154:arch/stm32/mcu_periph/i2c_arch.c **** }
 200              		.loc 1 154 0
 201 002e BDE81040 		pop	{r4, lr}
 132:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C2_GPIO_PORT, GPIO_AF4,
 202              		.loc 1 132 0
 203 0032 FFF7FEBF 		b	gpio_set_af
 204              	.LVL20:
 205              	.L7:
 206 0036 00BF     		.align	2
 207              	.L6:
 208 0038 00040240 		.word	1073873920
 209              		.cfi_endproc
 210              	.LFE45:
 212              		.section	.text.stmi2c_clear_pending_interrupts,"ax",%progbits
 213              		.align	1
 214              		.thumb
 215              		.thumb_func
 217              	stmi2c_clear_pending_interrupts:
 218              	.LFB15:
 205:arch/stm32/mcu_periph/i2c_arch.c **** 
 206:arch/stm32/mcu_periph/i2c_arch.c **** }
 207:arch/stm32/mcu_periph/i2c_arch.c **** 
 208:arch/stm32/mcu_periph/i2c_arch.c **** // STOP
 209:arch/stm32/mcu_periph/i2c_arch.c **** 
 210:arch/stm32/mcu_periph/i2c_arch.c **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 211:arch/stm32/mcu_periph/i2c_arch.c **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 212:arch/stm32/mcu_periph/i2c_arch.c **** //
 213:arch/stm32/mcu_periph/i2c_arch.c **** //  SUBTRANSACTION SEQUENCES
 214:arch/stm32/mcu_periph/i2c_arch.c **** //  -We arrive here every time a ISR is called with no error
 215:arch/stm32/mcu_periph/i2c_arch.c **** 
 216:arch/stm32/mcu_periph/i2c_arch.c **** enum STMI2CSubTransactionStatus {
 217:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Busy,
 218:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Ready_StopRequested,
 219:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Ready,
 220:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Error
 221:arch/stm32/mcu_periph/i2c_arch.c **** };
 222:arch/stm32/mcu_periph/i2c_arch.c **** 
 223:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 710/1072
 224:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Transmitter
 225:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_send(uint32_t i2c, struct i2c_periph *periph,
 226:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 227:arch/stm32/mcu_periph/i2c_arch.c **** {
 228:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 229:arch/stm32/mcu_periph/i2c_arch.c **** 
 230:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 231:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 232:arch/stm32/mcu_periph/i2c_arch.c ****     // Disable buffer interrupt
 233:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 234:arch/stm32/mcu_periph/i2c_arch.c ****     // Send Slave address and wait for ADDR interrupt
 235:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr);
 236:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 237:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrWrSent;
 238:arch/stm32/mcu_periph/i2c_arch.c ****   }
 239:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 240:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 241:arch/stm32/mcu_periph/i2c_arch.c ****     // Now read SR2 to clear the ADDR status Bit
 242:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2  __attribute__((unused)) = I2C_SR2(i2c);
 243:arch/stm32/mcu_periph/i2c_arch.c **** 
 244:arch/stm32/mcu_periph/i2c_arch.c ****     // Maybe check we are transmitting (did not loose arbitration for instance)
 245:arch/stm32/mcu_periph/i2c_arch.c ****     // if (! BIT_X_IS_SET_IN_REG(I2C_SR2_TRA, SR2)) { }
 246:arch/stm32/mcu_periph/i2c_arch.c ****     // update: this should be caught by the ARLO error: so we will not arrive here
 247:arch/stm32/mcu_periph/i2c_arch.c **** 
 248:arch/stm32/mcu_periph/i2c_arch.c ****     // Send First max 2 bytes
 249:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[0]);
 250:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->len_w > 1) {
 251:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, trans->buf[1]);
 252:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 2;
 253:arch/stm32/mcu_periph/i2c_arch.c ****     } else {
 254:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 1;
 255:arch/stm32/mcu_periph/i2c_arch.c ****     }
 256:arch/stm32/mcu_periph/i2c_arch.c **** 
 257:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable buffer-space available interrupt
 258:arch/stm32/mcu_periph/i2c_arch.c ****     // only if there is more to send: wait for TXE, no more to send: wait for BTF
 259:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < trans->len_w) {
 260:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 261:arch/stm32/mcu_periph/i2c_arch.c ****     }
 262:arch/stm32/mcu_periph/i2c_arch.c **** 
 263:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 264:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CSendingByte;
 265:arch/stm32/mcu_periph/i2c_arch.c ****   }
 266:arch/stm32/mcu_periph/i2c_arch.c ****   // The buffer is not full anymore AND we were not waiting for BTF
 267:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_TxE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR2
 268:arch/stm32/mcu_periph/i2c_arch.c ****     // Send the next byte
 269:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[periph->idx_buf]);
 270:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf++;
 271:arch/stm32/mcu_periph/i2c_arch.c **** 
 272:arch/stm32/mcu_periph/i2c_arch.c ****     // All bytes Sent? Then wait for BTF instead
 273:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf >= trans->len_w) {
 274:arch/stm32/mcu_periph/i2c_arch.c ****       // Not interested anymore to know the buffer has space left
 275:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 276:arch/stm32/mcu_periph/i2c_arch.c ****       // Next interrupt will be BTF (or error)
 277:arch/stm32/mcu_periph/i2c_arch.c ****     }
 278:arch/stm32/mcu_periph/i2c_arch.c ****   }
 279:arch/stm32/mcu_periph/i2c_arch.c ****   // BTF: means last byte was sent
 280:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 281:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTx) {
 282:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell the driver we are ready
 283:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 284:arch/stm32/mcu_periph/i2c_arch.c ****     }
 285:arch/stm32/mcu_periph/i2c_arch.c ****     // Otherwise we still need to do the receiving part
 286:arch/stm32/mcu_periph/i2c_arch.c **** 
 287:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready;
 288:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 289:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 290:arch/stm32/mcu_periph/i2c_arch.c ****   }
 291:arch/stm32/mcu_periph/i2c_arch.c **** 
 292:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 293:arch/stm32/mcu_periph/i2c_arch.c **** }
 294:arch/stm32/mcu_periph/i2c_arch.c **** 
 295:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 714/1072
 296:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N=1
 297:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_read1(uint32_t i2c, struct i2c_periph *periph,
 298:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 299:arch/stm32/mcu_periph/i2c_arch.c **** {
 300:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 301:arch/stm32/mcu_periph/i2c_arch.c **** 
 302:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 303:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 304:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 305:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 306:arch/stm32/mcu_periph/i2c_arch.c **** 
 307:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 308:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 309:arch/stm32/mcu_periph/i2c_arch.c ****   }
 310:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 311:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 312:arch/stm32/mcu_periph/i2c_arch.c ****     // First Clear the ACK bit: after the next byte we do not want new bytes
 313:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 314:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 315:arch/stm32/mcu_periph/i2c_arch.c **** 
 316:arch/stm32/mcu_periph/i2c_arch.c ****     // --- next to steps MUST be executed together to avoid missing the stop
 317:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 318:arch/stm32/mcu_periph/i2c_arch.c **** 
 319:arch/stm32/mcu_periph/i2c_arch.c ****     // Only after setting ACK, read SR2 to clear the ADDR (next byte will start arriving)
 320:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 321:arch/stm32/mcu_periph/i2c_arch.c **** 
 322:arch/stm32/mcu_periph/i2c_arch.c ****     // Schedule a Stop
 323:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 324:arch/stm32/mcu_periph/i2c_arch.c **** 
 325:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 326:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 327:arch/stm32/mcu_periph/i2c_arch.c **** 
 328:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable the RXNE: it will trigger as soon as the 1 byte is received to get the result
 329:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 330:arch/stm32/mcu_periph/i2c_arch.c **** 
 331:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 332:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingLastByte;
 333:arch/stm32/mcu_periph/i2c_arch.c ****   }
 334:arch/stm32/mcu_periph/i2c_arch.c ****   // As soon as there is 1 byte ready to read, we have our byte
 335:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) {
 336:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 337:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 338:arch/stm32/mcu_periph/i2c_arch.c **** 
 339:arch/stm32/mcu_periph/i2c_arch.c ****     // We got all the results (stop condition might still be in progress but this is the last inter
 340:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 341:arch/stm32/mcu_periph/i2c_arch.c **** 
 342:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status:
 343:arch/stm32/mcu_periph/i2c_arch.c ****     // -the stop was actually already requested in the previous step
 344:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 345:arch/stm32/mcu_periph/i2c_arch.c **** 
 346:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready_StopRequested;
 347:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 348:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 349:arch/stm32/mcu_periph/i2c_arch.c ****   }
 350:arch/stm32/mcu_periph/i2c_arch.c **** 
 351:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 352:arch/stm32/mcu_periph/i2c_arch.c **** }
 353:arch/stm32/mcu_periph/i2c_arch.c **** 
 354:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 713/1072
 355:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N=2
 356:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_read2(uint32_t i2c, struct i2c_periph *periph,
 357:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 358:arch/stm32/mcu_periph/i2c_arch.c **** {
 359:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 360:arch/stm32/mcu_periph/i2c_arch.c **** 
 361:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 362:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 363:arch/stm32/mcu_periph/i2c_arch.c ****     // according to the datasheet: instantly shedule a NAK on the second received byte:
 364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 365:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 366:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_next(i2c);
 367:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 368:arch/stm32/mcu_periph/i2c_arch.c **** 
 369:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 370:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 371:arch/stm32/mcu_periph/i2c_arch.c ****   }
 372:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 373:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 374:arch/stm32/mcu_periph/i2c_arch.c ****     // --- make absolutely sure this command is not delayed too much after the previous:
 375:arch/stm32/mcu_periph/i2c_arch.c ****     // --- the NAK bits must be set before the first byte arrived: allow other interrupts here
 376:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 377:arch/stm32/mcu_periph/i2c_arch.c **** 
 378:arch/stm32/mcu_periph/i2c_arch.c ****     //       if transfer of DR was finished already then we will get too many bytes
 379:arch/stm32/mcu_periph/i2c_arch.c ****     // BEFORE clearing ACK, read SR2 to clear the ADDR (next byte will start arriving)
 380:arch/stm32/mcu_periph/i2c_arch.c ****     // clearing ACK after the byte transfer has already started will NACK the next (2nd)
 381:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 382:arch/stm32/mcu_periph/i2c_arch.c **** 
 383:arch/stm32/mcu_periph/i2c_arch.c ****     // NOT First Clear the ACK bit but only AFTER clearing ADDR
 384:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 385:arch/stm32/mcu_periph/i2c_arch.c **** 
 386:arch/stm32/mcu_periph/i2c_arch.c ****     // Disable the RXNE and wait for BTF
 387:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 388:arch/stm32/mcu_periph/i2c_arch.c **** 
 389:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 390:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 391:arch/stm32/mcu_periph/i2c_arch.c **** 
 392:arch/stm32/mcu_periph/i2c_arch.c ****     // We do not set the RxE but wait for both bytes to arrive using BTF
 393:arch/stm32/mcu_periph/i2c_arch.c **** 
 394:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 395:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 396:arch/stm32/mcu_periph/i2c_arch.c ****   }
 397:arch/stm32/mcu_periph/i2c_arch.c ****   // Receive buffer if full, master is halted: BTF
 398:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 399:arch/stm32/mcu_periph/i2c_arch.c ****     // Stop condition MUST be set BEFORE reading the DR
 400:arch/stm32/mcu_periph/i2c_arch.c ****     // otherwise since there is new buffer space a new byte will be read
 401:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 402:arch/stm32/mcu_periph/i2c_arch.c **** 
 403:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 404:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 405:arch/stm32/mcu_periph/i2c_arch.c **** 
 406:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 407:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[1] = I2C_DR(i2c);
 408:arch/stm32/mcu_periph/i2c_arch.c **** 
 409:arch/stm32/mcu_periph/i2c_arch.c ****     // We got all the results
 410:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 411:arch/stm32/mcu_periph/i2c_arch.c **** 
 412:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready_StopRequested;
 413:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 414:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 415:arch/stm32/mcu_periph/i2c_arch.c ****   }
 416:arch/stm32/mcu_periph/i2c_arch.c **** 
 417:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 418:arch/stm32/mcu_periph/i2c_arch.c **** }
 419:arch/stm32/mcu_periph/i2c_arch.c **** 
 420:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 712/1072
 421:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N>2
 422:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_readmany(uint32_t i2c, struct i2c_periph *peri
 423:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 424:arch/stm32/mcu_periph/i2c_arch.c **** {
 425:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 426:arch/stm32/mcu_periph/i2c_arch.c **** 
 427:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 428:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 429:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 430:arch/stm32/mcu_periph/i2c_arch.c ****     // The first data byte will be acked in read many so the slave knows it should send more
 431:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 432:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 433:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear the SB flag
 434:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 435:arch/stm32/mcu_periph/i2c_arch.c **** 
 436:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 437:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 438:arch/stm32/mcu_periph/i2c_arch.c ****   }
 439:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 440:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 441:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf = 0;
 442:arch/stm32/mcu_periph/i2c_arch.c **** 
 443:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable RXNE: receive an interrupt any time a byte is available
 444:arch/stm32/mcu_periph/i2c_arch.c ****     // only enable if MORE than 3 bytes need to be read
 445:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 446:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 447:arch/stm32/mcu_periph/i2c_arch.c ****     }
 448:arch/stm32/mcu_periph/i2c_arch.c **** 
 449:arch/stm32/mcu_periph/i2c_arch.c ****     // ACK is still on to get more DATA
 450:arch/stm32/mcu_periph/i2c_arch.c ****     // Read SR2 to clear the ADDR (next byte will start arriving)
 451:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 452:arch/stm32/mcu_periph/i2c_arch.c **** 
 453:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 454:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 455:arch/stm32/mcu_periph/i2c_arch.c ****   }
 456:arch/stm32/mcu_periph/i2c_arch.c ****   // one or more bytes are available AND we were interested in Buffer interrupts
 457:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR
 458:arch/stm32/mcu_periph/i2c_arch.c ****     // read byte until 3 bytes remain to be read (e.g. len_r = 6, -> idx=3 means idx 3,4,5 = 3 rema
 459:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 460:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = I2C_DR(i2c);
 461:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 462:arch/stm32/mcu_periph/i2c_arch.c ****     }
 463:arch/stm32/mcu_periph/i2c_arch.c ****     // from : 3bytes -> last byte: do nothing
 464:arch/stm32/mcu_periph/i2c_arch.c ****     //
 465:arch/stm32/mcu_periph/i2c_arch.c ****     // finally: this was the last byte
 466:arch/stm32/mcu_periph/i2c_arch.c ****     else if (periph->idx_buf >= (trans->len_r - 1)) {
 467:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 468:arch/stm32/mcu_periph/i2c_arch.c **** 
 469:arch/stm32/mcu_periph/i2c_arch.c ****       // Last Value
 470:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 471:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 472:arch/stm32/mcu_periph/i2c_arch.c **** 
 473:arch/stm32/mcu_periph/i2c_arch.c ****       // We got all the results
 474:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 475:arch/stm32/mcu_periph/i2c_arch.c **** 
 476:arch/stm32/mcu_periph/i2c_arch.c ****       return STMI2C_SubTra_Ready_StopRequested;
 477:arch/stm32/mcu_periph/i2c_arch.c ****     }
 478:arch/stm32/mcu_periph/i2c_arch.c **** 
 479:arch/stm32/mcu_periph/i2c_arch.c ****     // Check for end of transaction: start waiting for BTF instead of RXNE
 480:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 481:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 482:arch/stm32/mcu_periph/i2c_arch.c ****     } else { // idx >= len-3: there are 3 bytes to be read
 483:arch/stm32/mcu_periph/i2c_arch.c ****       // We want to halt I2C to have sufficient time to clear ACK, so:
 484:arch/stm32/mcu_periph/i2c_arch.c ****       // Stop listening to RXNE as it will be triggered infinitely since we did not empty the buffe
 485:arch/stm32/mcu_periph/i2c_arch.c ****       // on the next (second in buffer) received byte BTF will be set (buffer full and I2C halted)
 486:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 487:arch/stm32/mcu_periph/i2c_arch.c ****     }
 488:arch/stm32/mcu_periph/i2c_arch.c ****   }
 489:arch/stm32/mcu_periph/i2c_arch.c ****   // Buffer is full while this was not a RXNE interrupt
 490:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 491:arch/stm32/mcu_periph/i2c_arch.c ****     // Now the shift register and data register contain data(n-2) and data(n-1)
 492:arch/stm32/mcu_periph/i2c_arch.c ****     // And I2C is halted so we have time
 493:arch/stm32/mcu_periph/i2c_arch.c **** 
 494:arch/stm32/mcu_periph/i2c_arch.c ****     // --- Make absolutely sure the next 2 I2C actions are performed with no delay
 495:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 496:arch/stm32/mcu_periph/i2c_arch.c **** 
 497:arch/stm32/mcu_periph/i2c_arch.c ****     // First we clear the ACK while the SCL is held low by BTF
 498:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 499:arch/stm32/mcu_periph/i2c_arch.c **** 
 500:arch/stm32/mcu_periph/i2c_arch.c ****     // Now that ACK is cleared we read one byte: instantly the last byte is being clocked in...
 501:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 502:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 503:arch/stm32/mcu_periph/i2c_arch.c **** 
 504:arch/stm32/mcu_periph/i2c_arch.c ****     // Now the last byte is being clocked. Stop in MUST be set BEFORE the transfer of the last byte
 505:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 506:arch/stm32/mcu_periph/i2c_arch.c **** 
 507:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 508:arch/stm32/mcu_periph/i2c_arch.c **** 
 509:arch/stm32/mcu_periph/i2c_arch.c **** 
 510:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 511:arch/stm32/mcu_periph/i2c_arch.c **** 
 512:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 513:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 514:arch/stm32/mcu_periph/i2c_arch.c **** 
 515:arch/stm32/mcu_periph/i2c_arch.c ****     // read the byte2 we had in the buffer (BTF means 2 bytes available)
 516:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 517:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 518:arch/stm32/mcu_periph/i2c_arch.c **** 
 519:arch/stm32/mcu_periph/i2c_arch.c ****     // Ask for an interrupt to read the last byte (which is normally still busy now)
 520:arch/stm32/mcu_periph/i2c_arch.c ****     // The last byte will be received with RXNE
 521:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 522:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 523:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 524:arch/stm32/mcu_periph/i2c_arch.c ****   }
 525:arch/stm32/mcu_periph/i2c_arch.c **** 
 526:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 527:arch/stm32/mcu_periph/i2c_arch.c **** }
 528:arch/stm32/mcu_periph/i2c_arch.c **** 
 529:arch/stm32/mcu_periph/i2c_arch.c **** ////////////////////////////////////////////////
 530:arch/stm32/mcu_periph/i2c_arch.c **** // Restore bus conditions to normal after errors
 531:arch/stm32/mcu_periph/i2c_arch.c **** 
 532:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_error(struct i2c_periph *periph)
 533:arch/stm32/mcu_periph/i2c_arch.c **** {
 534:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 535:arch/stm32/mcu_periph/i2c_arch.c ****   uint8_t err_nr = 0;
 536:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 537:arch/stm32/mcu_periph/i2c_arch.c ****   periph->errors->er_irq_cnt;
 538:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_AF) != 0) { /* Acknowledge failure */
 539:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->ack_fail_cnt++;
 540:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_AF;
 541:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 542:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 1;
 543:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 544:arch/stm32/mcu_periph/i2c_arch.c ****   }
 545:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_BERR) != 0) {     /* Misplaced Start or Stop c
 546:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->miss_start_stop_cnt++;
 547:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_BERR;
 548:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 549:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 2;
 550:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 551:arch/stm32/mcu_periph/i2c_arch.c ****   }
 552:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_ARLO) != 0) {     /* Arbitration lost */
 553:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->arb_lost_cnt++;
 554:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_ARLO;
 555:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 556:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 3;
 557:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 558:arch/stm32/mcu_periph/i2c_arch.c ****   }
 559:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_OVR) != 0) {      /* Overrun/Underrun */
 560:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->over_under_cnt++;
 561:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_OVR;
 562:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 563:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 4;
 564:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 565:arch/stm32/mcu_periph/i2c_arch.c ****   }
 566:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_PECERR) != 0) {   /* PEC Error in reception */
 567:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->pec_recep_cnt++;
 568:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_PECERR;
 569:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 570:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 5;
 571:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 572:arch/stm32/mcu_periph/i2c_arch.c ****   }
 573:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_TIMEOUT) != 0) {  /* Timeout or Tlow error */
 574:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->timeout_tlow_cnt++;
 575:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_TIMEOUT;
 576:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 577:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 6;
 578:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 579:arch/stm32/mcu_periph/i2c_arch.c ****   }
 580:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_SMBALERT) != 0) { /* SMBus alert */
 581:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->smbus_alert_cnt++;
 582:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_SMBALERT;
 583:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 584:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 7;
 585:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 586:arch/stm32/mcu_periph/i2c_arch.c ****   }
 587:arch/stm32/mcu_periph/i2c_arch.c **** 
 588:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 589:arch/stm32/mcu_periph/i2c_arch.c ****   LED_ERROR(20, err_nr);
 590:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 591:arch/stm32/mcu_periph/i2c_arch.c **** 
 592:arch/stm32/mcu_periph/i2c_arch.c ****   return;
 593:arch/stm32/mcu_periph/i2c_arch.c **** }
 594:arch/stm32/mcu_periph/i2c_arch.c **** 
 595:arch/stm32/mcu_periph/i2c_arch.c **** 
 596:arch/stm32/mcu_periph/i2c_arch.c **** static inline void stmi2c_clear_pending_interrupts(uint32_t i2c)
 597:arch/stm32/mcu_periph/i2c_arch.c **** {
 219              		.loc 1 597 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 0
 222              		@ frame_needed = 0, uses_anonymous_args = 0
 223              	.LVL21:
 224 0000 38B5     		push	{r3, r4, r5, lr}
 225              		.cfi_def_cfa_offset 16
 226              		.cfi_offset 3, -16
 227              		.cfi_offset 4, -12
 228              		.cfi_offset 5, -8
 229              		.cfi_offset 14, -4
 598:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 230              		.loc 1 598 0
 231 0002 4569     		ldr	r5, [r0, #20]
 232              	.LVL22:
 599:arch/stm32/mcu_periph/i2c_arch.c **** 
 600:arch/stm32/mcu_periph/i2c_arch.c ****   // Certainly do not wait for buffer interrupts:
 601:arch/stm32/mcu_periph/i2c_arch.c ****   // -------------------------------------------
 602:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);      // Disable TXE, RXNE
 233              		.loc 1 602 0
 234 0004 4FF48061 		mov	r1, #1024
 235 0008 ADB2     		uxth	r5, r5
 236              	.LVL23:
 597:arch/stm32/mcu_periph/i2c_arch.c **** {
 237              		.loc 1 597 0
 238 000a 0446     		mov	r4, r0
 239              		.loc 1 602 0
 240 000c FFF7FEFF 		bl	i2c_disable_interrupt
 241              	.LVL24:
 603:arch/stm32/mcu_periph/i2c_arch.c **** 
 604:arch/stm32/mcu_periph/i2c_arch.c ****   // Error interrupts are handled separately:
 605:arch/stm32/mcu_periph/i2c_arch.c ****   // ---------------------------------------
 606:arch/stm32/mcu_periph/i2c_arch.c **** 
 607:arch/stm32/mcu_periph/i2c_arch.c ****   // Clear Event interrupt conditions:
 608:arch/stm32/mcu_periph/i2c_arch.c ****   // --------------------------------
 609:arch/stm32/mcu_periph/i2c_arch.c **** 
 610:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Generated
 611:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 242              		.loc 1 611 0
 243 0010 E907     		lsls	r1, r5, #31
 244 0012 03D5     		bpl	.L9
 612:arch/stm32/mcu_periph/i2c_arch.c ****     // SB: cleared by software when reading SR1 and writing to DR
 613:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 245              		.loc 1 613 0
 246 0014 2046     		mov	r0, r4
 247 0016 0021     		movs	r1, #0
 248 0018 FFF7FEFF 		bl	i2c_send_data
 249              	.LVL25:
 250              	.L9:
 614:arch/stm32/mcu_periph/i2c_arch.c ****   }
 615:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 616:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 251              		.loc 1 616 0
 252 001c AA07     		lsls	r2, r5, #30
 253              	.LBB79:
 617:arch/stm32/mcu_periph/i2c_arch.c ****     // ADDR: Cleared by software when reading SR1 and then SR2
 618:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 254              		.loc 1 618 0
 255 001e 48BF     		it	mi
 256 0020 A369     		ldrmi	r3, [r4, #24]
 257              	.LBE79:
 619:arch/stm32/mcu_periph/i2c_arch.c ****   }
 620:arch/stm32/mcu_periph/i2c_arch.c ****   // Byte Transfer Finished
 621:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 258              		.loc 1 621 0
 259 0022 6B07     		lsls	r3, r5, #29
 260 0024 08D5     		bpl	.L8
 261              	.LVL26:
 262              	.LBB80:
 263              	.LBB81:
 264              	.LBB82:
 622:arch/stm32/mcu_periph/i2c_arch.c ****     // SB: cleared by software when reading SR1 and reading/writing to DR
 623:arch/stm32/mcu_periph/i2c_arch.c ****     uint8_t dummy __attribute__((unused)) = i2c_get_data(i2c);
 265              		.loc 1 623 0
 266 0026 2046     		mov	r0, r4
 267 0028 FFF7FEFF 		bl	i2c_get_data
 268              	.LVL27:
 624:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 269              		.loc 1 624 0
 270 002c 2046     		mov	r0, r4
 271 002e 0021     		movs	r1, #0
 272              	.LBE82:
 273              	.LBE81:
 274              	.LBE80:
 625:arch/stm32/mcu_periph/i2c_arch.c ****   }
 626:arch/stm32/mcu_periph/i2c_arch.c **** 
 627:arch/stm32/mcu_periph/i2c_arch.c **** }
 275              		.loc 1 627 0
 276 0030 BDE83840 		pop	{r3, r4, r5, lr}
 277              	.LVL28:
 278              	.LBB85:
 279              	.LBB84:
 280              	.LBB83:
 624:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 281              		.loc 1 624 0
 282 0034 FFF7FEBF 		b	i2c_send_data
 283              	.LVL29:
 284              	.L8:
 285 0038 38BD     		pop	{r3, r4, r5, pc}
 286              	.LBE83:
 287              	.LBE84:
 288              	.LBE85:
 289              		.cfi_endproc
 290              	.LFE15:
 292              		.section	.text.i2c_error.constprop.7,"ax",%progbits
 293              		.align	1
 294              		.thumb
 295              		.thumb_func
 297              	i2c_error.constprop.7:
 298              	.LFB55:
 532:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_error(struct i2c_periph *periph)
 299              		.loc 1 532 0
 300              		.cfi_startproc
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              		@ link register save eliminated.
 304              	.LVL30:
 537:arch/stm32/mcu_periph/i2c_arch.c ****   periph->errors->er_irq_cnt;
 305              		.loc 1 537 0
 306 0000 284B     		ldr	r3, .L48
 307 0002 DA6A     		ldr	r2, [r3, #44]
 538:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_AF) != 0) { /* Acknowledge failure */
 308              		.loc 1 538 0
 309 0004 5B6A     		ldr	r3, [r3, #36]
 537:arch/stm32/mcu_periph/i2c_arch.c ****   periph->errors->er_irq_cnt;
 310              		.loc 1 537 0
 311 0006 9169     		ldr	r1, [r2, #24]
 538:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_AF) != 0) { /* Acknowledge failure */
 312              		.loc 1 538 0
 313 0008 5969     		ldr	r1, [r3, #20]
 314 000a 4905     		lsls	r1, r1, #21
 315 000c 07D5     		bpl	.L20
 539:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->ack_fail_cnt++;
 316              		.loc 1 539 0
 317 000e 5188     		ldrh	r1, [r2, #2]
 318 0010 0131     		adds	r1, r1, #1
 319 0012 89B2     		uxth	r1, r1
 320 0014 5180     		strh	r1, [r2, #2]	@ movhi
 540:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_AF;
 321              		.loc 1 540 0
 322 0016 5969     		ldr	r1, [r3, #20]
 323 0018 21F48061 		bic	r1, r1, #1024
 324 001c 5961     		str	r1, [r3, #20]
 325              	.L20:
 545:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_BERR) != 0) {     /* Misplaced Start or Stop c
 326              		.loc 1 545 0
 327 001e 5969     		ldr	r1, [r3, #20]
 328 0020 C805     		lsls	r0, r1, #23
 329 0022 07D5     		bpl	.L21
 546:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->miss_start_stop_cnt++;
 330              		.loc 1 546 0
 331 0024 9188     		ldrh	r1, [r2, #4]
 332 0026 0131     		adds	r1, r1, #1
 333 0028 89B2     		uxth	r1, r1
 334 002a 9180     		strh	r1, [r2, #4]	@ movhi
 547:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_BERR;
 335              		.loc 1 547 0
 336 002c 5969     		ldr	r1, [r3, #20]
 337 002e 21F48071 		bic	r1, r1, #256
 338 0032 5961     		str	r1, [r3, #20]
 339              	.L21:
 552:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_ARLO) != 0) {     /* Arbitration lost */
 340              		.loc 1 552 0
 341 0034 5969     		ldr	r1, [r3, #20]
 342 0036 8905     		lsls	r1, r1, #22
 343 0038 07D5     		bpl	.L22
 553:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->arb_lost_cnt++;
 344              		.loc 1 553 0
 345 003a D188     		ldrh	r1, [r2, #6]
 346 003c 0131     		adds	r1, r1, #1
 347 003e 89B2     		uxth	r1, r1
 348 0040 D180     		strh	r1, [r2, #6]	@ movhi
 554:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_ARLO;
 349              		.loc 1 554 0
 350 0042 5969     		ldr	r1, [r3, #20]
 351 0044 21F40071 		bic	r1, r1, #512
 352 0048 5961     		str	r1, [r3, #20]
 353              	.L22:
 559:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_OVR) != 0) {      /* Overrun/Underrun */
 354              		.loc 1 559 0
 355 004a 5969     		ldr	r1, [r3, #20]
 356 004c 0805     		lsls	r0, r1, #20
 357 004e 07D5     		bpl	.L23
 560:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->over_under_cnt++;
 358              		.loc 1 560 0
 359 0050 1189     		ldrh	r1, [r2, #8]
 360 0052 0131     		adds	r1, r1, #1
 361 0054 89B2     		uxth	r1, r1
 362 0056 1181     		strh	r1, [r2, #8]	@ movhi
 561:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_OVR;
 363              		.loc 1 561 0
 364 0058 5969     		ldr	r1, [r3, #20]
 365 005a 21F40061 		bic	r1, r1, #2048
 366 005e 5961     		str	r1, [r3, #20]
 367              	.L23:
 566:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_PECERR) != 0) {   /* PEC Error in reception */
 368              		.loc 1 566 0
 369 0060 5969     		ldr	r1, [r3, #20]
 370 0062 C904     		lsls	r1, r1, #19
 371 0064 07D5     		bpl	.L24
 567:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->pec_recep_cnt++;
 372              		.loc 1 567 0
 373 0066 5189     		ldrh	r1, [r2, #10]
 374 0068 0131     		adds	r1, r1, #1
 375 006a 89B2     		uxth	r1, r1
 376 006c 5181     		strh	r1, [r2, #10]	@ movhi
 568:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_PECERR;
 377              		.loc 1 568 0
 378 006e 5969     		ldr	r1, [r3, #20]
 379 0070 21F48051 		bic	r1, r1, #4096
 380 0074 5961     		str	r1, [r3, #20]
 381              	.L24:
 573:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_TIMEOUT) != 0) {  /* Timeout or Tlow error */
 382              		.loc 1 573 0
 383 0076 5969     		ldr	r1, [r3, #20]
 384 0078 4804     		lsls	r0, r1, #17
 385 007a 07D5     		bpl	.L25
 574:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->timeout_tlow_cnt++;
 386              		.loc 1 574 0
 387 007c 9189     		ldrh	r1, [r2, #12]
 388 007e 0131     		adds	r1, r1, #1
 389 0080 89B2     		uxth	r1, r1
 390 0082 9181     		strh	r1, [r2, #12]	@ movhi
 575:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_TIMEOUT;
 391              		.loc 1 575 0
 392 0084 5969     		ldr	r1, [r3, #20]
 393 0086 21F48041 		bic	r1, r1, #16384
 394 008a 5961     		str	r1, [r3, #20]
 395              	.L25:
 580:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_SMBALERT) != 0) { /* SMBus alert */
 396              		.loc 1 580 0
 397 008c 5969     		ldr	r1, [r3, #20]
 398 008e 0904     		lsls	r1, r1, #16
 399 0090 07D5     		bpl	.L19
 581:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->smbus_alert_cnt++;
 400              		.loc 1 581 0
 401 0092 D189     		ldrh	r1, [r2, #14]
 402 0094 0131     		adds	r1, r1, #1
 403 0096 89B2     		uxth	r1, r1
 404 0098 D181     		strh	r1, [r2, #14]	@ movhi
 582:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_SMBALERT;
 405              		.loc 1 582 0
 406 009a 5A69     		ldr	r2, [r3, #20]
 407 009c 22F40042 		bic	r2, r2, #32768
 408 00a0 5A61     		str	r2, [r3, #20]
 409              	.L19:
 410 00a2 7047     		bx	lr
 411              	.L49:
 412              		.align	2
 413              	.L48:
 414 00a4 00000000 		.word	i2c2
 415              		.cfi_endproc
 416              	.LFE55:
 418              		.section	.text.i2c_irq.constprop.6,"ax",%progbits
 419              		.align	1
 420              		.thumb
 421              		.thumb_func
 423              	i2c_irq.constprop.6:
 424              	.LFB56:
 628:arch/stm32/mcu_periph/i2c_arch.c **** 
 629:arch/stm32/mcu_periph/i2c_arch.c **** 
 630:arch/stm32/mcu_periph/i2c_arch.c **** ////////////////////////////////////////////////
 631:arch/stm32/mcu_periph/i2c_arch.c **** // Restore bus conditions to normal after errors
 632:arch/stm32/mcu_periph/i2c_arch.c **** 
 633:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_irq(struct i2c_periph *periph)
 425              		.loc 1 633 0
 426              		.cfi_startproc
 427              		@ args = 0, pretend = 0, frame = 0
 428              		@ frame_needed = 0, uses_anonymous_args = 0
 429              	.LVL31:
 430 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 431              		.cfi_def_cfa_offset 32
 432              		.cfi_offset 3, -32
 433              		.cfi_offset 4, -28
 434              		.cfi_offset 5, -24
 435              		.cfi_offset 6, -20
 436              		.cfi_offset 7, -16
 437              		.cfi_offset 8, -12
 438              		.cfi_offset 9, -8
 439              		.cfi_offset 14, -4
 634:arch/stm32/mcu_periph/i2c_arch.c **** {
 635:arch/stm32/mcu_periph/i2c_arch.c **** 
 636:arch/stm32/mcu_periph/i2c_arch.c ****   /*
 637:arch/stm32/mcu_periph/i2c_arch.c ****     There are 7 possible event reasons to get here + all errors
 638:arch/stm32/mcu_periph/i2c_arch.c **** 
 639:arch/stm32/mcu_periph/i2c_arch.c ****     If IT_EV_FEN
 640:arch/stm32/mcu_periph/i2c_arch.c ****     -------------------------
 641:arch/stm32/mcu_periph/i2c_arch.c **** 
 642:arch/stm32/mcu_periph/i2c_arch.c ****     We are always interested in all IT_EV_FEV: all are required.
 643:arch/stm32/mcu_periph/i2c_arch.c **** 
 644:arch/stm32/mcu_periph/i2c_arch.c ****     1) SB   // Start Condition Success in Master mode
 645:arch/stm32/mcu_periph/i2c_arch.c ****     2) ADDR   // Address sent received Acknowledge
 646:arch/stm32/mcu_periph/i2c_arch.c ****     [ADDR10]  // -- 10bit address stuff: not used
 647:arch/stm32/mcu_periph/i2c_arch.c ****     [STOPF]   // -- only for slaves: master has no stop interrupt: not used
 648:arch/stm32/mcu_periph/i2c_arch.c ****     3) BTF    // I2C has stopped working (it is waiting for new data, all buffers are tx_empty/rx_f
 649:arch/stm32/mcu_periph/i2c_arch.c **** 
 650:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: using the buffered I2C has some interesting properties:
 651:arch/stm32/mcu_periph/i2c_arch.c ****     - in master receive mode: BTF only occurs after the 2nd received byte: after the first byte is 
 652:arch/stm32/mcu_periph/i2c_arch.c ****       in RD but the I2C can still receive a second byte. Only when the 2nd byte is received while t
 653:arch/stm32/mcu_periph/i2c_arch.c ****       then a BTF occurs (I2C can not continue receiving bytes or they will get lost). During BTF I2
 654:arch/stm32/mcu_periph/i2c_arch.c ****     - in master transmit mode: when writing a byte to WD, you instantly get a new TxE interrupt whi
 655:arch/stm32/mcu_periph/i2c_arch.c ****       transmitted yet. The byte was pushed to the I2C shift register and the buffer is ready for mo
 656:arch/stm32/mcu_periph/i2c_arch.c ****       fill new data in the buffer while the first is still being transmitted for max performance tr
 657:arch/stm32/mcu_periph/i2c_arch.c **** 
 658:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: besides data buffering you can/must plan several consecutive actions. You can send 2
 659:arch/stm32/mcu_periph/i2c_arch.c ****     a new start in one go.
 660:arch/stm32/mcu_periph/i2c_arch.c **** 
 661:arch/stm32/mcu_periph/i2c_arch.c ****     - thanks to / because of this buffering and event sheduling there is not 1 interrupt per start 
 662:arch/stm32/mcu_periph/i2c_arch.c ****       This also means you must think more in advance and a transaction could be popped from the tra
 663:arch/stm32/mcu_periph/i2c_arch.c ****       stop condition is actually generated.
 664:arch/stm32/mcu_periph/i2c_arch.c **** 
 665:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: the order in which Status (and other register) is read determines how flags are clea
 666:arch/stm32/mcu_periph/i2c_arch.c ****     You should NOT simply read SR1 & SR2 every time
 667:arch/stm32/mcu_periph/i2c_arch.c **** 
 668:arch/stm32/mcu_periph/i2c_arch.c ****     If IT_EV_FEN AND IT_EV_BUF
 669:arch/stm32/mcu_periph/i2c_arch.c ****     --------------------------
 670:arch/stm32/mcu_periph/i2c_arch.c **** 
 671:arch/stm32/mcu_periph/i2c_arch.c ****     Buffer event are not always wanted and are typically switched on during longer data transfers. 
 672:arch/stm32/mcu_periph/i2c_arch.c **** 
 673:arch/stm32/mcu_periph/i2c_arch.c ****     4) RxNE
 674:arch/stm32/mcu_periph/i2c_arch.c ****     5) TxE
 675:arch/stm32/mcu_periph/i2c_arch.c **** 
 676:arch/stm32/mcu_periph/i2c_arch.c ****     -----------------------------------------------------------------------------------------------
 677:arch/stm32/mcu_periph/i2c_arch.c **** 
 678:arch/stm32/mcu_periph/i2c_arch.c ****     The STM waits indefinitely (holding SCL low) for user interaction:
 679:arch/stm32/mcu_periph/i2c_arch.c ****     a) after a master-start (waiting for address)
 680:arch/stm32/mcu_periph/i2c_arch.c ****     b) after an address (waiting for data)
 681:arch/stm32/mcu_periph/i2c_arch.c ****        not during data sending when using buffered
 682:arch/stm32/mcu_periph/i2c_arch.c ****     c) after the last byte is transmitted (waiting for either stop or restart)
 683:arch/stm32/mcu_periph/i2c_arch.c ****        not during data receiving when using buffered
 684:arch/stm32/mcu_periph/i2c_arch.c ****        not after the last byte is received
 685:arch/stm32/mcu_periph/i2c_arch.c **** 
 686:arch/stm32/mcu_periph/i2c_arch.c ****     - The STM I2C stalls indefinitely when a stop condition was attempted that
 687:arch/stm32/mcu_periph/i2c_arch.c ****       did not succeed. The BUSY flag remains on.
 688:arch/stm32/mcu_periph/i2c_arch.c ****     - There is no STOP interrupt.
 689:arch/stm32/mcu_periph/i2c_arch.c **** 
 690:arch/stm32/mcu_periph/i2c_arch.c ****     Caution Reading the status:
 691:arch/stm32/mcu_periph/i2c_arch.c ****     - Caution: this clears several flags and can start transmissions etc...
 692:arch/stm32/mcu_periph/i2c_arch.c ****     - Certain flags like STOP / (N)ACK need to be guaranteed to be set before
 693:arch/stm32/mcu_periph/i2c_arch.c ****       the transmission of the byte is finished. At higher clock rates that can be
 694:arch/stm32/mcu_periph/i2c_arch.c ****       quite fast: so we allow no other interrupt to be triggered in between
 695:arch/stm32/mcu_periph/i2c_arch.c ****       reading the status and setting all needed flags
 696:arch/stm32/mcu_periph/i2c_arch.c **** 
 697:arch/stm32/mcu_periph/i2c_arch.c ****   */
 698:arch/stm32/mcu_periph/i2c_arch.c **** 
 699:arch/stm32/mcu_periph/i2c_arch.c ****   // Here we go ...
 700:arch/stm32/mcu_periph/i2c_arch.c **** 
 701:arch/stm32/mcu_periph/i2c_arch.c ****   // Apparently we got an I2C interrupt: EVT BUF or ERR
 702:arch/stm32/mcu_periph/i2c_arch.c **** 
 703:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 704:arch/stm32/mcu_periph/i2c_arch.c ****   // Notify ISR is triggered
 705:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 706:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 707:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 708:arch/stm32/mcu_periph/i2c_arch.c **** 
 709:arch/stm32/mcu_periph/i2c_arch.c ****   // Save Some Direct Access to the I2C Registers ...
 710:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 440              		.loc 1 710 0
 441 0004 B54F     		ldr	r7, .L115
 711:arch/stm32/mcu_periph/i2c_arch.c **** 
 712:arch/stm32/mcu_periph/i2c_arch.c ****   /////////////////////////////
 713:arch/stm32/mcu_periph/i2c_arch.c ****   // Check if we were ready ...
 714:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->trans_extract_idx == periph->trans_insert_idx) {
 442              		.loc 1 714 0
 443 0006 97F82130 		ldrb	r3, [r7, #33]	@ zero_extendqisi2
 444 000a 97F82020 		ldrb	r2, [r7, #32]	@ zero_extendqisi2
 710:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 445              		.loc 1 710 0
 446 000e 7C6A     		ldr	r4, [r7, #36]
 447              	.LVL32:
 448              		.loc 1 714 0
 449 0010 9A42     		cmp	r2, r3
 450 0012 3D46     		mov	r5, r7
 451 0014 0AD1     		bne	.L51
 715:arch/stm32/mcu_periph/i2c_arch.c ****     // Nothing Left To Do
 716:arch/stm32/mcu_periph/i2c_arch.c **** 
 717:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 718:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
 719:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
 720:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
 721:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
 722:arch/stm32/mcu_periph/i2c_arch.c **** 
 723:arch/stm32/mcu_periph/i2c_arch.c ****     // no transaction and also an error?
 724:arch/stm32/mcu_periph/i2c_arch.c ****     LED_SHOW_ACTIVE_BITS(regs);
 725:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 726:arch/stm32/mcu_periph/i2c_arch.c **** 
 727:arch/stm32/mcu_periph/i2c_arch.c ****     // If we still get an interrupt but there are no more things to do
 728:arch/stm32/mcu_periph/i2c_arch.c ****     // (which can happen if an event was sheduled just before a bus error occurs)
 729:arch/stm32/mcu_periph/i2c_arch.c ****     // (or can happen if both error and event interrupts were called together [the 2nd will then ge
 730:arch/stm32/mcu_periph/i2c_arch.c **** 
 731:arch/stm32/mcu_periph/i2c_arch.c ****     // since there is nothing more to do: its easy: just stop: clear all interrupt generating bits
 732:arch/stm32/mcu_periph/i2c_arch.c **** 
 733:arch/stm32/mcu_periph/i2c_arch.c ****     // Count The Errors
 734:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_error(periph);
 452              		.loc 1 734 0
 453 0016 FFF7FEFF 		bl	i2c_error.constprop.7
 454              	.LVL33:
 735:arch/stm32/mcu_periph/i2c_arch.c **** 
 736:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear Running Events
 737:arch/stm32/mcu_periph/i2c_arch.c ****     stmi2c_clear_pending_interrupts(i2c);
 455              		.loc 1 737 0
 456 001a 2046     		mov	r0, r4
 457 001c FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 458              	.LVL34:
 738:arch/stm32/mcu_periph/i2c_arch.c **** 
 739:arch/stm32/mcu_periph/i2c_arch.c ****     // Mark this as a special error
 740:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->last_unexpected_event++;
 459              		.loc 1 740 0
 460 0020 FB6A     		ldr	r3, [r7, #44]
 461 0022 5A69     		ldr	r2, [r3, #20]
 462 0024 0132     		adds	r2, r2, #1
 463 0026 5A61     		str	r2, [r3, #20]
 741:arch/stm32/mcu_periph/i2c_arch.c **** 
 742:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 743:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CIdle;
 464              		.loc 1 743 0
 465 0028 0023     		movs	r3, #0
 466 002a 33E0     		b	.L109
 467              	.L51:
 468              	.LVL35:
 744:arch/stm32/mcu_periph/i2c_arch.c **** 
 745:arch/stm32/mcu_periph/i2c_arch.c ****     // There are no transactions anymore: return
 746:arch/stm32/mcu_periph/i2c_arch.c ****     // further-on in this routine we need a transaction pointer: so we are not allowed to continue
 747:arch/stm32/mcu_periph/i2c_arch.c ****     return;
 748:arch/stm32/mcu_periph/i2c_arch.c ****   }
 749:arch/stm32/mcu_periph/i2c_arch.c **** 
 750:arch/stm32/mcu_periph/i2c_arch.c ****   // get the I2C transaction we were working on ...
 751:arch/stm32/mcu_periph/i2c_arch.c **** 
 752:arch/stm32/mcu_periph/i2c_arch.c ****   enum STMI2CSubTransactionStatus ret = 0;
 753:arch/stm32/mcu_periph/i2c_arch.c ****   struct i2c_transaction *trans = periph->trans[periph->trans_extract_idx];
 469              		.loc 1 753 0
 470 002c 57F82360 		ldr	r6, [r7, r3, lsl #2]
 471              	.LVL36:
 754:arch/stm32/mcu_periph/i2c_arch.c **** 
 755:arch/stm32/mcu_periph/i2c_arch.c ****   ///////////////////////////
 756:arch/stm32/mcu_periph/i2c_arch.c ****   // If there was an error:
 757:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1(i2c) & I2C_SR1_ERR_MASK) != 0x0000) {
 472              		.loc 1 757 0
 473 0030 6369     		ldr	r3, [r4, #20]
 474 0032 13F45F4F 		tst	r3, #57088
 475 0036 0ED0     		beq	.L53
 758:arch/stm32/mcu_periph/i2c_arch.c **** 
 759:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 760:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
 761:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
 762:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
 763:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
 764:arch/stm32/mcu_periph/i2c_arch.c **** 
 765:arch/stm32/mcu_periph/i2c_arch.c ****     LED_SHOW_ACTIVE_BITS(regs);
 766:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 767:arch/stm32/mcu_periph/i2c_arch.c **** 
 768:arch/stm32/mcu_periph/i2c_arch.c ****     // Notify everyone about the error ...
 769:arch/stm32/mcu_periph/i2c_arch.c **** 
 770:arch/stm32/mcu_periph/i2c_arch.c ****     // Set result in transaction
 771:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransFailed;
 476              		.loc 1 771 0
 477 0038 0323     		movs	r3, #3
 478 003a 86F82530 		strb	r3, [r6, #37]
 772:arch/stm32/mcu_periph/i2c_arch.c **** 
 773:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 774:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CFailed;
 479              		.loc 1 774 0
 480 003e 0A23     		movs	r3, #10
 481 0040 87F82230 		strb	r3, [r7, #34]
 775:arch/stm32/mcu_periph/i2c_arch.c **** 
 776:arch/stm32/mcu_periph/i2c_arch.c ****     // Make sure a TxRx does not Restart
 777:arch/stm32/mcu_periph/i2c_arch.c ****     trans->type = I2CTransRx;
 482              		.loc 1 777 0
 483 0044 0123     		movs	r3, #1
 484 0046 3370     		strb	r3, [r6]
 778:arch/stm32/mcu_periph/i2c_arch.c **** 
 779:arch/stm32/mcu_periph/i2c_arch.c ****     // Count The Errors
 780:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_error(periph);
 485              		.loc 1 780 0
 486 0048 FFF7FEFF 		bl	i2c_error.constprop.7
 487              	.LVL37:
 781:arch/stm32/mcu_periph/i2c_arch.c **** 
 782:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear Running Events
 783:arch/stm32/mcu_periph/i2c_arch.c ****     stmi2c_clear_pending_interrupts(i2c);
 488              		.loc 1 783 0
 489 004c 2046     		mov	r0, r4
 490 004e FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 491              	.LVL38:
 784:arch/stm32/mcu_periph/i2c_arch.c **** 
 785:arch/stm32/mcu_periph/i2c_arch.c ****     // Now continue as if everything was normal from now on
 786:arch/stm32/mcu_periph/i2c_arch.c ****     ret = STMI2C_SubTra_Ready;
 492              		.loc 1 786 0
 493 0052 0227     		movs	r7, #2
 494 0054 7BE1     		b	.L54
 495              	.LVL39:
 496              	.L53:
 787:arch/stm32/mcu_periph/i2c_arch.c **** 
 788:arch/stm32/mcu_periph/i2c_arch.c ****   }
 789:arch/stm32/mcu_periph/i2c_arch.c **** 
 790:arch/stm32/mcu_periph/i2c_arch.c ****   ///////////////////////////
 791:arch/stm32/mcu_periph/i2c_arch.c ****   // Normal Event:
 792:arch/stm32/mcu_periph/i2c_arch.c ****   else {
 793:arch/stm32/mcu_periph/i2c_arch.c **** 
 794:arch/stm32/mcu_periph/i2c_arch.c ****     ///////////////////////////////////////////////////////////////////////////////////////////////
 795:arch/stm32/mcu_periph/i2c_arch.c ****     ///////////////////////////////////////////////////////////////////////////////////////////////
 796:arch/stm32/mcu_periph/i2c_arch.c ****     //
 797:arch/stm32/mcu_periph/i2c_arch.c ****     //  SUB-TRANSACTION HANDLER
 798:arch/stm32/mcu_periph/i2c_arch.c **** 
 799:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransRx) { // TxRx are converted to Rx after the Tx Part
 497              		.loc 1 799 0
 498 0056 96F80090 		ldrb	r9, [r6]	@ zero_extendqisi2
 499 005a B9F1010F 		cmp	r9, #1
 500 005e 40F00C81 		bne	.L55
 800:arch/stm32/mcu_periph/i2c_arch.c ****       switch (trans->len_r) {
 501              		.loc 1 800 0
 502 0062 B6F80280 		ldrh	r8, [r6, #2]
 503 0066 B8F1010F 		cmp	r8, #1
 504 006a 03D0     		beq	.L57
 505 006c B8F1020F 		cmp	r8, #2
 506 0070 3BD0     		beq	.L58
 507 0072 6BE0     		b	.L114
 508              	.L57:
 509              	.LVL40:
 510              	.LBB122:
 511              	.LBB123:
 300:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 512              		.loc 1 300 0
 513 0074 6369     		ldr	r3, [r4, #20]
 514              	.LVL41:
 515 0076 9BB2     		uxth	r3, r3
 516              	.LVL42:
 303:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 517              		.loc 1 303 0
 518 0078 D907     		lsls	r1, r3, #31
 519 007a 0FD5     		bpl	.L59
 304:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 520              		.loc 1 304 0
 521 007c 2046     		mov	r0, r4
 522 007e 4FF48061 		mov	r1, #1024
 523 0082 FFF7FEFF 		bl	i2c_disable_interrupt
 524              	.LVL43:
 525              	.L110:
 305:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 526              		.loc 1 305 0
 527 0086 7178     		ldrb	r1, [r6, #1]	@ zero_extendqisi2
 528 0088 2046     		mov	r0, r4
 529 008a 41F00101 		orr	r1, r1, #1
 530 008e FFF7FEFF 		bl	i2c_send_data
 531              	.LVL44:
 308:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 532              		.loc 1 308 0
 533 0092 0323     		movs	r3, #3
 534              	.LVL45:
 535              	.L109:
 536 0094 87F82230 		strb	r3, [r7, #34]
 537 0098 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 538              	.LVL46:
 539              	.L59:
 311:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 540              		.loc 1 311 0
 541 009c 9A07     		lsls	r2, r3, #30
 542 009e 12D5     		bpl	.L61
 543              	.LBB124:
 313:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 544              		.loc 1 313 0
 545 00a0 2046     		mov	r0, r4
 546 00a2 FFF7FEFF 		bl	i2c_nack_current
 547              	.LVL47:
 314:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 548              		.loc 1 314 0
 549 00a6 2046     		mov	r0, r4
 550 00a8 FFF7FEFF 		bl	i2c_disable_ack
 551              	.LVL48:
 552              	.LBB125:
 553              	.LBB126:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
 554              		.loc 1 65 0
 555              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 556 00ac 72B6     		cpsid i
 557              	@ 0 "" 2
 558              		.thumb
 559              	.LBE126:
 560              	.LBE125:
 561              	.LBB127:
 562              	.LBB128:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 563              		.loc 1 161 0
 564 00ae 2046     		mov	r0, r4
 565              	.LBE128:
 566              	.LBE127:
 320:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 567              		.loc 1 320 0
 568 00b0 A369     		ldr	r3, [r4, #24]
 569              	.LVL49:
 570              	.LBB130:
 571              	.LBB129:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 572              		.loc 1 161 0
 573 00b2 FFF7FEFF 		bl	i2c_send_stop
 574              	.LVL50:
 575              	.LBE129:
 576              	.LBE130:
 577              	.LBB131:
 578              	.LBB132:
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 579              		.loc 1 66 0
 580              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 581 00b6 62B6     		cpsie i
 582              	@ 0 "" 2
 583              		.thumb
 584              	.LBE132:
 585              	.LBE131:
 329:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 586              		.loc 1 329 0
 587 00b8 4FF48061 		mov	r1, #1024
 588 00bc 2046     		mov	r0, r4
 589 00be FFF7FEFF 		bl	i2c_enable_interrupt
 590              	.LVL51:
 332:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingLastByte;
 591              		.loc 1 332 0
 592 00c2 0623     		movs	r3, #6
 593 00c4 E6E7     		b	.L109
 594              	.LVL52:
 595              	.L61:
 596              	.LBE124:
 335:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) {
 597              		.loc 1 335 0
 598 00c6 5806     		lsls	r0, r3, #25
 599 00c8 40F13181 		bpl	.L90
 336:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 600              		.loc 1 336 0
 601 00cc 2046     		mov	r0, r4
 602 00ce 4FF48061 		mov	r1, #1024
 603 00d2 FFF7FEFF 		bl	i2c_disable_interrupt
 604              	.LVL53:
 337:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 605              		.loc 1 337 0
 606 00d6 2369     		ldr	r3, [r4, #16]
 607 00d8 DBB2     		uxtb	r3, r3
 608 00da 7371     		strb	r3, [r6, #5]
 340:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 609              		.loc 1 340 0
 610 00dc 0223     		movs	r3, #2
 611 00de 86F82530 		strb	r3, [r6, #37]
 344:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 612              		.loc 1 344 0
 613 00e2 0723     		movs	r3, #7
 614 00e4 87F82230 		strb	r3, [r7, #34]
 615 00e8 8AE0     		b	.L108
 616              	.LVL54:
 617              	.L58:
 618              	.LBE123:
 619              	.LBE122:
 620              	.LBB133:
 621              	.LBB134:
 359:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 622              		.loc 1 359 0
 623 00ea 6369     		ldr	r3, [r4, #20]
 624              	.LVL55:
 625 00ec 9BB2     		uxth	r3, r3
 626              	.LVL56:
 362:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 627              		.loc 1 362 0
 628 00ee D907     		lsls	r1, r3, #31
 629 00f0 0BD5     		bpl	.L63
 364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 630              		.loc 1 364 0
 631 00f2 2046     		mov	r0, r4
 632 00f4 4FF48061 		mov	r1, #1024
 633 00f8 FFF7FEFF 		bl	i2c_disable_interrupt
 634              	.LVL57:
 365:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 635              		.loc 1 365 0
 636 00fc 2046     		mov	r0, r4
 637 00fe FFF7FEFF 		bl	i2c_enable_ack
 638              	.LVL58:
 366:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_next(i2c);
 639              		.loc 1 366 0
 640 0102 2046     		mov	r0, r4
 641 0104 FFF7FEFF 		bl	i2c_nack_next
 642              	.LVL59:
 643 0108 BDE7     		b	.L110
 644              	.L63:
 373:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 645              		.loc 1 373 0
 646 010a 9A07     		lsls	r2, r3, #30
 647 010c 0CD5     		bpl	.L65
 648              	.LBB135:
 649              	.LBB136:
 650              	.LBB137:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
 651              		.loc 1 65 0
 652              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 653 010e 72B6     		cpsid i
 654              	@ 0 "" 2
 655              		.thumb
 656              	.LBE137:
 657              	.LBE136:
 384:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 658              		.loc 1 384 0
 659 0110 2046     		mov	r0, r4
 381:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 660              		.loc 1 381 0
 661 0112 A369     		ldr	r3, [r4, #24]
 384:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 662              		.loc 1 384 0
 663 0114 FFF7FEFF 		bl	i2c_disable_ack
 664              	.LVL60:
 387:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 665              		.loc 1 387 0
 666 0118 2046     		mov	r0, r4
 667 011a 4FF48061 		mov	r1, #1024
 668 011e FFF7FEFF 		bl	i2c_disable_interrupt
 669              	.LVL61:
 670              	.LBB138:
 671              	.LBB139:
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 672              		.loc 1 66 0
 673              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 674 0122 62B6     		cpsie i
 675              	@ 0 "" 2
 676              		.thumb
 677              	.LBE139:
 678              	.LBE138:
 395:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 679              		.loc 1 395 0
 680 0124 0523     		movs	r3, #5
 681 0126 B5E7     		b	.L109
 682              	.L65:
 683              	.LBE135:
 398:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 684              		.loc 1 398 0
 685 0128 5807     		lsls	r0, r3, #29
 686 012a 40F10081 		bpl	.L90
 687              	.LVL62:
 688              	.LBB140:
 689              	.LBB141:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 690              		.loc 1 161 0
 691 012e 2046     		mov	r0, r4
 692 0130 FFF7FEFF 		bl	i2c_send_stop
 693              	.LVL63:
 694              	.LBE141:
 695              	.LBE140:
 404:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 696              		.loc 1 404 0
 697 0134 0723     		movs	r3, #7
 698 0136 87F82230 		strb	r3, [r7, #34]
 406:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 699              		.loc 1 406 0
 700 013a 2369     		ldr	r3, [r4, #16]
 701 013c DBB2     		uxtb	r3, r3
 702 013e 7371     		strb	r3, [r6, #5]
 407:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[1] = I2C_DR(i2c);
 703              		.loc 1 407 0
 704 0140 2369     		ldr	r3, [r4, #16]
 705 0142 DBB2     		uxtb	r3, r3
 706 0144 B371     		strb	r3, [r6, #6]
 410:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 707              		.loc 1 410 0
 708 0146 86F82580 		strb	r8, [r6, #37]
 709 014a 59E0     		b	.L108
 710              	.LVL64:
 711              	.L114:
 712              	.LBE134:
 713              	.LBE133:
 714              	.LBB142:
 715              	.LBB143:
 425:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 716              		.loc 1 425 0
 717 014c 6369     		ldr	r3, [r4, #20]
 718              	.LVL65:
 719 014e 9BB2     		uxth	r3, r3
 720              	.LVL66:
 428:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 721              		.loc 1 428 0
 722 0150 13F00102 		ands	r2, r3, #1
 723 0154 0BD0     		beq	.L66
 429:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 724              		.loc 1 429 0
 725 0156 2046     		mov	r0, r4
 726 0158 4FF48061 		mov	r1, #1024
 727 015c FFF7FEFF 		bl	i2c_disable_interrupt
 728              	.LVL67:
 431:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 729              		.loc 1 431 0
 730 0160 2046     		mov	r0, r4
 731 0162 FFF7FEFF 		bl	i2c_nack_current
 732              	.LVL68:
 432:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 733              		.loc 1 432 0
 734 0166 2046     		mov	r0, r4
 735 0168 FFF7FEFF 		bl	i2c_enable_ack
 736              	.LVL69:
 737 016c 8BE7     		b	.L110
 738              	.L66:
 440:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 739              		.loc 1 440 0
 740 016e 9907     		lsls	r1, r3, #30
 741 0170 0FD5     		bpl	.L68
 742              	.LBB144:
 441:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf = 0;
 743              		.loc 1 441 0
 744 0172 87F82320 		strb	r2, [r7, #35]
 445:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 745              		.loc 1 445 0
 746 0176 7388     		ldrh	r3, [r6, #2]
 747 0178 97F82320 		ldrb	r2, [r7, #35]	@ zero_extendqisi2
 748 017c 033B     		subs	r3, r3, #3
 749 017e 9A42     		cmp	r2, r3
 750 0180 04DA     		bge	.L69
 446:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 751              		.loc 1 446 0
 752 0182 2046     		mov	r0, r4
 753 0184 4FF48061 		mov	r1, #1024
 754 0188 FFF7FEFF 		bl	i2c_enable_interrupt
 755              	.LVL70:
 756              	.L69:
 451:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 757              		.loc 1 451 0
 758 018c A369     		ldr	r3, [r4, #24]
 454:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 759              		.loc 1 454 0
 760 018e 0523     		movs	r3, #5
 761 0190 A0E0     		b	.L113
 762              	.L68:
 763              	.LBE144:
 457:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR
 764              		.loc 1 457 0
 765 0192 5F06     		lsls	r7, r3, #25
 766 0194 40D5     		bpl	.L70
 767 0196 6268     		ldr	r2, [r4, #4]
 768 0198 5005     		lsls	r0, r2, #21
 769 019a 3DD5     		bpl	.L70
 459:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 770              		.loc 1 459 0
 771 019c 95F82320 		ldrb	r2, [r5, #35]	@ zero_extendqisi2
 772 01a0 A8F10303 		sub	r3, r8, #3
 773 01a4 9A42     		cmp	r2, r3
 774 01a6 0CDA     		bge	.L71
 460:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = I2C_DR(i2c);
 775              		.loc 1 460 0
 776 01a8 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 777 01ac 2269     		ldr	r2, [r4, #16]
 778 01ae 3344     		add	r3, r3, r6
 779 01b0 D2B2     		uxtb	r2, r2
 780 01b2 5A71     		strb	r2, [r3, #5]
 461:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 781              		.loc 1 461 0
 782 01b4 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 783 01b8 0133     		adds	r3, r3, #1
 784 01ba DBB2     		uxtb	r3, r3
 785 01bc 85F82330 		strb	r3, [r5, #35]
 786 01c0 20E0     		b	.L72
 787              	.L71:
 466:arch/stm32/mcu_periph/i2c_arch.c ****     else if (periph->idx_buf >= (trans->len_r - 1)) {
 788              		.loc 1 466 0
 789 01c2 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 790 01c6 454F     		ldr	r7, .L115
 791 01c8 08F1FF38 		add	r8, r8, #-1
 792 01cc 4345     		cmp	r3, r8
 793 01ce 19DB     		blt	.L72
 467:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 794              		.loc 1 467 0
 795 01d0 2046     		mov	r0, r4
 796 01d2 4FF48061 		mov	r1, #1024
 797 01d6 FFF7FEFF 		bl	i2c_disable_interrupt
 798              	.LVL71:
 470:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 799              		.loc 1 470 0
 800 01da 97F82380 		ldrb	r8, [r7, #35]	@ zero_extendqisi2
 801 01de 2046     		mov	r0, r4
 802 01e0 FFF7FEFF 		bl	i2c_get_data
 803              	.LVL72:
 804 01e4 5FFA88F8 		uxtb	r8, r8
 805 01e8 06EB0803 		add	r3, r6, r8
 806 01ec 5871     		strb	r0, [r3, #5]
 471:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 807              		.loc 1 471 0
 808 01ee 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 809 01f2 0133     		adds	r3, r3, #1
 810 01f4 DBB2     		uxtb	r3, r3
 811 01f6 87F82330 		strb	r3, [r7, #35]
 474:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 812              		.loc 1 474 0
 813 01fa 0223     		movs	r3, #2
 814 01fc 86F82530 		strb	r3, [r6, #37]
 815              	.LVL73:
 816              	.L108:
 476:arch/stm32/mcu_periph/i2c_arch.c ****       return STMI2C_SubTra_Ready_StopRequested;
 817              		.loc 1 476 0
 818 0200 0127     		movs	r7, #1
 819 0202 A4E0     		b	.L54
 820              	.LVL74:
 821              	.L72:
 480:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 822              		.loc 1 480 0
 823 0204 7388     		ldrh	r3, [r6, #2]
 824 0206 95F82320 		ldrb	r2, [r5, #35]	@ zero_extendqisi2
 825 020a 033B     		subs	r3, r3, #3
 826 020c 9A42     		cmp	r2, r3
 481:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 827              		.loc 1 481 0
 828 020e 2046     		mov	r0, r4
 829 0210 4FF48061 		mov	r1, #1024
 480:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 830              		.loc 1 480 0
 831 0214 7EDA     		bge	.L111
 832              	.LVL75:
 833 0216 2CE0     		b	.L112
 834              	.LVL76:
 835              	.L70:
 490:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 836              		.loc 1 490 0
 837 0218 5907     		lsls	r1, r3, #29
 838 021a 40F18880 		bpl	.L90
 839              	.LBB145:
 840              	.LBB146:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
 841              		.loc 1 65 0
 842              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 843 021e 72B6     		cpsid i
 844              	@ 0 "" 2
 845              		.thumb
 846              	.LBE146:
 847              	.LBE145:
 498:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 848              		.loc 1 498 0
 849 0220 2046     		mov	r0, r4
 850 0222 FFF7FEFF 		bl	i2c_disable_ack
 851              	.LVL77:
 501:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 852              		.loc 1 501 0
 853 0226 95F82370 		ldrb	r7, [r5, #35]	@ zero_extendqisi2
 854 022a 2046     		mov	r0, r4
 855 022c FFF7FEFF 		bl	i2c_get_data
 856              	.LVL78:
 857 0230 FFB2     		uxtb	r7, r7
 858 0232 3744     		add	r7, r7, r6
 859 0234 7871     		strb	r0, [r7, #5]
 502:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 860              		.loc 1 502 0
 861 0236 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 862 023a 0133     		adds	r3, r3, #1
 863 023c DBB2     		uxtb	r3, r3
 864              	.LBB147:
 865              	.LBB148:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 866              		.loc 1 161 0
 867 023e 2046     		mov	r0, r4
 868              	.LBE148:
 869              	.LBE147:
 502:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 870              		.loc 1 502 0
 871 0240 85F82330 		strb	r3, [r5, #35]
 872              	.LVL79:
 873              	.LBB150:
 874              	.LBB149:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 875              		.loc 1 161 0
 876 0244 FFF7FEFF 		bl	i2c_send_stop
 877              	.LVL80:
 878              	.LBE149:
 879              	.LBE150:
 880              	.LBB151:
 881              	.LBB152:
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 882              		.loc 1 66 0
 883              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 884 0248 62B6     		cpsie i
 885              	@ 0 "" 2
 886              		.thumb
 887              	.LBE152:
 888              	.LBE151:
 513:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 889              		.loc 1 513 0
 890 024a 0723     		movs	r3, #7
 891 024c 85F82230 		strb	r3, [r5, #34]
 516:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 892              		.loc 1 516 0
 893 0250 95F82370 		ldrb	r7, [r5, #35]	@ zero_extendqisi2
 894 0254 2046     		mov	r0, r4
 895 0256 FFF7FEFF 		bl	i2c_get_data
 896              	.LVL81:
 897 025a FFB2     		uxtb	r7, r7
 898 025c 3E44     		add	r6, r6, r7
 899              	.LVL82:
 521:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 900              		.loc 1 521 0
 901 025e 4FF48061 		mov	r1, #1024
 516:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 902              		.loc 1 516 0
 903 0262 7071     		strb	r0, [r6, #5]
 517:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 904              		.loc 1 517 0
 905 0264 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 906 0268 0133     		adds	r3, r3, #1
 907 026a DBB2     		uxtb	r3, r3
 908 026c 85F82330 		strb	r3, [r5, #35]
 521:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 909              		.loc 1 521 0
 910 0270 2046     		mov	r0, r4
 911              	.LVL83:
 912              	.L112:
 913 0272 FFF7FEFF 		bl	i2c_enable_interrupt
 914              	.LVL84:
 915 0276 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 916              	.LVL85:
 917              	.L55:
 918              	.LBE143:
 919              	.LBE142:
 920              	.LBB153:
 921              	.LBB154:
 228:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 922              		.loc 1 228 0
 923 027a 6369     		ldr	r3, [r4, #20]
 924              	.LVL86:
 925 027c 9BB2     		uxth	r3, r3
 926              	.LVL87:
 231:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 927              		.loc 1 231 0
 928 027e DA07     		lsls	r2, r3, #31
 929 0280 0AD5     		bpl	.L74
 233:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 930              		.loc 1 233 0
 931 0282 2046     		mov	r0, r4
 932 0284 4FF48061 		mov	r1, #1024
 933 0288 FFF7FEFF 		bl	i2c_disable_interrupt
 934              	.LVL88:
 235:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr);
 935              		.loc 1 235 0
 936 028c 2046     		mov	r0, r4
 937 028e 7178     		ldrb	r1, [r6, #1]	@ zero_extendqisi2
 938 0290 FFF7FEFF 		bl	i2c_send_data
 939              	.LVL89:
 237:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrWrSent;
 940              		.loc 1 237 0
 941 0294 0223     		movs	r3, #2
 942 0296 FDE6     		b	.L109
 943              	.L74:
 240:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 944              		.loc 1 240 0
 945 0298 9807     		lsls	r0, r3, #30
 946 029a 21D5     		bpl	.L76
 947              	.LBB155:
 242:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2  __attribute__((unused)) = I2C_SR2(i2c);
 948              		.loc 1 242 0
 949 029c A369     		ldr	r3, [r4, #24]
 249:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[0]);
 950              		.loc 1 249 0
 951 029e 7179     		ldrb	r1, [r6, #5]	@ zero_extendqisi2
 952 02a0 2046     		mov	r0, r4
 953 02a2 FFF7FEFF 		bl	i2c_send_data
 954              	.LVL90:
 250:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->len_w > 1) {
 955              		.loc 1 250 0
 956 02a6 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 957 02a8 012B     		cmp	r3, #1
 958 02aa 05D9     		bls	.L77
 251:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, trans->buf[1]);
 959              		.loc 1 251 0
 960 02ac B179     		ldrb	r1, [r6, #6]	@ zero_extendqisi2
 961 02ae 2046     		mov	r0, r4
 962 02b0 FFF7FEFF 		bl	i2c_send_data
 963              	.LVL91:
 252:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 2;
 964              		.loc 1 252 0
 965 02b4 0223     		movs	r3, #2
 966 02b6 00E0     		b	.L107
 967              	.L77:
 254:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 1;
 968              		.loc 1 254 0
 969 02b8 0123     		movs	r3, #1
 970              	.L107:
 971 02ba 85F82330 		strb	r3, [r5, #35]
 259:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < trans->len_w) {
 972              		.loc 1 259 0
 973 02be 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 974 02c2 3279     		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 975 02c4 9A42     		cmp	r2, r3
 976 02c6 04D9     		bls	.L79
 260:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 977              		.loc 1 260 0
 978 02c8 2046     		mov	r0, r4
 979 02ca 4FF48061 		mov	r1, #1024
 980 02ce FFF7FEFF 		bl	i2c_enable_interrupt
 981              	.LVL92:
 982              	.L79:
 264:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CSendingByte;
 983              		.loc 1 264 0
 984 02d2 0423     		movs	r3, #4
 985              	.LVL93:
 986              	.L113:
 987 02d4 85F82230 		strb	r3, [r5, #34]
 988 02d8 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 989              	.LVL94:
 990              	.L116:
 991              		.align	2
 992              	.L115:
 993 02dc 00000000 		.word	i2c2
 994              	.LVL95:
 995              	.L76:
 996              	.LBE155:
 267:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_TxE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR2
 997              		.loc 1 267 0
 998 02e0 1906     		lsls	r1, r3, #24
 999 02e2 1BD5     		bpl	.L80
 1000 02e4 6268     		ldr	r2, [r4, #4]
 1001 02e6 5205     		lsls	r2, r2, #21
 1002 02e8 18D5     		bpl	.L80
 269:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[periph->idx_buf]);
 1003              		.loc 1 269 0
 1004 02ea 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 1005 02ee 3344     		add	r3, r3, r6
 1006 02f0 2046     		mov	r0, r4
 1007 02f2 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1008 02f4 FFF7FEFF 		bl	i2c_send_data
 1009              	.LVL96:
 270:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf++;
 1010              		.loc 1 270 0
 1011 02f8 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 1012 02fc 0133     		adds	r3, r3, #1
 1013 02fe DBB2     		uxtb	r3, r3
 1014 0300 87F82330 		strb	r3, [r7, #35]
 273:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf >= trans->len_w) {
 1015              		.loc 1 273 0
 1016 0304 97F82330 		ldrb	r3, [r7, #35]	@ zero_extendqisi2
 1017 0308 3279     		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 1018 030a 9A42     		cmp	r2, r3
 1019 030c 57D8     		bhi	.L50
 275:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1020              		.loc 1 275 0
 1021 030e 2046     		mov	r0, r4
 1022 0310 4FF48061 		mov	r1, #1024
 1023              	.LVL97:
 1024              	.L111:
 1025 0314 FFF7FEFF 		bl	i2c_disable_interrupt
 1026              	.LVL98:
 1027 0318 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1028              	.LVL99:
 1029              	.L80:
 280:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 1030              		.loc 1 280 0
 1031 031c 5B07     		lsls	r3, r3, #29
 1032 031e 06D5     		bpl	.L90
 1033 0320 0227     		movs	r7, #2
 281:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTx) {
 1034              		.loc 1 281 0
 1035 0322 B9F1000F 		cmp	r9, #0
 1036 0326 12D1     		bne	.L54
 283:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 1037              		.loc 1 283 0
 1038 0328 86F82570 		strb	r7, [r6, #37]
 1039 032c 0FE0     		b	.L54
 1040              	.LVL100:
 1041              	.L90:
 1042              	.LBE154:
 1043              	.LBE153:
 801:arch/stm32/mcu_periph/i2c_arch.c ****         case 1:
 802:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_read1(i2c, periph, trans);
 803:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 804:arch/stm32/mcu_periph/i2c_arch.c ****         case 2:
 805:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_read2(i2c, periph, trans);
 806:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 807:arch/stm32/mcu_periph/i2c_arch.c ****         default:
 808:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_readmany(i2c, periph, trans);
 809:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 810:arch/stm32/mcu_periph/i2c_arch.c ****       }
 811:arch/stm32/mcu_periph/i2c_arch.c ****     } else { // TxRx or Tx
 812:arch/stm32/mcu_periph/i2c_arch.c ****       ret = stmi2c_send(i2c, periph, trans);
 813:arch/stm32/mcu_periph/i2c_arch.c ****     }
 814:arch/stm32/mcu_periph/i2c_arch.c ****   }
 815:arch/stm32/mcu_periph/i2c_arch.c **** 
 816:arch/stm32/mcu_periph/i2c_arch.c ****   /////////////////////////////////
 817:arch/stm32/mcu_periph/i2c_arch.c ****   // Sub-transaction has finished
 818:arch/stm32/mcu_periph/i2c_arch.c ****   if (ret != STMI2C_SubTra_Busy) {
 819:arch/stm32/mcu_periph/i2c_arch.c ****     // Ready or SubTraError
 820:arch/stm32/mcu_periph/i2c_arch.c ****     // -ready: with or without stop already asked
 821:arch/stm32/mcu_periph/i2c_arch.c **** 
 822:arch/stm32/mcu_periph/i2c_arch.c ****     // In case of unexpected event condition during subtransaction handling:
 823:arch/stm32/mcu_periph/i2c_arch.c ****     if (ret == STMI2C_SubTra_Error) {
 824:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell everyone about the subtransaction error:
 825:arch/stm32/mcu_periph/i2c_arch.c ****       // this is the previously called SPURRIOUS INTERRUPT
 826:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CFailed;
 1044              		.loc 1 826 0
 1045 032e 0A23     		movs	r3, #10
 1046 0330 85F82230 		strb	r3, [r5, #34]
 827:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;   // Avoid possible restart
 1047              		.loc 1 827 0
 1048 0334 0123     		movs	r3, #1
 1049 0336 3370     		strb	r3, [r6]
 1050              	.LBB157:
 1051              	.LBB156:
 289:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 1052              		.loc 1 289 0
 1053 0338 0327     		movs	r7, #3
 1054              	.LBE156:
 1055              	.LBE157:
 828:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransFailed; // Notify Ready
 829:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->unexpected_event_cnt++;
 1056              		.loc 1 829 0
 1057 033a EB6A     		ldr	r3, [r5, #44]
 828:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransFailed; // Notify Ready
 1058              		.loc 1 828 0
 1059 033c 86F82570 		strb	r7, [r6, #37]
 1060              		.loc 1 829 0
 1061 0340 1A8A     		ldrh	r2, [r3, #16]
 1062 0342 0132     		adds	r2, r2, #1
 1063 0344 92B2     		uxth	r2, r2
 1064 0346 1A82     		strh	r2, [r3, #16]	@ movhi
 830:arch/stm32/mcu_periph/i2c_arch.c **** 
 831:arch/stm32/mcu_periph/i2c_arch.c ****       // Error
 832:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 833:arch/stm32/mcu_periph/i2c_arch.c ****       LED2_ON();
 834:arch/stm32/mcu_periph/i2c_arch.c ****       LED1_ON();
 835:arch/stm32/mcu_periph/i2c_arch.c ****       LED2_OFF();
 836:arch/stm32/mcu_periph/i2c_arch.c ****       LED1_OFF();
 837:arch/stm32/mcu_periph/i2c_arch.c **** 
 838:arch/stm32/mcu_periph/i2c_arch.c ****       LED_SHOW_ACTIVE_BITS(regs);
 839:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 840:arch/stm32/mcu_periph/i2c_arch.c **** 
 841:arch/stm32/mcu_periph/i2c_arch.c ****       // Clear Running Events
 842:arch/stm32/mcu_periph/i2c_arch.c ****       stmi2c_clear_pending_interrupts(i2c);
 1065              		.loc 1 842 0
 1066 0348 2046     		mov	r0, r4
 1067 034a FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 1068              	.LVL101:
 1069              	.L54:
 843:arch/stm32/mcu_periph/i2c_arch.c ****     }
 844:arch/stm32/mcu_periph/i2c_arch.c **** 
 845:arch/stm32/mcu_periph/i2c_arch.c ****     // RxTx -> Restart and do Rx part
 846:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTxRx) {
 1070              		.loc 1 846 0
 1071 034e 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1072 0350 022B     		cmp	r3, #2
 1073 0352 0CD1     		bne	.L81
 847:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;
 1074              		.loc 1 847 0
 1075 0354 0123     		movs	r3, #1
 1076 0356 3370     		strb	r3, [r6]
 848:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CStartRequested;
 849:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_start(i2c);
 1077              		.loc 1 849 0
 1078 0358 2046     		mov	r0, r4
 848:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CStartRequested;
 1079              		.loc 1 848 0
 1080 035a 85F82230 		strb	r3, [r5, #34]
 1081              		.loc 1 849 0
 1082 035e FFF7FEFF 		bl	i2c_send_start
 1083              	.LVL102:
 850:arch/stm32/mcu_periph/i2c_arch.c **** 
 851:arch/stm32/mcu_periph/i2c_arch.c ****       // Silent any BTF that would occur before SB
 852:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, 0x00);
 1084              		.loc 1 852 0
 1085 0362 2046     		mov	r0, r4
 1086 0364 0021     		movs	r1, #0
 853:arch/stm32/mcu_periph/i2c_arch.c ****     }
 854:arch/stm32/mcu_periph/i2c_arch.c ****     // If a restart is not needed: Rx part or Tx-only
 855:arch/stm32/mcu_periph/i2c_arch.c ****     else {
 856:arch/stm32/mcu_periph/i2c_arch.c ****       // Ready, no stop condition set yet
 857:arch/stm32/mcu_periph/i2c_arch.c ****       if (ret == STMI2C_SubTra_Ready) {
 858:arch/stm32/mcu_periph/i2c_arch.c **** 
 859:arch/stm32/mcu_periph/i2c_arch.c ****         // Program a stop
 860:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_STOP(i2c);
 861:arch/stm32/mcu_periph/i2c_arch.c **** 
 862:arch/stm32/mcu_periph/i2c_arch.c ****         // Silent any BTF that would occur before STOP is executed
 863:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_send_data(i2c, 0x00);
 864:arch/stm32/mcu_periph/i2c_arch.c ****       }
 865:arch/stm32/mcu_periph/i2c_arch.c **** 
 866:arch/stm32/mcu_periph/i2c_arch.c ****       // Jump to the next transaction
 867:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx++;
 868:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx >= I2C_TRANSACTION_QUEUE_LEN) {
 869:arch/stm32/mcu_periph/i2c_arch.c ****         periph->trans_extract_idx = 0;
 870:arch/stm32/mcu_periph/i2c_arch.c ****       }
 871:arch/stm32/mcu_periph/i2c_arch.c **** 
 872:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell everyone we are ready
 873:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
 874:arch/stm32/mcu_periph/i2c_arch.c **** 
 875:arch/stm32/mcu_periph/i2c_arch.c **** 
 876:arch/stm32/mcu_periph/i2c_arch.c ****       // if we have no more transaction to process, stop here
 877:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx == periph->trans_insert_idx) {
 878:arch/stm32/mcu_periph/i2c_arch.c **** 
 879:arch/stm32/mcu_periph/i2c_arch.c ****         periph->watchdog = -1; // stop watchdog
 880:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 881:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_ON();
 882:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_ON();
 883:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_OFF();
 884:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_ON();
 885:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_OFF();
 886:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_OFF();
 887:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 888:arch/stm32/mcu_periph/i2c_arch.c ****       }
 889:arch/stm32/mcu_periph/i2c_arch.c ****       // if not, start next transaction
 890:arch/stm32/mcu_periph/i2c_arch.c ****       else {
 891:arch/stm32/mcu_periph/i2c_arch.c ****         // Restart transaction doing the Rx part now
 892:arch/stm32/mcu_periph/i2c_arch.c ****         // --- moved to idle function
 893:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_START(periph);
 894:arch/stm32/mcu_periph/i2c_arch.c ****         // ------
 895:arch/stm32/mcu_periph/i2c_arch.c ****       }
 896:arch/stm32/mcu_periph/i2c_arch.c ****     }
 897:arch/stm32/mcu_periph/i2c_arch.c ****   }
 898:arch/stm32/mcu_periph/i2c_arch.c **** 
 899:arch/stm32/mcu_periph/i2c_arch.c ****   return;
 900:arch/stm32/mcu_periph/i2c_arch.c **** }
 1087              		.loc 1 900 0
 1088 0366 BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 1089              	.LVL103:
 852:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, 0x00);
 1090              		.loc 1 852 0
 1091 036a FFF7FEBF 		b	i2c_send_data
 1092              	.LVL104:
 1093              	.L81:
 857:arch/stm32/mcu_periph/i2c_arch.c ****       if (ret == STMI2C_SubTra_Ready) {
 1094              		.loc 1 857 0
 1095 036e 022F     		cmp	r7, #2
 1096 0370 06D1     		bne	.L82
 1097              	.LVL105:
 1098              	.LBB158:
 1099              	.LBB159:
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 1100              		.loc 1 161 0
 1101 0372 2046     		mov	r0, r4
 1102 0374 FFF7FEFF 		bl	i2c_send_stop
 1103              	.LVL106:
 1104              	.LBE159:
 1105              	.LBE158:
 863:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_send_data(i2c, 0x00);
 1106              		.loc 1 863 0
 1107 0378 2046     		mov	r0, r4
 1108 037a 0021     		movs	r1, #0
 1109 037c FFF7FEFF 		bl	i2c_send_data
 1110              	.LVL107:
 1111              	.L82:
 1112              	.LBB160:
 1113              	.LBB161:
 867:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx++;
 1114              		.loc 1 867 0
 1115 0380 95F82110 		ldrb	r1, [r5, #33]	@ zero_extendqisi2
 1116 0384 0F4A     		ldr	r2, .L117
 873:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
 1117              		.loc 1 873 0
 1118 0386 0F48     		ldr	r0, .L117
 867:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx++;
 1119              		.loc 1 867 0
 1120 0388 0131     		adds	r1, r1, #1
 1121 038a C9B2     		uxtb	r1, r1
 868:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx >= I2C_TRANSACTION_QUEUE_LEN) {
 1122              		.loc 1 868 0
 1123 038c 0729     		cmp	r1, #7
 1124 038e 4FF00003 		mov	r3, #0
 869:arch/stm32/mcu_periph/i2c_arch.c ****         periph->trans_extract_idx = 0;
 1125              		.loc 1 869 0
 1126 0392 8CBF     		ite	hi
 1127 0394 82F82130 		strbhi	r3, [r2, #33]
 867:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx++;
 1128              		.loc 1 867 0
 1129 0398 82F82110 		strbls	r1, [r2, #33]
 873:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
 1130              		.loc 1 873 0
 1131 039c 85F82230 		strb	r3, [r5, #34]
 877:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx == periph->trans_insert_idx) {
 1132              		.loc 1 877 0
 1133 03a0 95F82120 		ldrb	r2, [r5, #33]	@ zero_extendqisi2
 1134 03a4 95F82030 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 1135 03a8 9A42     		cmp	r2, r3
 1136 03aa 04D1     		bne	.L85
 879:arch/stm32/mcu_periph/i2c_arch.c ****         periph->watchdog = -1; // stop watchdog
 1137              		.loc 1 879 0
 1138 03ac 4FF6FF73 		movw	r3, #65535
 1139 03b0 0386     		strh	r3, [r0, #48]	@ movhi
 1140 03b2 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1141              	.LVL108:
 1142              	.L85:
 1143              	.LBE161:
 1144              	.LBE160:
 1145              		.loc 1 900 0
 1146 03b6 BDE8F843 		pop	{r3, r4, r5, r6, r7, r8, r9, lr}
 1147              	.LVL109:
 1148              	.LBB163:
 1149              	.LBB162:
 893:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_START(periph);
 1150              		.loc 1 893 0
 1151 03ba FFF7FEBF 		b	PPRZ_I2C_SEND_START
 1152              	.LVL110:
 1153              	.L50:
 1154 03be BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 1155              	.LVL111:
 1156              	.L118:
 1157 03c2 00BF     		.align	2
 1158              	.L117:
 1159 03c4 00000000 		.word	i2c2
 1160              	.LBE162:
 1161              	.LBE163:
 1162              		.cfi_endproc
 1163              	.LFE56:
 1165              		.section	.text.i2c2_ev_isr,"ax",%progbits
 1166              		.align	1
 1167              		.weak	i2c2_ev_isr
 1168              		.thumb
 1169              		.thumb_func
 1171              	i2c2_ev_isr:
 1172              	.LFB18:
 901:arch/stm32/mcu_periph/i2c_arch.c **** 
 902:arch/stm32/mcu_periph/i2c_arch.c **** 
 903:arch/stm32/mcu_periph/i2c_arch.c **** /*
 904:arch/stm32/mcu_periph/i2c_arch.c **** // Make sure the bus is free before resetting (p722)
 905:arch/stm32/mcu_periph/i2c_arch.c **** if (regs->SR2 & (I2C_FLAG_BUSY >> 16)) {
 906:arch/stm32/mcu_periph/i2c_arch.c **** // Reset the I2C block
 907:arch/stm32/mcu_periph/i2c_arch.c **** I2C_SoftwareResetCmd(periph->reg_addr, ENABLE);
 908:arch/stm32/mcu_periph/i2c_arch.c **** I2C_SoftwareResetCmd(periph->reg_addr, DISABLE);
 909:arch/stm32/mcu_periph/i2c_arch.c **** }
 910:arch/stm32/mcu_periph/i2c_arch.c **** */
 911:arch/stm32/mcu_periph/i2c_arch.c **** 
 912:arch/stm32/mcu_periph/i2c_arch.c **** 
 913:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C0
 914:arch/stm32/mcu_periph/i2c_arch.c **** #error "The STM32 doesn't have I2C0, use I2C1 or I2C2"
 915:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 916:arch/stm32/mcu_periph/i2c_arch.c **** 
 917:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 918:arch/stm32/mcu_periph/i2c_arch.c **** 
 919:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C1 clock speed */
 920:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C1_CLOCK_SPEED
 921:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C1_CLOCK_SPEED 200000
 922:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 923:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C1_CLOCK_SPEED)
 924:arch/stm32/mcu_periph/i2c_arch.c **** 
 925:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c1_errors;
 926:arch/stm32/mcu_periph/i2c_arch.c **** 
 927:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_hw_init(void)
 928:arch/stm32/mcu_periph/i2c_arch.c **** {
 929:arch/stm32/mcu_periph/i2c_arch.c **** 
 930:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.reg_addr = (void *)I2C1;
 931:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.init_struct = NULL;
 932:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.errors = &i2c1_errors;
 933:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = -1;
 934:arch/stm32/mcu_periph/i2c_arch.c **** 
 935:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
 936:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c1_errors);
 937:arch/stm32/mcu_periph/i2c_arch.c **** 
 938:arch/stm32/mcu_periph/i2c_arch.c ****   // Extra
 939:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 940:arch/stm32/mcu_periph/i2c_arch.c ****   LED_INIT();
 941:arch/stm32/mcu_periph/i2c_arch.c **** #else
 942:arch/stm32/mcu_periph/i2c_arch.c **** 
 943:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
 944:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C1);
 945:arch/stm32/mcu_periph/i2c_arch.c **** 
 946:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C1 event interrupt --------------------------------*/
 947:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C1_EV_IRQ, NVIC_I2C1_IRQ_PRIO);
 948:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_EV_IRQ);
 949:arch/stm32/mcu_periph/i2c_arch.c **** 
 950:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C1 err interrupt ----------------------------------*/
 951:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C1_ER_IRQ, NVIC_I2C1_IRQ_PRIO + 1);
 952:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_ER_IRQ);
 953:arch/stm32/mcu_periph/i2c_arch.c **** 
 954:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
 955:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C1 clock */
 956:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C1);
 957:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
 958:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C1);
 959:arch/stm32/mcu_periph/i2c_arch.c **** 
 960:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C1);
 961:arch/stm32/mcu_periph/i2c_arch.c **** 
 962:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
 963:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C1);
 964:arch/stm32/mcu_periph/i2c_arch.c **** 
 965:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C1, 0);
 966:arch/stm32/mcu_periph/i2c_arch.c **** 
 967:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
 968:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C1, I2C_CR2_ITERREN);
 969:arch/stm32/mcu_periph/i2c_arch.c **** 
 970:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c1, I2C1_CLOCK_SPEED);
 971:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 972:arch/stm32/mcu_periph/i2c_arch.c **** }
 973:arch/stm32/mcu_periph/i2c_arch.c **** 
 974:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_ev_isr(void)
 975:arch/stm32/mcu_periph/i2c_arch.c **** {
 976:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 977:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 978:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 979:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);;
 980:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 981:arch/stm32/mcu_periph/i2c_arch.c **** }
 982:arch/stm32/mcu_periph/i2c_arch.c **** 
 983:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_er_isr(void)
 984:arch/stm32/mcu_periph/i2c_arch.c **** {
 985:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 986:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 987:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 988:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);
 989:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 990:arch/stm32/mcu_periph/i2c_arch.c **** }
 991:arch/stm32/mcu_periph/i2c_arch.c **** 
 992:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C1 */
 993:arch/stm32/mcu_periph/i2c_arch.c **** 
 994:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
 995:arch/stm32/mcu_periph/i2c_arch.c **** 
 996:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C2 clock speed */
 997:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C2_CLOCK_SPEED
 998:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C2_CLOCK_SPEED 300000
 999:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1000:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C2_CLOCK_SPEED)
1001:arch/stm32/mcu_periph/i2c_arch.c **** 
1002:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c2_errors;
1003:arch/stm32/mcu_periph/i2c_arch.c **** 
1004:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_hw_init(void)
1005:arch/stm32/mcu_periph/i2c_arch.c **** {
1006:arch/stm32/mcu_periph/i2c_arch.c **** 
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.reg_addr = (void *)I2C2;
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
1010:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
1011:arch/stm32/mcu_periph/i2c_arch.c **** 
1012:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
1013:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c2_errors);
1014:arch/stm32/mcu_periph/i2c_arch.c **** 
1015:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
1016:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C2);
1017:arch/stm32/mcu_periph/i2c_arch.c **** 
1018:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C2 event interrupt --------------------------------*/
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_EV_IRQ, NVIC_I2C2_IRQ_PRIO);
1020:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_EV_IRQ);
1021:arch/stm32/mcu_periph/i2c_arch.c **** 
1022:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C2 err interrupt ----------------------------------*/
1023:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_ER_IRQ, NVIC_I2C2_IRQ_PRIO + 1);
1024:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_ER_IRQ);
1025:arch/stm32/mcu_periph/i2c_arch.c **** 
1026:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
1027:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C2 clock */
1028:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C2);
1029:arch/stm32/mcu_periph/i2c_arch.c **** 
1030:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
1031:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C2);
1032:arch/stm32/mcu_periph/i2c_arch.c **** 
1033:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C2);
1034:arch/stm32/mcu_periph/i2c_arch.c **** 
1035:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
1036:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C2);
1037:arch/stm32/mcu_periph/i2c_arch.c **** 
1038:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C2, 0);
1039:arch/stm32/mcu_periph/i2c_arch.c **** 
1040:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
1041:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C2, I2C_CR2_ITERREN);
1042:arch/stm32/mcu_periph/i2c_arch.c **** 
1043:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c2, I2C2_CLOCK_SPEED);
1044:arch/stm32/mcu_periph/i2c_arch.c **** }
1045:arch/stm32/mcu_periph/i2c_arch.c **** 
1046:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_ev_isr(void)
1047:arch/stm32/mcu_periph/i2c_arch.c **** {
 1173              		.loc 1 1047 0
 1174              		.cfi_startproc
 1175              		@ args = 0, pretend = 0, frame = 0
 1176              		@ frame_needed = 0, uses_anonymous_args = 0
 1177 0000 38B5     		push	{r3, r4, r5, lr}
 1178              		.cfi_def_cfa_offset 16
 1179              		.cfi_offset 3, -16
 1180              		.cfi_offset 4, -12
 1181              		.cfi_offset 5, -8
 1182              		.cfi_offset 14, -4
1048:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
 1183              		.loc 1 1048 0
 1184 0002 094D     		ldr	r5, .L120
 1185 0004 6C6A     		ldr	r4, [r5, #36]
 1186              	.LVL112:
1049:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 1187              		.loc 1 1049 0
 1188 0006 4FF48071 		mov	r1, #256
 1189 000a 2046     		mov	r0, r4
 1190 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1191              	.LVL113:
1050:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
 1192              		.loc 1 1050 0
 1193 0010 0023     		movs	r3, #0
 1194 0012 2B86     		strh	r3, [r5, #48]	@ movhi
1051:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1195              		.loc 1 1051 0
 1196 0014 FFF7FEFF 		bl	i2c_irq.constprop.6
 1197              	.LVL114:
1052:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1198              		.loc 1 1052 0
 1199 0018 2046     		mov	r0, r4
 1200 001a 4FF48071 		mov	r1, #256
1053:arch/stm32/mcu_periph/i2c_arch.c **** }
 1201              		.loc 1 1053 0
 1202 001e BDE83840 		pop	{r3, r4, r5, lr}
 1203              	.LVL115:
1052:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1204              		.loc 1 1052 0
 1205 0022 FFF7FEBF 		b	i2c_enable_interrupt
 1206              	.LVL116:
 1207              	.L121:
 1208 0026 00BF     		.align	2
 1209              	.L120:
 1210 0028 00000000 		.word	i2c2
 1211              		.cfi_endproc
 1212              	.LFE18:
 1214              		.section	.text.i2c2_er_isr,"ax",%progbits
 1215              		.align	1
 1216              		.weak	i2c2_er_isr
 1217              		.thumb
 1218              		.thumb_func
 1220              	i2c2_er_isr:
 1221              	.LFB19:
1054:arch/stm32/mcu_periph/i2c_arch.c **** 
1055:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_er_isr(void)
1056:arch/stm32/mcu_periph/i2c_arch.c **** {
 1222              		.loc 1 1056 0
 1223              		.cfi_startproc
 1224              		@ args = 0, pretend = 0, frame = 0
 1225              		@ frame_needed = 0, uses_anonymous_args = 0
 1226 0000 38B5     		push	{r3, r4, r5, lr}
 1227              		.cfi_def_cfa_offset 16
 1228              		.cfi_offset 3, -16
 1229              		.cfi_offset 4, -12
 1230              		.cfi_offset 5, -8
 1231              		.cfi_offset 14, -4
1057:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
 1232              		.loc 1 1057 0
 1233 0002 094D     		ldr	r5, .L123
 1234 0004 6C6A     		ldr	r4, [r5, #36]
 1235              	.LVL117:
1058:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1236              		.loc 1 1058 0
 1237 0006 4FF40071 		mov	r1, #512
 1238 000a 2046     		mov	r0, r4
 1239 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1240              	.LVL118:
1059:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
 1241              		.loc 1 1059 0
 1242 0010 0023     		movs	r3, #0
 1243 0012 2B86     		strh	r3, [r5, #48]	@ movhi
1060:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1244              		.loc 1 1060 0
 1245 0014 FFF7FEFF 		bl	i2c_irq.constprop.6
 1246              	.LVL119:
1061:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1247              		.loc 1 1061 0
 1248 0018 2046     		mov	r0, r4
 1249 001a 4FF40071 		mov	r1, #512
1062:arch/stm32/mcu_periph/i2c_arch.c **** }
 1250              		.loc 1 1062 0
 1251 001e BDE83840 		pop	{r3, r4, r5, lr}
 1252              	.LVL120:
1061:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1253              		.loc 1 1061 0
 1254 0022 FFF7FEBF 		b	i2c_enable_interrupt
 1255              	.LVL121:
 1256              	.L124:
 1257 0026 00BF     		.align	2
 1258              	.L123:
 1259 0028 00000000 		.word	i2c2
 1260              		.cfi_endproc
 1261              	.LFE19:
 1263              		.section	.text.i2c_event,"ax",%progbits
 1264              		.align	1
 1265              		.global	i2c_event
 1266              		.thumb
 1267              		.thumb_func
 1269              	i2c_event:
 1270              	.LFB42:
1063:arch/stm32/mcu_periph/i2c_arch.c **** 
1064:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C2 */
1065:arch/stm32/mcu_periph/i2c_arch.c **** 
1066:arch/stm32/mcu_periph/i2c_arch.c **** 
1067:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3 && defined STM32F4
1068:arch/stm32/mcu_periph/i2c_arch.c **** 
1069:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C3 clock speed */
1070:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C3_CLOCK_SPEED
1071:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C3_CLOCK_SPEED 300000
1072:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1073:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C3_CLOCK_SPEED)
1074:arch/stm32/mcu_periph/i2c_arch.c **** 
1075:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c3_errors;
1076:arch/stm32/mcu_periph/i2c_arch.c **** 
1077:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_hw_init(void)
1078:arch/stm32/mcu_periph/i2c_arch.c **** {
1079:arch/stm32/mcu_periph/i2c_arch.c **** 
1080:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.reg_addr = (void *)I2C3;
1081:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.init_struct = NULL;
1082:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.errors = &i2c3_errors;
1083:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = -1;
1084:arch/stm32/mcu_periph/i2c_arch.c **** 
1085:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
1086:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c3_errors);
1087:arch/stm32/mcu_periph/i2c_arch.c **** 
1088:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
1089:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C3);
1090:arch/stm32/mcu_periph/i2c_arch.c **** 
1091:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C3 event interrupt --------------------------------*/
1092:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C3_EV_IRQ, NVIC_I2C3_IRQ_PRIO);
1093:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C3_EV_IRQ);
1094:arch/stm32/mcu_periph/i2c_arch.c **** 
1095:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C3 err interrupt ----------------------------------*/
1096:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C3_ER_IRQ, NVIC_I2C3_IRQ_PRIO + 1);
1097:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C3_ER_IRQ);
1098:arch/stm32/mcu_periph/i2c_arch.c **** 
1099:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
1100:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C3 clock */
1101:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C3);
1102:arch/stm32/mcu_periph/i2c_arch.c **** 
1103:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
1104:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C3);
1105:arch/stm32/mcu_periph/i2c_arch.c **** 
1106:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C3);
1107:arch/stm32/mcu_periph/i2c_arch.c **** 
1108:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
1109:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C3);
1110:arch/stm32/mcu_periph/i2c_arch.c **** 
1111:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C3, 0);
1112:arch/stm32/mcu_periph/i2c_arch.c **** 
1113:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
1114:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C3, I2C_CR2_ITERREN);
1115:arch/stm32/mcu_periph/i2c_arch.c **** 
1116:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c3, I2C3_CLOCK_SPEED);
1117:arch/stm32/mcu_periph/i2c_arch.c **** }
1118:arch/stm32/mcu_periph/i2c_arch.c **** 
1119:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_ev_isr(void)
1120:arch/stm32/mcu_periph/i2c_arch.c **** {
1121:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c3.reg_addr;
1122:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
1123:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = 0; // restart watchdog
1124:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c3);
1125:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
1126:arch/stm32/mcu_periph/i2c_arch.c **** }
1127:arch/stm32/mcu_periph/i2c_arch.c **** 
1128:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_er_isr(void)
1129:arch/stm32/mcu_periph/i2c_arch.c **** {
1130:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c3.reg_addr;
1131:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
1132:arch/stm32/mcu_periph/i2c_arch.c ****   I2C_CR2(i2c) &= ~I2C_CR2_ITEVTEN;
1133:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = 0;  // restart watchdog
1134:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c3);
1135:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
1136:arch/stm32/mcu_periph/i2c_arch.c **** }
1137:arch/stm32/mcu_periph/i2c_arch.c **** 
1138:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C3 */
1139:arch/stm32/mcu_periph/i2c_arch.c **** 
1140:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////
1141:arch/stm32/mcu_periph/i2c_arch.c **** // Set Bitrate to Match your application:
1142:arch/stm32/mcu_periph/i2c_arch.c **** // -short wires, low capacitance bus: IMU: high speed
1143:arch/stm32/mcu_periph/i2c_arch.c **** // -long wires with a lot of capacitance: motor controller: put speed as low as possible
1144:arch/stm32/mcu_periph/i2c_arch.c **** 
1145:arch/stm32/mcu_periph/i2c_arch.c **** void i2c_setbitrate(struct i2c_periph *periph, int bitrate)
1146:arch/stm32/mcu_periph/i2c_arch.c **** {
1147:arch/stm32/mcu_periph/i2c_arch.c ****   // If NOT Busy
1148:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c_idle(periph)) {
1149:arch/stm32/mcu_periph/i2c_arch.c ****     volatile int devider;
1150:arch/stm32/mcu_periph/i2c_arch.c ****     volatile int risetime;
1151:arch/stm32/mcu_periph/i2c_arch.c **** 
1152:arch/stm32/mcu_periph/i2c_arch.c ****     uint32_t i2c = (uint32_t) periph->reg_addr;
1153:arch/stm32/mcu_periph/i2c_arch.c **** 
1154:arch/stm32/mcu_periph/i2c_arch.c ****     /*****************************************************
1155:arch/stm32/mcu_periph/i2c_arch.c ****     Bitrate:
1156:arch/stm32/mcu_periph/i2c_arch.c **** 
1157:arch/stm32/mcu_periph/i2c_arch.c ****     -CR2 + CCR + TRISE registers
1158:arch/stm32/mcu_periph/i2c_arch.c ****     -only change when PE=0
1159:arch/stm32/mcu_periph/i2c_arch.c **** 
1160:arch/stm32/mcu_periph/i2c_arch.c ****     e.g.
1161:arch/stm32/mcu_periph/i2c_arch.c **** 
1162:arch/stm32/mcu_periph/i2c_arch.c ****     10kHz:  36MHz + Standard 0x708 + 0x25
1163:arch/stm32/mcu_periph/i2c_arch.c ****     70kHz:  36MHz + Standard 0x101 +
1164:arch/stm32/mcu_periph/i2c_arch.c ****     400kHz: 36MHz + Fast 0x1E      + 0xb
1165:arch/stm32/mcu_periph/i2c_arch.c **** 
1166:arch/stm32/mcu_periph/i2c_arch.c ****     // 1) Program peripheral input clock CR2: to get correct timings
1167:arch/stm32/mcu_periph/i2c_arch.c ****     // 2) Configure clock control registers
1168:arch/stm32/mcu_periph/i2c_arch.c ****     // 3) Configure rise time register
1169:arch/stm32/mcu_periph/i2c_arch.c ****     ******************************************************/
1170:arch/stm32/mcu_periph/i2c_arch.c **** 
1171:arch/stm32/mcu_periph/i2c_arch.c ****     if (bitrate < 3000) {
1172:arch/stm32/mcu_periph/i2c_arch.c ****       bitrate = 3000;
1173:arch/stm32/mcu_periph/i2c_arch.c ****     }
1174:arch/stm32/mcu_periph/i2c_arch.c **** 
1175:arch/stm32/mcu_periph/i2c_arch.c ****     // rcc_apb1_frequency is normally configured to max: 36MHz on F1 and 42MHz on F4
1176:arch/stm32/mcu_periph/i2c_arch.c ****     // in fast mode: 2counts low 1 count high -> / 3:
1177:arch/stm32/mcu_periph/i2c_arch.c ****     // in standard mode: 1 count low, 1 count high -> /2:
1178:arch/stm32/mcu_periph/i2c_arch.c ****     devider = (rcc_apb1_frequency / 2000) / (bitrate / 1000);
1179:arch/stm32/mcu_periph/i2c_arch.c **** 
1180:arch/stm32/mcu_periph/i2c_arch.c ****     // never allow faster than 600kbps
1181:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider < 20) {
1182:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 20;
1183:arch/stm32/mcu_periph/i2c_arch.c ****     }
1184:arch/stm32/mcu_periph/i2c_arch.c **** 
1185:arch/stm32/mcu_periph/i2c_arch.c ****     // no overflow either
1186:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider >= 4095) {
1187:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 4095;
1188:arch/stm32/mcu_periph/i2c_arch.c ****     }
1189:arch/stm32/mcu_periph/i2c_arch.c **** 
1190:arch/stm32/mcu_periph/i2c_arch.c ****     // risetime can be up to 1/6th of the period
1191:arch/stm32/mcu_periph/i2c_arch.c ****     risetime = 1000000 / (bitrate / 1000) / 6 / 28;
1192:arch/stm32/mcu_periph/i2c_arch.c **** 
1193:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime < 10) {
1194:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 10;
1195:arch/stm32/mcu_periph/i2c_arch.c ****     }
1196:arch/stm32/mcu_periph/i2c_arch.c **** 
1197:arch/stm32/mcu_periph/i2c_arch.c ****     // more will overflow the register: for more you should lower the FREQ
1198:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime >= 31) {
1199:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 31;
1200:arch/stm32/mcu_periph/i2c_arch.c ****     }
1201:arch/stm32/mcu_periph/i2c_arch.c **** 
1202:arch/stm32/mcu_periph/i2c_arch.c ****     // we do not expect an interrupt as the interface should have been idle, but just in case...
1203:arch/stm32/mcu_periph/i2c_arch.c ****     __disable_irq(); // this code is in user space:
1204:arch/stm32/mcu_periph/i2c_arch.c **** 
1205:arch/stm32/mcu_periph/i2c_arch.c ****     // CCR can only be written when PE is disabled
1206:arch/stm32/mcu_periph/i2c_arch.c ****     // p731 note 5
1207:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_disable(i2c);
1208:arch/stm32/mcu_periph/i2c_arch.c **** 
1209:arch/stm32/mcu_periph/i2c_arch.c ****     // 1)
1210:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef STM32F1
1211:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_clock_frequency(i2c, I2C_CR2_FREQ_36MHZ);
1212:arch/stm32/mcu_periph/i2c_arch.c **** #else // STM32F4
1213:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_clock_frequency(i2c, I2C_CR2_FREQ_42MHZ);
1214:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1215:arch/stm32/mcu_periph/i2c_arch.c ****     // 2)
1216:arch/stm32/mcu_periph/i2c_arch.c ****     //i2c_set_fast_mode(i2c);
1217:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_ccr(i2c, devider);
1218:arch/stm32/mcu_periph/i2c_arch.c ****     // 3)
1219:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_trise(i2c, risetime);
1220:arch/stm32/mcu_periph/i2c_arch.c **** 
1221:arch/stm32/mcu_periph/i2c_arch.c ****     // Re-Enable
1222:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_enable(i2c);
1223:arch/stm32/mcu_periph/i2c_arch.c **** 
1224:arch/stm32/mcu_periph/i2c_arch.c ****     __enable_irq();
1225:arch/stm32/mcu_periph/i2c_arch.c **** 
1226:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1227:arch/stm32/mcu_periph/i2c_arch.c ****     __disable_irq(); // this code is in user space:
1228:arch/stm32/mcu_periph/i2c_arch.c **** 
1229:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
1230:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
1231:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
1232:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
1233:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
1234:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
1235:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
1236:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
1237:arch/stm32/mcu_periph/i2c_arch.c **** 
1238:arch/stm32/mcu_periph/i2c_arch.c ****     __enable_irq();
1239:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1240:arch/stm32/mcu_periph/i2c_arch.c **** 
1241:arch/stm32/mcu_periph/i2c_arch.c ****   }
1242:arch/stm32/mcu_periph/i2c_arch.c **** }
1243:arch/stm32/mcu_periph/i2c_arch.c **** 
1244:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1 || USE_I2C2 || USE_I2C3
1245:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_scl_set(uint32_t i2c)
1246:arch/stm32/mcu_periph/i2c_arch.c **** {
1247:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1248:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C1) {
1249:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
1250:arch/stm32/mcu_periph/i2c_arch.c ****   }
1251:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1252:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1253:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
1254:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
1255:arch/stm32/mcu_periph/i2c_arch.c ****   }
1256:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1257:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1258:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C3) {
1259:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1260:arch/stm32/mcu_periph/i2c_arch.c ****   }
1261:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1262:arch/stm32/mcu_periph/i2c_arch.c **** }
1263:arch/stm32/mcu_periph/i2c_arch.c **** 
1264:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_scl_clear(uint32_t i2c)
1265:arch/stm32/mcu_periph/i2c_arch.c **** {
1266:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1267:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C1) {
1268:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
1269:arch/stm32/mcu_periph/i2c_arch.c ****   }
1270:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1271:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1272:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
1273:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
1274:arch/stm32/mcu_periph/i2c_arch.c ****   }
1275:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1276:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1277:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C3) {
1278:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1279:arch/stm32/mcu_periph/i2c_arch.c ****   }
1280:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1281:arch/stm32/mcu_periph/i2c_arch.c **** }
1282:arch/stm32/mcu_periph/i2c_arch.c **** 
1283:arch/stm32/mcu_periph/i2c_arch.c **** #define WD_DELAY 20           // number of ticks with 2ms - 40ms delay before resetting the bus
1284:arch/stm32/mcu_periph/i2c_arch.c **** #define WD_RECOVERY_TICKS 10  // number of generated SCL clocking pulses
1285:arch/stm32/mcu_periph/i2c_arch.c **** 
1286:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_wd_check(struct i2c_periph *periph)
1287:arch/stm32/mcu_periph/i2c_arch.c **** {
1288:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
1289:arch/stm32/mcu_periph/i2c_arch.c **** 
1290:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog > WD_DELAY) {
1291:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->watchdog == WD_DELAY + 1) {
1292:arch/stm32/mcu_periph/i2c_arch.c **** 
1293:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
1294:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
1295:arch/stm32/mcu_periph/i2c_arch.c **** 
1296:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_disable(i2c);
1297:arch/stm32/mcu_periph/i2c_arch.c **** 
1298:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1299:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C1) {
1300:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
1301:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C1_GPIO_PORT, I2C1_GPIO_SDA);
1302:arch/stm32/mcu_periph/i2c_arch.c ****       }
1303:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1304:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1305:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C2) {
1306:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
1307:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C2_GPIO_PORT, I2C2_GPIO_SDA);
1308:arch/stm32/mcu_periph/i2c_arch.c ****       }
1309:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1310:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1311:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C3) {
1312:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1313:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C3_GPIO_PORT_SDA, I2C3_GPIO_SDA);
1314:arch/stm32/mcu_periph/i2c_arch.c ****       }
1315:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1316:arch/stm32/mcu_periph/i2c_arch.c **** 
1317:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_scl_clear(i2c);
1318:arch/stm32/mcu_periph/i2c_arch.c ****     } else if (periph->watchdog < WD_DELAY + WD_RECOVERY_TICKS) {
1319:arch/stm32/mcu_periph/i2c_arch.c ****       if ((periph->watchdog - WD_DELAY) % 2) {
1320:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_scl_clear(i2c);
1321:arch/stm32/mcu_periph/i2c_arch.c ****       } else {
1322:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_scl_set(i2c);
1323:arch/stm32/mcu_periph/i2c_arch.c ****       }
1324:arch/stm32/mcu_periph/i2c_arch.c ****     } else {
1325:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_scl_set(i2c);
1326:arch/stm32/mcu_periph/i2c_arch.c **** 
1327:arch/stm32/mcu_periph/i2c_arch.c ****       /* setup gpios for normal i2c operation again */
1328:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_setup_gpio(i2c);
1329:arch/stm32/mcu_periph/i2c_arch.c **** 
1330:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_insert_idx = 0;
1331:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx = 0;
1332:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
1333:arch/stm32/mcu_periph/i2c_arch.c **** 
1334:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
1335:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
1336:arch/stm32/mcu_periph/i2c_arch.c **** 
1337:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_enable(i2c);
1338:arch/stm32/mcu_periph/i2c_arch.c ****       periph->watchdog = 0; // restart watchdog
1339:arch/stm32/mcu_periph/i2c_arch.c **** 
1340:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->timeout_tlow_cnt++;
1341:arch/stm32/mcu_periph/i2c_arch.c **** 
1342:arch/stm32/mcu_periph/i2c_arch.c ****       return;
1343:arch/stm32/mcu_periph/i2c_arch.c ****     }
1344:arch/stm32/mcu_periph/i2c_arch.c ****   }
1345:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog >= 0) {
1346:arch/stm32/mcu_periph/i2c_arch.c ****     periph->watchdog++;
1347:arch/stm32/mcu_periph/i2c_arch.c ****   }
1348:arch/stm32/mcu_periph/i2c_arch.c **** }
1349:arch/stm32/mcu_periph/i2c_arch.c **** #endif // USE_I2Cx
1350:arch/stm32/mcu_periph/i2c_arch.c **** 
1351:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/sys_time.h"
1352:arch/stm32/mcu_periph/i2c_arch.c **** 
1353:arch/stm32/mcu_periph/i2c_arch.c **** void i2c_event(void)
1354:arch/stm32/mcu_periph/i2c_arch.c **** {
 1271              		.loc 1 1354 0
 1272              		.cfi_startproc
 1273              		@ args = 0, pretend = 0, frame = 0
 1274              		@ frame_needed = 0, uses_anonymous_args = 0
 1275 0000 70B5     		push	{r4, r5, r6, lr}
 1276              		.cfi_def_cfa_offset 16
 1277              		.cfi_offset 4, -16
 1278              		.cfi_offset 5, -12
 1279              		.cfi_offset 6, -8
 1280              		.cfi_offset 14, -4
1355:arch/stm32/mcu_periph/i2c_arch.c ****   static uint32_t i2c_wd_timer;
1356:arch/stm32/mcu_periph/i2c_arch.c **** 
1357:arch/stm32/mcu_periph/i2c_arch.c ****   if (SysTimeTimer(i2c_wd_timer) > 2000) { // 2ms (500Hz) periodic watchdog check
 1281              		.loc 1 1357 0
 1282 0002 3B4C     		ldr	r4, .L136
 1283 0004 FFF7FEFF 		bl	get_sys_time_usec
 1284              	.LVL122:
 1285 0008 2368     		ldr	r3, [r4]
 1286 000a C01A     		subs	r0, r0, r3
 1287 000c B0F5FA6F 		cmp	r0, #2000
 1288 0010 6CD9     		bls	.L125
 1289              	.LBB184:
 1290              	.LBB185:
1288:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 1291              		.loc 1 1288 0
 1292 0012 384D     		ldr	r5, .L136+4
 1293              	.LBE185:
 1294              	.LBE184:
1358:arch/stm32/mcu_periph/i2c_arch.c ****     SysTimeTimerStart(i2c_wd_timer);
 1295              		.loc 1 1358 0
 1296 0014 FFF7FEFF 		bl	get_sys_time_usec
 1297              	.LVL123:
 1298              	.LBB202:
 1299              	.LBB200:
1290:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog > WD_DELAY) {
 1300              		.loc 1 1290 0
 1301 0018 2B8E     		ldrh	r3, [r5, #48]
 1302              	.LBE200:
 1303              	.LBE202:
 1304              		.loc 1 1358 0
 1305 001a 2060     		str	r0, [r4]
 1306              	.LVL124:
 1307              	.LBB203:
 1308              	.LBB201:
1290:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog > WD_DELAY) {
 1309              		.loc 1 1290 0
 1310 001c 1BB2     		sxth	r3, r3
 1311 001e 142B     		cmp	r3, #20
1288:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 1312              		.loc 1 1288 0
 1313 0020 6C6A     		ldr	r4, [r5, #36]
 1314              	.LVL125:
1290:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog > WD_DELAY) {
 1315              		.loc 1 1290 0
 1316 0022 5ADD     		ble	.L130
1291:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->watchdog == WD_DELAY + 1) {
 1317              		.loc 1 1291 0
 1318 0024 2B8E     		ldrh	r3, [r5, #48]
 1319 0026 1BB2     		sxth	r3, r3
 1320 0028 152B     		cmp	r3, #21
 1321 002a 1AD1     		bne	.L129
1293:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1322              		.loc 1 1293 0
 1323 002c 2046     		mov	r0, r4
 1324 002e 4FF40071 		mov	r1, #512
 1325 0032 FFF7FEFF 		bl	i2c_disable_interrupt
 1326              	.LVL126:
1294:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 1327              		.loc 1 1294 0
 1328 0036 2046     		mov	r0, r4
 1329 0038 4FF48071 		mov	r1, #256
 1330 003c FFF7FEFF 		bl	i2c_disable_interrupt
 1331              	.LVL127:
1296:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_disable(i2c);
 1332              		.loc 1 1296 0
 1333 0040 2046     		mov	r0, r4
 1334 0042 FFF7FEFF 		bl	i2c_peripheral_disable
 1335              	.LVL128:
1305:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C2) {
 1336              		.loc 1 1305 0
 1337 0046 2C4B     		ldr	r3, .L136+8
 1338 0048 9C42     		cmp	r4, r3
 1339 004a 46D1     		bne	.L130
1306:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 1340              		.loc 1 1306 0
 1341 004c 2B48     		ldr	r0, .L136+12
 1342 004e 4FF48061 		mov	r1, #1024
 1343 0052 FFF7FEFF 		bl	gpio_setup_output
 1344              	.LVL129:
1307:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C2_GPIO_PORT, I2C2_GPIO_SDA);
 1345              		.loc 1 1307 0
 1346 0056 2948     		ldr	r0, .L136+12
 1347 0058 4FF40061 		mov	r1, #2048
 1348 005c FFF7FEFF 		bl	gpio_setup_input
 1349              	.LVL130:
 1350 0060 09E0     		b	.L135
 1351              	.LVL131:
 1352              	.L129:
1318:arch/stm32/mcu_periph/i2c_arch.c ****     } else if (periph->watchdog < WD_DELAY + WD_RECOVERY_TICKS) {
 1353              		.loc 1 1318 0
 1354 0062 2B8E     		ldrh	r3, [r5, #48]
 1355 0064 1BB2     		sxth	r3, r3
 1356 0066 1D2B     		cmp	r3, #29
 1357 0068 234B     		ldr	r3, .L136+8
 1358 006a 12DC     		bgt	.L131
1319:arch/stm32/mcu_periph/i2c_arch.c ****       if ((periph->watchdog - WD_DELAY) % 2) {
 1359              		.loc 1 1319 0
 1360 006c 2A8E     		ldrh	r2, [r5, #48]
 1361 006e D207     		lsls	r2, r2, #31
 1362 0070 07D5     		bpl	.L132
 1363              	.LVL132:
 1364              	.LBB186:
 1365              	.LBB187:
1272:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
 1366              		.loc 1 1272 0
 1367 0072 9C42     		cmp	r4, r3
 1368 0074 31D1     		bne	.L130
 1369              	.LVL133:
 1370              	.L135:
 1371              	.LBB188:
 1372              	.LBB189:
1273:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 1373              		.loc 1 1273 0
 1374 0076 2148     		ldr	r0, .L136+12
 1375 0078 4FF48061 		mov	r1, #1024
 1376 007c FFF7FEFF 		bl	gpio_clear
 1377              	.LVL134:
 1378 0080 2BE0     		b	.L130
 1379              	.LVL135:
 1380              	.L132:
 1381              	.LBE189:
 1382              	.LBE188:
 1383              	.LBE187:
 1384              	.LBE186:
 1385              	.LBB190:
 1386              	.LBB191:
1253:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
 1387              		.loc 1 1253 0
 1388 0082 9C42     		cmp	r4, r3
 1389 0084 29D1     		bne	.L130
 1390              	.LVL136:
 1391              	.LBB192:
 1392              	.LBB193:
1254:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 1393              		.loc 1 1254 0
 1394 0086 1D48     		ldr	r0, .L136+12
 1395 0088 4FF48061 		mov	r1, #1024
 1396 008c FFF7FEFF 		bl	gpio_set
 1397              	.LVL137:
 1398 0090 23E0     		b	.L130
 1399              	.LVL138:
 1400              	.L131:
 1401              	.LBE193:
 1402              	.LBE192:
 1403              	.LBE191:
 1404              	.LBE190:
 1405              	.LBB194:
 1406              	.LBB195:
1253:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
 1407              		.loc 1 1253 0
 1408 0092 9C42     		cmp	r4, r3
 1409 0094 06D1     		bne	.L133
 1410              	.LVL139:
 1411              	.LBB196:
 1412              	.LBB197:
1254:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 1413              		.loc 1 1254 0
 1414 0096 1948     		ldr	r0, .L136+12
 1415 0098 4FF48061 		mov	r1, #1024
 1416 009c FFF7FEFF 		bl	gpio_set
 1417              	.LVL140:
 1418              	.LBE197:
 1419              	.LBE196:
 1420              	.LBE195:
 1421              	.LBE194:
 1422              	.LBB198:
 1423              	.LBB199:
 1424 00a0 FFF7FEFF 		bl	i2c_setup_gpio.part.0
 1425              	.LVL141:
 1426              	.L133:
 1427              	.LBE199:
 1428              	.LBE198:
1330:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_insert_idx = 0;
 1429              		.loc 1 1330 0
 1430 00a4 0026     		movs	r6, #0
1334:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1431              		.loc 1 1334 0
 1432 00a6 2046     		mov	r0, r4
 1433 00a8 4FF40071 		mov	r1, #512
1330:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_insert_idx = 0;
 1434              		.loc 1 1330 0
 1435 00ac 85F82060 		strb	r6, [r5, #32]
1331:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx = 0;
 1436              		.loc 1 1331 0
 1437 00b0 85F82160 		strb	r6, [r5, #33]
1332:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
 1438              		.loc 1 1332 0
 1439 00b4 85F82260 		strb	r6, [r5, #34]
1334:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1440              		.loc 1 1334 0
 1441 00b8 FFF7FEFF 		bl	i2c_enable_interrupt
 1442              	.LVL142:
1335:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1443              		.loc 1 1335 0
 1444 00bc 2046     		mov	r0, r4
 1445 00be 4FF48071 		mov	r1, #256
 1446 00c2 FFF7FEFF 		bl	i2c_enable_interrupt
 1447              	.LVL143:
1337:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_enable(i2c);
 1448              		.loc 1 1337 0
 1449 00c6 2046     		mov	r0, r4
 1450 00c8 FFF7FEFF 		bl	i2c_peripheral_enable
 1451              	.LVL144:
1340:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->timeout_tlow_cnt++;
 1452              		.loc 1 1340 0
 1453 00cc EB6A     		ldr	r3, [r5, #44]
1338:arch/stm32/mcu_periph/i2c_arch.c ****       periph->watchdog = 0; // restart watchdog
 1454              		.loc 1 1338 0
 1455 00ce 2E86     		strh	r6, [r5, #48]	@ movhi
1340:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->timeout_tlow_cnt++;
 1456              		.loc 1 1340 0
 1457 00d0 9A89     		ldrh	r2, [r3, #12]
 1458 00d2 0132     		adds	r2, r2, #1
 1459 00d4 92B2     		uxth	r2, r2
 1460 00d6 9A81     		strh	r2, [r3, #12]	@ movhi
 1461 00d8 70BD     		pop	{r4, r5, r6, pc}
 1462              	.LVL145:
 1463              	.L130:
1345:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog >= 0) {
 1464              		.loc 1 1345 0
 1465 00da 2A8E     		ldrh	r2, [r5, #48]
 1466 00dc 054B     		ldr	r3, .L136+4
 1467 00de 12B2     		sxth	r2, r2
 1468 00e0 002A     		cmp	r2, #0
 1469 00e2 03DB     		blt	.L125
1346:arch/stm32/mcu_periph/i2c_arch.c ****     periph->watchdog++;
 1470              		.loc 1 1346 0
 1471 00e4 1A8E     		ldrh	r2, [r3, #48]
 1472 00e6 0132     		adds	r2, r2, #1
 1473 00e8 92B2     		uxth	r2, r2
 1474 00ea 1A86     		strh	r2, [r3, #48]	@ movhi
 1475              	.LVL146:
 1476              	.L125:
 1477 00ec 70BD     		pop	{r4, r5, r6, pc}
 1478              	.L137:
 1479 00ee 00BF     		.align	2
 1480              	.L136:
 1481 00f0 00000000 		.word	.LANCHOR0
 1482 00f4 00000000 		.word	i2c2
 1483 00f8 00580040 		.word	1073764352
 1484 00fc 00040240 		.word	1073873920
 1485              	.LBE201:
 1486              	.LBE203:
 1487              		.cfi_endproc
 1488              	.LFE42:
 1490              		.section	.text.i2c_submit,"ax",%progbits
 1491              		.align	1
 1492              		.global	i2c_submit
 1493              		.thumb
 1494              		.thumb_func
 1496              	i2c_submit:
 1497              	.LFB43:
1359:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1360:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c1);
1361:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1362:arch/stm32/mcu_periph/i2c_arch.c **** 
1363:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c2);
1365:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1366:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1367:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c3);
1368:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1369:arch/stm32/mcu_periph/i2c_arch.c ****   }
1370:arch/stm32/mcu_periph/i2c_arch.c **** }
1371:arch/stm32/mcu_periph/i2c_arch.c **** 
1372:arch/stm32/mcu_periph/i2c_arch.c **** /////////////////////////////////////////////////////////
1373:arch/stm32/mcu_periph/i2c_arch.c **** // Implement Interface Functions
1374:arch/stm32/mcu_periph/i2c_arch.c **** 
1375:arch/stm32/mcu_periph/i2c_arch.c **** bool_t i2c_submit(struct i2c_periph *periph, struct i2c_transaction *t)
1376:arch/stm32/mcu_periph/i2c_arch.c **** {
 1498              		.loc 1 1376 0
 1499              		.cfi_startproc
 1500              		@ args = 0, pretend = 0, frame = 0
 1501              		@ frame_needed = 0, uses_anonymous_args = 0
 1502              	.LVL147:
 1503 0000 10B5     		push	{r4, lr}
 1504              		.cfi_def_cfa_offset 8
 1505              		.cfi_offset 4, -8
 1506              		.cfi_offset 14, -4
1377:arch/stm32/mcu_periph/i2c_arch.c **** 
1378:arch/stm32/mcu_periph/i2c_arch.c ****   uint8_t temp;
1379:arch/stm32/mcu_periph/i2c_arch.c ****   temp = periph->trans_insert_idx + 1;
 1507              		.loc 1 1379 0
 1508 0002 90F82020 		ldrb	r2, [r0, #32]	@ zero_extendqisi2
1380:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp >= I2C_TRANSACTION_QUEUE_LEN) { temp = 0; }
1381:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp == periph->trans_extract_idx) {
 1509              		.loc 1 1381 0
 1510 0006 90F82140 		ldrb	r4, [r0, #33]	@ zero_extendqisi2
1379:arch/stm32/mcu_periph/i2c_arch.c ****   temp = periph->trans_insert_idx + 1;
 1511              		.loc 1 1379 0
 1512 000a 0132     		adds	r2, r2, #1
 1513 000c D2B2     		uxtb	r2, r2
 1514              	.LVL148:
1380:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp >= I2C_TRANSACTION_QUEUE_LEN) { temp = 0; }
 1515              		.loc 1 1380 0
 1516 000e 082A     		cmp	r2, #8
 1517 0010 28BF     		it	cs
 1518 0012 0022     		movcs	r2, #0
 1519              	.LVL149:
 1520              		.loc 1 1381 0
 1521 0014 9442     		cmp	r4, r2
 1522 0016 09D1     		bne	.L140
1382:arch/stm32/mcu_periph/i2c_arch.c ****     // queue full
1383:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->queue_full_cnt++;
 1523              		.loc 1 1383 0
 1524 0018 C36A     		ldr	r3, [r0, #44]
 1525 001a 1A88     		ldrh	r2, [r3]
 1526              	.LVL150:
 1527 001c 0132     		adds	r2, r2, #1
 1528 001e 92B2     		uxth	r2, r2
 1529 0020 1A80     		strh	r2, [r3]	@ movhi
 1530              	.LVL151:
1384:arch/stm32/mcu_periph/i2c_arch.c ****     t->status = I2CTransFailed;
 1531              		.loc 1 1384 0
 1532 0022 0323     		movs	r3, #3
 1533 0024 81F82530 		strb	r3, [r1, #37]
1385:arch/stm32/mcu_periph/i2c_arch.c ****     return FALSE;
 1534              		.loc 1 1385 0
 1535 0028 0020     		movs	r0, #0
 1536              	.LVL152:
 1537 002a 10BD     		pop	{r4, pc}
 1538              	.LVL153:
 1539              	.L140:
1386:arch/stm32/mcu_periph/i2c_arch.c ****   }
1387:arch/stm32/mcu_periph/i2c_arch.c **** 
1388:arch/stm32/mcu_periph/i2c_arch.c ****   t->status = I2CTransPending;
 1540              		.loc 1 1388 0
 1541 002c 0024     		movs	r4, #0
 1542 002e 81F82540 		strb	r4, [r1, #37]
 1543              	.LBB204:
 1544              	.LBB205:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
 1545              		.loc 1 65 0
 1546              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1547 0032 72B6     		cpsid i
 1548              	@ 0 "" 2
 1549              		.thumb
 1550              	.LBE205:
 1551              	.LBE204:
1389:arch/stm32/mcu_periph/i2c_arch.c **** 
1390:arch/stm32/mcu_periph/i2c_arch.c ****   __disable_irq();
1391:arch/stm32/mcu_periph/i2c_arch.c ****   /* put transacation in queue */
1392:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans[periph->trans_insert_idx] = t;
 1552              		.loc 1 1392 0
 1553 0034 90F82040 		ldrb	r4, [r0, #32]	@ zero_extendqisi2
1393:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans_insert_idx = temp;
1394:arch/stm32/mcu_periph/i2c_arch.c **** 
1395:arch/stm32/mcu_periph/i2c_arch.c ****   /* if peripheral is idle, start the transaction */
1396:arch/stm32/mcu_periph/i2c_arch.c ****   // if (PPRZ_I2C_IS_IDLE(p))
1397:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->status == I2CIdle) {
 1554              		.loc 1 1397 0
 1555 0038 90F82230 		ldrb	r3, [r0, #34]	@ zero_extendqisi2
1392:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans[periph->trans_insert_idx] = t;
 1556              		.loc 1 1392 0
 1557 003c 40F82410 		str	r1, [r0, r4, lsl #2]
1393:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans_insert_idx = temp;
 1558              		.loc 1 1393 0
 1559 0040 80F82020 		strb	r2, [r0, #32]
 1560              		.loc 1 1397 0
 1561 0044 0BB9     		cbnz	r3, .L142
1398:arch/stm32/mcu_periph/i2c_arch.c ****     //if (i2c_idle(periph))
1399:arch/stm32/mcu_periph/i2c_arch.c ****     {
1400:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1401:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1402:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph == &i2c1) {
1403:arch/stm32/mcu_periph/i2c_arch.c **** 
1404:arch/stm32/mcu_periph/i2c_arch.c ****       } else
1405:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1406:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1407:arch/stm32/mcu_periph/i2c_arch.c ****       {
1408:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1409:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_ON();
1410:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_OFF();
1411:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1412:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_START(periph);
 1562              		.loc 1 1412 0
 1563 0046 FFF7FEFF 		bl	PPRZ_I2C_SEND_START
 1564              	.LVL154:
 1565              	.L142:
 1566              	.LBB206:
 1567              	.LBB207:
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 1568              		.loc 1 66 0
 1569              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1570 004a 62B6     		cpsie i
 1571              	@ 0 "" 2
 1572              		.thumb
 1573              	.LBE207:
 1574              	.LBE206:
1413:arch/stm32/mcu_periph/i2c_arch.c ****       }
1414:arch/stm32/mcu_periph/i2c_arch.c ****     }
1415:arch/stm32/mcu_periph/i2c_arch.c ****   }
1416:arch/stm32/mcu_periph/i2c_arch.c ****   /* else it will be started by the interrupt handler when the previous transactions completes */
1417:arch/stm32/mcu_periph/i2c_arch.c ****   __enable_irq();
1418:arch/stm32/mcu_periph/i2c_arch.c **** 
1419:arch/stm32/mcu_periph/i2c_arch.c ****   return TRUE;
 1575              		.loc 1 1419 0
 1576 004c 0120     		movs	r0, #1
1420:arch/stm32/mcu_periph/i2c_arch.c **** }
 1577              		.loc 1 1420 0
 1578 004e 10BD     		pop	{r4, pc}
 1579              		.cfi_endproc
 1580              	.LFE43:
 1582              		.section	.text.i2c_idle,"ax",%progbits
 1583              		.align	1
 1584              		.global	i2c_idle
 1585              		.thumb
 1586              		.thumb_func
 1588              	i2c_idle:
 1589              	.LFB44:
1421:arch/stm32/mcu_periph/i2c_arch.c **** 
1422:arch/stm32/mcu_periph/i2c_arch.c **** bool_t i2c_idle(struct i2c_periph *periph)
1423:arch/stm32/mcu_periph/i2c_arch.c **** {
 1590              		.loc 1 1423 0
 1591              		.cfi_startproc
 1592              		@ args = 0, pretend = 0, frame = 0
 1593              		@ frame_needed = 0, uses_anonymous_args = 0
 1594              		@ link register save eliminated.
 1595              	.LVL155:
1424:arch/stm32/mcu_periph/i2c_arch.c ****   // This is actually a difficult function:
1425:arch/stm32/mcu_periph/i2c_arch.c ****   // -simply reading the status flags can clear bits and corrupt the transaction
1426:arch/stm32/mcu_periph/i2c_arch.c **** 
1427:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
1428:arch/stm32/mcu_periph/i2c_arch.c **** 
1429:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1430:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1431:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph == &i2c1) {
1432:arch/stm32/mcu_periph/i2c_arch.c ****     return TRUE;
1433:arch/stm32/mcu_periph/i2c_arch.c ****   }
1434:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1435:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1436:arch/stm32/mcu_periph/i2c_arch.c **** 
1437:arch/stm32/mcu_periph/i2c_arch.c ****   // First we check if the software thinks it is ready
1438:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->status == I2CIdle) {
 1596              		.loc 1 1438 0
 1597 0000 90F82220 		ldrb	r2, [r0, #34]	@ zero_extendqisi2
1427:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 1598              		.loc 1 1427 0
 1599 0004 436A     		ldr	r3, [r0, #36]
 1600              	.LVL156:
 1601              		.loc 1 1438 0
 1602 0006 2AB9     		cbnz	r2, .L146
1439:arch/stm32/mcu_periph/i2c_arch.c ****     return !(BIT_X_IS_SET_IN_REG(I2C_SR2_BUSY, I2C_SR2(i2c)));
 1603              		.loc 1 1439 0
 1604 0008 9869     		ldr	r0, [r3, #24]
 1605              	.LVL157:
 1606 000a 80F00200 		eor	r0, r0, #2
 1607 000e C0F34000 		ubfx	r0, r0, #1, #1
 1608 0012 7047     		bx	lr
 1609              	.LVL158:
 1610              	.L146:
1440:arch/stm32/mcu_periph/i2c_arch.c ****   } else {
1441:arch/stm32/mcu_periph/i2c_arch.c ****     return FALSE;
 1611              		.loc 1 1441 0
 1612 0014 0020     		movs	r0, #0
 1613              	.LVL159:
1442:arch/stm32/mcu_periph/i2c_arch.c ****   }
1443:arch/stm32/mcu_periph/i2c_arch.c **** }
 1614              		.loc 1 1443 0
 1615 0016 7047     		bx	lr
 1616              		.cfi_endproc
 1617              	.LFE44:
 1619              		.section	.text.i2c_setbitrate,"ax",%progbits
 1620              		.align	1
 1621              		.global	i2c_setbitrate
 1622              		.thumb
 1623              		.thumb_func
 1625              	i2c_setbitrate:
 1626              	.LFB20:
1146:arch/stm32/mcu_periph/i2c_arch.c **** {
 1627              		.loc 1 1146 0
 1628              		.cfi_startproc
 1629              		@ args = 0, pretend = 0, frame = 8
 1630              		@ frame_needed = 0, uses_anonymous_args = 0
 1631              	.LVL160:
 1632 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1633              		.cfi_def_cfa_offset 24
 1634              		.cfi_offset 0, -24
 1635              		.cfi_offset 1, -20
 1636              		.cfi_offset 2, -16
 1637              		.cfi_offset 4, -12
 1638              		.cfi_offset 5, -8
 1639              		.cfi_offset 14, -4
1146:arch/stm32/mcu_periph/i2c_arch.c **** {
 1640              		.loc 1 1146 0
 1641 0002 0446     		mov	r4, r0
 1642 0004 0D46     		mov	r5, r1
1148:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c_idle(periph)) {
 1643              		.loc 1 1148 0
 1644 0006 FFF7FEFF 		bl	i2c_idle
 1645              	.LVL161:
 1646 000a 0028     		cmp	r0, #0
 1647 000c 46D0     		beq	.L147
 1648              	.LBB208:
1172:arch/stm32/mcu_periph/i2c_arch.c ****       bitrate = 3000;
 1649              		.loc 1 1172 0
 1650 000e 40F6B833 		movw	r3, #3000
 1651 0012 9D42     		cmp	r5, r3
 1652 0014 B8BF     		it	lt
 1653 0016 1D46     		movlt	r5, r3
 1654              	.LVL162:
1178:arch/stm32/mcu_periph/i2c_arch.c ****     devider = (rcc_apb1_frequency / 2000) / (bitrate / 1000);
 1655              		.loc 1 1178 0
 1656 0018 4FF47A73 		mov	r3, #1000
 1657 001c 95FBF3F5 		sdiv	r5, r5, r3
 1658 0020 1F4B     		ldr	r3, .L158
1152:arch/stm32/mcu_periph/i2c_arch.c ****     uint32_t i2c = (uint32_t) periph->reg_addr;
 1659              		.loc 1 1152 0
 1660 0022 646A     		ldr	r4, [r4, #36]
 1661              	.LVL163:
1178:arch/stm32/mcu_periph/i2c_arch.c ****     devider = (rcc_apb1_frequency / 2000) / (bitrate / 1000);
 1662              		.loc 1 1178 0
 1663 0024 1A68     		ldr	r2, [r3]
 1664 0026 4FF4FA63 		mov	r3, #2000
 1665 002a B2FBF3F3 		udiv	r3, r2, r3
 1666 002e B3FBF5F3 		udiv	r3, r3, r5
 1667 0032 0093     		str	r3, [sp]
1181:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider < 20) {
 1668              		.loc 1 1181 0
 1669 0034 009B     		ldr	r3, [sp]
 1670 0036 132B     		cmp	r3, #19
1182:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 20;
 1671              		.loc 1 1182 0
 1672 0038 DCBF     		itt	le
 1673 003a 1423     		movle	r3, #20
 1674 003c 0093     		strle	r3, [sp]
1186:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider >= 4095) {
 1675              		.loc 1 1186 0
 1676 003e 009A     		ldr	r2, [sp]
 1677 0040 40F6FE73 		movw	r3, #4094
 1678 0044 9A42     		cmp	r2, r3
1187:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 4095;
 1679              		.loc 1 1187 0
 1680 0046 C4BF     		itt	gt
 1681 0048 40F6FF73 		movwgt	r3, #4095
 1682 004c 0093     		strgt	r3, [sp]
1191:arch/stm32/mcu_periph/i2c_arch.c ****     risetime = 1000000 / (bitrate / 1000) / 6 / 28;
 1683              		.loc 1 1191 0
 1684 004e 154B     		ldr	r3, .L158+4
 1685 0050 93FBF5F5 		sdiv	r5, r3, r5
 1686 0054 A823     		movs	r3, #168
 1687 0056 95FBF3F5 		sdiv	r5, r5, r3
 1688 005a 0195     		str	r5, [sp, #4]
1193:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime < 10) {
 1689              		.loc 1 1193 0
 1690 005c 019B     		ldr	r3, [sp, #4]
 1691 005e 092B     		cmp	r3, #9
1194:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 10;
 1692              		.loc 1 1194 0
 1693 0060 DCBF     		itt	le
 1694 0062 0A23     		movle	r3, #10
 1695 0064 0193     		strle	r3, [sp, #4]
1198:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime >= 31) {
 1696              		.loc 1 1198 0
 1697 0066 019B     		ldr	r3, [sp, #4]
 1698 0068 1E2B     		cmp	r3, #30
1199:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 31;
 1699              		.loc 1 1199 0
 1700 006a C4BF     		itt	gt
 1701 006c 1F23     		movgt	r3, #31
 1702 006e 0193     		strgt	r3, [sp, #4]
 1703              	.LBB209:
 1704              	.LBB210:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
 1705              		.loc 1 65 0
 1706              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1707 0070 72B6     		cpsid i
 1708              	@ 0 "" 2
 1709              		.thumb
 1710              	.LBE210:
 1711              	.LBE209:
1207:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_disable(i2c);
 1712              		.loc 1 1207 0
 1713 0072 2046     		mov	r0, r4
 1714 0074 FFF7FEFF 		bl	i2c_peripheral_disable
 1715              	.LVL164:
1213:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_clock_frequency(i2c, I2C_CR2_FREQ_42MHZ);
 1716              		.loc 1 1213 0
 1717 0078 2046     		mov	r0, r4
 1718 007a 2A21     		movs	r1, #42
 1719 007c FFF7FEFF 		bl	i2c_set_clock_frequency
 1720              	.LVL165:
1217:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_ccr(i2c, devider);
 1721              		.loc 1 1217 0
 1722 0080 0099     		ldr	r1, [sp]
 1723 0082 2046     		mov	r0, r4
 1724 0084 89B2     		uxth	r1, r1
 1725 0086 FFF7FEFF 		bl	i2c_set_ccr
 1726              	.LVL166:
1219:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_trise(i2c, risetime);
 1727              		.loc 1 1219 0
 1728 008a 0199     		ldr	r1, [sp, #4]
 1729 008c 2046     		mov	r0, r4
 1730 008e 89B2     		uxth	r1, r1
 1731 0090 FFF7FEFF 		bl	i2c_set_trise
 1732              	.LVL167:
1222:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_enable(i2c);
 1733              		.loc 1 1222 0
 1734 0094 2046     		mov	r0, r4
 1735 0096 FFF7FEFF 		bl	i2c_peripheral_enable
 1736              	.LVL168:
 1737              	.LBB211:
 1738              	.LBB212:
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 1739              		.loc 1 66 0
 1740              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1741 009a 62B6     		cpsie i
 1742              	@ 0 "" 2
 1743              	.LVL169:
 1744              		.thumb
 1745              	.L147:
 1746              	.LBE212:
 1747              	.LBE211:
 1748              	.LBE208:
1242:arch/stm32/mcu_periph/i2c_arch.c **** }
 1749              		.loc 1 1242 0
 1750 009c 03B0     		add	sp, sp, #12
 1751              		@ sp needed
 1752 009e 30BD     		pop	{r4, r5, pc}
 1753              	.L159:
 1754              		.align	2
 1755              	.L158:
 1756 00a0 00000000 		.word	rcc_apb1_frequency
 1757 00a4 40420F00 		.word	1000000
 1758              		.cfi_endproc
 1759              	.LFE20:
 1761              		.section	.text.i2c2_hw_init,"ax",%progbits
 1762              		.align	1
 1763              		.global	i2c2_hw_init
 1764              		.thumb
 1765              		.thumb_func
 1767              	i2c2_hw_init:
 1768              	.LFB17:
1005:arch/stm32/mcu_periph/i2c_arch.c **** {
 1769              		.loc 1 1005 0
 1770              		.cfi_startproc
 1771              		@ args = 0, pretend = 0, frame = 0
 1772              		@ frame_needed = 0, uses_anonymous_args = 0
 1773 0000 70B5     		push	{r4, r5, r6, lr}
 1774              		.cfi_def_cfa_offset 16
 1775              		.cfi_offset 4, -16
 1776              		.cfi_offset 5, -12
 1777              		.cfi_offset 6, -8
 1778              		.cfi_offset 14, -4
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
 1779              		.loc 1 1009 0
 1780 0002 1F4B     		ldr	r3, .L161
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.reg_addr = (void *)I2C2;
 1781              		.loc 1 1007 0
 1782 0004 1F4D     		ldr	r5, .L161+4
 1783 0006 204E     		ldr	r6, .L161+8
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
 1784              		.loc 1 1009 0
 1785 0008 EB62     		str	r3, [r5, #44]
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
 1786              		.loc 1 1008 0
 1787 000a 0024     		movs	r4, #0
1010:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
 1788              		.loc 1 1010 0
 1789 000c 4FF6FF72 		movw	r2, #65535
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_EV_IRQ, NVIC_I2C2_IRQ_PRIO);
 1790              		.loc 1 1019 0
 1791 0010 2146     		mov	r1, r4
 1792 0012 2120     		movs	r0, #33
1010:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
 1793              		.loc 1 1010 0
 1794 0014 2A86     		strh	r2, [r5, #48]	@ movhi
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.reg_addr = (void *)I2C2;
 1795              		.loc 1 1007 0
 1796 0016 6E62     		str	r6, [r5, #36]
1013:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c2_errors);
 1797              		.loc 1 1013 0
 1798 0018 1C80     		strh	r4, [r3]	@ movhi
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
 1799              		.loc 1 1008 0
 1800 001a AC62     		str	r4, [r5, #40]
1013:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c2_errors);
 1801              		.loc 1 1013 0
 1802 001c 5C80     		strh	r4, [r3, #2]	@ movhi
 1803 001e 9C80     		strh	r4, [r3, #4]	@ movhi
 1804 0020 DC80     		strh	r4, [r3, #6]	@ movhi
 1805 0022 1C81     		strh	r4, [r3, #8]	@ movhi
 1806 0024 5C81     		strh	r4, [r3, #10]	@ movhi
 1807 0026 9C81     		strh	r4, [r3, #12]	@ movhi
 1808 0028 DC81     		strh	r4, [r3, #14]	@ movhi
 1809 002a 1C82     		strh	r4, [r3, #16]	@ movhi
 1810 002c 5C61     		str	r4, [r3, #20]
 1811 002e 9C61     		str	r4, [r3, #24]
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_EV_IRQ, NVIC_I2C2_IRQ_PRIO);
 1812              		.loc 1 1019 0
 1813 0030 FFF7FEFF 		bl	nvic_set_priority
 1814              	.LVL170:
1020:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_EV_IRQ);
 1815              		.loc 1 1020 0
 1816 0034 2120     		movs	r0, #33
 1817 0036 FFF7FEFF 		bl	nvic_enable_irq
 1818              	.LVL171:
1023:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_ER_IRQ, NVIC_I2C2_IRQ_PRIO + 1);
 1819              		.loc 1 1023 0
 1820 003a 0121     		movs	r1, #1
 1821 003c 2220     		movs	r0, #34
 1822 003e FFF7FEFF 		bl	nvic_set_priority
 1823              	.LVL172:
1024:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_ER_IRQ);
 1824              		.loc 1 1024 0
 1825 0042 2220     		movs	r0, #34
 1826 0044 FFF7FEFF 		bl	nvic_enable_irq
 1827              	.LVL173:
1028:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C2);
 1828              		.loc 1 1028 0
 1829 0048 40F61600 		movw	r0, #2070
 1830 004c FFF7FEFF 		bl	rcc_periph_clock_enable
 1831              	.LVL174:
 1832              	.LBB215:
 1833              	.LBB216:
 1834 0050 FFF7FEFF 		bl	i2c_setup_gpio.part.0
 1835              	.LVL175:
 1836              	.LBE216:
 1837              	.LBE215:
1033:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C2);
 1838              		.loc 1 1033 0
 1839 0054 40F21640 		movw	r0, #1046
 1840 0058 FFF7FEFF 		bl	rcc_periph_reset_pulse
 1841              	.LVL176:
1036:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C2);
 1842              		.loc 1 1036 0
 1843 005c 3046     		mov	r0, r6
 1844 005e FFF7FEFF 		bl	i2c_peripheral_enable
 1845              	.LVL177:
1038:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C2, 0);
 1846              		.loc 1 1038 0
 1847 0062 3046     		mov	r0, r6
 1848 0064 2146     		mov	r1, r4
 1849 0066 FFF7FEFF 		bl	i2c_set_own_7bit_slave_address
 1850              	.LVL178:
1041:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C2, I2C_CR2_ITERREN);
 1851              		.loc 1 1041 0
 1852 006a 3046     		mov	r0, r6
 1853 006c 4FF48071 		mov	r1, #256
 1854 0070 FFF7FEFF 		bl	i2c_enable_interrupt
 1855              	.LVL179:
1043:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c2, I2C2_CLOCK_SPEED);
 1856              		.loc 1 1043 0
 1857 0074 2846     		mov	r0, r5
 1858 0076 0549     		ldr	r1, .L161+12
1044:arch/stm32/mcu_periph/i2c_arch.c **** }
 1859              		.loc 1 1044 0
 1860 0078 BDE87040 		pop	{r4, r5, r6, lr}
1043:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c2, I2C2_CLOCK_SPEED);
 1861              		.loc 1 1043 0
 1862 007c FFF7FEBF 		b	i2c_setbitrate
 1863              	.LVL180:
 1864              	.L162:
 1865              		.align	2
 1866              	.L161:
 1867 0080 00000000 		.word	.LANCHOR1
 1868 0084 00000000 		.word	i2c2
 1869 0088 00580040 		.word	1073764352
 1870 008c 801A0600 		.word	400000
 1871              		.cfi_endproc
 1872              	.LFE17:
 1874              		.global	i2c2_errors
 1875              		.section	.bss.i2c2_errors,"aw",%nobits
 1876              		.align	2
 1877              		.set	.LANCHOR1,. + 0
 1880              	i2c2_errors:
 1881 0000 00000000 		.space	112
 1881      00000000 
 1881      00000000 
 1881      00000000 
 1881      00000000 
 1882              		.section	.bss.i2c_wd_timer.6396,"aw",%nobits
 1883              		.align	2
 1884              		.set	.LANCHOR0,. + 0
 1887              	i2c_wd_timer.6396:
 1888 0000 00000000 		.space	4
 1889              		.text
 1890              	.Letext0:
 1891              		.file 4 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 1892              		.file 5 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 1893              		.file 6 "/home/lsk/paparazzi/sw/include/std.h"
 1894              		.file 7 "./mcu_periph/i2c.h"
 1895              		.file 8 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
 1896              		.file 9 "../ext/libopencm3/include/libopencm3/stm32/common/i2c_common_all.h"
 1897              		.file 10 "../ext/libopencm3/include/libopencm3/cm3/systick.h"
 1898              		.file 11 "/home/lsk/paparazzi/sw/airborne/arch/stm32/mcu_periph/gpio_arch.h"
 1899              		.file 12 "../ext/libopencm3/include/libopencm3/stm32/common/gpio_common_f234.h"
 1900              		.file 13 "../ext/libopencm3/include/libopencm3/stm32/common/gpio_common_all.h"
 1901              		.file 14 "../ext/libopencm3/include/libopencm3/cm3/nvic.h"
 1902              		.file 15 "../ext/libopencm3/include/libopencm3/stm32/common/rcc_common_all.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_arch.c
     /tmp/ccbhmiXY.s:20     .text.PPRZ_I2C_SEND_START:00000000 $t
     /tmp/ccbhmiXY.s:24     .text.PPRZ_I2C_SEND_START:00000000 PPRZ_I2C_SEND_START
     /tmp/ccbhmiXY.s:90     .text.get_sys_time_usec:00000000 $t
     /tmp/ccbhmiXY.s:94     .text.get_sys_time_usec:00000000 get_sys_time_usec
     /tmp/ccbhmiXY.s:156    .text.get_sys_time_usec:00000038 $d
     /tmp/ccbhmiXY.s:162    .text.i2c_setup_gpio.part.0:00000000 $t
     /tmp/ccbhmiXY.s:166    .text.i2c_setup_gpio.part.0:00000000 i2c_setup_gpio.part.0
     /tmp/ccbhmiXY.s:208    .text.i2c_setup_gpio.part.0:00000038 $d
     /tmp/ccbhmiXY.s:213    .text.stmi2c_clear_pending_interrupts:00000000 $t
     /tmp/ccbhmiXY.s:217    .text.stmi2c_clear_pending_interrupts:00000000 stmi2c_clear_pending_interrupts
     /tmp/ccbhmiXY.s:293    .text.i2c_error.constprop.7:00000000 $t
     /tmp/ccbhmiXY.s:297    .text.i2c_error.constprop.7:00000000 i2c_error.constprop.7
     /tmp/ccbhmiXY.s:414    .text.i2c_error.constprop.7:000000a4 $d
     /tmp/ccbhmiXY.s:419    .text.i2c_irq.constprop.6:00000000 $t
     /tmp/ccbhmiXY.s:423    .text.i2c_irq.constprop.6:00000000 i2c_irq.constprop.6
     /tmp/ccbhmiXY.s:993    .text.i2c_irq.constprop.6:000002dc $d
     /tmp/ccbhmiXY.s:998    .text.i2c_irq.constprop.6:000002e0 $t
     /tmp/ccbhmiXY.s:1159   .text.i2c_irq.constprop.6:000003c4 $d
     /tmp/ccbhmiXY.s:1166   .text.i2c2_ev_isr:00000000 $t
     /tmp/ccbhmiXY.s:1171   .text.i2c2_ev_isr:00000000 i2c2_ev_isr
     /tmp/ccbhmiXY.s:1210   .text.i2c2_ev_isr:00000028 $d
     /tmp/ccbhmiXY.s:1215   .text.i2c2_er_isr:00000000 $t
     /tmp/ccbhmiXY.s:1220   .text.i2c2_er_isr:00000000 i2c2_er_isr
     /tmp/ccbhmiXY.s:1259   .text.i2c2_er_isr:00000028 $d
     /tmp/ccbhmiXY.s:1264   .text.i2c_event:00000000 $t
     /tmp/ccbhmiXY.s:1269   .text.i2c_event:00000000 i2c_event
     /tmp/ccbhmiXY.s:1481   .text.i2c_event:000000f0 $d
     /tmp/ccbhmiXY.s:1491   .text.i2c_submit:00000000 $t
     /tmp/ccbhmiXY.s:1496   .text.i2c_submit:00000000 i2c_submit
     /tmp/ccbhmiXY.s:1583   .text.i2c_idle:00000000 $t
     /tmp/ccbhmiXY.s:1588   .text.i2c_idle:00000000 i2c_idle
     /tmp/ccbhmiXY.s:1620   .text.i2c_setbitrate:00000000 $t
     /tmp/ccbhmiXY.s:1625   .text.i2c_setbitrate:00000000 i2c_setbitrate
     /tmp/ccbhmiXY.s:1756   .text.i2c_setbitrate:000000a0 $d
     /tmp/ccbhmiXY.s:1762   .text.i2c2_hw_init:00000000 $t
     /tmp/ccbhmiXY.s:1767   .text.i2c2_hw_init:00000000 i2c2_hw_init
     /tmp/ccbhmiXY.s:1867   .text.i2c2_hw_init:00000080 $d
     /tmp/ccbhmiXY.s:1880   .bss.i2c2_errors:00000000 i2c2_errors
     /tmp/ccbhmiXY.s:1876   .bss.i2c2_errors:00000000 $d
     /tmp/ccbhmiXY.s:1883   .bss.i2c_wd_timer.6396:00000000 $d
     /tmp/ccbhmiXY.s:1887   .bss.i2c_wd_timer.6396:00000000 i2c_wd_timer.6396
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.61e172dafa1e7adfbd840ee8b103061f
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.4db40689d622c4d3b547b5801303bdae
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.13c5bec129ef04ad1bb0a1152b29c624
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.common.h.21.22efaac882611267214d0a36f6f15e74
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.i2c_common_all.h.33.0891c362b103dbf9b3c797a7eb8c45dd
                           .group:00000000 wm4.i2c.h.84.34a7bcc5d6061ae04ce49649a64c2253
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.i2c.h.173.edf41ec62e7796285c1333ff32983d5f
                           .group:00000000 wm4.krooz_sd.h.2.013366a614baabbe44cc2bbd3205e3d1
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.nvic.h.38.b26077e701ba065ebce4922ce89b9357
                           .group:00000000 wm4.nvic.h.16.68b2cd144a8737a35a31e344912a6e4f
                           .group:00000000 wm4.scb.h.22.290c4c25c761b65def084c067920a0d2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:00000000 wm4.sys_time.h.40.92f532b5cea824e0ec5ea845e7275d34
                           .group:00000000 wm4.systick.h.44.34e759e1f218a187b07e9a617cb1d556
                           .group:00000000 wm4.sys_time.h.213.4ee43452c5934214134db56488f53299

UNDEFINED SYMBOLS
i2c_enable_interrupt
i2c_disable_interrupt
i2c_nack_current
i2c_disable_ack
i2c_clear_stop
i2c_peripheral_enable
i2c_send_start
systick_get_reload
systick_get_value
sys_time
gpio_enable_clock
gpio_mode_setup
gpio_set_output_options
gpio_set_af
i2c_send_data
i2c_get_data
i2c2
i2c_send_stop
i2c_enable_ack
i2c_nack_next
i2c_peripheral_disable
gpio_setup_output
gpio_setup_input
gpio_clear
gpio_set
i2c_set_clock_frequency
i2c_set_ccr
i2c_set_trise
rcc_apb1_frequency
nvic_set_priority
nvic_enable_irq
rcc_periph_clock_enable
rcc_periph_reset_pulse
i2c_set_own_7bit_slave_address
