   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"ahrs_int_cmpl_quat.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.float_quat_normalize,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	float_quat_normalize:
  25              	.LFB43:
  26              		.file 1 "./math/pprz_algebra_float.h"
   1:./math/pprz_algebra_float.h **** /*
   2:./math/pprz_algebra_float.h ****  * Copyright (C) 2008-2014 The Paparazzi Team
   3:./math/pprz_algebra_float.h ****  *
   4:./math/pprz_algebra_float.h ****  * This file is part of paparazzi.
   5:./math/pprz_algebra_float.h ****  *
   6:./math/pprz_algebra_float.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_algebra_float.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_algebra_float.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_algebra_float.h ****  * any later version.
  10:./math/pprz_algebra_float.h ****  *
  11:./math/pprz_algebra_float.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_algebra_float.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_algebra_float.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_algebra_float.h ****  * GNU General Public License for more details.
  15:./math/pprz_algebra_float.h ****  *
  16:./math/pprz_algebra_float.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_algebra_float.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_algebra_float.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_algebra_float.h ****  */
  20:./math/pprz_algebra_float.h **** 
  21:./math/pprz_algebra_float.h **** /**
  22:./math/pprz_algebra_float.h ****  * @file pprz_algebra_float.h
  23:./math/pprz_algebra_float.h ****  * @brief Paparazzi floating point algebra.
  24:./math/pprz_algebra_float.h ****  *
  25:./math/pprz_algebra_float.h ****  * @addtogroup math_algebra
  26:./math/pprz_algebra_float.h ****  * @{
  27:./math/pprz_algebra_float.h ****  * @defgroup math_algebra_float Float Algebra
  28:./math/pprz_algebra_float.h ****  * @{
  29:./math/pprz_algebra_float.h ****  */
  30:./math/pprz_algebra_float.h **** 
  31:./math/pprz_algebra_float.h **** #ifndef PPRZ_ALGEBRA_FLOAT_H
  32:./math/pprz_algebra_float.h **** #define PPRZ_ALGEBRA_FLOAT_H
  33:./math/pprz_algebra_float.h **** 
  34:./math/pprz_algebra_float.h **** #ifdef __cplusplus
  35:./math/pprz_algebra_float.h **** extern "C" {
  36:./math/pprz_algebra_float.h **** #endif
  37:./math/pprz_algebra_float.h **** 
  38:./math/pprz_algebra_float.h **** #include "pprz_algebra.h"
  39:./math/pprz_algebra_float.h **** 
  40:./math/pprz_algebra_float.h **** #include <math.h>
  41:./math/pprz_algebra_float.h **** #include <float.h> // for FLT_MIN
  42:./math/pprz_algebra_float.h **** 
  43:./math/pprz_algebra_float.h **** /* this seems to be missing for some arch */
  44:./math/pprz_algebra_float.h **** #ifndef M_SQRT2
  45:./math/pprz_algebra_float.h **** #define M_SQRT2         1.41421356237309504880
  46:./math/pprz_algebra_float.h **** #endif
  47:./math/pprz_algebra_float.h **** 
  48:./math/pprz_algebra_float.h **** struct FloatVect2 {
  49:./math/pprz_algebra_float.h ****   float x;
  50:./math/pprz_algebra_float.h ****   float y;
  51:./math/pprz_algebra_float.h **** };
  52:./math/pprz_algebra_float.h **** 
  53:./math/pprz_algebra_float.h **** struct FloatVect3 {
  54:./math/pprz_algebra_float.h ****   float x;
  55:./math/pprz_algebra_float.h ****   float y;
  56:./math/pprz_algebra_float.h ****   float z;
  57:./math/pprz_algebra_float.h **** };
  58:./math/pprz_algebra_float.h **** 
  59:./math/pprz_algebra_float.h **** /**
  60:./math/pprz_algebra_float.h ****  * @brief Roation quaternion
  61:./math/pprz_algebra_float.h ****  */
  62:./math/pprz_algebra_float.h **** struct FloatQuat {
  63:./math/pprz_algebra_float.h ****   float qi;
  64:./math/pprz_algebra_float.h ****   float qx;
  65:./math/pprz_algebra_float.h ****   float qy;
  66:./math/pprz_algebra_float.h ****   float qz;
  67:./math/pprz_algebra_float.h **** };
  68:./math/pprz_algebra_float.h **** 
  69:./math/pprz_algebra_float.h **** struct FloatMat33 {
  70:./math/pprz_algebra_float.h ****   float m[3 * 3];
  71:./math/pprz_algebra_float.h **** };
  72:./math/pprz_algebra_float.h **** 
  73:./math/pprz_algebra_float.h **** /**
  74:./math/pprz_algebra_float.h ****  * @brief rotation matrix
  75:./math/pprz_algebra_float.h ****  */
  76:./math/pprz_algebra_float.h **** struct FloatRMat {
  77:./math/pprz_algebra_float.h ****   float m[3 * 3];
  78:./math/pprz_algebra_float.h **** };
  79:./math/pprz_algebra_float.h **** 
  80:./math/pprz_algebra_float.h **** /**
  81:./math/pprz_algebra_float.h ****  * @brief euler angles
  82:./math/pprz_algebra_float.h ****  * @details Units: radians */
  83:./math/pprz_algebra_float.h **** struct FloatEulers {
  84:./math/pprz_algebra_float.h ****   float phi; ///< in radians
  85:./math/pprz_algebra_float.h ****   float theta; ///< in radians
  86:./math/pprz_algebra_float.h ****   float psi; ///< in radians
  87:./math/pprz_algebra_float.h **** };
  88:./math/pprz_algebra_float.h **** 
  89:./math/pprz_algebra_float.h **** /**
  90:./math/pprz_algebra_float.h ****  * @brief angular rates
  91:./math/pprz_algebra_float.h ****  * @details Units: rad/s */
  92:./math/pprz_algebra_float.h **** struct FloatRates {
  93:./math/pprz_algebra_float.h ****   float p; ///< in rad/s
  94:./math/pprz_algebra_float.h ****   float q; ///< in rad/s
  95:./math/pprz_algebra_float.h ****   float r; ///< in rad/s
  96:./math/pprz_algebra_float.h **** };
  97:./math/pprz_algebra_float.h **** 
  98:./math/pprz_algebra_float.h **** #define FLOAT_ANGLE_NORMALIZE(_a) {             \
  99:./math/pprz_algebra_float.h ****     while (_a >  M_PI) _a -= (2.*M_PI);             \
 100:./math/pprz_algebra_float.h ****     while (_a < -M_PI) _a += (2.*M_PI);             \
 101:./math/pprz_algebra_float.h ****   }
 102:./math/pprz_algebra_float.h **** 
 103:./math/pprz_algebra_float.h **** //
 104:./math/pprz_algebra_float.h **** //
 105:./math/pprz_algebra_float.h **** // Vector algebra
 106:./math/pprz_algebra_float.h **** //
 107:./math/pprz_algebra_float.h **** //
 108:./math/pprz_algebra_float.h **** 
 109:./math/pprz_algebra_float.h **** 
 110:./math/pprz_algebra_float.h **** /*
 111:./math/pprz_algebra_float.h ****  * Dimension 2 Vectors
 112:./math/pprz_algebra_float.h ****  */
 113:./math/pprz_algebra_float.h **** 
 114:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_ZERO(_v) VECT2_ASSIGN(_v, 0., 0.)
 115:./math/pprz_algebra_float.h **** 
 116:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect2, but a different struct with x,y members */
 117:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORM(_v) sqrtf(VECT2_NORM2(_v))
 118:./math/pprz_algebra_float.h **** 
 119:./math/pprz_algebra_float.h **** static inline float float_vect2_norm2(struct FloatVect2 *v)
 120:./math/pprz_algebra_float.h **** {
 121:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y;
 122:./math/pprz_algebra_float.h **** }
 123:./math/pprz_algebra_float.h **** 
 124:./math/pprz_algebra_float.h **** static inline float float_vect2_norm(struct FloatVect2 *v)
 125:./math/pprz_algebra_float.h **** {
 126:./math/pprz_algebra_float.h ****   return sqrtf(float_vect2_norm2(v));
 127:./math/pprz_algebra_float.h **** }
 128:./math/pprz_algebra_float.h **** 
 129:./math/pprz_algebra_float.h **** /** normalize 2D vector in place */
 130:./math/pprz_algebra_float.h **** static inline void float_vect2_normalize(struct FloatVect2 *v)
 131:./math/pprz_algebra_float.h **** {
 132:./math/pprz_algebra_float.h ****   const float n = float_vect2_norm(v);
 133:./math/pprz_algebra_float.h ****   if (n > 0) {
 134:./math/pprz_algebra_float.h ****     v->x /= n;
 135:./math/pprz_algebra_float.h ****     v->y /= n;
 136:./math/pprz_algebra_float.h ****   }
 137:./math/pprz_algebra_float.h **** }
 138:./math/pprz_algebra_float.h **** 
 139:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORMALIZE(_v) float_vect2_normalize(&(_v))
 140:./math/pprz_algebra_float.h **** 
 141:./math/pprz_algebra_float.h **** 
 142:./math/pprz_algebra_float.h **** /*
 143:./math/pprz_algebra_float.h ****  * Dimension 3 Vectors
 144:./math/pprz_algebra_float.h ****  */
 145:./math/pprz_algebra_float.h **** 
 146:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0., 0., 0.)
 147:./math/pprz_algebra_float.h **** 
 148:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect3, but a different struct with x,y,z members */
 149:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORM(_v) sqrtf(VECT3_NORM2(_v))
 150:./math/pprz_algebra_float.h **** 
 151:./math/pprz_algebra_float.h **** static inline float float_vect3_norm2(struct FloatVect3 *v)
 152:./math/pprz_algebra_float.h **** {
 153:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y + v->z * v->z;
 154:./math/pprz_algebra_float.h **** }
 155:./math/pprz_algebra_float.h **** 
 156:./math/pprz_algebra_float.h **** static inline float float_vect3_norm(struct FloatVect3 *v)
 157:./math/pprz_algebra_float.h **** {
 158:./math/pprz_algebra_float.h ****   return sqrtf(float_vect3_norm2(v));
 159:./math/pprz_algebra_float.h **** }
 160:./math/pprz_algebra_float.h **** 
 161:./math/pprz_algebra_float.h **** /** normalize 3D vector in place */
 162:./math/pprz_algebra_float.h **** static inline void float_vect3_normalize(struct FloatVect3 *v)
 163:./math/pprz_algebra_float.h **** {
 164:./math/pprz_algebra_float.h ****   const float n = float_vect3_norm(v);
 165:./math/pprz_algebra_float.h ****   if (n > 0) {
 166:./math/pprz_algebra_float.h ****     v->x /= n;
 167:./math/pprz_algebra_float.h ****     v->y /= n;
 168:./math/pprz_algebra_float.h ****     v->z /= n;
 169:./math/pprz_algebra_float.h ****   }
 170:./math/pprz_algebra_float.h **** }
 171:./math/pprz_algebra_float.h **** 
 172:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORMALIZE(_v) float_vect3_normalize(&(_v))
 173:./math/pprz_algebra_float.h **** 
 174:./math/pprz_algebra_float.h **** 
 175:./math/pprz_algebra_float.h **** 
 176:./math/pprz_algebra_float.h **** #define FLOAT_RATES_ZERO(_r) {          \
 177:./math/pprz_algebra_float.h ****     RATES_ASSIGN(_r, 0., 0., 0.);       \
 178:./math/pprz_algebra_float.h ****   }
 179:./math/pprz_algebra_float.h **** 
 180:./math/pprz_algebra_float.h **** #define FLOAT_RATES_NORM(_v) (sqrtf((_v).p*(_v).p + (_v).q*(_v).q + (_v).r*(_v).r))
 181:./math/pprz_algebra_float.h **** 
 182:./math/pprz_algebra_float.h **** #define FLOAT_RATES_LIN_CMB(_ro, _r1, _s1, _r2, _s2) {          \
 183:./math/pprz_algebra_float.h ****     _ro.p = _s1 * _r1.p + _s2 * _r2.p;                  \
 184:./math/pprz_algebra_float.h ****     _ro.q = _s1 * _r1.q + _s2 * _r2.q;                  \
 185:./math/pprz_algebra_float.h ****     _ro.r = _s1 * _r1.r + _s2 * _r2.r;                  \
 186:./math/pprz_algebra_float.h ****   }
 187:./math/pprz_algebra_float.h **** 
 188:./math/pprz_algebra_float.h **** 
 189:./math/pprz_algebra_float.h **** extern void float_vect3_integrate_fi(struct FloatVect3 *vec, struct FloatVect3 *dv,
 190:./math/pprz_algebra_float.h ****                                      float dt);
 191:./math/pprz_algebra_float.h **** 
 192:./math/pprz_algebra_float.h **** extern void float_rates_integrate_fi(struct FloatRates *r, struct FloatRates *dr,
 193:./math/pprz_algebra_float.h ****                                      float dt);
 194:./math/pprz_algebra_float.h **** 
 195:./math/pprz_algebra_float.h **** extern void float_rates_of_euler_dot(struct FloatRates *r, struct FloatEulers *e,
 196:./math/pprz_algebra_float.h ****                                      struct FloatEulers *edot);
 197:./math/pprz_algebra_float.h **** 
 198:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 199:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_INTEGRATE_FI(_vo, _dv, _dt) float_vect3_integrate_fi(&(_vo), &(_dv), _dt)
 200:./math/pprz_algebra_float.h **** #define FLOAT_RATES_INTEGRATE_FI(_ra, _racc, _dt) float_rates_integrate_fi(&(_ra), &(_racc), _dt)
 201:./math/pprz_algebra_float.h **** #define FLOAT_RATES_OF_EULER_DOT(_ra, _e, _ed) float_rates_of_euler_dot(&(_ra), &(_e), &(_ed))
 202:./math/pprz_algebra_float.h **** 
 203:./math/pprz_algebra_float.h **** 
 204:./math/pprz_algebra_float.h **** /*
 205:./math/pprz_algebra_float.h ****  * 3x3 matrices
 206:./math/pprz_algebra_float.h ****  */
 207:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_ZERO(_m) {                      \
 208:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = 0.;                      \
 209:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 210:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 211:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 212:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = 0.;                      \
 213:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 214:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 215:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 216:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = 0.;                      \
 217:./math/pprz_algebra_float.h ****   }
 218:./math/pprz_algebra_float.h **** 
 219:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_DIAG(_m, _d00, _d11, _d22) {    \
 220:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = _d00;                    \
 221:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 222:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 223:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 224:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = _d11;                    \
 225:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 226:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 227:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 228:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = _d22;                    \
 229:./math/pprz_algebra_float.h ****   }
 230:./math/pprz_algebra_float.h **** 
 231:./math/pprz_algebra_float.h **** 
 232:./math/pprz_algebra_float.h **** //
 233:./math/pprz_algebra_float.h **** //
 234:./math/pprz_algebra_float.h **** // Rotation Matrices
 235:./math/pprz_algebra_float.h **** //
 236:./math/pprz_algebra_float.h **** //
 237:./math/pprz_algebra_float.h **** 
 238:./math/pprz_algebra_float.h **** 
 239:./math/pprz_algebra_float.h **** /** initialises a rotation matrix to identity */
 240:./math/pprz_algebra_float.h **** static inline void float_rmat_identity(struct FloatRMat *rm)
 241:./math/pprz_algebra_float.h **** {
 242:./math/pprz_algebra_float.h ****   FLOAT_MAT33_DIAG(*rm, 1., 1., 1.);
 243:./math/pprz_algebra_float.h **** }
 244:./math/pprz_algebra_float.h **** 
 245:./math/pprz_algebra_float.h **** /** Inverse/transpose of a rotation matrix.
 246:./math/pprz_algebra_float.h ****  * m_b2a = inv(_m_a2b) = transp(_m_a2b)
 247:./math/pprz_algebra_float.h ****  */
 248:./math/pprz_algebra_float.h **** extern void float_rmat_inv(struct FloatRMat *m_b2a, struct FloatRMat *m_a2b);
 249:./math/pprz_algebra_float.h **** 
 250:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 251:./math/pprz_algebra_float.h ****  * m_a2c = m_a2b comp m_b2c , aka  m_a2c = m_b2c * m_a2b
 252:./math/pprz_algebra_float.h ****  */
 253:./math/pprz_algebra_float.h **** extern void float_rmat_comp(struct FloatRMat *m_a2c, struct FloatRMat *m_a2b,
 254:./math/pprz_algebra_float.h ****                             struct FloatRMat *m_b2c);
 255:./math/pprz_algebra_float.h **** 
 256:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 257:./math/pprz_algebra_float.h ****  * m_a2b = m_a2c comp_inv m_b2c , aka  m_a2b = inv(_m_b2c) * m_a2c
 258:./math/pprz_algebra_float.h ****  */
 259:./math/pprz_algebra_float.h **** extern void float_rmat_comp_inv(struct FloatRMat *m_a2b, struct FloatRMat *m_a2c,
 260:./math/pprz_algebra_float.h ****                                 struct FloatRMat *m_b2c);
 261:./math/pprz_algebra_float.h **** 
 262:./math/pprz_algebra_float.h **** /// Norm of a rotation matrix.
 263:./math/pprz_algebra_float.h **** extern float float_rmat_norm(struct FloatRMat *rm);
 264:./math/pprz_algebra_float.h **** 
 265:./math/pprz_algebra_float.h **** /** rotate 3D vector by rotation matrix.
 266:./math/pprz_algebra_float.h ****  * vb = m_a2b * va
 267:./math/pprz_algebra_float.h ****  */
 268:./math/pprz_algebra_float.h **** extern void float_rmat_vmult(struct FloatVect3 *vb, struct FloatRMat *m_a2b,
 269:./math/pprz_algebra_float.h ****                              struct FloatVect3 *va);
 270:./math/pprz_algebra_float.h **** 
 271:./math/pprz_algebra_float.h **** /** rotate 3D vector by transposed rotation matrix.
 272:./math/pprz_algebra_float.h ****  * vb = m_b2a^T * va
 273:./math/pprz_algebra_float.h ****  */
 274:./math/pprz_algebra_float.h **** extern void float_rmat_transp_vmult(struct FloatVect3 *vb, struct FloatRMat *m_b2a,
 275:./math/pprz_algebra_float.h ****                                     struct FloatVect3 *va);
 276:./math/pprz_algebra_float.h **** 
 277:./math/pprz_algebra_float.h **** /** rotate anglular rates by rotation matrix.
 278:./math/pprz_algebra_float.h ****  * rb = m_a2b * ra
 279:./math/pprz_algebra_float.h ****  */
 280:./math/pprz_algebra_float.h **** extern void float_rmat_ratemult(struct FloatRates *rb, struct FloatRMat *m_a2b,
 281:./math/pprz_algebra_float.h ****                                 struct FloatRates *ra);
 282:./math/pprz_algebra_float.h **** 
 283:./math/pprz_algebra_float.h **** /** rotate anglular rates by transposed rotation matrix.
 284:./math/pprz_algebra_float.h ****  * rb = m_b2a^T * ra
 285:./math/pprz_algebra_float.h ****  */
 286:./math/pprz_algebra_float.h **** extern void float_rmat_transp_ratemult(struct FloatRates *rb, struct FloatRMat *m_b2a,
 287:./math/pprz_algebra_float.h ****                                        struct FloatRates *ra);
 288:./math/pprz_algebra_float.h **** 
 289:./math/pprz_algebra_float.h **** /** initialises a rotation matrix from unit vector axis and angle */
 290:./math/pprz_algebra_float.h **** extern void float_rmat_of_axis_angle(struct FloatRMat *rm, struct FloatVect3 *uv, float angle);
 291:./math/pprz_algebra_float.h **** 
 292:./math/pprz_algebra_float.h **** /** Rotation matrix from 321 Euler angles (float).
 293:./math/pprz_algebra_float.h ****  * The Euler angles are interpreted as zy'x'' (intrinsic) rotation.
 294:./math/pprz_algebra_float.h ****  * First rotate around z with psi, then around the new y' with theta,
 295:./math/pprz_algebra_float.h ****  * then around new x'' with phi.
 296:./math/pprz_algebra_float.h ****  * This is the same as a xyz (extrinsic) rotation,
 297:./math/pprz_algebra_float.h ****  * rotating around the fixed x, then y then z axis.
 298:./math/pprz_algebra_float.h ****  * - psi range: -pi < psi <= pi
 299:./math/pprz_algebra_float.h ****  * - theta range: -pi/2 <= theta <= pi/2
 300:./math/pprz_algebra_float.h ****  * - phi range: -pi < phi <= pi
 301:./math/pprz_algebra_float.h ****  * @param[out] rm pointer to rotation matrix
 302:./math/pprz_algebra_float.h ****  * @param[in]  e pointer to Euler angles
 303:./math/pprz_algebra_float.h ****  */
 304:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_321(struct FloatRMat *rm, struct FloatEulers *e);
 305:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_312(struct FloatRMat *rm, struct FloatEulers *e);
 306:./math/pprz_algebra_float.h **** #define float_rmat_of_eulers float_rmat_of_eulers_321
 307:./math/pprz_algebra_float.h **** 
 308:./math/pprz_algebra_float.h **** extern void float_rmat_of_quat(struct FloatRMat *rm, struct FloatQuat *q);
 309:./math/pprz_algebra_float.h **** /** in place first order integration of a rotation matrix */
 310:./math/pprz_algebra_float.h **** extern void float_rmat_integrate_fi(struct FloatRMat *rm, struct FloatRates *omega, float dt);
 311:./math/pprz_algebra_float.h **** extern float float_rmat_reorthogonalize(struct FloatRMat *rm);
 312:./math/pprz_algebra_float.h **** 
 313:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 314:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INV(_m_b2a, _m_a2b) float_rmat_inv(&(_m_b2a), &(_m_a2b))
 315:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_NORM(_m) float_rmat_norm(&(_m))
 316:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP(_m_a2c, _m_a2b, _m_b2c) float_rmat_comp(&(_m_a2c), &(_m_a2b), &(_m_b2c))
 317:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP_INV(_m_a2b, _m_a2c, _m_b2c) float_rmat_comp_inv(&(_m_a2b), &(_m_a2c), &(_m_
 318:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_VMULT(_vb, _m_a2b, _va) float_rmat_vmult(&(_vb), &(_m_a2b), &(_va))
 319:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_VMULT(_vb, _m_b2a, _va) float_rmat_transp_vmult(&(_vb), &(_m_b2a), &(_va)
 320:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_RATEMULT(_rb, _m_a2b, _ra) float_rmat_ratemult(&(_rb), &(_m_a2b), &(_ra))
 321:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_RATEMULT(_rb, _m_b2a, _ra) float_rmat_ratemult(&(_rb), &(_m_b2a), &(_ra))
 322:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_AXIS_ANGLE(_rm, _uv, _an) float_rmat_of_axis_angle(&(_rm), &(_uv), _an)
 323:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS(_rm, _e)     float_rmat_of_eulers_321(&(_rm), &(_e))
 324:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_321(_rm, _e) float_rmat_of_eulers_321(&(_rm), &(_e))
 325:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_312(_rm, _e) float_rmat_of_eulers_312(&(_rm), &(_e))
 326:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_QUAT(_rm, _q)       float_rmat_of_quat(&(_rm), &(_q))
 327:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INTEGRATE_FI(_rm, _omega, _dt) float_rmat_integrate_fi(&(_rm), &(_omega), &(_dt)
 328:./math/pprz_algebra_float.h **** 
 329:./math/pprz_algebra_float.h **** 
 330:./math/pprz_algebra_float.h **** 
 331:./math/pprz_algebra_float.h **** //
 332:./math/pprz_algebra_float.h **** //
 333:./math/pprz_algebra_float.h **** // Quaternion algebras
 334:./math/pprz_algebra_float.h **** //
 335:./math/pprz_algebra_float.h **** //
 336:./math/pprz_algebra_float.h **** 
 337:./math/pprz_algebra_float.h **** /** initialises a quaternion to identity */
 338:./math/pprz_algebra_float.h **** static inline void float_quat_identity(struct FloatQuat *q)
 339:./math/pprz_algebra_float.h **** {
 340:./math/pprz_algebra_float.h ****   q->qi = 1.0;
 341:./math/pprz_algebra_float.h ****   q->qx = 0;
 342:./math/pprz_algebra_float.h ****   q->qy = 0;
 343:./math/pprz_algebra_float.h ****   q->qz = 0;
 344:./math/pprz_algebra_float.h **** }
 345:./math/pprz_algebra_float.h **** 
 346:./math/pprz_algebra_float.h **** #define FLOAT_QUAT_NORM2(_q) (SQUARE((_q).qi) + SQUARE((_q).qx) + SQUARE((_q).qy) + SQUARE((_q).qz)
 347:./math/pprz_algebra_float.h **** 
 348:./math/pprz_algebra_float.h **** static inline float float_quat_norm(struct FloatQuat *q)
 349:./math/pprz_algebra_float.h **** {
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
 351:./math/pprz_algebra_float.h **** }
 352:./math/pprz_algebra_float.h **** 
 353:./math/pprz_algebra_float.h **** static inline void float_quat_normalize(struct FloatQuat *q)
 354:./math/pprz_algebra_float.h **** {
  27              		.loc 1 354 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32              	.LBB7:
  33              	.LBB8:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  34              		.loc 1 350 0
  35 0000 D0ED017A 		flds	s15, [r0, #4]
  36 0004 90ED006A 		flds	s12, [r0]
  37 0008 D0ED026A 		flds	s13, [r0, #8]
  38 000c 90ED037A 		flds	s14, [r0, #12]
  39 0010 67EEA77A 		fmuls	s15, s15, s15
  40              	.LBE8:
  41              	.LBE7:
  42              		.loc 1 354 0
  43 0014 10B5     		push	{r4, lr}
  44              		.cfi_def_cfa_offset 8
  45              		.cfi_offset 4, -8
  46              		.cfi_offset 14, -4
  47              	.LBB12:
  48              	.LBB9:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  49              		.loc 1 350 0
  50 0016 E6EE067A 		vfma.f32	s15, s12, s12
  51              	.LBE9:
  52              	.LBE12:
  53              		.loc 1 354 0
  54 001a 0446     		mov	r4, r0
  55              	.LBB13:
  56              	.LBB10:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  57              		.loc 1 350 0
  58 001c E6EEA67A 		vfma.f32	s15, s13, s13
  59 0020 E7EE077A 		vfma.f32	s15, s14, s14
  60 0024 17EE900A 		fmrs	r0, s15
  61              	.LVL1:
  62 0028 FFF7FEFF 		bl	sqrtf
  63              	.LVL2:
  64              	.LBE10:
  65              	.LBE13:
 355:./math/pprz_algebra_float.h ****   float qnorm = float_quat_norm(q);
 356:./math/pprz_algebra_float.h ****   if (qnorm > FLT_MIN) {
  66              		.loc 1 356 0
  67 002c 9FED107A 		flds	s14, .L6
  68              	.LBB14:
  69              	.LBB11:
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
  70              		.loc 1 350 0
  71 0030 07EE900A 		fmsr	s15, r0
  72              	.LBE11:
  73              	.LBE14:
  74              		.loc 1 356 0
  75 0034 F4EEC77A 		fcmpes	s15, s14
  76 0038 F1EE10FA 		fmstat
  77 003c 17DD     		ble	.L1
 357:./math/pprz_algebra_float.h ****     q->qi = q->qi / qnorm;
  78              		.loc 1 357 0
  79 003e 94ED007A 		flds	s14, [r4]
  80 0042 87EE277A 		fdivs	s14, s14, s15
  81 0046 84ED007A 		fsts	s14, [r4]
 358:./math/pprz_algebra_float.h ****     q->qx = q->qx / qnorm;
  82              		.loc 1 358 0
  83 004a 94ED017A 		flds	s14, [r4, #4]
  84 004e 87EE277A 		fdivs	s14, s14, s15
  85 0052 84ED017A 		fsts	s14, [r4, #4]
 359:./math/pprz_algebra_float.h ****     q->qy = q->qy / qnorm;
  86              		.loc 1 359 0
  87 0056 94ED027A 		flds	s14, [r4, #8]
  88 005a 87EE277A 		fdivs	s14, s14, s15
  89 005e 84ED027A 		fsts	s14, [r4, #8]
 360:./math/pprz_algebra_float.h ****     q->qz = q->qz / qnorm;
  90              		.loc 1 360 0
  91 0062 94ED037A 		flds	s14, [r4, #12]
  92 0066 C7EE277A 		fdivs	s15, s14, s15
  93 006a C4ED037A 		fsts	s15, [r4, #12]
  94              	.L1:
  95 006e 10BD     		pop	{r4, pc}
  96              	.LVL3:
  97              	.L7:
  98              		.align	2
  99              	.L6:
 100 0070 00008000 		.word	8388608
 101              		.cfi_endproc
 102              	.LFE43:
 104              		.section	.text.int32_quat_normalize,"ax",%progbits
 105              		.align	1
 106              		.thumb
 107              		.thumb_func
 109              	int32_quat_normalize:
 110              	.LFB8:
 111              		.file 2 "./math/pprz_algebra_int.h"
   1:./math/pprz_algebra_int.h **** /*
   2:./math/pprz_algebra_int.h ****  * Copyright (C) 2008-2014 The Paparazzi Team
   3:./math/pprz_algebra_int.h ****  *
   4:./math/pprz_algebra_int.h ****  * This file is part of paparazzi.
   5:./math/pprz_algebra_int.h ****  *
   6:./math/pprz_algebra_int.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_algebra_int.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_algebra_int.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_algebra_int.h ****  * any later version.
  10:./math/pprz_algebra_int.h ****  *
  11:./math/pprz_algebra_int.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_algebra_int.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_algebra_int.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_algebra_int.h ****  * GNU General Public License for more details.
  15:./math/pprz_algebra_int.h ****  *
  16:./math/pprz_algebra_int.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_algebra_int.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_algebra_int.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_algebra_int.h ****  */
  20:./math/pprz_algebra_int.h **** 
  21:./math/pprz_algebra_int.h **** /**
  22:./math/pprz_algebra_int.h ****  * @file pprz_algebra_int.h
  23:./math/pprz_algebra_int.h ****  * @brief Paparazzi fixed point algebra.
  24:./math/pprz_algebra_int.h ****  *
  25:./math/pprz_algebra_int.h ****  * @addtogroup math_algebra
  26:./math/pprz_algebra_int.h ****  * @{
  27:./math/pprz_algebra_int.h ****  * @addtogroup math_algebra_int Fixed Point Algebra
  28:./math/pprz_algebra_int.h ****  * @{
  29:./math/pprz_algebra_int.h ****  */
  30:./math/pprz_algebra_int.h **** 
  31:./math/pprz_algebra_int.h **** #ifndef PPRZ_ALGEBRA_INT_H
  32:./math/pprz_algebra_int.h **** #define PPRZ_ALGEBRA_INT_H
  33:./math/pprz_algebra_int.h **** 
  34:./math/pprz_algebra_int.h **** #ifdef __cplusplus
  35:./math/pprz_algebra_int.h **** extern "C" {
  36:./math/pprz_algebra_int.h **** #endif
  37:./math/pprz_algebra_int.h **** 
  38:./math/pprz_algebra_int.h **** #include "std.h"
  39:./math/pprz_algebra_int.h **** #include "math/pprz_algebra.h"
  40:./math/pprz_algebra_int.h **** #include "math/pprz_trig_int.h"
  41:./math/pprz_algebra_int.h **** #include <stdlib.h>
  42:./math/pprz_algebra_int.h **** 
  43:./math/pprz_algebra_int.h **** 
  44:./math/pprz_algebra_int.h **** struct Uint8Vect3 {
  45:./math/pprz_algebra_int.h ****   uint8_t x;
  46:./math/pprz_algebra_int.h ****   uint8_t y;
  47:./math/pprz_algebra_int.h ****   uint8_t z;
  48:./math/pprz_algebra_int.h **** };
  49:./math/pprz_algebra_int.h **** 
  50:./math/pprz_algebra_int.h **** struct Int8Vect3 {
  51:./math/pprz_algebra_int.h ****   int8_t x;
  52:./math/pprz_algebra_int.h ****   int8_t y;
  53:./math/pprz_algebra_int.h ****   int8_t z;
  54:./math/pprz_algebra_int.h **** };
  55:./math/pprz_algebra_int.h **** 
  56:./math/pprz_algebra_int.h **** struct Uint16Vect3 {
  57:./math/pprz_algebra_int.h ****   uint16_t x;
  58:./math/pprz_algebra_int.h ****   uint16_t y;
  59:./math/pprz_algebra_int.h ****   uint16_t z;
  60:./math/pprz_algebra_int.h **** };
  61:./math/pprz_algebra_int.h **** 
  62:./math/pprz_algebra_int.h **** struct Int16Vect3 {
  63:./math/pprz_algebra_int.h ****   int16_t x;
  64:./math/pprz_algebra_int.h ****   int16_t y;
  65:./math/pprz_algebra_int.h ****   int16_t z;
  66:./math/pprz_algebra_int.h **** };
  67:./math/pprz_algebra_int.h **** 
  68:./math/pprz_algebra_int.h **** #define INT32_POS_FRAC 8
  69:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM 2.56
  70:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM_NUM 64
  71:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM_DEN 25
  72:./math/pprz_algebra_int.h **** 
  73:./math/pprz_algebra_int.h **** #define INT32_SPEED_FRAC 19
  74:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S 5242.88
  75:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S_NUM 41943
  76:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S_DEN 8
  77:./math/pprz_algebra_int.h **** 
  78:./math/pprz_algebra_int.h **** #define INT32_ACCEL_FRAC 10
  79:./math/pprz_algebra_int.h **** #define INT32_MAG_FRAC 11
  80:./math/pprz_algebra_int.h **** 
  81:./math/pprz_algebra_int.h **** #define INT32_PERCENTAGE_FRAC 10
  82:./math/pprz_algebra_int.h **** 
  83:./math/pprz_algebra_int.h **** struct Int32Vect2 {
  84:./math/pprz_algebra_int.h ****   int32_t x;
  85:./math/pprz_algebra_int.h ****   int32_t y;
  86:./math/pprz_algebra_int.h **** };
  87:./math/pprz_algebra_int.h **** 
  88:./math/pprz_algebra_int.h **** struct Int32Vect3 {
  89:./math/pprz_algebra_int.h ****   int32_t x;
  90:./math/pprz_algebra_int.h ****   int32_t y;
  91:./math/pprz_algebra_int.h ****   int32_t z;
  92:./math/pprz_algebra_int.h **** };
  93:./math/pprz_algebra_int.h **** 
  94:./math/pprz_algebra_int.h **** /* Rotation quaternions                         */
  95:./math/pprz_algebra_int.h **** #define INT32_QUAT_FRAC 15
  96:./math/pprz_algebra_int.h **** /**
  97:./math/pprz_algebra_int.h ****  * @brief Rotation quaternion
  98:./math/pprz_algebra_int.h ****  * @details Units: BFP with #INT32_QUAT_FRAC */
  99:./math/pprz_algebra_int.h **** struct Int32Quat {
 100:./math/pprz_algebra_int.h ****   int32_t qi;
 101:./math/pprz_algebra_int.h ****   int32_t qx;
 102:./math/pprz_algebra_int.h ****   int32_t qy;
 103:./math/pprz_algebra_int.h ****   int32_t qz;
 104:./math/pprz_algebra_int.h **** };
 105:./math/pprz_algebra_int.h **** 
 106:./math/pprz_algebra_int.h **** 
 107:./math/pprz_algebra_int.h **** struct Int64Quat {
 108:./math/pprz_algebra_int.h ****   int64_t qi;
 109:./math/pprz_algebra_int.h ****   int64_t qx;
 110:./math/pprz_algebra_int.h ****   int64_t qy;
 111:./math/pprz_algebra_int.h ****   int64_t qz;
 112:./math/pprz_algebra_int.h **** };
 113:./math/pprz_algebra_int.h **** 
 114:./math/pprz_algebra_int.h **** 
 115:./math/pprz_algebra_int.h **** /* Euler angles                                 */
 116:./math/pprz_algebra_int.h **** #define INT32_ANGLE_FRAC 12
 117:./math/pprz_algebra_int.h **** #define INT32_RATE_FRAC 12
 118:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI_4   (int32_t)ANGLE_BFP_OF_REAL(   0.7853981633974483096156608458198757)
 119:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI_2   (int32_t)ANGLE_BFP_OF_REAL(   1.5707963267948966192313216916397514)
 120:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI     (int32_t)ANGLE_BFP_OF_REAL(   3.1415926535897932384626433832795029)
 121:./math/pprz_algebra_int.h **** #define INT32_ANGLE_2_PI   (int32_t)ANGLE_BFP_OF_REAL(2.*3.1415926535897932384626433832795029)
 122:./math/pprz_algebra_int.h **** 
 123:./math/pprz_algebra_int.h **** #define INT32_RAD_OF_DEG(_deg) (int32_t)(((int64_t)(_deg) * 14964008)/857374503)
 124:./math/pprz_algebra_int.h **** #define INT32_DEG_OF_RAD(_rad) (int32_t)(((int64_t)(_rad) * 857374503)/14964008)
 125:./math/pprz_algebra_int.h **** 
 126:./math/pprz_algebra_int.h **** #define INT32_ANGLE_NORMALIZE(_a) {             \
 127:./math/pprz_algebra_int.h ****     while ((_a) > INT32_ANGLE_PI)  (_a) -= INT32_ANGLE_2_PI;    \
 128:./math/pprz_algebra_int.h ****     while ((_a) < -INT32_ANGLE_PI) (_a) += INT32_ANGLE_2_PI;    \
 129:./math/pprz_algebra_int.h ****   }
 130:./math/pprz_algebra_int.h **** 
 131:./math/pprz_algebra_int.h **** #define INT32_COURSE_NORMALIZE(_a) {                \
 132:./math/pprz_algebra_int.h ****     while ((_a) < 0) (_a) += INT32_ANGLE_2_PI;                  \
 133:./math/pprz_algebra_int.h ****     while ((_a) >= INT32_ANGLE_2_PI)  (_a) -= INT32_ANGLE_2_PI; \
 134:./math/pprz_algebra_int.h ****   }
 135:./math/pprz_algebra_int.h **** 
 136:./math/pprz_algebra_int.h **** 
 137:./math/pprz_algebra_int.h **** struct Int16Eulers {
 138:./math/pprz_algebra_int.h ****   int16_t phi;
 139:./math/pprz_algebra_int.h ****   int16_t theta;
 140:./math/pprz_algebra_int.h ****   int16_t psi;
 141:./math/pprz_algebra_int.h **** };
 142:./math/pprz_algebra_int.h **** 
 143:./math/pprz_algebra_int.h **** /**
 144:./math/pprz_algebra_int.h ****  * @brief euler angles
 145:./math/pprz_algebra_int.h ****  * @details Units: rad in BFP with #INT32_ANGLE_FRAC */
 146:./math/pprz_algebra_int.h **** struct Int32Eulers {
 147:./math/pprz_algebra_int.h ****   int32_t phi;   ///< in rad with #INT32_ANGLE_FRAC
 148:./math/pprz_algebra_int.h ****   int32_t theta; ///< in rad with #INT32_ANGLE_FRAC
 149:./math/pprz_algebra_int.h ****   int32_t psi;   ///< in rad with #INT32_ANGLE_FRAC
 150:./math/pprz_algebra_int.h **** };
 151:./math/pprz_algebra_int.h **** 
 152:./math/pprz_algebra_int.h **** 
 153:./math/pprz_algebra_int.h **** /* Rotation matrix. */
 154:./math/pprz_algebra_int.h **** #define INT32_TRIG_FRAC 14
 155:./math/pprz_algebra_int.h **** 
 156:./math/pprz_algebra_int.h **** /**
 157:./math/pprz_algebra_int.h ****  * @brief rotation matrix
 158:./math/pprz_algebra_int.h ****  * @details Units: rad in BFP with #INT32_TRIG_FRAC */
 159:./math/pprz_algebra_int.h **** struct Int32RMat {
 160:./math/pprz_algebra_int.h ****   int32_t m[3 * 3];
 161:./math/pprz_algebra_int.h **** };
 162:./math/pprz_algebra_int.h **** 
 163:./math/pprz_algebra_int.h **** /* 3x3 matrix                                    */
 164:./math/pprz_algebra_int.h **** struct Int32Mat33 {
 165:./math/pprz_algebra_int.h ****   int32_t m[3 * 3];
 166:./math/pprz_algebra_int.h **** };
 167:./math/pprz_algebra_int.h **** 
 168:./math/pprz_algebra_int.h **** /* Rotational speed                              */
 169:./math/pprz_algebra_int.h **** struct Int16Rates {
 170:./math/pprz_algebra_int.h ****   int16_t p;
 171:./math/pprz_algebra_int.h ****   int16_t q;
 172:./math/pprz_algebra_int.h ****   int16_t r;
 173:./math/pprz_algebra_int.h **** };
 174:./math/pprz_algebra_int.h **** 
 175:./math/pprz_algebra_int.h **** /* Rotational speed                              */
 176:./math/pprz_algebra_int.h **** /**
 177:./math/pprz_algebra_int.h ****  * @brief angular rates
 178:./math/pprz_algebra_int.h ****  * @details Units: rad/s in BFP with #INT32_RATE_FRAC */
 179:./math/pprz_algebra_int.h **** struct Int32Rates {
 180:./math/pprz_algebra_int.h ****   int32_t p; ///< in rad/s with #INT32_RATE_FRAC
 181:./math/pprz_algebra_int.h ****   int32_t q; ///< in rad/s with #INT32_RATE_FRAC
 182:./math/pprz_algebra_int.h ****   int32_t r; ///< in rad/s with #INT32_RATE_FRAC
 183:./math/pprz_algebra_int.h **** };
 184:./math/pprz_algebra_int.h **** 
 185:./math/pprz_algebra_int.h **** struct Int64Rates {
 186:./math/pprz_algebra_int.h ****   int64_t p;
 187:./math/pprz_algebra_int.h ****   int64_t q;
 188:./math/pprz_algebra_int.h ****   int64_t r;
 189:./math/pprz_algebra_int.h **** };
 190:./math/pprz_algebra_int.h **** 
 191:./math/pprz_algebra_int.h **** 
 192:./math/pprz_algebra_int.h **** struct Int64Vect2 {
 193:./math/pprz_algebra_int.h ****   int64_t x;
 194:./math/pprz_algebra_int.h ****   int64_t y;
 195:./math/pprz_algebra_int.h **** };
 196:./math/pprz_algebra_int.h **** 
 197:./math/pprz_algebra_int.h **** struct Int64Vect3 {
 198:./math/pprz_algebra_int.h ****   int64_t x;
 199:./math/pprz_algebra_int.h ****   int64_t y;
 200:./math/pprz_algebra_int.h ****   int64_t z;
 201:./math/pprz_algebra_int.h **** };
 202:./math/pprz_algebra_int.h **** 
 203:./math/pprz_algebra_int.h **** 
 204:./math/pprz_algebra_int.h **** // Real (floating point) ->  Binary Fixed Point  (int)
 205:./math/pprz_algebra_int.h **** #define BFP_OF_REAL(_vr, _frac)    ((_vr)*(1<<(_frac)))
 206:./math/pprz_algebra_int.h **** #define FLOAT_OF_BFP(_vbfp, _frac) ((float)(_vbfp)/(1<<(_frac)))
 207:./math/pprz_algebra_int.h **** #define DOUBLE_OF_BFP(_vbfp, _frac) ((double)(_vbfp)/(1<<(_frac)))
 208:./math/pprz_algebra_int.h **** #define RATE_BFP_OF_REAL(_af)   BFP_OF_REAL((_af), INT32_RATE_FRAC)
 209:./math/pprz_algebra_int.h **** #define RATE_FLOAT_OF_BFP(_ai)  FLOAT_OF_BFP((_ai), INT32_RATE_FRAC)
 210:./math/pprz_algebra_int.h **** #define ANGLE_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_ANGLE_FRAC)
 211:./math/pprz_algebra_int.h **** #define ANGLE_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_ANGLE_FRAC)
 212:./math/pprz_algebra_int.h **** #define QUAT1_BFP_OF_REAL(_qf)  BFP_OF_REAL((_qf), INT32_QUAT_FRAC)
 213:./math/pprz_algebra_int.h **** #define QUAT1_FLOAT_OF_BFP(_qi) FLOAT_OF_BFP((_qi), INT32_QUAT_FRAC)
 214:./math/pprz_algebra_int.h **** #define TRIG_BFP_OF_REAL(_tf)   BFP_OF_REAL((_tf), INT32_TRIG_FRAC)
 215:./math/pprz_algebra_int.h **** #define TRIG_FLOAT_OF_BFP(_ti)  FLOAT_OF_BFP((_ti),INT32_TRIG_FRAC)
 216:./math/pprz_algebra_int.h **** #define POS_BFP_OF_REAL(_af)    BFP_OF_REAL((_af), INT32_POS_FRAC)
 217:./math/pprz_algebra_int.h **** #define POS_FLOAT_OF_BFP(_ai)   FLOAT_OF_BFP((_ai), INT32_POS_FRAC)
 218:./math/pprz_algebra_int.h **** #define SPEED_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_SPEED_FRAC)
 219:./math/pprz_algebra_int.h **** #define SPEED_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_SPEED_FRAC)
 220:./math/pprz_algebra_int.h **** #define ACCEL_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_ACCEL_FRAC)
 221:./math/pprz_algebra_int.h **** #define ACCEL_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_ACCEL_FRAC)
 222:./math/pprz_algebra_int.h **** #define MAG_BFP_OF_REAL(_af)    BFP_OF_REAL((_af), INT32_MAG_FRAC)
 223:./math/pprz_algebra_int.h **** #define MAG_FLOAT_OF_BFP(_ai)   FLOAT_OF_BFP((_ai), INT32_MAG_FRAC)
 224:./math/pprz_algebra_int.h **** 
 225:./math/pprz_algebra_int.h **** #define INT_MULT_RSHIFT(_a, _b, _r) (((_a)*(_b))>>(_r))
 226:./math/pprz_algebra_int.h **** 
 227:./math/pprz_algebra_int.h **** 
 228:./math/pprz_algebra_int.h **** extern uint32_t int32_sqrt(uint32_t in);
 229:./math/pprz_algebra_int.h **** #define INT32_SQRT(_out,_in) { _out = int32_sqrt(_in); }
 230:./math/pprz_algebra_int.h **** 
 231:./math/pprz_algebra_int.h **** 
 232:./math/pprz_algebra_int.h **** /*
 233:./math/pprz_algebra_int.h ****  * Dimension 2 Vectors
 234:./math/pprz_algebra_int.h ****  */
 235:./math/pprz_algebra_int.h **** 
 236:./math/pprz_algebra_int.h **** #define INT_VECT2_ZERO(_v) VECT2_ASSIGN(_v, 0, 0)
 237:./math/pprz_algebra_int.h **** 
 238:./math/pprz_algebra_int.h **** /* macros also usable if _v is not a Int32Vect2, but a different struct with x,y members */
 239:./math/pprz_algebra_int.h **** #define INT32_VECT2_NORM(_v) int32_sqrt(VECT2_NORM2(_v))
 240:./math/pprz_algebra_int.h **** 
 241:./math/pprz_algebra_int.h **** /** return squared norm of 2D vector */
 242:./math/pprz_algebra_int.h **** static inline uint32_t int32_vect2_norm2(struct Int32Vect2 *v)
 243:./math/pprz_algebra_int.h **** {
 244:./math/pprz_algebra_int.h ****   return v->x * v->x + v->y * v->y;
 245:./math/pprz_algebra_int.h **** }
 246:./math/pprz_algebra_int.h **** 
 247:./math/pprz_algebra_int.h **** /** return norm of 2D vector */
 248:./math/pprz_algebra_int.h **** static inline uint32_t int32_vect2_norm(struct Int32Vect2 *v)
 249:./math/pprz_algebra_int.h **** {
 250:./math/pprz_algebra_int.h ****   return int32_sqrt(int32_vect2_norm2(v));
 251:./math/pprz_algebra_int.h **** }
 252:./math/pprz_algebra_int.h **** 
 253:./math/pprz_algebra_int.h **** /** normalize 2D vector inplace */
 254:./math/pprz_algebra_int.h **** static inline void int32_vect2_normalize(struct Int32Vect2 *v, uint8_t frac)
 255:./math/pprz_algebra_int.h **** {
 256:./math/pprz_algebra_int.h ****   const uint32_t n = int32_vect2_norm(v);
 257:./math/pprz_algebra_int.h ****   if (n > 0) {
 258:./math/pprz_algebra_int.h ****     const int32_t f = BFP_OF_REAL((1.), frac);
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 261:./math/pprz_algebra_int.h ****   }
 262:./math/pprz_algebra_int.h **** }
 263:./math/pprz_algebra_int.h **** 
 264:./math/pprz_algebra_int.h **** #define INT32_VECT2_NORMALIZE(_v,_frac) int32_vect2_normalize(&(_v), _frac)
 265:./math/pprz_algebra_int.h **** 
 266:./math/pprz_algebra_int.h **** 
 267:./math/pprz_algebra_int.h **** #define INT32_VECT2_RSHIFT(_o, _i, _r) { \
 268:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x >> (_r)); \
 269:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y >> (_r)); \
 270:./math/pprz_algebra_int.h ****   }
 271:./math/pprz_algebra_int.h **** 
 272:./math/pprz_algebra_int.h **** #define INT32_VECT2_LSHIFT(_o, _i, _l) { \
 273:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x << (_l)); \
 274:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y << (_l)); \
 275:./math/pprz_algebra_int.h ****   }
 276:./math/pprz_algebra_int.h **** 
 277:./math/pprz_algebra_int.h **** #define INT32_VECT2_SCALE_2(_a, _b, _num, _den) {   \
 278:./math/pprz_algebra_int.h ****     (_a).x = ((_b).x * (_num)) / (_den);        \
 279:./math/pprz_algebra_int.h ****     (_a).y = ((_b).y * (_num)) / (_den);        \
 280:./math/pprz_algebra_int.h ****   }
 281:./math/pprz_algebra_int.h **** 
 282:./math/pprz_algebra_int.h **** /*
 283:./math/pprz_algebra_int.h ****  * Dimension 3 Vectors
 284:./math/pprz_algebra_int.h ****  */
 285:./math/pprz_algebra_int.h **** 
 286:./math/pprz_algebra_int.h **** #define INT_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0, 0, 0)
 287:./math/pprz_algebra_int.h **** #define INT32_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0, 0, 0)
 288:./math/pprz_algebra_int.h **** 
 289:./math/pprz_algebra_int.h **** #define INT32_VECT3_SCALE_2(_a, _b, _num, _den) {   \
 290:./math/pprz_algebra_int.h ****     (_a).x = ((_b).x * (_num)) / (_den);        \
 291:./math/pprz_algebra_int.h ****     (_a).y = ((_b).y * (_num)) / (_den);        \
 292:./math/pprz_algebra_int.h ****     (_a).z = ((_b).z * (_num)) / (_den);        \
 293:./math/pprz_algebra_int.h ****   }
 294:./math/pprz_algebra_int.h **** 
 295:./math/pprz_algebra_int.h **** #define INT32_VECT3_NORM(_v) int32_sqrt(VECT3_NORM2(_v))
 296:./math/pprz_algebra_int.h **** 
 297:./math/pprz_algebra_int.h **** #define INT32_VECT3_RSHIFT(_o, _i, _r) { \
 298:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x >> (_r));       \
 299:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y >> (_r));       \
 300:./math/pprz_algebra_int.h ****     (_o).z = ((_i).z >> (_r));       \
 301:./math/pprz_algebra_int.h ****   }
 302:./math/pprz_algebra_int.h **** 
 303:./math/pprz_algebra_int.h **** #define INT32_VECT3_LSHIFT(_o, _i, _l) { \
 304:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x << (_l));       \
 305:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y << (_l));       \
 306:./math/pprz_algebra_int.h ****     (_o).z = ((_i).z << (_l));       \
 307:./math/pprz_algebra_int.h ****   }
 308:./math/pprz_algebra_int.h **** 
 309:./math/pprz_algebra_int.h **** 
 310:./math/pprz_algebra_int.h **** 
 311:./math/pprz_algebra_int.h **** /*
 312:./math/pprz_algebra_int.h ****  * 3x3 Matrices
 313:./math/pprz_algebra_int.h ****  */
 314:./math/pprz_algebra_int.h **** #define INT32_MAT33_ZERO(_m) {                      \
 315:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 0) = 0;                     \
 316:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 1) = 0;                     \
 317:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 2) = 0;                     \
 318:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 0) = 0;                     \
 319:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 1) = 0;                     \
 320:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 2) = 0;                     \
 321:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 0) = 0;                     \
 322:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 1) = 0;                     \
 323:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 2) = 0;                     \
 324:./math/pprz_algebra_int.h ****   }
 325:./math/pprz_algebra_int.h **** 
 326:./math/pprz_algebra_int.h **** #define INT32_MAT33_DIAG(_m, _d00, _d11, _d22) {    \
 327:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 0) = (_d00);                \
 328:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 1) = 0;                     \
 329:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 2) = 0;                     \
 330:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 0) = 0;                     \
 331:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 1) = (_d11);                \
 332:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 2) = 0;                     \
 333:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 0) = 0;                     \
 334:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 1) = 0;                     \
 335:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 2) = (_d22);                \
 336:./math/pprz_algebra_int.h ****   }
 337:./math/pprz_algebra_int.h **** 
 338:./math/pprz_algebra_int.h **** 
 339:./math/pprz_algebra_int.h **** 
 340:./math/pprz_algebra_int.h **** /*
 341:./math/pprz_algebra_int.h ****  * Rotation matrices
 342:./math/pprz_algebra_int.h ****  */
 343:./math/pprz_algebra_int.h **** 
 344:./math/pprz_algebra_int.h **** /** initialises a rotation matrix to identity */
 345:./math/pprz_algebra_int.h **** static inline void int32_rmat_identity(struct Int32RMat *rm)
 346:./math/pprz_algebra_int.h **** {
 347:./math/pprz_algebra_int.h ****   INT32_MAT33_DIAG(*rm, TRIG_BFP_OF_REAL(1.), TRIG_BFP_OF_REAL(1.), TRIG_BFP_OF_REAL(1.));
 348:./math/pprz_algebra_int.h **** }
 349:./math/pprz_algebra_int.h **** 
 350:./math/pprz_algebra_int.h **** /** Composition (multiplication) of two rotation matrices.
 351:./math/pprz_algebra_int.h ****  * m_a2c = m_a2b comp m_b2c , aka  m_a2c = m_b2c * m_a2b
 352:./math/pprz_algebra_int.h ****  */
 353:./math/pprz_algebra_int.h **** extern void int32_rmat_comp(struct Int32RMat *m_a2c, struct Int32RMat *m_a2b,
 354:./math/pprz_algebra_int.h ****                             struct Int32RMat *m_b2c);
 355:./math/pprz_algebra_int.h **** 
 356:./math/pprz_algebra_int.h **** /** Composition (multiplication) of two rotation matrices.
 357:./math/pprz_algebra_int.h ****  * m_a2b = m_a2c comp_inv m_b2c , aka  m_a2b = inv(_m_b2c) * m_a2c
 358:./math/pprz_algebra_int.h ****  */
 359:./math/pprz_algebra_int.h **** extern void int32_rmat_comp_inv(struct Int32RMat *m_a2b, struct Int32RMat *m_a2c,
 360:./math/pprz_algebra_int.h ****                                 struct Int32RMat *m_b2c);
 361:./math/pprz_algebra_int.h **** 
 362:./math/pprz_algebra_int.h **** /** rotate 3D vector by rotation matrix.
 363:./math/pprz_algebra_int.h ****  * vb = m_a2b * va
 364:./math/pprz_algebra_int.h ****  */
 365:./math/pprz_algebra_int.h **** extern void int32_rmat_vmult(struct Int32Vect3 *vb, struct Int32RMat *m_a2b,
 366:./math/pprz_algebra_int.h ****                              struct Int32Vect3 *va);
 367:./math/pprz_algebra_int.h **** 
 368:./math/pprz_algebra_int.h **** /** rotate 3D vector by transposed rotation matrix.
 369:./math/pprz_algebra_int.h ****  * vb = m_b2a^T * va
 370:./math/pprz_algebra_int.h ****  */
 371:./math/pprz_algebra_int.h **** extern void int32_rmat_transp_vmult(struct Int32Vect3 *vb, struct Int32RMat *m_b2a,
 372:./math/pprz_algebra_int.h ****                                     struct Int32Vect3 *va);
 373:./math/pprz_algebra_int.h **** 
 374:./math/pprz_algebra_int.h **** /** rotate anglular rates by rotation matrix.
 375:./math/pprz_algebra_int.h ****  * rb = m_a2b * ra
 376:./math/pprz_algebra_int.h ****  */
 377:./math/pprz_algebra_int.h **** extern void int32_rmat_ratemult(struct Int32Rates *rb, struct Int32RMat *m_a2b,
 378:./math/pprz_algebra_int.h ****                                 struct Int32Rates *ra);
 379:./math/pprz_algebra_int.h **** 
 380:./math/pprz_algebra_int.h **** /** rotate anglular rates by transposed rotation matrix.
 381:./math/pprz_algebra_int.h ****  * rb = m_b2a^T * ra
 382:./math/pprz_algebra_int.h ****  */
 383:./math/pprz_algebra_int.h **** extern void int32_rmat_transp_ratemult(struct Int32Rates *rb, struct Int32RMat *m_b2a,
 384:./math/pprz_algebra_int.h ****                                        struct Int32Rates *ra);
 385:./math/pprz_algebra_int.h **** 
 386:./math/pprz_algebra_int.h **** /// Convert unit quaternion to rotation matrix.
 387:./math/pprz_algebra_int.h **** extern void int32_rmat_of_quat(struct Int32RMat *rm, struct Int32Quat *q);
 388:./math/pprz_algebra_int.h **** 
 389:./math/pprz_algebra_int.h **** /** Rotation matrix from 321 Euler angles (int).
 390:./math/pprz_algebra_int.h ****  * The Euler angles are interpreted as zy'x'' (intrinsic) rotation.
 391:./math/pprz_algebra_int.h ****  * First rotate around z with psi, then around the new y' with theta,
 392:./math/pprz_algebra_int.h ****  * then around new x'' with phi.
 393:./math/pprz_algebra_int.h ****  * This is the same as a xyz (extrinsic) rotation,
 394:./math/pprz_algebra_int.h ****  * rotating around the fixed x, then y then z axis.
 395:./math/pprz_algebra_int.h ****  * - psi range: -pi < psi <= pi
 396:./math/pprz_algebra_int.h ****  * - theta range: -pi/2 <= theta <= pi/2
 397:./math/pprz_algebra_int.h ****  * - phi range: -pi < phi <= pi
 398:./math/pprz_algebra_int.h ****  * @param[out] rm pointer to rotation matrix
 399:./math/pprz_algebra_int.h ****  * @param[in]  e pointer to Euler angles
 400:./math/pprz_algebra_int.h ****  */
 401:./math/pprz_algebra_int.h **** extern void int32_rmat_of_eulers_321(struct Int32RMat *rm, struct Int32Eulers *e);
 402:./math/pprz_algebra_int.h **** 
 403:./math/pprz_algebra_int.h **** /// Rotation matrix from 312 Euler angles.
 404:./math/pprz_algebra_int.h **** extern void int32_rmat_of_eulers_312(struct Int32RMat *rm, struct Int32Eulers *e);
 405:./math/pprz_algebra_int.h **** 
 406:./math/pprz_algebra_int.h **** /// Rotation matrix from Euler angles.
 407:./math/pprz_algebra_int.h **** #define int32_rmat_of_eulers int32_rmat_of_eulers_321
 408:./math/pprz_algebra_int.h **** 
 409:./math/pprz_algebra_int.h **** /* defines for backwards compatibility */
 410:./math/pprz_algebra_int.h **** #define INT32_RMAT_COMP(_m_a2c, _m_a2b, _m_b2c) int32_rmat_comp(&(_m_a2c), &(_m_a2b), &(_m_b2c))
 411:./math/pprz_algebra_int.h **** #define INT32_RMAT_COMP_INV(_m_a2b, _m_a2c, _m_b2c) int32_rmat_comp_inv(&(_m_a2b), &(_m_a2c), &(_m_
 412:./math/pprz_algebra_int.h **** #define INT32_RMAT_VMULT(_vb, _m_a2b, _va) int32_rmat_vmult(&(_vb), &(_m_a2b), &(_va))
 413:./math/pprz_algebra_int.h **** #define INT32_RMAT_TRANSP_VMULT(_vb, _m_b2a, _va) int32_rmat_transp_vmult(&(_vb), &(_m_b2a), &(_va)
 414:./math/pprz_algebra_int.h **** #define INT32_RMAT_RATEMULT(_rb, _m_a2b, _ra) int32_rmat_ratemult(&(_rb), &(_m_a2b), &(_ra))
 415:./math/pprz_algebra_int.h **** #define INT32_RMAT_TRANSP_RATEMULT(_rb, _m_b2a, _ra) int32_rmat_ratemult(&(_rb), &(_m_b2a), &(_ra))
 416:./math/pprz_algebra_int.h **** 
 417:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_QUAT(_rm, _q) int32_rmat_of_quat(&(_rm), &(_q))
 418:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS(_rm, _e) int32_rmat_of_eulers_321(&(_rm), &(_e))
 419:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS_321(_rm, _e) int32_rmat_of_eulers_321(&(_rm), &(_e))
 420:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS_312(_rm, _e) int32_rmat_of_eulers_312(&(_rm), &(_e))
 421:./math/pprz_algebra_int.h **** 
 422:./math/pprz_algebra_int.h **** 
 423:./math/pprz_algebra_int.h **** /*
 424:./math/pprz_algebra_int.h ****  *
 425:./math/pprz_algebra_int.h ****  * Quaternions
 426:./math/pprz_algebra_int.h ****  *
 427:./math/pprz_algebra_int.h ****  */
 428:./math/pprz_algebra_int.h **** 
 429:./math/pprz_algebra_int.h **** /** initialises a quaternion to identity */
 430:./math/pprz_algebra_int.h **** static inline void int32_quat_identity(struct Int32Quat *q)
 431:./math/pprz_algebra_int.h **** {
 432:./math/pprz_algebra_int.h ****   q->qi = QUAT1_BFP_OF_REAL(1);
 433:./math/pprz_algebra_int.h ****   q->qx = 0;
 434:./math/pprz_algebra_int.h ****   q->qy = 0;
 435:./math/pprz_algebra_int.h ****   q->qz = 0;
 436:./math/pprz_algebra_int.h **** }
 437:./math/pprz_algebra_int.h **** 
 438:./math/pprz_algebra_int.h **** /** Norm of a quaternion.
 439:./math/pprz_algebra_int.h ****  */
 440:./math/pprz_algebra_int.h **** static inline uint32_t int32_quat_norm(struct Int32Quat *q)
 441:./math/pprz_algebra_int.h **** {
 442:./math/pprz_algebra_int.h ****   uint32_t n2 = q->qi * q->qi + q->qx * q->qx + q->qy * q->qy + q->qz * q->qz;
 443:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 444:./math/pprz_algebra_int.h **** }
 445:./math/pprz_algebra_int.h **** 
 446:./math/pprz_algebra_int.h **** static inline void int32_quat_wrap_shortest(struct Int32Quat *q)
 447:./math/pprz_algebra_int.h **** {
 448:./math/pprz_algebra_int.h ****   if (q->qi < 0) {
 449:./math/pprz_algebra_int.h ****     QUAT_EXPLEMENTARY(*q, *q);
 450:./math/pprz_algebra_int.h ****   }
 451:./math/pprz_algebra_int.h **** }
 452:./math/pprz_algebra_int.h **** 
 453:./math/pprz_algebra_int.h **** /** normalize a quaternion inplace */
 454:./math/pprz_algebra_int.h **** static inline void int32_quat_normalize(struct Int32Quat *q)
 455:./math/pprz_algebra_int.h **** {
 112              		.loc 2 455 0
 113              		.cfi_startproc
 114              		@ args = 0, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              	.LVL4:
 117              	.LBB17:
 118              	.LBB18:
 442:./math/pprz_algebra_int.h ****   uint32_t n2 = q->qi * q->qi + q->qx * q->qx + q->qy * q->qy + q->qz * q->qz;
 119              		.loc 2 442 0
 120 0000 4168     		ldr	r1, [r0, #4]
 121 0002 0268     		ldr	r2, [r0]
 122 0004 8368     		ldr	r3, [r0, #8]
 123 0006 4943     		muls	r1, r1, r1
 124              	.LBE18:
 125              	.LBE17:
 126              		.loc 2 455 0
 127 0008 10B5     		push	{r4, lr}
 128              		.cfi_def_cfa_offset 8
 129              		.cfi_offset 4, -8
 130              		.cfi_offset 14, -4
 131              	.LBB21:
 132              	.LBB19:
 442:./math/pprz_algebra_int.h ****   uint32_t n2 = q->qi * q->qi + q->qx * q->qx + q->qy * q->qy + q->qz * q->qz;
 133              		.loc 2 442 0
 134 000a 02FB0212 		mla	r2, r2, r2, r1
 135              	.LBE19:
 136              	.LBE21:
 137              		.loc 2 455 0
 138 000e 0446     		mov	r4, r0
 139              	.LBB22:
 140              	.LBB20:
 442:./math/pprz_algebra_int.h ****   uint32_t n2 = q->qi * q->qi + q->qx * q->qx + q->qy * q->qy + q->qz * q->qz;
 141              		.loc 2 442 0
 142 0010 C068     		ldr	r0, [r0, #12]
 143              	.LVL5:
 144 0012 03FB0323 		mla	r3, r3, r3, r2
 443:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 145              		.loc 2 443 0
 146 0016 00FB0030 		mla	r0, r0, r0, r3
 147 001a FFF7FEFF 		bl	int32_sqrt
 148              	.LVL6:
 149              	.LBE20:
 150              	.LBE22:
 456:./math/pprz_algebra_int.h ****   int32_t n = int32_quat_norm(q);
 457:./math/pprz_algebra_int.h ****   if (n > 0) {
 151              		.loc 2 457 0
 152 001e 0028     		cmp	r0, #0
 153 0020 13DD     		ble	.L8
 458:./math/pprz_algebra_int.h ****     q->qi = q->qi * QUAT1_BFP_OF_REAL(1) / n;
 154              		.loc 2 458 0
 155 0022 2368     		ldr	r3, [r4]
 156 0024 DB03     		lsls	r3, r3, #15
 157 0026 93FBF0F3 		sdiv	r3, r3, r0
 158 002a 2360     		str	r3, [r4]
 459:./math/pprz_algebra_int.h ****     q->qx = q->qx * QUAT1_BFP_OF_REAL(1) / n;
 159              		.loc 2 459 0
 160 002c 6368     		ldr	r3, [r4, #4]
 161 002e DB03     		lsls	r3, r3, #15
 162 0030 93FBF0F3 		sdiv	r3, r3, r0
 163 0034 6360     		str	r3, [r4, #4]
 460:./math/pprz_algebra_int.h ****     q->qy = q->qy * QUAT1_BFP_OF_REAL(1) / n;
 164              		.loc 2 460 0
 165 0036 A368     		ldr	r3, [r4, #8]
 166 0038 DB03     		lsls	r3, r3, #15
 167 003a 93FBF0F3 		sdiv	r3, r3, r0
 168 003e A360     		str	r3, [r4, #8]
 461:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 169              		.loc 2 461 0
 170 0040 E368     		ldr	r3, [r4, #12]
 171 0042 DB03     		lsls	r3, r3, #15
 172 0044 93FBF0F0 		sdiv	r0, r3, r0
 173              	.LVL7:
 174 0048 E060     		str	r0, [r4, #12]
 175              	.L8:
 176 004a 10BD     		pop	{r4, pc}
 177              		.cfi_endproc
 178              	.LFE8:
 180              		.global	__aeabi_f2d
 181              		.global	__aeabi_dsub
 182              		.global	__aeabi_dcmplt
 183              		.global	__aeabi_dcmpgt
 184              		.global	__aeabi_dmul
 185              		.global	__aeabi_dadd
 186              		.global	__aeabi_d2f
 187              		.section	.text.ahrs_icq_align,"ax",%progbits
 188              		.align	1
 189              		.global	ahrs_icq_align
 190              		.thumb
 191              		.thumb_func
 193              	ahrs_icq_align:
 194              	.LFB90:
 195              		.file 3 "subsystems/ahrs/ahrs_int_cmpl_quat.c"
   1:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /*
   2:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Copyright (C) 2008-2013 The Paparazzi Team
   3:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
   4:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * This file is part of paparazzi.
   5:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
   6:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * it under the terms of the GNU General Public License as published by
   8:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * any later version.
  10:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  11:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * GNU General Public License for more details.
  15:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  16:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * You should have received a copy of the GNU General Public License
  17:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Boston, MA 02111-1307, USA.
  20:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  21:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  22:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /**
  23:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * @file subsystems/ahrs/ahrs_int_cmpl_quat.c
  24:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  25:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Quaternion complementary filter (fixed-point).
  26:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  27:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Estimate the attitude, heading and gyro bias.
  28:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  29:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  30:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  31:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "generated/airframe.h"
  32:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  33:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/ahrs/ahrs_int_cmpl_quat.h"
  34:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/ahrs/ahrs_int_utils.h"
  35:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  36:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_GPS
  37:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/gps.h"
  38:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  39:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "math/pprz_trig_int.h"
  40:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "math/pprz_algebra_int.h"
  41:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  42:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_PROPAGATE_LOW_PASS_RATES
  43:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_MSG("LOW PASS FILTER ON GYRO RATES")
  44:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  45:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  46:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_MAG_UPDATE_YAW_ONLY
  47:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #error "The define AHRS_MAG_UPDATE_YAW_ONLY doesn't exist anymore, please remove it. This is the de
  48:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  49:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  50:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER && AHRS_USE_GPS_HEADING
  51:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #warning "Using both magnetometer and GPS course to update heading. Probably better to configure US
  52:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  53:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  54:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if !USE_MAGNETOMETER && !AHRS_USE_GPS_HEADING
  55:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #warning "Please use either USE_MAGNETOMETER or AHRS_USE_GPS_HEADING."
  56:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  57:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  58:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_USE_GPS_HEADING && !USE_GPS
  59:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #error "AHRS_USE_GPS_HEADING needs USE_GPS to be TRUE"
  60:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  61:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  62:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /*
  63:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * default gains for correcting attitude and bias from accel/mag
  64:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  65:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_ACCEL_OMEGA
  66:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_ACCEL_OMEGA 0.063
  67:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  68:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_ACCEL_ZETA
  69:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_ACCEL_ZETA 0.9
  70:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  71:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_ACCEL_OMEGA)
  72:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_ACCEL_ZETA)
  73:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  74:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  75:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_MAG_OMEGA
  76:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_MAG_OMEGA 0.04
  77:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  78:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_MAG_ZETA
  79:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_MAG_ZETA 0.9
  80:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  81:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER
  82:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_MAG_OMEGA)
  83:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_MAG_ZETA)
  84:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  85:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  86:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** by default use the gravity heuristic to reduce gain */
  87:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_GRAVITY_HEURISTIC_FACTOR
  88:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_GRAVITY_HEURISTIC_FACTOR 30
  89:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  90:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  91:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** don't update gyro bias if heading deviation is above this threshold in degrees */
  92:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_BIAS_UPDATE_HEADING_THRESHOLD
  93:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_BIAS_UPDATE_HEADING_THRESHOLD 5.0
  94:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  95:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  96:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** Minimum speed in m/s for heading update via GPS.
  97:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Don't update heading from GPS course if GPS ground speed is below is this threshold
  98:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  99:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_HEADING_UPDATE_GPS_MIN_SPEED
 100:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_HEADING_UPDATE_GPS_MIN_SPEED 5.0
 101:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 102:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 103:subsystems/ahrs/ahrs_int_cmpl_quat.c **** struct AhrsIntCmplQuat ahrs_icq;
 104:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 105:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void UNUSED ahrs_icq_update_mag_full(struct Int32Vect3 *mag, float dt);
 106:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_2d(struct Int32Vect3 *mag, float dt);
 107:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 108:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_init(void)
 109:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 110:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_UNINIT;
 112:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 113:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 114:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.ltp_vel_norm_valid = FALSE;
 115:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 116:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 117:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* init ltp_to_imu quaternion as zero/identity rotation */
 118:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_identity(&ahrs_icq.ltp_to_imu_quat);
 119:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 120:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.imu_rate);
 121:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 122:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.gyro_bias);
 123:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.high_rez_bias);
 125:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 126:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* set default filter cut-off frequency and damping */
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_omega = AHRS_ACCEL_OMEGA;
 128:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_zeta = AHRS_ACCEL_ZETA;
 129:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_accel_gains();
 130:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_omega = AHRS_MAG_OMEGA;
 131:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_zeta = AHRS_MAG_ZETA;
 132:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_mag_gains();
 133:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 134:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* set default gravity heuristic */
 135:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.gravity_heuristic_factor = AHRS_GRAVITY_HEURISTIC_FACTOR;
 136:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 137:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_GRAVITY_UPDATE_COORDINATED_TURN
 138:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.correct_gravity = TRUE;
 139:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 140:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.correct_gravity = FALSE;
 141:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 142:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 143:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ASSIGN(ahrs_icq.mag_h, MAG_BFP_OF_REAL(AHRS_H_X),
 144:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                MAG_BFP_OF_REAL(AHRS_H_Y), MAG_BFP_OF_REAL(AHRS_H_Z));
 145:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 146:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 147:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 148:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 149:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 150:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 151:subsystems/ahrs/ahrs_int_cmpl_quat.c **** bool_t ahrs_icq_align(struct Int32Rates *lp_gyro, struct Int32Vect3 *lp_accel,
 152:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                       struct Int32Vect3 *lp_mag)
 153:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 196              		.loc 3 153 0
 197              		.cfi_startproc
 198              		@ args = 0, pretend = 0, frame = 112
 199              		@ frame_needed = 0, uses_anonymous_args = 0
 200              	.LVL8:
 201 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 202              		.cfi_def_cfa_offset 24
 203              		.cfi_offset 4, -24
 204              		.cfi_offset 5, -20
 205              		.cfi_offset 6, -16
 206              		.cfi_offset 7, -12
 207              		.cfi_offset 8, -8
 208              		.cfi_offset 14, -4
 209              	.LBB35:
 210              	.LBB36:
 211              	.LBB37:
 212              	.LBB38:
 213              	.LBB39:
 214              	.LBB40:
 215              		.file 4 "./subsystems/ahrs/ahrs_float_utils.h"
   1:./subsystems/ahrs/ahrs_float_utils.h **** /*
   2:./subsystems/ahrs/ahrs_float_utils.h ****  * Copyright (C) 2009 Felix Ruess <felix.ruess@gmail.com>
   3:./subsystems/ahrs/ahrs_float_utils.h ****  * Copyright (C) 2009 Antoine Drouin <poinix@gmail.com>
   4:./subsystems/ahrs/ahrs_float_utils.h ****  *
   5:./subsystems/ahrs/ahrs_float_utils.h ****  * This file is part of paparazzi.
   6:./subsystems/ahrs/ahrs_float_utils.h ****  *
   7:./subsystems/ahrs/ahrs_float_utils.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./subsystems/ahrs/ahrs_float_utils.h ****  * it under the terms of the GNU General Public License as published by
   9:./subsystems/ahrs/ahrs_float_utils.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./subsystems/ahrs/ahrs_float_utils.h ****  * any later version.
  11:./subsystems/ahrs/ahrs_float_utils.h ****  *
  12:./subsystems/ahrs/ahrs_float_utils.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./subsystems/ahrs/ahrs_float_utils.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./subsystems/ahrs/ahrs_float_utils.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./subsystems/ahrs/ahrs_float_utils.h ****  * GNU General Public License for more details.
  16:./subsystems/ahrs/ahrs_float_utils.h ****  *
  17:./subsystems/ahrs/ahrs_float_utils.h ****  * You should have received a copy of the GNU General Public License
  18:./subsystems/ahrs/ahrs_float_utils.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./subsystems/ahrs/ahrs_float_utils.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./subsystems/ahrs/ahrs_float_utils.h ****  * Boston, MA 02111-1307, USA.
  21:./subsystems/ahrs/ahrs_float_utils.h ****  */
  22:./subsystems/ahrs/ahrs_float_utils.h **** 
  23:./subsystems/ahrs/ahrs_float_utils.h **** /**
  24:./subsystems/ahrs/ahrs_float_utils.h ****  * @file subsystems/ahrs/ahrs_float_utils.h
  25:./subsystems/ahrs/ahrs_float_utils.h ****  *
  26:./subsystems/ahrs/ahrs_float_utils.h ****  * Utility functions for floating point AHRS implementations.
  27:./subsystems/ahrs/ahrs_float_utils.h ****  *
  28:./subsystems/ahrs/ahrs_float_utils.h ****  */
  29:./subsystems/ahrs/ahrs_float_utils.h **** 
  30:./subsystems/ahrs/ahrs_float_utils.h **** #ifndef AHRS_FLOAT_UTILS_H
  31:./subsystems/ahrs/ahrs_float_utils.h **** #define AHRS_FLOAT_UTILS_H
  32:./subsystems/ahrs/ahrs_float_utils.h **** 
  33:./subsystems/ahrs/ahrs_float_utils.h **** #include "math/pprz_algebra_float.h"
  34:./subsystems/ahrs/ahrs_float_utils.h **** #include "subsystems/ahrs/ahrs_magnetic_field_model.h"
  35:./subsystems/ahrs/ahrs_float_utils.h **** 
  36:./subsystems/ahrs/ahrs_float_utils.h **** #include "std.h" // for ABS
  37:./subsystems/ahrs/ahrs_float_utils.h **** 
  38:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_euler_from_accel_mag(struct FloatEulers *e, struct Int32Vect3 *ac
  39:./subsystems/ahrs/ahrs_float_utils.h ****     struct Int32Vect3 *mag)
  40:./subsystems/ahrs/ahrs_float_utils.h **** {
  41:./subsystems/ahrs/ahrs_float_utils.h ****   /* get phi and theta from accelerometer */
  42:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 accelf;
  43:./subsystems/ahrs/ahrs_float_utils.h ****   ACCELS_FLOAT_OF_BFP(accelf, *accel);
  44:./subsystems/ahrs/ahrs_float_utils.h ****   const float phi   = atan2f(-accelf.y, -accelf.z);
  45:./subsystems/ahrs/ahrs_float_utils.h ****   const float cphi = cosf(phi);
  46:./subsystems/ahrs/ahrs_float_utils.h ****   const float theta = atan2f(cphi * accelf.x, -accelf.z);
  47:./subsystems/ahrs/ahrs_float_utils.h **** 
  48:./subsystems/ahrs/ahrs_float_utils.h ****   /* get psi from magnetometer */
  49:./subsystems/ahrs/ahrs_float_utils.h ****   /* project mag on local tangeant plane */
  50:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 magf;
  51:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(magf, *mag);
  52:./subsystems/ahrs/ahrs_float_utils.h ****   const float sphi   = sinf(phi);
  53:./subsystems/ahrs/ahrs_float_utils.h ****   const float ctheta = cosf(theta);
  54:./subsystems/ahrs/ahrs_float_utils.h ****   const float stheta = sinf(theta);
  55:./subsystems/ahrs/ahrs_float_utils.h ****   const float mn = ctheta * magf.x + sphi * stheta * magf.y + cphi * stheta * magf.z;
  56:./subsystems/ahrs/ahrs_float_utils.h ****   const float me =     0. * magf.x + cphi       * magf.y - sphi       * magf.z;
  57:./subsystems/ahrs/ahrs_float_utils.h ****   float psi = -atan2f(me, mn) + atan2(AHRS_H_Y, AHRS_H_X);
  58:./subsystems/ahrs/ahrs_float_utils.h ****   if (psi > M_PI) { psi -= 2.*M_PI; } if (psi < -M_PI) { psi += 2.*M_PI; }
  59:./subsystems/ahrs/ahrs_float_utils.h ****   EULERS_ASSIGN(*e, phi, theta, psi);
  60:./subsystems/ahrs/ahrs_float_utils.h **** 
  61:./subsystems/ahrs/ahrs_float_utils.h **** }
  62:./subsystems/ahrs/ahrs_float_utils.h **** 
  63:./subsystems/ahrs/ahrs_float_utils.h **** /** Compute a quaternion representing roll and pitch from an accelerometer measurement. */
  64:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_quat_from_accel(struct FloatQuat *q, struct Int32Vect3 *accel)
  65:./subsystems/ahrs/ahrs_float_utils.h **** {
  66:./subsystems/ahrs/ahrs_float_utils.h ****   /* normalized accel measurement in floating point */
  67:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 acc_normalized;
  68:./subsystems/ahrs/ahrs_float_utils.h ****   ACCELS_FLOAT_OF_BFP(acc_normalized, *accel);
 216              		.loc 4 68 0
 217 0004 91ED017A 		flds	s14, [r1, #4]	@ int
 218 0008 DFEDAB7A 		flds	s15, .L32+16
 219 000c D1ED006A 		flds	s13, [r1]	@ int
 220              	.LBE40:
 221              	.LBE39:
 222              	.LBE38:
 223              	.LBE37:
 224              	.LBE36:
 225              	.LBE35:
 226              		.loc 3 153 0
 227 0010 2DED048B 		fstmfdd	sp!, {d8, d9}
 228              		.cfi_def_cfa_offset 40
 229              		.cfi_offset 80, -40
 230              		.cfi_offset 82, -32
 231              	.LBB83:
 232              	.LBB69:
 233              	.LBB66:
 234              	.LBB63:
 235              	.LBB60:
 236              	.LBB57:
 237              		.loc 4 68 0
 238 0014 B8EEC79A 		fsitos	s18, s14
 239 0018 91ED028A 		flds	s16, [r1, #8]	@ int
 240 001c F8EEE68A 		fsitos	s17, s13
 241 0020 29EE279A 		fmuls	s18, s18, s15
 242 0024 B8EEC88A 		fsitos	s16, s16
 243 0028 68EEA78A 		fmuls	s17, s17, s15
 244 002c 28EE278A 		fmuls	s16, s16, s15
 245              	.LBB41:
 246              	.LBB42:
 247              	.LBB43:
 248              	.LBB44:
 249              	.LBB45:
 250              	.LBB46:
 153:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y + v->z * v->z;
 251              		.loc 1 153 0
 252 0030 69EE097A 		fmuls	s15, s18, s18
 253              	.LBE46:
 254              	.LBE45:
 255              	.LBE44:
 256              	.LBE43:
 257              	.LBE42:
 258              	.LBE41:
 259              	.LBE57:
 260              	.LBE60:
 261              	.LBE63:
 262              	.LBE66:
 263              	.LBE69:
 264              	.LBE83:
 265              		.loc 3 153 0
 266 0034 9CB0     		sub	sp, sp, #112
 267              		.cfi_def_cfa_offset 152
 268              	.LBB84:
 269              	.LBB70:
 270              	.LBB67:
 271              	.LBB64:
 272              	.LBB61:
 273              	.LBB58:
 274              	.LBB55:
 275              	.LBB53:
 276              	.LBB51:
 277              	.LBB49:
 278              	.LBB48:
 279              	.LBB47:
 153:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y + v->z * v->z;
 280              		.loc 1 153 0
 281 0036 E8EEA87A 		vfma.f32	s15, s17, s17
 282              	.LBE47:
 283              	.LBE48:
 284              	.LBE49:
 285              	.LBE51:
 286              	.LBE53:
 287              	.LBE55:
 288              	.LBE58:
 289              	.LBE61:
 290              	.LBE64:
 291              	.LBE67:
 292              	.LBE70:
 293              	.LBE84:
 294              		.loc 3 153 0
 295 003a 0646     		mov	r6, r0
 296 003c 9046     		mov	r8, r2
 297              	.LVL9:
 298              	.LBB85:
 299              	.LBB71:
 300              	.LBB68:
 301              	.LBB65:
 302              	.LBB62:
 303              	.LBB59:
 304              	.LBB56:
 305              	.LBB54:
 306              	.LBB52:
 307              	.LBB50:
 158:./math/pprz_algebra_float.h ****   return sqrtf(float_vect3_norm2(v));
 308              		.loc 1 158 0
 309 003e E8EE087A 		vfma.f32	s15, s16, s16
 310 0042 17EE900A 		fmrs	r0, s15
 311              	.LVL10:
 312 0046 FFF7FEFF 		bl	sqrtf
 313              	.LVL11:
 314 004a 07EE900A 		fmsr	s15, r0
 315              	.LBE50:
 316              	.LBE52:
 165:./math/pprz_algebra_float.h ****   if (n > 0) {
 317              		.loc 1 165 0
 318 004e F5EEC07A 		fcmpezs	s15
 319 0052 F1EE10FA 		fmstat
 320 0056 05DD     		ble	.L11
 166:./math/pprz_algebra_float.h ****     v->x /= n;
 321              		.loc 1 166 0
 322 0058 C8EEA78A 		fdivs	s17, s17, s15
 323              	.LVL12:
 167:./math/pprz_algebra_float.h ****     v->y /= n;
 324              		.loc 1 167 0
 325 005c 89EE279A 		fdivs	s18, s18, s15
 326              	.LVL13:
 168:./math/pprz_algebra_float.h ****     v->z /= n;
 327              		.loc 1 168 0
 328 0060 88EE278A 		fdivs	s16, s16, s15
 329              	.LVL14:
 330              	.L11:
 331              	.LBE54:
 332              	.LBE56:
  69:./subsystems/ahrs/ahrs_float_utils.h ****   FLOAT_VECT3_NORMALIZE(acc_normalized);
  70:./subsystems/ahrs/ahrs_float_utils.h **** 
  71:./subsystems/ahrs/ahrs_float_utils.h ****   /* check for 180deg case */
  72:./subsystems/ahrs/ahrs_float_utils.h ****   if (ABS(acc_normalized.z - 1.0) < 5 * FLT_MIN) {
 333              		.loc 4 72 0
 334 0064 4FF00107 		mov	r7, #1
 335 0068 18EE100A 		fmrs	r0, s16
 336 006c FFF7FEFF 		bl	__aeabi_f2d
 337              	.LVL15:
 338 0070 0022     		movs	r2, #0
 339 0072 924B     		ldr	r3, .L32+20
 340 0074 FFF7FEFF 		bl	__aeabi_dsub
 341              	.LVL16:
 342 0078 0022     		movs	r2, #0
 343 007a 0023     		movs	r3, #0
 344 007c 0446     		mov	r4, r0
 345 007e 0D46     		mov	r5, r1
 346 0080 FFF7FEFF 		bl	__aeabi_dcmplt
 347              	.LVL17:
 348 0084 30B1     		cbz	r0, .L28
 349 0086 2046     		mov	r0, r4
 350 0088 2946     		mov	r1, r5
 351 008a 0022     		movs	r2, #0
 352 008c 8C4B     		ldr	r3, .L32+24
 353 008e FFF7FEFF 		bl	__aeabi_dcmpgt
 354              	.LVL18:
 355 0092 05E0     		b	.L31
 356              	.L28:
 357 0094 2046     		mov	r0, r4
 358 0096 2946     		mov	r1, r5
 359 0098 0022     		movs	r2, #0
 360 009a 8A4B     		ldr	r3, .L32+28
 361 009c FFF7FEFF 		bl	__aeabi_dcmplt
 362              	.LVL19:
 363              	.L31:
 364 00a0 00B9     		cbnz	r0, .L17
 365 00a2 0746     		mov	r7, r0
 366              	.L17:
 367 00a4 FBB2     		uxtb	r3, r7
 368 00a6 F7EE009A 		fconsts	s19, #112
 369 00aa 0027     		movs	r7, #0
 370 00ac 2BB1     		cbz	r3, .L18
  73:./subsystems/ahrs/ahrs_float_utils.h ****     QUAT_ASSIGN(*q, 0.0, 1.0, 0.0, 0.0);
 371              		.loc 4 73 0
 372 00ae 0B97     		str	r7, [sp, #44]	@ float
 373 00b0 CDED0C9A 		fsts	s19, [sp, #48]
 374 00b4 0D97     		str	r7, [sp, #52]	@ float
 375 00b6 0E97     		str	r7, [sp, #56]	@ float
 376 00b8 0DE0     		b	.L19
 377              	.L18:
  74:./subsystems/ahrs/ahrs_float_utils.h ****   } else {
  75:./subsystems/ahrs/ahrs_float_utils.h ****     /*
  76:./subsystems/ahrs/ahrs_float_utils.h ****      * axis we want to rotate around is cross product of accel and reference [0,0,-g]
  77:./subsystems/ahrs/ahrs_float_utils.h ****      * normalized: cross(acc_normalized, [0,0,-1])
  78:./subsystems/ahrs/ahrs_float_utils.h ****      * vector part of quaternion is the axis
  79:./subsystems/ahrs/ahrs_float_utils.h ****      * scalar part (angle): 1.0 + dot(acc_normalized, [0,0,-1])
  80:./subsystems/ahrs/ahrs_float_utils.h ****      */
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qx = - acc_normalized.y;
  82:./subsystems/ahrs/ahrs_float_utils.h ****     q->qy = acc_normalized.x;
  83:./subsystems/ahrs/ahrs_float_utils.h ****     q->qz = 0.0;
  84:./subsystems/ahrs/ahrs_float_utils.h ****     q->qi = 1.0 - acc_normalized.z;
 378              		.loc 4 84 0
 379 00ba 39EEC88A 		fsubs	s16, s19, s16
 380              	.LVL20:
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qx = - acc_normalized.y;
 381              		.loc 4 81 0
 382 00be B1EE499A 		fnegs	s18, s18
 383              	.LVL21:
  85:./subsystems/ahrs/ahrs_float_utils.h ****     float_quat_normalize(q);
 384              		.loc 4 85 0
 385 00c2 0BA8     		add	r0, sp, #44
 386              	.LVL22:
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qx = - acc_normalized.y;
 387              		.loc 4 81 0
 388 00c4 8DED0C9A 		fsts	s18, [sp, #48]
  82:./subsystems/ahrs/ahrs_float_utils.h ****     q->qy = acc_normalized.x;
 389              		.loc 4 82 0
 390 00c8 CDED0D8A 		fsts	s17, [sp, #52]
  83:./subsystems/ahrs/ahrs_float_utils.h ****     q->qz = 0.0;
 391              		.loc 4 83 0
 392 00cc 0E97     		str	r7, [sp, #56]	@ float
  84:./subsystems/ahrs/ahrs_float_utils.h ****     q->qi = 1.0 - acc_normalized.z;
 393              		.loc 4 84 0
 394 00ce 8DED0B8A 		fsts	s16, [sp, #44]
 395              		.loc 4 85 0
 396 00d2 FFF7FEFF 		bl	float_quat_normalize
 397              	.LVL23:
 398              	.L19:
 399              	.LBE59:
 400              	.LBE62:
  86:./subsystems/ahrs/ahrs_float_utils.h ****   }
  87:./subsystems/ahrs/ahrs_float_utils.h **** }
  88:./subsystems/ahrs/ahrs_float_utils.h **** 
  89:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_quat_from_accel_mag(struct FloatQuat *q, struct Int32Vect3 *accel
  90:./subsystems/ahrs/ahrs_float_utils.h ****     struct Int32Vect3 *mag)
  91:./subsystems/ahrs/ahrs_float_utils.h **** {
  92:./subsystems/ahrs/ahrs_float_utils.h **** 
  93:./subsystems/ahrs/ahrs_float_utils.h ****   /* the quaternion representing roll and pitch from acc measurement */
  94:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatQuat q_a;
  95:./subsystems/ahrs/ahrs_float_utils.h ****   ahrs_float_get_quat_from_accel(&q_a, accel);
  96:./subsystems/ahrs/ahrs_float_utils.h **** 
  97:./subsystems/ahrs/ahrs_float_utils.h **** 
  98:./subsystems/ahrs/ahrs_float_utils.h ****   /* convert mag measurement to float */
  99:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 mag_float;
 100:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(mag_float, *mag);
 401              		.loc 4 100 0
 402 00d6 D8ED007A 		flds	s15, [r8]	@ int
 403 00da D8ED016A 		flds	s13, [r8, #4]	@ int
 404 00de B8EEE77A 		fsitos	s14, s15
 405 00e2 DFED797A 		flds	s15, .L32+32
 406 00e6 27EE277A 		fmuls	s14, s14, s15
 101:./subsystems/ahrs/ahrs_float_utils.h **** 
 102:./subsystems/ahrs/ahrs_float_utils.h ****   /* and rotate to horizontal plane using the quat from above */
 103:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatRMat rmat_phi_theta;
 104:./subsystems/ahrs/ahrs_float_utils.h ****   float_rmat_of_quat(&rmat_phi_theta, &q_a);
 407              		.loc 4 104 0
 408 00ea 13A8     		add	r0, sp, #76
 100:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(mag_float, *mag);
 409              		.loc 4 100 0
 410 00ec 8DED017A 		fsts	s14, [sp, #4]
 411 00f0 B8EEE67A 		fsitos	s14, s13
 412              		.loc 4 104 0
 413 00f4 0BA9     		add	r1, sp, #44
 414              	.LVL24:
 100:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(mag_float, *mag);
 415              		.loc 4 100 0
 416 00f6 27EE277A 		fmuls	s14, s14, s15
 417 00fa 8DED027A 		fsts	s14, [sp, #8]
 418 00fe 98ED027A 		flds	s14, [r8, #8]	@ int
 419 0102 B8EEC77A 		fsitos	s14, s14
 420 0106 67EE277A 		fmuls	s15, s14, s15
 421 010a CDED037A 		fsts	s15, [sp, #12]
 422              		.loc 4 104 0
 423 010e FFF7FEFF 		bl	float_rmat_of_quat
 424              	.LVL25:
 105:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 mag_ltp;
 106:./subsystems/ahrs/ahrs_float_utils.h ****   float_rmat_transp_vmult(&mag_ltp, &rmat_phi_theta, &mag_float);
 425              		.loc 4 106 0
 426 0112 01AA     		add	r2, sp, #4
 427 0114 13A9     		add	r1, sp, #76
 428 0116 04A8     		add	r0, sp, #16
 429 0118 FFF7FEFF 		bl	float_rmat_transp_vmult
 430              	.LVL26:
 107:./subsystems/ahrs/ahrs_float_utils.h **** 
 108:./subsystems/ahrs/ahrs_float_utils.h ****   /* heading from mag -> make quaternion to rotate around ltp z axis*/
 109:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatQuat q_m;
 110:./subsystems/ahrs/ahrs_float_utils.h **** 
 111:./subsystems/ahrs/ahrs_float_utils.h ****   /* dot([mag_n.x, mag_n.x, 0], [AHRS_H_X, AHRS_H_Y, 0]) */
 112:./subsystems/ahrs/ahrs_float_utils.h ****   float dot = mag_ltp.x * AHRS_H_X + mag_ltp.y * AHRS_H_Y;
 431              		.loc 4 112 0
 432 011c 9DED058A 		flds	s16, [sp, #20]
 433 0120 DDED048A 		flds	s17, [sp, #16]
 434              	.LVL27:
 113:./subsystems/ahrs/ahrs_float_utils.h **** 
 114:./subsystems/ahrs/ahrs_float_utils.h ****   /* |v1||v2| */
 115:./subsystems/ahrs/ahrs_float_utils.h ****   float norm2 = sqrtf(SQUARE(mag_ltp.x) + SQUARE(mag_ltp.y))
 435              		.loc 4 115 0
 436 0124 68EE087A 		fmuls	s15, s16, s16
 437 0128 E8EEA87A 		vfma.f32	s15, s17, s17
 438 012c 17EE900A 		fmrs	r0, s15
 439 0130 FFF7FEFF 		bl	sqrtf
 440              	.LVL28:
 441 0134 09EE100A 		fmsr	s18, r0
 442              	.LVL29:
 112:./subsystems/ahrs/ahrs_float_utils.h ****   float dot = mag_ltp.x * AHRS_H_X + mag_ltp.y * AHRS_H_Y;
 443              		.loc 4 112 0
 444 0138 18EE900A 		fmrs	r0, s17
 445              	.LVL30:
 446 013c FFF7FEFF 		bl	__aeabi_f2d
 447              	.LVL31:
 448 0140 59A3     		adr	r3, .L32
 449 0142 D3E90023 		ldrd	r2, [r3]
 450 0146 FFF7FEFF 		bl	__aeabi_dmul
 451              	.LVL32:
 452 014a 0446     		mov	r4, r0
 453 014c 18EE100A 		fmrs	r0, s16
 454 0150 0D46     		mov	r5, r1
 455 0152 FFF7FEFF 		bl	__aeabi_f2d
 456              	.LVL33:
 457 0156 56A3     		adr	r3, .L32+8
 458 0158 D3E90023 		ldrd	r2, [r3]
 459 015c FFF7FEFF 		bl	__aeabi_dmul
 460              	.LVL34:
 461 0160 0246     		mov	r2, r0
 462 0162 0B46     		mov	r3, r1
 463 0164 2046     		mov	r0, r4
 464 0166 2946     		mov	r1, r5
 465 0168 FFF7FEFF 		bl	__aeabi_dadd
 466              	.LVL35:
 467 016c FFF7FEFF 		bl	__aeabi_d2f
 468              	.LVL36:
 116:./subsystems/ahrs/ahrs_float_utils.h ****                 * sqrtf(SQUARE(AHRS_H_X) + SQUARE(AHRS_H_Y));
 117:./subsystems/ahrs/ahrs_float_utils.h **** 
 118:./subsystems/ahrs/ahrs_float_utils.h ****   // catch 180deg case
 119:./subsystems/ahrs/ahrs_float_utils.h ****   if (ABS(norm2 + dot) < 5 * FLT_MIN) {
 469              		.loc 4 119 0
 470 0170 DFED567A 		flds	s15, .L32+36
 471 0174 08EE100A 		fmsr	s16, r0
 472              	.LVL37:
 473 0178 A9EE278A 		vfma.f32	s16, s18, s15
 474 017c B5EEC08A 		fcmpezs	s16
 475 0180 F1EE10FA 		fmstat
 476 0184 09D5     		bpl	.L29
 477 0186 DFED527A 		flds	s15, .L32+40
 478 018a B4EEE78A 		fcmpes	s16, s15
 479 018e F1EE10FA 		fmstat
 480 0192 D4BF     		ite	le
 481 0194 0023     		movle	r3, #0
 482 0196 0123     		movgt	r3, #1
 483 0198 08E0     		b	.L22
 484              	.L29:
 485 019a DFED4E7A 		flds	s15, .L32+44
 486 019e B4EEE78A 		fcmpes	s16, s15
 487 01a2 F1EE10FA 		fmstat
 488 01a6 54BF     		ite	pl
 489 01a8 0023     		movpl	r3, #0
 490 01aa 0123     		movmi	r3, #1
 491              	.L22:
 492 01ac 2BB1     		cbz	r3, .L23
 120:./subsystems/ahrs/ahrs_float_utils.h ****     QUAT_ASSIGN(q_m, 0.0, 0.0, 0.0, 1.0);
 493              		.loc 4 120 0
 494 01ae 0F97     		str	r7, [sp, #60]	@ float
 495 01b0 1097     		str	r7, [sp, #64]	@ float
 496 01b2 1197     		str	r7, [sp, #68]	@ float
 497 01b4 CDED129A 		fsts	s19, [sp, #72]
 498 01b8 21E0     		b	.L24
 499              	.L23:
 121:./subsystems/ahrs/ahrs_float_utils.h ****   } else {
 122:./subsystems/ahrs/ahrs_float_utils.h ****     /* q_xyz = cross([mag_n.x, mag_n.y, 0], [AHRS_H_X, AHRS_H_Y, 0]) */
 123:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qx = 0.0;
 124:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qy = 0.0;
 125:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qz = mag_ltp.x * AHRS_H_Y - mag_ltp.y * AHRS_H_X;
 500              		.loc 4 125 0
 501 01ba 0498     		ldr	r0, [sp, #16]	@ float
 123:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qx = 0.0;
 502              		.loc 4 123 0
 503 01bc 1097     		str	r7, [sp, #64]	@ float
 124:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qy = 0.0;
 504              		.loc 4 124 0
 505 01be 1197     		str	r7, [sp, #68]	@ float
 506              		.loc 4 125 0
 507 01c0 FFF7FEFF 		bl	__aeabi_f2d
 508              	.LVL38:
 509 01c4 3AA3     		adr	r3, .L32+8
 510 01c6 D3E90023 		ldrd	r2, [r3]
 511 01ca FFF7FEFF 		bl	__aeabi_dmul
 512              	.LVL39:
 513 01ce 0446     		mov	r4, r0
 514 01d0 0598     		ldr	r0, [sp, #20]	@ float
 515 01d2 0D46     		mov	r5, r1
 516 01d4 FFF7FEFF 		bl	__aeabi_f2d
 517              	.LVL40:
 518 01d8 33A3     		adr	r3, .L32
 519 01da D3E90023 		ldrd	r2, [r3]
 520 01de FFF7FEFF 		bl	__aeabi_dmul
 521              	.LVL41:
 522 01e2 0246     		mov	r2, r0
 523 01e4 0B46     		mov	r3, r1
 524 01e6 2046     		mov	r0, r4
 525 01e8 2946     		mov	r1, r5
 526 01ea FFF7FEFF 		bl	__aeabi_dsub
 527              	.LVL42:
 528 01ee FFF7FEFF 		bl	__aeabi_d2f
 529              	.LVL43:
 530 01f2 1290     		str	r0, [sp, #72]	@ float
 126:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qi = norm2 + dot;
 127:./subsystems/ahrs/ahrs_float_utils.h ****     float_quat_normalize(&q_m);
 531              		.loc 4 127 0
 532 01f4 0FA8     		add	r0, sp, #60
 126:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qi = norm2 + dot;
 533              		.loc 4 126 0
 534 01f6 8DED0F8A 		fsts	s16, [sp, #60]
 535              		.loc 4 127 0
 536 01fa FFF7FEFF 		bl	float_quat_normalize
 537              	.LVL44:
 538              	.L24:
 128:./subsystems/ahrs/ahrs_float_utils.h ****   }
 129:./subsystems/ahrs/ahrs_float_utils.h **** 
 130:./subsystems/ahrs/ahrs_float_utils.h ****   // q_ltp2imu = q_a * q_m
 131:./subsystems/ahrs/ahrs_float_utils.h ****   // and wrap and normalize
 132:./subsystems/ahrs/ahrs_float_utils.h ****   float_quat_comp_norm_shortest(q, &q_m, &q_a);
 539              		.loc 4 132 0
 540 01fe 07A8     		add	r0, sp, #28
 541              	.LVL45:
 542 0200 0FA9     		add	r1, sp, #60
 543 0202 0BAA     		add	r2, sp, #44
 544              	.LVL46:
 545 0204 FFF7FEFF 		bl	float_quat_comp_norm_shortest
 546              	.LVL47:
 547              	.LBE65:
 548              	.LBE68:
 549              		.file 5 "./subsystems/ahrs/ahrs_int_utils.h"
   1:./subsystems/ahrs/ahrs_int_utils.h **** /*
   2:./subsystems/ahrs/ahrs_int_utils.h ****  * Copyright (C) 2009 Felix Ruess <felix.ruess@gmail.com>
   3:./subsystems/ahrs/ahrs_int_utils.h ****  * Copyright (C) 2009 Antoine Drouin <poinix@gmail.com>
   4:./subsystems/ahrs/ahrs_int_utils.h ****  *
   5:./subsystems/ahrs/ahrs_int_utils.h ****  * This file is part of paparazzi.
   6:./subsystems/ahrs/ahrs_int_utils.h ****  *
   7:./subsystems/ahrs/ahrs_int_utils.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./subsystems/ahrs/ahrs_int_utils.h ****  * it under the terms of the GNU General Public License as published by
   9:./subsystems/ahrs/ahrs_int_utils.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./subsystems/ahrs/ahrs_int_utils.h ****  * any later version.
  11:./subsystems/ahrs/ahrs_int_utils.h ****  *
  12:./subsystems/ahrs/ahrs_int_utils.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./subsystems/ahrs/ahrs_int_utils.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./subsystems/ahrs/ahrs_int_utils.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./subsystems/ahrs/ahrs_int_utils.h ****  * GNU General Public License for more details.
  16:./subsystems/ahrs/ahrs_int_utils.h ****  *
  17:./subsystems/ahrs/ahrs_int_utils.h ****  * You should have received a copy of the GNU General Public License
  18:./subsystems/ahrs/ahrs_int_utils.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./subsystems/ahrs/ahrs_int_utils.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./subsystems/ahrs/ahrs_int_utils.h ****  * Boston, MA 02111-1307, USA.
  21:./subsystems/ahrs/ahrs_int_utils.h ****  */
  22:./subsystems/ahrs/ahrs_int_utils.h **** 
  23:./subsystems/ahrs/ahrs_int_utils.h **** /**
  24:./subsystems/ahrs/ahrs_int_utils.h ****  * @file subsystems/ahrs/ahrs_int_utils.h
  25:./subsystems/ahrs/ahrs_int_utils.h ****  *
  26:./subsystems/ahrs/ahrs_int_utils.h ****  * Utility functions for fixed point AHRS implementations.
  27:./subsystems/ahrs/ahrs_int_utils.h ****  *
  28:./subsystems/ahrs/ahrs_int_utils.h ****  */
  29:./subsystems/ahrs/ahrs_int_utils.h **** 
  30:./subsystems/ahrs/ahrs_int_utils.h **** #ifndef AHRS_INT_UTILS_H
  31:./subsystems/ahrs/ahrs_int_utils.h **** #define AHRS_INT_UTILS_H
  32:./subsystems/ahrs/ahrs_int_utils.h **** 
  33:./subsystems/ahrs/ahrs_int_utils.h **** //#include "../../test/pprz_algebra_print.h"
  34:./subsystems/ahrs/ahrs_int_utils.h **** #include "math/pprz_algebra_int.h"
  35:./subsystems/ahrs/ahrs_int_utils.h **** 
  36:./subsystems/ahrs/ahrs_int_utils.h **** #include "subsystems/ahrs/ahrs_magnetic_field_model.h"
  37:./subsystems/ahrs/ahrs_int_utils.h **** 
  38:./subsystems/ahrs/ahrs_int_utils.h **** #include "subsystems/ahrs/ahrs_float_utils.h"
  39:./subsystems/ahrs/ahrs_int_utils.h **** 
  40:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_euler_from_accel_mag(struct Int32Eulers *e, struct Int32Vect3 *acce
  41:./subsystems/ahrs/ahrs_int_utils.h ****     struct Int32Vect3 *mag)
  42:./subsystems/ahrs/ahrs_int_utils.h **** {
  43:./subsystems/ahrs/ahrs_int_utils.h ****   //  DISPLAY_INT32_VECT3("# accel", (*accel));
  44:./subsystems/ahrs/ahrs_int_utils.h ****   const float fphi = atan2f(-accel->y, -accel->z);
  45:./subsystems/ahrs/ahrs_int_utils.h ****   //  printf("# atan float %f\n", DegOfRad(fphi));
  46:./subsystems/ahrs/ahrs_int_utils.h ****   e->phi = ANGLE_BFP_OF_REAL(fphi);
  47:./subsystems/ahrs/ahrs_int_utils.h **** 
  48:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi;
  49:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_COS(cphi, e->phi);
  50:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi_ax = -INT_MULT_RSHIFT(cphi, accel->x, INT32_TRIG_FRAC);
  51:./subsystems/ahrs/ahrs_int_utils.h ****   const float ftheta = atan2f(-cphi_ax, -accel->z);
  52:./subsystems/ahrs/ahrs_int_utils.h ****   e->theta = ANGLE_BFP_OF_REAL(ftheta);
  53:./subsystems/ahrs/ahrs_int_utils.h **** 
  54:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t sphi;
  55:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_SIN(sphi, e->phi);
  56:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t stheta;
  57:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_SIN(stheta, e->theta);
  58:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t ctheta;
  59:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_COS(ctheta, e->theta);
  60:./subsystems/ahrs/ahrs_int_utils.h **** 
  61:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t sphi_stheta = (sphi * stheta) >> INT32_TRIG_FRAC;
  62:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi_stheta = (cphi * stheta) >> INT32_TRIG_FRAC;
  63:./subsystems/ahrs/ahrs_int_utils.h ****   //int32_t sphi_ctheta = (sphi*ctheta)>>INT32_TRIG_FRAC;
  64:./subsystems/ahrs/ahrs_int_utils.h ****   //int32_t cphi_ctheta = (cphi*ctheta)>>INT32_TRIG_FRAC;
  65:./subsystems/ahrs/ahrs_int_utils.h **** 
  66:./subsystems/ahrs/ahrs_int_utils.h ****   const int32_t mn = ctheta * mag->x + sphi_stheta * mag->y + cphi_stheta * mag->z;
  67:./subsystems/ahrs/ahrs_int_utils.h ****   const int32_t me = 0      * mag->x + cphi        * mag->y - sphi        * mag->z;
  68:./subsystems/ahrs/ahrs_int_utils.h ****   //const int32_t md =
  69:./subsystems/ahrs/ahrs_int_utils.h ****   //  -stheta     * imu.mag.x +
  70:./subsystems/ahrs/ahrs_int_utils.h ****   //  sphi_ctheta * imu.mag.y +
  71:./subsystems/ahrs/ahrs_int_utils.h ****   //  cphi_ctheta * imu.mag.z;
  72:./subsystems/ahrs/ahrs_int_utils.h ****   //  float m_psi = -atan2(me, mn);
  73:./subsystems/ahrs/ahrs_int_utils.h ****   const float mag_dec = atan2(-AHRS_H_Y, AHRS_H_X);
  74:./subsystems/ahrs/ahrs_int_utils.h ****   const float fpsi = atan2f(-me, mn) - mag_dec;
  75:./subsystems/ahrs/ahrs_int_utils.h ****   e->psi = ANGLE_BFP_OF_REAL(fpsi);
  76:./subsystems/ahrs/ahrs_int_utils.h ****   INT32_ANGLE_NORMALIZE(e->psi);
  77:./subsystems/ahrs/ahrs_int_utils.h **** 
  78:./subsystems/ahrs/ahrs_int_utils.h **** }
  79:./subsystems/ahrs/ahrs_int_utils.h **** 
  80:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_quat_from_accel(struct Int32Quat *q, struct Int32Vect3 *accel)
  81:./subsystems/ahrs/ahrs_int_utils.h **** {
  82:./subsystems/ahrs/ahrs_int_utils.h ****   struct FloatQuat q_f;
  83:./subsystems/ahrs/ahrs_int_utils.h ****   ahrs_float_get_quat_from_accel(&q_f, accel);
  84:./subsystems/ahrs/ahrs_int_utils.h ****   QUAT_BFP_OF_REAL(*q, q_f);
  85:./subsystems/ahrs/ahrs_int_utils.h **** }
  86:./subsystems/ahrs/ahrs_int_utils.h **** 
  87:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_quat_from_accel_mag(struct Int32Quat *q, struct Int32Vect3 *accel,
  88:./subsystems/ahrs/ahrs_int_utils.h ****     struct Int32Vect3 *mag)
  89:./subsystems/ahrs/ahrs_int_utils.h **** {
  90:./subsystems/ahrs/ahrs_int_utils.h **** 
  91:./subsystems/ahrs/ahrs_int_utils.h ****   struct FloatQuat q_f;
  92:./subsystems/ahrs/ahrs_int_utils.h ****   ahrs_float_get_quat_from_accel_mag(&q_f, accel, mag);
  93:./subsystems/ahrs/ahrs_int_utils.h ****   QUAT_BFP_OF_REAL(*q, q_f);
 550              		.loc 5 93 0
 551 0208 DFED337A 		flds	s15, .L32+48
 552 020c 9DED077A 		flds	s14, [sp, #28]
 553 0210 3249     		ldr	r1, .L32+52
 554 0212 27EE277A 		fmuls	s14, s14, s15
 555              	.LBE71:
 556              	.LBE85:
 154:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 155:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER
 156:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Compute an initial orientation from accel and mag directly as quaternion */
 157:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_int_get_quat_from_accel_mag(&ahrs_icq.ltp_to_imu_quat,
 158:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                    lp_accel, lp_mag);
 159:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = TRUE;
 557              		.loc 3 159 0
 558 0216 0120     		movs	r0, #1
 559              	.LBB86:
 560              	.LBB72:
 561              		.loc 5 93 0
 562 0218 BDEEC77A 		ftosizs	s14, s14
 563              	.LBE72:
 564              	.LBE86:
 565              		.loc 3 159 0
 566 021c 81F88100 		strb	r0, [r1, #129]
 567              	.LBB87:
 568              	.LBB73:
 569              		.loc 5 93 0
 570 0220 81ED187A 		fsts	s14, [r1, #96]	@ int
 571 0224 9DED087A 		flds	s14, [sp, #32]
 572              	.LBE73:
 573              	.LBE87:
 160:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 161:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Compute an initial orientation from accel and just set heading to zero */
 162:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_int_get_quat_from_accel(&ahrs_icq.ltp_to_imu_quat, lp_accel);
 163:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 164:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // supress unused arg warning
 165:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   lp_mag = lp_mag;
 166:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 167:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 168:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Use low passed gyro value as initial bias */
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.gyro_bias, *lp_gyro);
 574              		.loc 3 169 0
 575 0228 3368     		ldr	r3, [r6]
 576 022a 0B60     		str	r3, [r1]
 577              	.LBB88:
 578              	.LBB74:
 579              		.loc 5 93 0
 580 022c 27EE277A 		fmuls	s14, s14, s15
 581              	.LBE74:
 582              	.LBE88:
 583              		.loc 3 169 0
 584 0230 7368     		ldr	r3, [r6, #4]
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 585              		.loc 3 170 0
 586 0232 3268     		ldr	r2, [r6]
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.gyro_bias, *lp_gyro);
 587              		.loc 3 169 0
 588 0234 4B60     		str	r3, [r1, #4]
 589              	.LBB89:
 590              	.LBB75:
 591              		.loc 5 93 0
 592 0236 BDEEC77A 		ftosizs	s14, s14
 593              	.LBE75:
 594              	.LBE89:
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.gyro_bias, *lp_gyro);
 595              		.loc 3 169 0
 596 023a B368     		ldr	r3, [r6, #8]
 597              	.LBB90:
 598              	.LBB76:
 599              		.loc 5 93 0
 600 023c 81ED197A 		fsts	s14, [r1, #100]	@ int
 601 0240 9DED097A 		flds	s14, [sp, #36]
 602              	.LBE76:
 603              	.LBE90:
 604              		.loc 3 170 0
 605 0244 D6F804C0 		ldr	ip, [r6, #4]
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.gyro_bias, *lp_gyro);
 606              		.loc 3 169 0
 607 0248 8B60     		str	r3, [r1, #8]
 608              	.LBB91:
 609              	.LBB77:
 610              		.loc 5 93 0
 611 024a 27EE277A 		fmuls	s14, s14, s15
 612              	.LBE77:
 613              	.LBE91:
 614              		.loc 3 170 0
 615 024e D717     		asrs	r7, r2, #31
 616              	.LBB92:
 617              	.LBB78:
 618              		.loc 5 93 0
 619 0250 BDEEC77A 		ftosizs	s14, s14
 620              	.LBE78:
 621              	.LBE92:
 622              		.loc 3 170 0
 623 0254 B468     		ldr	r4, [r6, #8]
 624              	.LBB93:
 625              	.LBB79:
 626              		.loc 5 93 0
 627 0256 81ED1A7A 		fsts	s14, [r1, #104]	@ int
 628 025a 9DED0A7A 		flds	s14, [sp, #40]
 629              	.LBE79:
 630              	.LBE93:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 172:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 173:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_RUNNING;
 631              		.loc 3 173 0
 632 025e 81F83401 		strb	r0, [r1, #308]
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 633              		.loc 3 171 0
 634 0262 3E07     		lsls	r6, r7, #28
 635              	.LVL48:
 636 0264 46EA1216 		orr	r6, r6, r2, lsr #4
 637              	.LBB94:
 638              	.LBB80:
 639              		.loc 5 93 0
 640 0268 67EE277A 		fmuls	s15, s14, s15
 641              	.LBE80:
 642              	.LBE94:
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 643              		.loc 3 170 0
 644 026c 4FEAEC75 		asr	r5, ip, #31
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 645              		.loc 3 171 0
 646 0270 1207     		lsls	r2, r2, #28
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 647              		.loc 3 170 0
 648 0272 E317     		asrs	r3, r4, #31
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 649              		.loc 3 171 0
 650 0274 8A64     		str	r2, [r1, #72]
 651 0276 2A07     		lsls	r2, r5, #28
 652 0278 42EA1C12 		orr	r2, r2, ip, lsr #4
 653              	.LBB95:
 654              	.LBB81:
 655              		.loc 5 93 0
 656 027c FDEEE77A 		ftosizs	s15, s15
 657              	.LBE81:
 658              	.LBE95:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 659              		.loc 3 171 0
 660 0280 1B07     		lsls	r3, r3, #28
 661 0282 43EA1413 		orr	r3, r3, r4, lsr #4
 662 0286 4A65     		str	r2, [r1, #84]
 663 0288 2407     		lsls	r4, r4, #28
 664 028a 4FEA0C72 		lsl	r2, ip, #28
 665              	.LBB96:
 666              	.LBB82:
 667              		.loc 5 93 0
 668 028e C1ED1B7A 		fsts	s15, [r1, #108]	@ int
 669              	.LBE82:
 670              	.LBE96:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 671              		.loc 3 171 0
 672 0292 CE64     		str	r6, [r1, #76]
 673 0294 0A65     		str	r2, [r1, #80]
 674 0296 CB65     		str	r3, [r1, #92]
 675 0298 8C65     		str	r4, [r1, #88]
 174:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = TRUE;
 676              		.loc 3 174 0
 677 029a 81F83501 		strb	r0, [r1, #309]
 175:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 176:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   return TRUE;
 177:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 678              		.loc 3 177 0
 679 029e 1CB0     		add	sp, sp, #112
 680              		@ sp needed
 681 02a0 BDEC048B 		fldmfdd	sp!, {d8-d9}
 682              	.LVL49:
 683 02a4 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 684              	.LVL50:
 685              	.L33:
 686              		.align	3
 687              	.L32:
 688 02a8 F2C0471E 		.word	508018930
 689 02ac 1C6AE03F 		.word	1071671836
 690 02b0 F25E56E2 		.word	-497656078
 691 02b4 42D3AEBF 		.word	-1079061694
 692 02b8 0000803A 		.word	981467136
 693 02bc 0000F03F 		.word	1072693248
 694 02c0 000034B8 		.word	-1204551680
 695 02c4 00003438 		.word	942931968
 696 02c8 0000003A 		.word	973078528
 697 02cc A337043F 		.word	1057240995
 698 02d0 0000A081 		.word	-2120220672
 699 02d4 0000A001 		.word	27262976
 700 02d8 00000047 		.word	1191182336
 701 02dc 00000000 		.word	.LANCHOR0
 702              		.cfi_endproc
 703              	.LFE90:
 705              		.global	__aeabi_ddiv
 706              		.global	__aeabi_d2iz
 707              		.section	.text.ahrs_icq_propagate,"ax",%progbits
 708              		.align	1
 709              		.global	ahrs_icq_propagate
 710              		.thumb
 711              		.thumb_func
 713              	ahrs_icq_propagate:
 714              	.LFB91:
 178:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 179:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 180:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_propagate(struct Int32Rates *gyro, float dt)
 181:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 715              		.loc 3 181 0
 716              		.cfi_startproc
 717              		@ args = 0, pretend = 0, frame = 16
 718              		@ frame_needed = 0, uses_anonymous_args = 0
 719              	.LVL51:
 720 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 721              		.cfi_def_cfa_offset 20
 722              		.cfi_offset 4, -20
 723              		.cfi_offset 5, -16
 724              		.cfi_offset 6, -12
 725              		.cfi_offset 7, -8
 726              		.cfi_offset 14, -4
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 183:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 184:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* unbias gyro             */
 185:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Rates omega;
 186:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_DIFF(omega, *gyro, ahrs_icq.gyro_bias);
 727              		.loc 3 186 0
 728 0002 274C     		ldr	r4, .L35
 729 0004 0668     		ldr	r6, [r0]
 730 0006 2368     		ldr	r3, [r4]
 731 0008 4568     		ldr	r5, [r0, #4]
 732 000a 8268     		ldr	r2, [r0, #8]
 187:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 188:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* low pass rate */
 189:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_PROPAGATE_LOW_PASS_RATES
 190:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SMUL(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 2);
 733              		.loc 3 190 0
 734 000c E068     		ldr	r0, [r4, #12]
 735              	.LVL52:
 186:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_DIFF(omega, *gyro, ahrs_icq.gyro_bias);
 736              		.loc 3 186 0
 737 000e F61A     		subs	r6, r6, r3
 738 0010 6368     		ldr	r3, [r4, #4]
 739 0012 ED1A     		subs	r5, r5, r3
 740 0014 A368     		ldr	r3, [r4, #8]
 741 0016 D21A     		subs	r2, r2, r3
 742              		.loc 3 190 0
 743 0018 2369     		ldr	r3, [r4, #16]
 191:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(ahrs_icq.imu_rate, omega);
 744              		.loc 3 191 0
 745 001a 05EB430E 		add	lr, r5, r3, lsl #1
 190:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SMUL(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 2);
 746              		.loc 3 190 0
 747 001e 6369     		ldr	r3, [r4, #20]
 748              		.loc 3 191 0
 749 0020 06EB4000 		add	r0, r6, r0, lsl #1
 750 0024 02EB4307 		add	r7, r2, r3, lsl #1
 192:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SDIV(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 3);
 751              		.loc 3 192 0
 752 0028 0323     		movs	r3, #3
 753 002a 90FBF3F0 		sdiv	r0, r0, r3
 754 002e E060     		str	r0, [r4, #12]
 755 0030 9EFBF3F0 		sdiv	r0, lr, r3
 756 0034 97FBF3F3 		sdiv	r3, r7, r3
 757 0038 6361     		str	r3, [r4, #20]
 193:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 194:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.imu_rate, omega);
 195:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 196:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 197:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* add correction */
 198:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(omega, ahrs_icq.rate_correction);
 758              		.loc 3 198 0
 759 003a A369     		ldr	r3, [r4, #24]
 192:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SDIV(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 3);
 760              		.loc 3 192 0
 761 003c 2061     		str	r0, [r4, #16]
 762              		.loc 3 198 0
 763 003e 1E44     		add	r6, r6, r3
 764 0040 E369     		ldr	r3, [r4, #28]
 765 0042 1D44     		add	r5, r5, r3
 766 0044 236A     		ldr	r3, [r4, #32]
 181:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 767              		.loc 3 181 0
 768 0046 85B0     		sub	sp, sp, #20
 769              		.cfi_def_cfa_offset 40
 770              		.loc 3 198 0
 771 0048 1A44     		add	r2, r2, r3
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 772              		.loc 3 182 0
 773 004a 0846     		mov	r0, r1	@ float
 199:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* and zeros it */
 200:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 774              		.loc 3 200 0
 775 004c 0023     		movs	r3, #0
 198:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(omega, ahrs_icq.rate_correction);
 776              		.loc 3 198 0
 777 004e 0295     		str	r5, [sp, #8]
 778 0050 0392     		str	r2, [sp, #12]
 779              		.loc 3 200 0
 780 0052 A361     		str	r3, [r4, #24]
 781 0054 E361     		str	r3, [r4, #28]
 782 0056 2362     		str	r3, [r4, #32]
 198:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(omega, ahrs_icq.rate_correction);
 783              		.loc 3 198 0
 784 0058 0196     		str	r6, [sp, #4]
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 785              		.loc 3 182 0
 786 005a FFF7FEFF 		bl	__aeabi_f2d
 787              	.LVL53:
 788 005e 0246     		mov	r2, r0
 789 0060 0B46     		mov	r3, r1
 790 0062 0020     		movs	r0, #0
 791 0064 0F49     		ldr	r1, .L35+4
 792 0066 FFF7FEFF 		bl	__aeabi_ddiv
 793              	.LVL54:
 794 006a FFF7FEFF 		bl	__aeabi_d2iz
 795              	.LVL55:
 201:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 202:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* integrate quaternion */
 203:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_integrate_fi(&ahrs_icq.ltp_to_imu_quat, &ahrs_icq.high_rez_quat,
 796              		.loc 3 203 0
 797 006e 04F16005 		add	r5, r4, #96
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 798              		.loc 3 182 0
 799 0072 0346     		mov	r3, r0
 800              		.loc 3 203 0
 801 0074 A5F13801 		sub	r1, r5, #56
 802 0078 2846     		mov	r0, r5
 803 007a 01AA     		add	r2, sp, #4
 804 007c FFF7FEFF 		bl	int32_quat_integrate_fi
 805              	.LVL56:
 204:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           &omega, freq);
 205:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_normalize(&ahrs_icq.ltp_to_imu_quat);
 806              		.loc 3 205 0
 807 0080 2846     		mov	r0, r5
 808 0082 FFF7FEFF 		bl	int32_quat_normalize
 809              	.LVL57:
 206:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 207:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // increase accel and mag propagation counters
 208:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt++;
 810              		.loc 3 208 0
 811 0086 B4F8AC30 		ldrh	r3, [r4, #172]
 812 008a 0133     		adds	r3, r3, #1
 813 008c A4F8AC30 		strh	r3, [r4, #172]	@ movhi
 209:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt++;
 814              		.loc 3 209 0
 815 0090 B4F8AE30 		ldrh	r3, [r4, #174]
 816 0094 0133     		adds	r3, r3, #1
 817 0096 A4F8AE30 		strh	r3, [r4, #174]	@ movhi
 210:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 818              		.loc 3 210 0
 819 009a 05B0     		add	sp, sp, #20
 820              		@ sp needed
 821 009c F0BD     		pop	{r4, r5, r6, r7, pc}
 822              	.L36:
 823 009e 00BF     		.align	2
 824              	.L35:
 825 00a0 00000000 		.word	.LANCHOR0
 826 00a4 0000F03F 		.word	1072693248
 827              		.cfi_endproc
 828              	.LFE91:
 830              		.section	.text.ahrs_icq_set_accel_gains,"ax",%progbits
 831              		.align	1
 832              		.global	ahrs_icq_set_accel_gains
 833              		.thumb
 834              		.thumb_func
 836              	ahrs_icq_set_accel_gains:
 837              	.LFB92:
 211:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 212:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 213:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_accel_gains(void)
 214:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 838              		.loc 3 214 0
 839              		.cfi_startproc
 840              		@ args = 0, pretend = 0, frame = 0
 841              		@ frame_needed = 0, uses_anonymous_args = 0
 842 0000 10B5     		push	{r4, lr}
 843              		.cfi_def_cfa_offset 8
 844              		.cfi_offset 4, -8
 845              		.cfi_offset 14, -4
 215:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain (without frequency correction)
 216:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * omega * zeta
 217:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 218:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 1 / (Kp * FRAC_conversion / cross_product_gain)
 219:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 4096 * 9.81 / Kp
 220:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 221:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_kp = 4096 * 9.81 /
 222:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           (2 * ahrs_icq.accel_omega * ahrs_icq.accel_zeta);
 846              		.loc 3 222 0
 847 0002 1B4C     		ldr	r4, .L38+16
 214:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 848              		.loc 3 214 0
 849 0004 2DED028B 		fstmfdd	sp!, {d8}
 850              		.cfi_def_cfa_offset 16
 851              		.cfi_offset 80, -16
 852              		.loc 3 222 0
 853 0008 94ED278A 		flds	s16, [r4, #156]
 854 000c D4ED287A 		flds	s15, [r4, #160]
 855 0010 38EE087A 		fadds	s14, s16, s16
 223:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 224:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 225:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2
 226:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 227:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / (Ki * FRAC_conversion / cross_product_gain)
 228:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / 2^16 * 9.81 / Ki
 229:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 9.81 / 2048 / Ki
 230:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 231:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_ki = 9.81 / 2048 / (ahrs_icq.accel_omega * ahrs_icq.accel_omega);
 856              		.loc 3 231 0
 857 0014 28EE088A 		fmuls	s16, s16, s16
 221:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_kp = 4096 * 9.81 /
 858              		.loc 3 221 0
 859 0018 67EE277A 		fmuls	s15, s14, s15
 860 001c 17EE900A 		fmrs	r0, s15
 861 0020 FFF7FEFF 		bl	__aeabi_f2d
 862              	.LVL58:
 863 0024 0246     		mov	r2, r0
 864 0026 0B46     		mov	r3, r1
 865 0028 0DA1     		adr	r1, .L38
 866 002a D1E90001 		ldrd	r0, [r1]
 867 002e FFF7FEFF 		bl	__aeabi_ddiv
 868              	.LVL59:
 869 0032 FFF7FEFF 		bl	__aeabi_d2f
 870              	.LVL60:
 871 0036 C4F88800 		str	r0, [r4, #136]	@ float
 872              		.loc 3 231 0
 873 003a 18EE100A 		fmrs	r0, s16
 874 003e FFF7FEFF 		bl	__aeabi_f2d
 875              	.LVL61:
 876 0042 0246     		mov	r2, r0
 877 0044 0B46     		mov	r3, r1
 878 0046 08A1     		adr	r1, .L38+8
 879 0048 D1E90001 		ldrd	r0, [r1]
 880 004c FFF7FEFF 		bl	__aeabi_ddiv
 881              	.LVL62:
 882 0050 FFF7FEFF 		bl	__aeabi_d2f
 883              	.LVL63:
 232:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 884              		.loc 3 232 0
 885 0054 BDEC028B 		fldmfdd	sp!, {d8}
 231:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_ki = 9.81 / 2048 / (ahrs_icq.accel_omega * ahrs_icq.accel_omega);
 886              		.loc 3 231 0
 887 0058 C4F88C00 		str	r0, [r4, #140]	@ float
 888              		.loc 3 232 0
 889 005c 10BD     		pop	{r4, pc}
 890              	.L39:
 891 005e 00BF     		.align	3
 892              	.L38:
 893 0060 1F85EB51 		.word	1374389535
 894 0064 B89EE340 		.word	1088659128
 895 0068 1F85EB51 		.word	1374389535
 896 006c B89E733F 		.word	1064541880
 897 0070 00000000 		.word	.LANCHOR0
 898              		.cfi_endproc
 899              	.LFE92:
 901              		.global	__aeabi_i2d
 902 0074 AFF30080 		.section	.text.ahrs_icq_update_accel,"ax",%progbits
 903              		.align	1
 904              		.global	ahrs_icq_update_accel
 905              		.thumb
 906              		.thumb_func
 908              	ahrs_icq_update_accel:
 909              	.LFB93:
 233:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 234:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_accel(struct Int32Vect3 *accel, float dt)
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 910              		.loc 3 235 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 72
 913              		@ frame_needed = 0, uses_anonymous_args = 0
 914              	.LVL64:
 915 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 916              		.cfi_def_cfa_offset 36
 917              		.cfi_offset 4, -36
 918              		.cfi_offset 5, -32
 919              		.cfi_offset 6, -28
 920              		.cfi_offset 7, -24
 921              		.cfi_offset 8, -20
 922              		.cfi_offset 9, -16
 923              		.cfi_offset 10, -12
 924              		.cfi_offset 11, -8
 925              		.cfi_offset 14, -4
 236:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 237:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.accel_cnt == 0) {
 926              		.loc 3 237 0
 927 0004 AC4E     		ldr	r6, .L68+16
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 928              		.loc 3 235 0
 929 0006 2DED048B 		fstmfdd	sp!, {d8, d9}
 930              		.cfi_def_cfa_offset 52
 931              		.cfi_offset 80, -52
 932              		.cfi_offset 82, -44
 933              		.loc 3 237 0
 934 000a B6F8AC30 		ldrh	r3, [r6, #172]
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 935              		.loc 3 235 0
 936 000e 93B0     		sub	sp, sp, #76
 937              		.cfi_def_cfa_offset 128
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 938              		.loc 3 235 0
 939 0010 0446     		mov	r4, r0
 940 0012 09EE101A 		fmsr	s18, r1
 941              		.loc 3 237 0
 942 0016 002B     		cmp	r3, #0
 943 0018 00F03F81 		beq	.L40
 238:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     return;
 239:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 240:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 241:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // c2 = ltp z-axis in imu-frame
 242:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 243:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 944              		.loc 3 243 0
 945 001c 09A8     		add	r0, sp, #36
 946              	.LVL65:
 947 001e 06F16001 		add	r1, r6, #96
 948              	.LVL66:
 949 0022 FFF7FEFF 		bl	int32_rmat_of_quat
 950              	.LVL67:
 244:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 c2 = { RMAT_ELMT(ltp_to_imu_rmat, 0, 2),
 245:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 1, 2),
 246:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 2, 2)
 247:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 248:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual;
 249:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 250:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 pseudo_gravity_measurement;
 251:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 252:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.correct_gravity && ahrs_icq.ltp_vel_norm_valid) {
 951              		.loc 3 252 0
 952 0026 96F89830 		ldrb	r3, [r6, #152]	@ zero_extendqisi2
 244:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 c2 = { RMAT_ELMT(ltp_to_imu_rmat, 0, 2),
 953              		.loc 3 244 0
 954 002a 0B9D     		ldr	r5, [sp, #44]
 955              	.LVL68:
 245:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 1, 2),
 956              		.loc 3 245 0
 957 002c 0E9F     		ldr	r7, [sp, #56]
 958              	.LVL69:
 246:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 2, 2)
 959              		.loc 3 246 0
 960 002e DDF84480 		ldr	r8, [sp, #68]
 961              	.LVL70:
 962              		.loc 3 252 0
 963 0032 73B3     		cbz	r3, .L42
 964              		.loc 3 252 0 is_stmt 0 discriminator 1
 965 0034 96F88030 		ldrb	r3, [r6, #128]	@ zero_extendqisi2
 966 0038 5BB3     		cbz	r3, .L42
 967              	.LBB101:
 968              	.LBB102:
 969              	.LBB103:
 970              		.file 6 "./math/pprz_orientation_conversion.h"
   1:./math/pprz_orientation_conversion.h **** /*
   2:./math/pprz_orientation_conversion.h ****  * Copyright (C) 2011-2012 The Paparazzi Team
   3:./math/pprz_orientation_conversion.h ****  *
   4:./math/pprz_orientation_conversion.h ****  * This file is part of paparazzi.
   5:./math/pprz_orientation_conversion.h ****  *
   6:./math/pprz_orientation_conversion.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_orientation_conversion.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_orientation_conversion.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_orientation_conversion.h ****  * any later version.
  10:./math/pprz_orientation_conversion.h ****  *
  11:./math/pprz_orientation_conversion.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_orientation_conversion.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_orientation_conversion.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_orientation_conversion.h ****  * GNU General Public License for more details.
  15:./math/pprz_orientation_conversion.h ****  *
  16:./math/pprz_orientation_conversion.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_orientation_conversion.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_orientation_conversion.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_orientation_conversion.h ****  */
  20:./math/pprz_orientation_conversion.h **** 
  21:./math/pprz_orientation_conversion.h **** /**
  22:./math/pprz_orientation_conversion.h ****  * @file math/pprz_orientation_conversion.h
  23:./math/pprz_orientation_conversion.h ****  * Generic orientation representation and conversions.
  24:./math/pprz_orientation_conversion.h ****  *
  25:./math/pprz_orientation_conversion.h ****  * This file contains the functions to automatically convert between
  26:./math/pprz_orientation_conversion.h ****  * the different representations. They should normally not be used
  27:./math/pprz_orientation_conversion.h ****  * directly and instead the stateGet/Set interfaces used.
  28:./math/pprz_orientation_conversion.h ****  * Also see the @ref math_orientation_representation "Generic Orientation Representation" page.
  29:./math/pprz_orientation_conversion.h ****  *
  30:./math/pprz_orientation_conversion.h ****  * @author Felix Ruess <felix.ruess@gmail.com>
  31:./math/pprz_orientation_conversion.h ****  */
  32:./math/pprz_orientation_conversion.h **** 
  33:./math/pprz_orientation_conversion.h **** /**
  34:./math/pprz_orientation_conversion.h ****  * @addtogroup math
  35:./math/pprz_orientation_conversion.h ****  * @{
  36:./math/pprz_orientation_conversion.h ****  */
  37:./math/pprz_orientation_conversion.h **** 
  38:./math/pprz_orientation_conversion.h **** /**
  39:./math/pprz_orientation_conversion.h ****  * This generic orientation representation consists of a struct, containing the 6 orientation
  40:./math/pprz_orientation_conversion.h ****  * representations, and a status variable. The bits in the status variable indicate  which
  41:./math/pprz_orientation_conversion.h ****  * representations of the orientation are up-to-date.
  42:./math/pprz_orientation_conversion.h ****  *
  43:./math/pprz_orientation_conversion.h ****  * When a getter is used to get a certain representation, the status bit is checked to see if
  44:./math/pprz_orientation_conversion.h ****  * the current value is already available in the desired orientation representation.
  45:./math/pprz_orientation_conversion.h ****  * If the desired representation is not available, it will be calculated.
  46:./math/pprz_orientation_conversion.h ****  *
  47:./math/pprz_orientation_conversion.h ****  * When a setter is used to set a representation, all status bits are cleared, and only the
  48:./math/pprz_orientation_conversion.h ****  * status bit for the set representation is set to one.
  49:./math/pprz_orientation_conversion.h ****  */
  50:./math/pprz_orientation_conversion.h **** 
  51:./math/pprz_orientation_conversion.h **** /**
  52:./math/pprz_orientation_conversion.h ****  * @defgroup math_orientation_representation Generic Orientation Representations
  53:./math/pprz_orientation_conversion.h ****  * @{
  54:./math/pprz_orientation_conversion.h ****  */
  55:./math/pprz_orientation_conversion.h **** 
  56:./math/pprz_orientation_conversion.h **** #ifndef PPRZ_ORIENTATION_CONVERSION_H
  57:./math/pprz_orientation_conversion.h **** #define PPRZ_ORIENTATION_CONVERSION_H
  58:./math/pprz_orientation_conversion.h **** 
  59:./math/pprz_orientation_conversion.h **** #ifdef __cplusplus
  60:./math/pprz_orientation_conversion.h **** extern "C" {
  61:./math/pprz_orientation_conversion.h **** #endif
  62:./math/pprz_orientation_conversion.h **** 
  63:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_int.h"
  64:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_float.h"
  65:./math/pprz_orientation_conversion.h **** 
  66:./math/pprz_orientation_conversion.h **** #include "std.h"
  67:./math/pprz_orientation_conversion.h **** 
  68:./math/pprz_orientation_conversion.h **** 
  69:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_I  0  ///< Quaternion (BFP int)
  70:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_I 1  ///< zyx Euler (BFP int)
  71:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_I  2  ///< Rotation Matrix (BFP int)
  72:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_F  3  ///< Quaternion (float)
  73:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_F 4  ///< zyx Euler (float)
  74:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_F  5  ///< Rotation Matrix (float)
  75:./math/pprz_orientation_conversion.h **** 
  76:./math/pprz_orientation_conversion.h **** /*
  77:./math/pprz_orientation_conversion.h ****  * @brief Struct with euler/rmat/quaternion orientation representations in BFP int and float
  78:./math/pprz_orientation_conversion.h ****  */
  79:./math/pprz_orientation_conversion.h **** struct OrientationReps {
  80:./math/pprz_orientation_conversion.h ****   /**
  81:./math/pprz_orientation_conversion.h ****    * Holds the status bits for all orientation representations.
  82:./math/pprz_orientation_conversion.h ****    * When the corresponding bit is set, the representation
  83:./math/pprz_orientation_conversion.h ****    * is already computed.
  84:./math/pprz_orientation_conversion.h ****    */
  85:./math/pprz_orientation_conversion.h ****   uint8_t status;
  86:./math/pprz_orientation_conversion.h **** 
  87:./math/pprz_orientation_conversion.h ****   /**
  88:./math/pprz_orientation_conversion.h ****    * Orientation quaternion.
  89:./math/pprz_orientation_conversion.h ****    * Units: #INT32_QUAT_FRAC
  90:./math/pprz_orientation_conversion.h ****    */
  91:./math/pprz_orientation_conversion.h ****   struct Int32Quat quat_i;
  92:./math/pprz_orientation_conversion.h **** 
  93:./math/pprz_orientation_conversion.h ****   /**
  94:./math/pprz_orientation_conversion.h ****    * Orientation in zyx euler angles.
  95:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_ANGLE_FRAC
  96:./math/pprz_orientation_conversion.h ****    */
  97:./math/pprz_orientation_conversion.h ****   struct Int32Eulers eulers_i;
  98:./math/pprz_orientation_conversion.h **** 
  99:./math/pprz_orientation_conversion.h ****   /**
 100:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 101:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_TRIG_FRAC
 102:./math/pprz_orientation_conversion.h ****    */
 103:./math/pprz_orientation_conversion.h ****   struct Int32RMat rmat_i;
 104:./math/pprz_orientation_conversion.h **** 
 105:./math/pprz_orientation_conversion.h ****   /**
 106:./math/pprz_orientation_conversion.h ****    * Orientation as quaternion.
 107:./math/pprz_orientation_conversion.h ****    * Units: unit length quaternion
 108:./math/pprz_orientation_conversion.h ****    */
 109:./math/pprz_orientation_conversion.h ****   struct FloatQuat quat_f;
 110:./math/pprz_orientation_conversion.h **** 
 111:./math/pprz_orientation_conversion.h ****   /**
 112:./math/pprz_orientation_conversion.h ****    * Orienation in zyx euler angles.
 113:./math/pprz_orientation_conversion.h ****    * Units: rad
 114:./math/pprz_orientation_conversion.h ****    */
 115:./math/pprz_orientation_conversion.h ****   struct FloatEulers eulers_f;
 116:./math/pprz_orientation_conversion.h **** 
 117:./math/pprz_orientation_conversion.h ****   /**
 118:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 119:./math/pprz_orientation_conversion.h ****    * Units: rad
 120:./math/pprz_orientation_conversion.h ****    */
 121:./math/pprz_orientation_conversion.h ****   struct FloatRMat   rmat_f;
 122:./math/pprz_orientation_conversion.h **** };
 123:./math/pprz_orientation_conversion.h **** 
 124:./math/pprz_orientation_conversion.h **** /************* declaration of transformation functions ************/
 125:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_i(struct OrientationReps *orientation);
 126:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_i(struct OrientationReps *orientation);
 127:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_i(struct OrientationReps *orientation);
 128:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_f(struct OrientationReps *orientation);
 129:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_f(struct OrientationReps *orientation);
 130:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_f(struct OrientationReps *orientation);
 131:./math/pprz_orientation_conversion.h **** 
 132:./math/pprz_orientation_conversion.h **** 
 133:./math/pprz_orientation_conversion.h **** /*********************** validity test functions ******************/
 134:./math/pprz_orientation_conversion.h **** /// Test if orientations are valid.
 135:./math/pprz_orientation_conversion.h **** static inline bool_t orienationCheckValid(struct OrientationReps *orientation)
 136:./math/pprz_orientation_conversion.h **** {
 137:./math/pprz_orientation_conversion.h ****   return (orientation->status);
 138:./math/pprz_orientation_conversion.h **** }
 139:./math/pprz_orientation_conversion.h **** 
 140:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (int).
 141:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_i(struct OrientationReps *orientation, struct Int32Quat *quat
 142:./math/pprz_orientation_conversion.h **** {
 143:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_i, *quat);
 144:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 145:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_I);
 146:./math/pprz_orientation_conversion.h **** }
 147:./math/pprz_orientation_conversion.h **** 
 148:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (int).
 149:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_i(struct OrientationReps *orientation, struct Int32RMat *rmat
 150:./math/pprz_orientation_conversion.h **** {
 151:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_i, *rmat);
 152:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 153:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_I);
 154:./math/pprz_orientation_conversion.h **** }
 155:./math/pprz_orientation_conversion.h **** 
 156:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (int).
 157:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_i(struct OrientationReps *orientation, struct Int32Eulers *
 158:./math/pprz_orientation_conversion.h **** {
 159:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_i, *eulers);
 160:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 161:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_I);
 162:./math/pprz_orientation_conversion.h **** }
 163:./math/pprz_orientation_conversion.h **** 
 164:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (float).
 165:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_f(struct OrientationReps *orientation, struct FloatQuat *quat
 166:./math/pprz_orientation_conversion.h **** {
 167:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_f, *quat);
 168:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 169:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_F);
 170:./math/pprz_orientation_conversion.h **** }
 171:./math/pprz_orientation_conversion.h **** 
 172:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (float).
 173:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_f(struct OrientationReps *orientation, struct FloatRMat *rmat
 174:./math/pprz_orientation_conversion.h **** {
 175:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_f, *rmat);
 176:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 177:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_F);
 178:./math/pprz_orientation_conversion.h **** }
 179:./math/pprz_orientation_conversion.h **** 
 180:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (float).
 181:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_f(struct OrientationReps *orientation, struct FloatEulers *
 182:./math/pprz_orientation_conversion.h **** {
 183:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_f, *eulers);
 184:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 185:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_F);
 186:./math/pprz_orientation_conversion.h **** }
 187:./math/pprz_orientation_conversion.h **** 
 188:./math/pprz_orientation_conversion.h **** 
 189:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (int).
 190:./math/pprz_orientation_conversion.h **** static inline struct Int32Quat *orientationGetQuat_i(struct OrientationReps *orientation)
 191:./math/pprz_orientation_conversion.h **** {
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 194:./math/pprz_orientation_conversion.h ****   }
 195:./math/pprz_orientation_conversion.h ****   return &orientation->quat_i;
 196:./math/pprz_orientation_conversion.h **** }
 197:./math/pprz_orientation_conversion.h **** 
 198:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude rotation matrix (int).
 199:./math/pprz_orientation_conversion.h **** static inline struct Int32RMat *orientationGetRMat_i(struct OrientationReps *orientation)
 200:./math/pprz_orientation_conversion.h **** {
 201:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_RMAT_I)) {
 971              		.loc 6 201 0 is_stmt 1 discriminator 1
 972 003a 96F8B030 		ldrb	r3, [r6, #176]	@ zero_extendqisi2
 973              	.LBE103:
 974              	.LBE102:
 253:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /*
 254:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * centrifugal acceleration in body frame
 255:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * a_c_body = omega x (omega x r)
 256:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * (omega x r) = tangential velocity in body frame
 257:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * a_c_body = omega x vel_tangential_body
 258:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * assumption: tangential velocity only along body x-axis
 259:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      */
 260:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 261:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // FIXME: check overflows !
 262:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define COMPUTATION_FRAC 16
 263:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define ACC_FROM_CROSS_FRAC INT32_RATE_FRAC + INT32_SPEED_FRAC - INT32_ACCEL_FRAC - COMPUTATION_FRA
 264:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 265:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const struct Int32Vect3 vel_tangential_body =
 266:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       {ahrs_icq.ltp_vel_norm >> COMPUTATION_FRAC, 0, 0};
 975              		.loc 3 266 0 discriminator 1
 976 003e B6F97E90 		ldrsh	r9, [r6, #126]
 977              	.LVL71:
 978              	.LBB105:
 979              	.LBB104:
 980              		.loc 6 201 0 discriminator 1
 981 0042 5B07     		lsls	r3, r3, #29
 982 0044 03D4     		bmi	.L43
 202:./math/pprz_orientation_conversion.h ****     orientationCalcRMat_i(orientation);
 983              		.loc 6 202 0
 984 0046 06F1B000 		add	r0, r6, #176
 985 004a FFF7FEFF 		bl	orientationCalcRMat_i
 986              	.LVL72:
 987              	.L43:
 988              	.LBE104:
 989              	.LBE105:
 267:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32RMat *body_to_imu_rmat = orientationGetRMat_i(&ahrs_icq.body_to_imu);
 268:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Rates body_rate;
 269:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_rmat_transp_ratemult(&body_rate, body_to_imu_rmat, &ahrs_icq.imu_rate);
 990              		.loc 3 269 0
 991 004e 9B49     		ldr	r1, .L68+20
 992 0050 6846     		mov	r0, sp
 993 0052 A1F1C402 		sub	r2, r1, #196
 994 0056 FFF7FEFF 		bl	int32_rmat_transp_ratemult
 995              	.LVL73:
 270:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Vect3 acc_c_body;
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_RATES_CROSS_VECT3(acc_c_body, body_rate, vel_tangential_body);
 996              		.loc 3 271 0
 997 005a 0023     		movs	r3, #0
 998 005c 0393     		str	r3, [sp, #12]
 999 005e 029B     		ldr	r3, [sp, #8]
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 273:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 274:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* convert centrifucal acceleration from body to imu frame */
 275:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Vect3 acc_c_imu;
 276:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_rmat_vmult(&acc_c_imu, body_to_imu_rmat, &acc_c_body);
 1000              		.loc 3 276 0
 1001 0060 9649     		ldr	r1, .L68+20
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_RATES_CROSS_VECT3(acc_c_body, body_rate, vel_tangential_body);
 1002              		.loc 3 271 0
 1003 0062 09FB03F3 		mul	r3, r9, r3
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1004              		.loc 3 272 0
 1005 0066 5B11     		asrs	r3, r3, #5
 1006 0068 0493     		str	r3, [sp, #16]
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_RATES_CROSS_VECT3(acc_c_body, body_rate, vel_tangential_body);
 1007              		.loc 3 271 0
 1008 006a 019B     		ldr	r3, [sp, #4]
 1009 006c 09FB03F3 		mul	r3, r9, r3
 1010 0070 5B42     		negs	r3, r3
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1011              		.loc 3 272 0
 1012 0072 5B11     		asrs	r3, r3, #5
 1013              		.loc 3 276 0
 1014 0074 06A8     		add	r0, sp, #24
 1015 0076 03AA     		add	r2, sp, #12
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1016              		.loc 3 272 0
 1017 0078 0593     		str	r3, [sp, #20]
 1018              		.loc 3 276 0
 1019 007a FFF7FEFF 		bl	int32_rmat_vmult
 1020              	.LVL74:
 277:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 278:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* and subtract it from imu measurement to get a corrected measurement
 279:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * of the gravity vector */
 280:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_DIFF(pseudo_gravity_measurement, *accel, acc_c_imu);
 1021              		.loc 3 280 0
 1022 007e 069B     		ldr	r3, [sp, #24]
 1023 0080 2268     		ldr	r2, [r4]
 1024 0082 6068     		ldr	r0, [r4, #4]
 1025 0084 A168     		ldr	r1, [r4, #8]
 1026 0086 D21A     		subs	r2, r2, r3
 1027              	.LVL75:
 1028 0088 079B     		ldr	r3, [sp, #28]
 1029 008a C01A     		subs	r0, r0, r3
 1030              	.LVL76:
 1031 008c 089B     		ldr	r3, [sp, #32]
 1032 008e C91A     		subs	r1, r1, r3
 1033              	.LVL77:
 1034              	.LBE101:
 252:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.correct_gravity && ahrs_icq.ltp_vel_norm_valid) {
 1035              		.loc 3 252 0
 1036 0090 02E0     		b	.L44
 1037              	.LVL78:
 1038              	.L42:
 281:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 282:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_COPY(pseudo_gravity_measurement, *accel);
 1039              		.loc 3 282 0
 1040 0092 2268     		ldr	r2, [r4]
 1041              	.LVL79:
 1042 0094 6068     		ldr	r0, [r4, #4]
 1043              	.LVL80:
 1044 0096 A168     		ldr	r1, [r4, #8]
 1045              	.LVL81:
 1046              	.L44:
 283:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 284:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 285:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* compute the residual of the pseudo gravity vector in imu frame */
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, pseudo_gravity_measurement, c2);
 287:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 288:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 289:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* FIR filtered pseudo_gravity_measurement */
 290:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define FIR_FILTER_SIZE 8
 291:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   static struct Int32Vect3 filtered_gravity_measurement = {0, 0, 0};
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_SMUL(filtered_gravity_measurement, filtered_gravity_measurement, FIR_FILTER_SIZE - 1);
 1047              		.loc 3 292 0
 1048 0098 894B     		ldr	r3, .L68+24
 1049 009a 5C68     		ldr	r4, [r3, #4]
 1050              	.LVL82:
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, pseudo_gravity_measurement, c2);
 1051              		.loc 3 286 0
 1052 009c 08FB00FA 		mul	r10, r8, r0
 1053 00a0 07FB11AA 		mls	r10, r7, r1, r10
 1054              	.LVL83:
 1055              		.loc 3 292 0
 1056 00a4 C4EBC404 		rsb	r4, r4, r4, lsl #3
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, pseudo_gravity_measurement, c2);
 1057              		.loc 3 286 0
 1058 00a8 5743     		muls	r7, r2, r7
 1059              	.LVL84:
 1060 00aa 05FB01F9 		mul	r9, r5, r1
 1061 00ae 05FB1077 		mls	r7, r5, r0, r7
 1062              		.loc 3 292 0
 1063 00b2 1D68     		ldr	r5, [r3]
 1064              	.LVL85:
 293:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1065              		.loc 3 293 0
 1066 00b4 2044     		add	r0, r0, r4
 1067              	.LVL86:
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_SMUL(filtered_gravity_measurement, filtered_gravity_measurement, FIR_FILTER_SIZE - 1);
 1068              		.loc 3 292 0
 1069 00b6 9C68     		ldr	r4, [r3, #8]
 1070 00b8 C5EBC505 		rsb	r5, r5, r5, lsl #3
 1071 00bc C4EBC404 		rsb	r4, r4, r4, lsl #3
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, pseudo_gravity_measurement, c2);
 1072              		.loc 3 286 0
 1073 00c0 08FB1299 		mls	r9, r8, r2, r9
 1074              	.LVL87:
 1075              		.loc 3 293 0
 1076 00c4 2144     		add	r1, r1, r4
 1077              	.LVL88:
 1078 00c6 2A44     		add	r2, r2, r5
 1079              	.LVL89:
 294:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_SDIV(filtered_gravity_measurement, filtered_gravity_measurement, FIR_FILTER_SIZE);
 1080              		.loc 3 294 0
 1081 00c8 0824     		movs	r4, #8
 1082 00ca 92FBF4F2 		sdiv	r2, r2, r4
 1083 00ce 90FBF4F0 		sdiv	r0, r0, r4
 1084 00d2 91FBF4F4 		sdiv	r4, r1, r4
 1085 00d6 1A60     		str	r2, [r3]
 1086 00d8 5860     		str	r0, [r3, #4]
 1087 00da 9C60     		str	r4, [r3, #8]
 295:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 296:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 297:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.gravity_heuristic_factor) {
 1088              		.loc 3 297 0
 1089 00dc 96F89930 		ldrb	r3, [r6, #153]	@ zero_extendqisi2
 1090 00e0 DFF8D481 		ldr	r8, .L68+16
 1091              	.LVL90:
 1092 00e4 B7EE008A 		fconsts	s16, #112
 1093 00e8 002B     		cmp	r3, #0
 1094 00ea 5FD0     		beq	.L45
 1095              	.LBB106:
 298:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* heuristic on acceleration (gravity estimate) norm */
 299:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* Factor how strongly to change the weight.
 300:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * e.g. for gravity_heuristic_factor 30:
 301:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * <0.66G = 0, 1G = 1.0, >1.33G = 0
 302:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      */
 303:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 304:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct FloatVect3 g_meas_f;
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ACCELS_FLOAT_OF_BFP(g_meas_f, filtered_gravity_measurement);
 1096              		.loc 3 305 0
 1097 00ec 07EE900A 		fmsr	s15, r0	@ int
 1098 00f0 05EE902A 		fmsr	s11, r2	@ int
 1099 00f4 DFED736A 		flds	s13, .L68+28
 1100 00f8 B8EEE77A 		fsitos	s14, s15
 1101 00fc B8EEE56A 		fsitos	s12, s11
 1102 0100 27EE267A 		fmuls	s14, s14, s13
 1103 0104 26EE266A 		fmuls	s12, s12, s13
 1104              	.LVL91:
 1105 0108 05EE904A 		fmsr	s11, r4	@ int
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1106              		.loc 3 306 0
 1107 010c 27EE077A 		fmuls	s14, s14, s14
 1108              	.LVL92:
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ACCELS_FLOAT_OF_BFP(g_meas_f, filtered_gravity_measurement);
 1109              		.loc 3 305 0
 1110 0110 F8EEE57A 		fsitos	s15, s11
 1111              		.loc 3 306 0
 1112 0114 A6EE067A 		vfma.f32	s14, s12, s12
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ACCELS_FLOAT_OF_BFP(g_meas_f, filtered_gravity_measurement);
 1113              		.loc 3 305 0
 1114 0118 67EEA66A 		fmuls	s13, s15, s13
 1115              	.LVL93:
 1116              		.loc 3 306 0
 1117 011c A6EEA67A 		vfma.f32	s14, s13, s13
 1118 0120 17EE100A 		fmrs	r0, s14
 1119              	.LVL94:
 1120 0124 FFF7FEFF 		bl	sqrtf
 1121              	.LVL95:
 1122 0128 8346     		mov	fp, r0	@ float
 1123              	.LVL96:
 307:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0 - ahrs_icq.gravity_heuristic_factor * fabs(1.0 - g_meas_norm) / 10;
 1124              		.loc 3 307 0
 1125 012a 98F89900 		ldrb	r0, [r8, #153]	@ zero_extendqisi2
 1126              	.LVL97:
 1127 012e FFF7FEFF 		bl	__aeabi_i2d
 1128              	.LVL98:
 1129 0132 0446     		mov	r4, r0
 1130              	.LVL99:
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1131              		.loc 3 306 0
 1132 0134 5846     		mov	r0, fp	@ float
 1133              		.loc 3 307 0
 1134 0136 0D46     		mov	r5, r1
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1135              		.loc 3 306 0
 1136 0138 FFF7FEFF 		bl	__aeabi_f2d
 1137              	.LVL100:
 1138 013c 5AA3     		adr	r3, .L68
 1139 013e D3E90023 		ldrd	r2, [r3]
 1140 0142 FFF7FEFF 		bl	__aeabi_ddiv
 1141              	.LVL101:
 1142 0146 FFF7FEFF 		bl	__aeabi_d2f
 1143              	.LVL102:
 1144              		.loc 3 307 0
 1145 014a FFF7FEFF 		bl	__aeabi_f2d
 1146              	.LVL103:
 1147 014e 0246     		mov	r2, r0
 1148 0150 0B46     		mov	r3, r1
 1149 0152 0020     		movs	r0, #0
 1150 0154 5C49     		ldr	r1, .L68+32
 1151 0156 FFF7FEFF 		bl	__aeabi_dsub
 1152              	.LVL104:
 1153 015a 0246     		mov	r2, r0
 1154 015c 21F00043 		bic	r3, r1, #-2147483648
 1155 0160 2046     		mov	r0, r4
 1156 0162 2946     		mov	r1, r5
 1157 0164 FFF7FEFF 		bl	__aeabi_dmul
 1158              	.LVL105:
 1159 0168 0022     		movs	r2, #0
 1160 016a 584B     		ldr	r3, .L68+36
 1161 016c FFF7FEFF 		bl	__aeabi_ddiv
 1162              	.LVL106:
 1163 0170 0246     		mov	r2, r0
 1164 0172 0B46     		mov	r3, r1
 1165 0174 0020     		movs	r0, #0
 1166 0176 5449     		ldr	r1, .L68+32
 1167 0178 FFF7FEFF 		bl	__aeabi_dsub
 1168              	.LVL107:
 1169 017c FFF7FEFF 		bl	__aeabi_d2f
 1170              	.LVL108:
 1171 0180 08EE900A 		fmsr	s17, r0
 308:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     Bound(ahrs_icq.weight, 0.15, 1.0);
 1172              		.loc 3 308 0
 1173 0184 F4EEC88A 		fcmpes	s17, s16
 1174 0188 F1EE10FA 		fmstat
 1175 018c 0EDC     		bgt	.L45
 1176              		.loc 3 308 0 is_stmt 0 discriminator 2
 1177 018e FFF7FEFF 		bl	__aeabi_f2d
 1178              	.LVL109:
 1179 0192 47A3     		adr	r3, .L68+8
 1180 0194 D3E90023 		ldrd	r2, [r3]
 1181 0198 FFF7FEFF 		bl	__aeabi_dcmplt
 1182              	.LVL110:
 1183 019c 10B9     		cbnz	r0, .L49
 307:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0 - ahrs_icq.gravity_heuristic_factor * fabs(1.0 - g_meas_norm) / 10;
 1184              		.loc 3 307 0 is_stmt 1
 1185 019e C8ED218A 		fsts	s17, [r8, #132]
 1186 01a2 05E0     		b	.L48
 1187              	.L49:
 1188              		.loc 3 308 0 discriminator 1
 1189 01a4 4A4B     		ldr	r3, .L68+40
 1190 01a6 C8F88430 		str	r3, [r8, #132]	@ float
 1191 01aa 01E0     		b	.L48
 1192              	.LVL111:
 1193              	.L45:
 1194              	.LBE106:
 309:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 310:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0;
 1195              		.loc 3 310 0
 1196 01ac 88ED218A 		fsts	s16, [r8, #132]
 1197              	.L48:
 311:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 312:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 313:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportional gain.
 314:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * zeta * omega
 315:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.accel_cnt
 316:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.accel_cnt beeing the number of propagations since last update
 317:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 318:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC : ACCEL_FRAC + TRIG_FRAC = 10 + 14 = 24
 319:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 320:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC_conversion: 2^12 / 2^24 = 1 / 4096
 321:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * cross_product_gain : 9.81 m/s2
 322:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 323:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 1 / (Kp * FRAC_conversion / cross_product_gain)
 324:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 4096 * 9.81 / Kp
 325:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 326:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = 1 / (weight * Kp * FRAC_conversion / cross_product_gain)
 327:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = 1 / Kp / weight
 328:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = accel_inv_kp / accel_cnt / weight
 329:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_scale = (int32_t)(ahrs_icq.accel_inv_kp / ahrs_icq.accel_cnt
 1198              		.loc 3 330 0
 1199 01b0 B6F8AC30 		ldrh	r3, [r6, #172]
 1200 01b4 D6ED226A 		flds	s13, [r6, #136]
 331:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                      / ahrs_icq.weight);
 1201              		.loc 3 331 0
 1202 01b8 D6ED217A 		flds	s15, [r6, #132]
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_scale = (int32_t)(ahrs_icq.accel_inv_kp / ahrs_icq.accel_cnt
 1203              		.loc 3 330 0
 1204 01bc 07EE103A 		fmsr	s14, r3	@ int
 1205 01c0 B8EEC77A 		fsitos	s14, s14
 1206 01c4 86EE877A 		fdivs	s14, s13, s14
 1207              		.loc 3 331 0
 1208 01c8 87EE277A 		fdivs	s14, s14, s15
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_scale = (int32_t)(ahrs_icq.accel_inv_kp / ahrs_icq.accel_cnt
 1209              		.loc 3 330 0
 1210 01cc BDEEC77A 		ftosizs	s14, s14
 1211 01d0 17EE103A 		fmrs	r3, s14	@ int
 1212              	.LVL112:
 332:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   Bound(inv_rate_scale, 8192, 4194304);
 1213              		.loc 3 332 0
 1214 01d4 B3F5800F 		cmp	r3, #4194304
 1215 01d8 05DC     		bgt	.L53
 1216              		.loc 3 332 0 is_stmt 0 discriminator 2
 1217 01da B3F5005F 		cmp	r3, #8192
 1218 01de B8BF     		it	lt
 1219 01e0 4FF40053 		movlt	r3, #8192
 1220              	.LVL113:
 1221 01e4 01E0     		b	.L50
 1222              	.LVL114:
 1223              	.L53:
 1224              		.loc 3 332 0
 1225 01e6 4FF48003 		mov	r3, #4194304
 1226              	.LVL115:
 1227              	.L50:
 333:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p -= residual.x / inv_rate_scale;
 335:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 336:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r -= residual.z / inv_rate_scale;
 337:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 338:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // reset accel propagation counter
 339:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 340:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 341:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 342:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 343:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 344:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 345:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC = ACCEL_FRAC + TRIG_FRAC = 10 + 14 = 24
 346:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias = RATE_FRAC+28 = 40
 347:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC_conversion: 2^40 / 2^24 = 2^16
 348:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * cross_product_gain : 9.81 m/s2
 349:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 350:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / (Ki * FRAC_conversion / cross_product_gain)
 351:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / 2^16 * 9.81 * Ki = 9.81 / 2^11 * Ki
 352:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 353:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_bias_gain = 2^5 / (weight^2 * Ki * FRAC_conversion / cross_product_gain)
 354:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_bias_gain = accel_inv_ki / weight^2
 355:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 356:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_bias_gain = (int32_t)(ahrs_icq.accel_inv_ki /
 358:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                     (dt * ahrs_icq.weight * ahrs_icq.weight));
 1228              		.loc 3 358 0 is_stmt 1
 1229 01ea 29EE279A 		fmuls	s18, s18, s15
 1230              	.LVL116:
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p -= residual.x / inv_rate_scale;
 1231              		.loc 3 334 0
 1232 01ee B269     		ldr	r2, [r6, #24]
 1233              		.loc 3 358 0
 1234 01f0 69EE277A 		fmuls	s15, s18, s15
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_bias_gain = (int32_t)(ahrs_icq.accel_inv_ki /
 1235              		.loc 3 357 0
 1236 01f4 96ED239A 		flds	s18, [r6, #140]
 1237 01f8 C9EE277A 		fdivs	s15, s18, s15
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p -= residual.x / inv_rate_scale;
 1238              		.loc 3 334 0
 1239 01fc 9AFBF3F1 		sdiv	r1, r10, r3
 1240 0200 521A     		subs	r2, r2, r1
 1241 0202 B261     		str	r2, [r6, #24]
 335:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 1242              		.loc 3 335 0
 1243 0204 F269     		ldr	r2, [r6, #28]
 1244 0206 99FBF3F1 		sdiv	r1, r9, r3
 1245 020a 521A     		subs	r2, r2, r1
 1246 020c F261     		str	r2, [r6, #28]
 336:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r -= residual.z / inv_rate_scale;
 1247              		.loc 3 336 0
 1248 020e 326A     		ldr	r2, [r6, #32]
 1249 0210 97FBF3F3 		sdiv	r3, r7, r3
 1250              	.LVL117:
 1251 0214 D21A     		subs	r2, r2, r3
 339:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 1252              		.loc 3 339 0
 1253 0216 0023     		movs	r3, #0
 336:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r -= residual.z / inv_rate_scale;
 1254              		.loc 3 336 0
 1255 0218 3262     		str	r2, [r6, #32]
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_bias_gain = (int32_t)(ahrs_icq.accel_inv_ki /
 1256              		.loc 3 357 0
 1257 021a FDEEE77A 		ftosizs	s15, s15
 339:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 1258              		.loc 3 339 0
 1259 021e A6F8AC30 		strh	r3, [r6, #172]	@ movhi
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_bias_gain = (int32_t)(ahrs_icq.accel_inv_ki /
 1260              		.loc 3 357 0
 1261 0222 17EE901A 		fmrs	r1, s15	@ int
 1262              	.LVL118:
 359:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   Bound(inv_bias_gain, 8, 65536)
 1263              		.loc 3 359 0
 1264 0226 B1F5803F 		cmp	r1, #65536
 1265 022a 03DC     		bgt	.L55
 1266              		.loc 3 359 0 is_stmt 0 discriminator 2
 1267 022c 0829     		cmp	r1, #8
 1268 022e B8BF     		it	lt
 1269 0230 0821     		movlt	r1, #8
 1270              	.LVL119:
 1271 0232 01E0     		b	.L51
 1272              	.LVL120:
 1273              	.L55:
 1274              		.loc 3 359 0
 1275 0234 4FF48031 		mov	r1, #65536
 1276              	.LVL121:
 1277              	.L51:
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1278              		.loc 3 360 0 is_stmt 1 discriminator 1
 1279 0238 D6E91223 		ldrd	r2, [r6, #72]
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1280              		.loc 3 361 0 discriminator 1
 1281 023c D6E91445 		ldrd	r4, [r6, #80]
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1282              		.loc 3 360 0 discriminator 1
 1283 0240 9AFBF1FA 		sdiv	r10, r10, r1
 1284              	.LVL122:
 1285 0244 4FEA4A1A 		lsl	r10, r10, #5
 1286              		.loc 3 361 0 discriminator 1
 1287 0248 99FBF1F9 		sdiv	r9, r9, r1
 1288              	.LVL123:
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1289              		.loc 3 362 0 discriminator 1
 1290 024c 97FBF1F7 		sdiv	r7, r7, r1
 1291              	.LVL124:
 1292 0250 D6E91601 		ldrd	r0, [r6, #88]
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1293              		.loc 3 360 0 discriminator 1
 1294 0254 12EB0A02 		adds	r2, r2, r10
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1295              		.loc 3 361 0 discriminator 1
 1296 0258 4FEA4919 		lsl	r9, r9, #5
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1297              		.loc 3 360 0 discriminator 1
 1298 025c 43EBEA73 		adc	r3, r3, r10, asr #31
 1299              		.loc 3 362 0 discriminator 1
 1300 0260 7F01     		lsls	r7, r7, #5
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1301              		.loc 3 361 0 discriminator 1
 1302 0262 14EB0904 		adds	r4, r4, r9
 1303 0266 45EBE975 		adc	r5, r5, r9, asr #31
 363:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 364:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 1304              		.loc 3 364 0 discriminator 1
 1305 026a 4FEA1278 		lsr	r8, r2, #28
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1306              		.loc 3 362 0 discriminator 1
 1307 026e C019     		adds	r0, r0, r7
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1308              		.loc 3 360 0 discriminator 1
 1309 0270 C6E91223 		strd	r2, [r6, #72]
 1310              		.loc 3 364 0 discriminator 1
 1311 0274 4FEA1472 		lsr	r2, r4, #28
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1312              		.loc 3 362 0 discriminator 1
 1313 0278 41EBE771 		adc	r1, r1, r7, asr #31
 1314              	.LVL125:
 1315              		.loc 3 364 0 discriminator 1
 1316 027c 42EA0512 		orr	r2, r2, r5, lsl #4
 1317 0280 7260     		str	r2, [r6, #4]
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1318              		.loc 3 361 0 discriminator 1
 1319 0282 C6E91445 		strd	r4, [r6, #80]
 1320              		.loc 3 364 0 discriminator 1
 1321 0286 020F     		lsrs	r2, r0, #28
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1322              		.loc 3 362 0 discriminator 1
 1323 0288 C6E91601 		strd	r0, [r6, #88]
 1324              		.loc 3 364 0 discriminator 1
 1325 028c 48EA0318 		orr	r8, r8, r3, lsl #4
 1326 0290 42EA0112 		orr	r2, r2, r1, lsl #4
 1327 0294 C6F80080 		str	r8, [r6]
 1328 0298 B260     		str	r2, [r6, #8]
 1329              	.L40:
 365:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 366:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1330              		.loc 3 366 0
 1331 029a 13B0     		add	sp, sp, #76
 1332              		@ sp needed
 1333 029c BDEC048B 		fldmfdd	sp!, {d8-d9}
 1334 02a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1335              	.L69:
 1336 02a4 AFF30080 		.align	3
 1337              	.L68:
 1338 02a8 1F85EB51 		.word	1374389535
 1339 02ac B89E2340 		.word	1076076216
 1340 02b0 33333333 		.word	858993459
 1341 02b4 3333C33F 		.word	1069757235
 1342 02b8 00000000 		.word	.LANCHOR0
 1343 02bc D0000000 		.word	.LANCHOR0+208
 1344 02c0 00000000 		.word	.LANCHOR1
 1345 02c4 0000803A 		.word	981467136
 1346 02c8 0000F03F 		.word	1072693248
 1347 02cc 00002440 		.word	1076101120
 1348 02d0 9A99193E 		.word	1041865114
 1349              		.cfi_endproc
 1350              	.LFE93:
 1352 02d4 AFF30080 		.section	.text.ahrs_icq_update_mag,"ax",%progbits
 1353              		.align	1
 1354              		.global	ahrs_icq_update_mag
 1355              		.thumb
 1356              		.thumb_func
 1358              	ahrs_icq_update_mag:
 1359              	.LFB94:
 367:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 368:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 369:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_mag(struct Int32Vect3 *mag, float dt)
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1360              		.loc 3 370 0
 1361              		.cfi_startproc
 1362              		@ args = 0, pretend = 0, frame = 72
 1363              		@ frame_needed = 0, uses_anonymous_args = 0
 1364              	.LVL126:
 1365 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1366              		.cfi_def_cfa_offset 28
 1367              		.cfi_offset 4, -28
 1368              		.cfi_offset 5, -24
 1369              		.cfi_offset 6, -20
 1370              		.cfi_offset 7, -16
 1371              		.cfi_offset 8, -12
 1372              		.cfi_offset 9, -8
 1373              		.cfi_offset 14, -4
 371:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 372:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.mag_cnt == 0) {
 1374              		.loc 3 372 0
 1375 0004 554B     		ldr	r3, .L83
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1376              		.loc 3 370 0
 1377 0006 2DED028B 		fstmfdd	sp!, {d8}
 1378              		.cfi_def_cfa_offset 36
 1379              		.cfi_offset 80, -36
 1380              		.loc 3 372 0
 1381 000a B3F8AE20 		ldrh	r2, [r3, #174]
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1382              		.loc 3 370 0
 1383 000e 93B0     		sub	sp, sp, #76
 1384              		.cfi_def_cfa_offset 112
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1385              		.loc 3 370 0
 1386 0010 0646     		mov	r6, r0
 1387 0012 08EE101A 		fmsr	s16, r1
 1388              		.loc 3 372 0
 1389 0016 002A     		cmp	r2, #0
 1390 0018 00F09A80 		beq	.L70
 1391              	.LVL127:
 1392              	.LBB123:
 1393              	.LBB124:
 373:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     return;
 374:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 375:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_MAG_UPDATE_ALL_AXES
 376:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_update_mag_full(mag, dt);
 377:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 378:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_update_mag_2d(mag, dt);
 379:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 380:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // reset mag propagation counter
 381:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 382:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 383:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 384:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_mag_gains(void)
 385:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 386:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain = 2*omega*zeta */
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_kp = 2 * ahrs_icq.mag_zeta * ahrs_icq.mag_omega;
 388:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain = omega^2 */
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_ki = ahrs_icq.mag_omega * ahrs_icq.mag_omega;
 390:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 391:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 392:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 393:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_full(struct Int32Vect3 *mag, float dt)
 394:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 395:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 396:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 397:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 398:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 399:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 expected_imu;
 400:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&expected_imu, &ltp_to_imu_rmat, &ahrs_icq.mag_h);
 401:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 402:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual;
 403:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, *mag, expected_imu);
 404:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 405:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain.
 406:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * mag_zeta * mag_omega
 407:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.mag_cnt
 408:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.mag_cnt beeing the number of propagations since last update
 409:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 410:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC: 2 * MAG_FRAC = 22
 411:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 412:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^12 / 2^22 = 1/1024
 413:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 414:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1 / Kp / FRAC_conversion
 415:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1024 / Kp
 416:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 417:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 418:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   const int32_t inv_rate_gain = (int32_t)(1024.0 / (ahrs_icq.mag_kp * ahrs_icq.mag_cnt));
 419:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 420:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += residual.x / inv_rate_gain;
 421:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += residual.y / inv_rate_gain;
 422:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual.z / inv_rate_gain;
 423:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 424:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 425:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 426:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 427:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 428:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC: 2* MAG_FRAC = 22
 429:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias FRAC: RATE_FRAC+28 = 40
 430:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^40 / 2^22 = 2^18
 431:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 432:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * bias_gain = Ki * FRAC_conversion = Ki * 2^18
 433:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 434:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   const int32_t bias_gain = (int32_t)(ahrs_icq.mag_ki * dt * (1 << 18));
 435:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 436:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= residual.x * bias_gain;
 437:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= residual.y * bias_gain;
 438:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r -= residual.z * bias_gain;
 439:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 440:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 441:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 442:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 443:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 444:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 445:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 446:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_2d(struct Int32Vect3 *mag, float dt)
 447:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 448:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 449:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 expected_ltp = {ahrs_icq.mag_h.x, ahrs_icq.mag_h.y};
 1394              		.loc 3 449 0
 1395 001c 5D6F     		ldr	r5, [r3, #116]
 1396 001e 1C6F     		ldr	r4, [r3, #112]
 1397              	.LVL128:
 1398              	.LBB125:
 1399              	.LBB126:
 1400              	.LBB127:
 1401              	.LBB128:
 1402              	.LBB129:
 1403              	.LBB130:
 244:./math/pprz_algebra_int.h ****   return v->x * v->x + v->y * v->y;
 1404              		.loc 2 244 0
 1405 0020 05FB05F0 		mul	r0, r5, r5
 1406              	.LVL129:
 1407              	.LBE130:
 1408              	.LBE129:
 250:./math/pprz_algebra_int.h ****   return int32_sqrt(int32_vect2_norm2(v));
 1409              		.loc 2 250 0
 1410 0024 04FB0400 		mla	r0, r4, r4, r0
 1411 0028 FFF7FEFF 		bl	int32_sqrt
 1412              	.LVL130:
 1413              	.LBE128:
 1414              	.LBE127:
 257:./math/pprz_algebra_int.h ****   if (n > 0) {
 1415              		.loc 2 257 0
 1416 002c 28B1     		cbz	r0, .L72
 1417              	.LVL131:
 1418              	.LBB131:
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 1419              		.loc 2 259 0
 1420 002e E402     		lsls	r4, r4, #11
 1421              	.LVL132:
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1422              		.loc 2 260 0
 1423 0030 ED02     		lsls	r5, r5, #11
 1424              	.LVL133:
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 1425              		.loc 2 259 0
 1426 0032 94FBF0F4 		sdiv	r4, r4, r0
 1427              	.LVL134:
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1428              		.loc 2 260 0
 1429 0036 95FBF0F5 		sdiv	r5, r5, r0
 1430              	.LVL135:
 1431              	.L72:
 1432              	.LBE131:
 1433              	.LBE126:
 1434              	.LBE125:
 450:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* normalize expected ltp in 2D (x,y) */
 451:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_vect2_normalize(&expected_ltp, INT32_MAG_FRAC);
 452:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 453:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 454:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 1435              		.loc 3 454 0
 1436 003a 09A8     		add	r0, sp, #36
 1437 003c 4849     		ldr	r1, .L83+4
 1438 003e FFF7FEFF 		bl	int32_rmat_of_quat
 1439              	.LVL136:
 455:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 456:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 measured_ltp;
 457:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_transp_vmult(&measured_ltp, &ltp_to_imu_rmat, mag);
 1440              		.loc 3 457 0
 1441 0042 6846     		mov	r0, sp
 1442 0044 3246     		mov	r2, r6
 1443 0046 09A9     		add	r1, sp, #36
 1444 0048 FFF7FEFF 		bl	int32_rmat_transp_vmult
 1445              	.LVL137:
 458:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 459:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* normalize measured ltp in 2D (x,y) */
 460:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 measured_ltp_2d = {measured_ltp.x, measured_ltp.y};
 1446              		.loc 3 460 0
 1447 004c 019E     		ldr	r6, [sp, #4]
 1448              	.LVL138:
 1449 004e DDF80080 		ldr	r8, [sp]
 1450              	.LVL139:
 1451              	.LBB132:
 1452              	.LBB133:
 1453              	.LBB134:
 1454              	.LBB135:
 1455              	.LBB136:
 1456              	.LBB137:
 244:./math/pprz_algebra_int.h ****   return v->x * v->x + v->y * v->y;
 1457              		.loc 2 244 0
 1458 0052 06FB06F0 		mul	r0, r6, r6
 1459              	.LBE137:
 1460              	.LBE136:
 250:./math/pprz_algebra_int.h ****   return int32_sqrt(int32_vect2_norm2(v));
 1461              		.loc 2 250 0
 1462 0056 08FB0800 		mla	r0, r8, r8, r0
 1463 005a FFF7FEFF 		bl	int32_sqrt
 1464              	.LVL140:
 1465              	.LBE135:
 1466              	.LBE134:
 257:./math/pprz_algebra_int.h ****   if (n > 0) {
 1467              		.loc 2 257 0
 1468 005e 30B1     		cbz	r0, .L73
 1469              	.LVL141:
 1470              	.LBB138:
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 1471              		.loc 2 259 0
 1472 0060 4FEAC828 		lsl	r8, r8, #11
 1473              	.LVL142:
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1474              		.loc 2 260 0
 1475 0064 F602     		lsls	r6, r6, #11
 1476              	.LVL143:
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 1477              		.loc 2 259 0
 1478 0066 98FBF0F8 		sdiv	r8, r8, r0
 1479              	.LVL144:
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1480              		.loc 2 260 0
 1481 006a 96FBF0F6 		sdiv	r6, r6, r0
 1482              	.LVL145:
 1483              	.L73:
 1484              	.LBE138:
 1485              	.LBE133:
 1486              	.LBE132:
 461:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_vect2_normalize(&measured_ltp_2d, INT32_MAG_FRAC);
 462:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 463:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* residual_ltp FRAC: 2 * MAG_FRAC - 5 = 17 */
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 465:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 466:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     (measured_ltp_2d.x * expected_ltp.y - measured_ltp_2d.y * expected_ltp.x) / (1 << 5)
 1487              		.loc 3 467 0
 1488 006e 05FB08F5 		mul	r5, r5, r8
 1489              	.LVL146:
 1490 0072 04FB1654 		mls	r4, r4, r6, r5
 1491              	.LVL147:
 1492 0076 2023     		movs	r3, #32
 468:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 469:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 470:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 471:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_imu;
 472:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 473:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 474:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain.
 475:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * mag_zeta * mag_omega
 476:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.mag_cnt
 477:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.mag_cnt beeing the number of propagations since last update
 478:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 479:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual_imu FRAC = residual_ltp FRAC = 17
 480:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 481:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^12 / 2^17 = 1/32
 482:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 483:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1 / Kp / FRAC_conversion
 484:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 32 / Kp
 485:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 486:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_gain = (int32_t)(32.0 / (ahrs_icq.mag_kp * ahrs_icq.mag_cnt));
 1493              		.loc 3 486 0
 1494 0078 384E     		ldr	r6, .L83
 1495              	.LVL148:
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     (measured_ltp_2d.x * expected_ltp.y - measured_ltp_2d.y * expected_ltp.x) / (1 << 5)
 1496              		.loc 3 467 0
 1497 007a 94FBF3F4 		sdiv	r4, r4, r3
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1498              		.loc 3 464 0
 1499 007e 0027     		movs	r7, #0
 472:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 1500              		.loc 3 472 0
 1501 0080 03AA     		add	r2, sp, #12
 1502 0082 06A8     		add	r0, sp, #24
 1503 0084 09A9     		add	r1, sp, #36
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1504              		.loc 3 464 0
 1505 0086 0594     		str	r4, [sp, #20]
 1506 0088 0397     		str	r7, [sp, #12]
 1507 008a 0497     		str	r7, [sp, #16]
 472:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 1508              		.loc 3 472 0
 1509 008c FFF7FEFF 		bl	int32_rmat_vmult
 1510              	.LVL149:
 1511              		.loc 3 486 0
 1512 0090 B6F8AE30 		ldrh	r3, [r6, #174]
 1513 0094 D6ED247A 		flds	s15, [r6, #144]
 1514 0098 07EE103A 		fmsr	s14, r3	@ int
 1515 009c B8EEC77A 		fsitos	s14, s14
 1516 00a0 67EE277A 		fmuls	s15, s14, s15
 1517 00a4 17EE900A 		fmrs	r0, s15
 1518 00a8 FFF7FEFF 		bl	__aeabi_f2d
 1519              	.LVL150:
 1520 00ac 0246     		mov	r2, r0
 1521 00ae 0B46     		mov	r3, r1
 1522 00b0 0020     		movs	r0, #0
 1523 00b2 2C49     		ldr	r1, .L83+8
 1524 00b4 FFF7FEFF 		bl	__aeabi_ddiv
 1525              	.LVL151:
 1526 00b8 FFF7FEFF 		bl	__aeabi_d2iz
 1527              	.LVL152:
 487:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += (residual_imu.x / inv_rate_gain);
 1528              		.loc 3 488 0
 1529 00bc 069C     		ldr	r4, [sp, #24]
 1530 00be B369     		ldr	r3, [r6, #24]
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += (residual_imu.z / inv_rate_gain);
 491:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 492:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 493:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 494:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 495:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 496:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual_imu FRAC = residual_ltp FRAC = 17
 497:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias FRAC: RATE_FRAC+28 = 40
 498:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^40 / 2^17 = 2^23
 499:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 500:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * bias_gain = Ki * FRAC_conversion = Ki * 2^23
 501:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 502:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t bias_gain = (int32_t)(ahrs_icq.mag_ki * dt * (1 << 23));
 1531              		.loc 3 502 0
 1532 00c0 D6ED257A 		flds	s15, [r6, #148]
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1533              		.loc 3 489 0
 1534 00c4 0799     		ldr	r1, [sp, #28]
 1535              	.LBE124:
 1536              	.LBE123:
 381:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 1537              		.loc 3 381 0
 1538 00c6 A6F8AE70 		strh	r7, [r6, #174]	@ movhi
 1539              	.LBB140:
 1540              	.LBB139:
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += (residual_imu.x / inv_rate_gain);
 1541              		.loc 3 488 0
 1542 00ca 94FBF0F2 		sdiv	r2, r4, r0
 1543 00ce 1344     		add	r3, r3, r2
 1544              		.loc 3 502 0
 1545 00d0 28EE278A 		fmuls	s16, s16, s15
 1546              	.LVL153:
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += (residual_imu.x / inv_rate_gain);
 1547              		.loc 3 488 0
 1548 00d4 B361     		str	r3, [r6, #24]
 1549              		.loc 3 502 0
 1550 00d6 DFED247A 		flds	s15, .L83+12
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1551              		.loc 3 489 0
 1552 00da F369     		ldr	r3, [r6, #28]
 1553 00dc 91FBF0F2 		sdiv	r2, r1, r0
 1554 00e0 1344     		add	r3, r3, r2
 1555              		.loc 3 502 0
 1556 00e2 28EE278A 		fmuls	s16, s16, s15
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += (residual_imu.z / inv_rate_gain);
 1557              		.loc 3 490 0
 1558 00e6 089A     		ldr	r2, [sp, #32]
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1559              		.loc 3 489 0
 1560 00e8 F361     		str	r3, [r6, #28]
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += (residual_imu.z / inv_rate_gain);
 1561              		.loc 3 490 0
 1562 00ea 336A     		ldr	r3, [r6, #32]
 1563 00ec 92FBF0F0 		sdiv	r0, r2, r0
 1564              	.LVL154:
 1565              		.loc 3 502 0
 1566 00f0 BDEEC88A 		ftosizs	s16, s16
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += (residual_imu.z / inv_rate_gain);
 1567              		.loc 3 490 0
 1568 00f4 0344     		add	r3, r3, r0
 1569 00f6 3362     		str	r3, [r6, #32]
 1570              		.loc 3 502 0
 1571 00f8 18EE103A 		fmrs	r3, s16	@ int
 1572              	.LVL155:
 503:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 504:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= (residual_imu.x * bias_gain);
 1573              		.loc 3 504 0
 1574 00fc 03FB04F0 		mul	r0, r3, r4
 1575 0100 D6E91245 		ldrd	r4, [r6, #72]
 505:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= (residual_imu.y * bias_gain);
 1576              		.loc 3 505 0
 1577 0104 03FB01FC 		mul	ip, r3, r1
 504:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= (residual_imu.x * bias_gain);
 1578              		.loc 3 504 0
 1579 0108 241A     		subs	r4, r4, r0
 1580 010a 65EBE075 		sbc	r5, r5, r0, asr #31
 1581              		.loc 3 505 0
 1582 010e D6E91401 		ldrd	r0, [r6, #80]
 1583 0112 B0EB0C00 		subs	r0, r0, ip
 1584 0116 61EBEC71 		sbc	r1, r1, ip, asr #31
 506:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r -= (residual_imu.z * bias_gain);
 1585              		.loc 3 506 0
 1586 011a 03FB02FC 		mul	ip, r3, r2
 1587 011e D6E91623 		ldrd	r2, [r6, #88]
 1588 0122 B2EB0C08 		subs	r8, r2, ip
 1589 0126 63EBEC79 		sbc	r9, r3, ip, asr #31
 1590              	.LVL156:
 507:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 508:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 1591              		.loc 3 508 0
 1592 012a 220F     		lsrs	r2, r4, #28
 1593 012c 42EA0512 		orr	r2, r2, r5, lsl #4
 1594 0130 3260     		str	r2, [r6]
 1595 0132 020F     		lsrs	r2, r0, #28
 1596 0134 42EA0112 		orr	r2, r2, r1, lsl #4
 1597 0138 7260     		str	r2, [r6, #4]
 504:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= (residual_imu.x * bias_gain);
 1598              		.loc 3 504 0
 1599 013a C6E91245 		strd	r4, [r6, #72]
 1600              		.loc 3 508 0
 1601 013e 4FEA1872 		lsr	r2, r8, #28
 505:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= (residual_imu.y * bias_gain);
 1602              		.loc 3 505 0
 1603 0142 C6E91401 		strd	r0, [r6, #80]
 506:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r -= (residual_imu.z * bias_gain);
 1604              		.loc 3 506 0
 1605 0146 C6E91689 		strd	r8, [r6, #88]
 1606              		.loc 3 508 0
 1607 014a 42EA0912 		orr	r2, r2, r9, lsl #4
 1608 014e B260     		str	r2, [r6, #8]
 1609              	.LVL157:
 1610              	.L70:
 1611              	.LBE139:
 1612              	.LBE140:
 382:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1613              		.loc 3 382 0
 1614 0150 13B0     		add	sp, sp, #76
 1615              		@ sp needed
 1616 0152 BDEC028B 		fldmfdd	sp!, {d8}
 1617 0156 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1618              	.L84:
 1619 015a 00BF     		.align	2
 1620              	.L83:
 1621 015c 00000000 		.word	.LANCHOR0
 1622 0160 60000000 		.word	.LANCHOR0+96
 1623 0164 00004040 		.word	1077936128
 1624 0168 0000004B 		.word	1258291200
 1625              		.cfi_endproc
 1626              	.LFE94:
 1628              		.section	.text.ahrs_icq_set_mag_gains,"ax",%progbits
 1629              		.align	1
 1630              		.global	ahrs_icq_set_mag_gains
 1631              		.thumb
 1632              		.thumb_func
 1634              	ahrs_icq_set_mag_gains:
 1635              	.LFB95:
 385:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1636              		.loc 3 385 0
 1637              		.cfi_startproc
 1638              		@ args = 0, pretend = 0, frame = 0
 1639              		@ frame_needed = 0, uses_anonymous_args = 0
 1640              		@ link register save eliminated.
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_kp = 2 * ahrs_icq.mag_zeta * ahrs_icq.mag_omega;
 1641              		.loc 3 387 0
 1642 0000 074B     		ldr	r3, .L86
 1643 0002 93ED2A7A 		flds	s14, [r3, #168]
 1644 0006 D3ED297A 		flds	s15, [r3, #164]
 1645 000a 37EE077A 		fadds	s14, s14, s14
 1646 000e 27EE277A 		fmuls	s14, s14, s15
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_ki = ahrs_icq.mag_omega * ahrs_icq.mag_omega;
 1647              		.loc 3 389 0
 1648 0012 67EEA77A 		fmuls	s15, s15, s15
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_kp = 2 * ahrs_icq.mag_zeta * ahrs_icq.mag_omega;
 1649              		.loc 3 387 0
 1650 0016 83ED247A 		fsts	s14, [r3, #144]
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_ki = ahrs_icq.mag_omega * ahrs_icq.mag_omega;
 1651              		.loc 3 389 0
 1652 001a C3ED257A 		fsts	s15, [r3, #148]
 1653 001e 7047     		bx	lr
 1654              	.L87:
 1655              		.align	2
 1656              	.L86:
 1657 0020 00000000 		.word	.LANCHOR0
 1658              		.cfi_endproc
 1659              	.LFE95:
 1661              		.section	.text.ahrs_icq_init,"ax",%progbits
 1662              		.align	1
 1663              		.global	ahrs_icq_init
 1664              		.thumb
 1665              		.thumb_func
 1667              	ahrs_icq_init:
 1668              	.LFB89:
 109:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1669              		.loc 3 109 0
 1670              		.cfi_startproc
 1671              		@ args = 0, pretend = 0, frame = 0
 1672              		@ frame_needed = 0, uses_anonymous_args = 0
 1673 0000 70B5     		push	{r4, r5, r6, lr}
 1674              		.cfi_def_cfa_offset 16
 1675              		.cfi_offset 4, -16
 1676              		.cfi_offset 5, -12
 1677              		.cfi_offset 6, -8
 1678              		.cfi_offset 14, -4
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_UNINIT;
 1679              		.loc 3 111 0
 1680 0002 214C     		ldr	r4, .L89
 128:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_zeta = AHRS_ACCEL_ZETA;
 1681              		.loc 3 128 0
 1682 0004 214E     		ldr	r6, .L89+4
 1683 0006 C4F8A060 		str	r6, [r4, #160]	@ float
 1684              	.LBB141:
 1685              	.LBB142:
 432:./math/pprz_algebra_int.h ****   q->qi = QUAT1_BFP_OF_REAL(1);
 1686              		.loc 2 432 0
 1687 000a 4FF40043 		mov	r3, #32768
 1688              	.LBE142:
 1689              	.LBE141:
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_UNINIT;
 1690              		.loc 3 111 0
 1691 000e 0025     		movs	r5, #0
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.high_rez_bias);
 1692              		.loc 3 124 0
 1693 0010 0022     		movs	r2, #0
 1694              	.LBB146:
 1695              	.LBB143:
 432:./math/pprz_algebra_int.h ****   q->qi = QUAT1_BFP_OF_REAL(1);
 1696              		.loc 2 432 0
 1697 0012 2366     		str	r3, [r4, #96]
 1698              	.LBE143:
 1699              	.LBE146:
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.high_rez_bias);
 1700              		.loc 3 124 0
 1701 0014 0023     		movs	r3, #0
 1702 0016 C4E91223 		strd	r2, [r4, #72]
 1703 001a C4E91423 		strd	r2, [r4, #80]
 1704 001e C4E91623 		strd	r2, [r4, #88]
 1705              	.LBB147:
 1706              	.LBB144:
 433:./math/pprz_algebra_int.h ****   q->qx = 0;
 1707              		.loc 2 433 0
 1708 0022 6566     		str	r5, [r4, #100]
 1709              	.LBE144:
 1710              	.LBE147:
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_omega = AHRS_ACCEL_OMEGA;
 1711              		.loc 3 127 0
 1712 0024 1A4B     		ldr	r3, .L89+8
 1713              	.LBB148:
 1714              	.LBB145:
 434:./math/pprz_algebra_int.h ****   q->qy = 0;
 1715              		.loc 2 434 0
 1716 0026 A566     		str	r5, [r4, #104]
 435:./math/pprz_algebra_int.h ****   q->qz = 0;
 1717              		.loc 2 435 0
 1718 0028 E566     		str	r5, [r4, #108]
 1719              	.LBE145:
 1720              	.LBE148:
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_omega = AHRS_ACCEL_OMEGA;
 1721              		.loc 3 127 0
 1722 002a C4F89C30 		str	r3, [r4, #156]	@ float
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_UNINIT;
 1723              		.loc 3 111 0
 1724 002e 84F83451 		strb	r5, [r4, #308]
 112:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 1725              		.loc 3 112 0
 1726 0032 84F83551 		strb	r5, [r4, #309]
 114:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.ltp_vel_norm_valid = FALSE;
 1727              		.loc 3 114 0
 1728 0036 84F88050 		strb	r5, [r4, #128]
 115:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 1729              		.loc 3 115 0
 1730 003a 84F88150 		strb	r5, [r4, #129]
 1731              	.LVL158:
 120:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.imu_rate);
 1732              		.loc 3 120 0
 1733 003e E560     		str	r5, [r4, #12]
 1734 0040 2561     		str	r5, [r4, #16]
 1735 0042 6561     		str	r5, [r4, #20]
 122:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.gyro_bias);
 1736              		.loc 3 122 0
 1737 0044 2560     		str	r5, [r4]
 1738 0046 6560     		str	r5, [r4, #4]
 1739 0048 A560     		str	r5, [r4, #8]
 123:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 1740              		.loc 3 123 0
 1741 004a A561     		str	r5, [r4, #24]
 1742 004c E561     		str	r5, [r4, #28]
 1743 004e 2562     		str	r5, [r4, #32]
 129:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_accel_gains();
 1744              		.loc 3 129 0
 1745 0050 FFF7FEFF 		bl	ahrs_icq_set_accel_gains
 1746              	.LVL159:
 130:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_omega = AHRS_MAG_OMEGA;
 1747              		.loc 3 130 0
 1748 0054 0F4B     		ldr	r3, .L89+12
 1749 0056 C4F8A430 		str	r3, [r4, #164]	@ float
 131:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_zeta = AHRS_MAG_ZETA;
 1750              		.loc 3 131 0
 1751 005a C4F8A860 		str	r6, [r4, #168]	@ float
 132:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_mag_gains();
 1752              		.loc 3 132 0
 1753 005e FFF7FEFF 		bl	ahrs_icq_set_mag_gains
 1754              	.LVL160:
 135:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.gravity_heuristic_factor = AHRS_GRAVITY_HEURISTIC_FACTOR;
 1755              		.loc 3 135 0
 1756 0062 1E23     		movs	r3, #30
 1757 0064 84F89930 		strb	r3, [r4, #153]
 143:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ASSIGN(ahrs_icq.mag_h, MAG_BFP_OF_REAL(AHRS_H_X),
 1758              		.loc 3 143 0
 1759 0068 40F21A43 		movw	r3, #1050
 1760 006c 2367     		str	r3, [r4, #112]
 1761 006e 6FF07A03 		mvn	r3, #122
 1762 0072 6367     		str	r3, [r4, #116]
 140:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.correct_gravity = FALSE;
 1763              		.loc 3 140 0
 1764 0074 84F89850 		strb	r5, [r4, #152]
 143:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ASSIGN(ahrs_icq.mag_h, MAG_BFP_OF_REAL(AHRS_H_X),
 1765              		.loc 3 143 0
 1766 0078 40F2D963 		movw	r3, #1753
 1767 007c A367     		str	r3, [r4, #120]
 146:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 1768              		.loc 3 146 0
 1769 007e A4F8AC50 		strh	r5, [r4, #172]	@ movhi
 147:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 1770              		.loc 3 147 0
 1771 0082 A4F8AE50 		strh	r5, [r4, #174]	@ movhi
 1772 0086 70BD     		pop	{r4, r5, r6, pc}
 1773              	.L90:
 1774              		.align	2
 1775              	.L89:
 1776 0088 00000000 		.word	.LANCHOR0
 1777 008c 6666663F 		.word	1063675494
 1778 0090 2506813D 		.word	1031865893
 1779 0094 0AD7233D 		.word	1025758986
 1780              		.cfi_endproc
 1781              	.LFE89:
 1783              		.section	.text.ahrs_icq_update_gps,"ax",%progbits
 1784              		.align	1
 1785              		.global	ahrs_icq_update_gps
 1786              		.thumb
 1787              		.thumb_func
 1789              	ahrs_icq_update_gps:
 1790              	.LFB98:
 509:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 510:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 511:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 512:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_gps(struct GpsState *gps_s __attribute__((unused)))
 513:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1791              		.loc 3 513 0
 1792              		.cfi_startproc
 1793              		@ args = 0, pretend = 0, frame = 0
 1794              		@ frame_needed = 0, uses_anonymous_args = 0
 1795              		@ link register save eliminated.
 1796              	.LVL161:
 1797 0000 7047     		bx	lr
 1798              		.cfi_endproc
 1799              	.LFE98:
 1801              		.section	.text.ahrs_icq_update_heading,"ax",%progbits
 1802              		.align	1
 1803              		.global	ahrs_icq_update_heading
 1804              		.thumb
 1805              		.thumb_func
 1807              	ahrs_icq_update_heading:
 1808              	.LFB99:
 514:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_GRAVITY_UPDATE_COORDINATED_TURN && USE_GPS
 515:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (gps_s->fix == GPS_FIX_3D) {
 516:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm = SPEED_BFP_OF_REAL(gps_s->speed_3d / 100.);
 517:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm_valid = TRUE;
 518:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 519:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm_valid = FALSE;
 520:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 521:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 522:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 523:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_USE_GPS_HEADING && USE_GPS
 524:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // got a 3d fix, ground speed > AHRS_HEADING_UPDATE_GPS_MIN_SPEED (default 5.0 m/s)
 525:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // and course accuracy is better than 10deg
 526:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (gps_s->fix == GPS_FIX_3D &&
 527:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       gps_s->gspeed >= (AHRS_HEADING_UPDATE_GPS_MIN_SPEED * 100) &&
 528:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       gps_s->cacc <= RadOfDeg(10 * 1e7)) {
 529:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 530:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // gps_s->course is in rad * 1e7, we need it in rad * 2^INT32_ANGLE_FRAC
 531:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_t course = gps_s->course * ((1 << INT32_ANGLE_FRAC) / 1e7);
 532:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 533:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* the assumption here is that there is no side-slip, so heading=course */
 534:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 535:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     if (ahrs_icq.heading_aligned) {
 536:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       ahrs_icq_update_heading(course);
 537:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     } else {
 538:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       /* hard reset the heading if this is the first measurement */
 539:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       ahrs_icq_realign_heading(course);
 540:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     }
 541:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 542:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 543:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 544:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 545:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 546:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_heading(int32_t heading)
 547:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1809              		.loc 3 547 0
 1810              		.cfi_startproc
 1811              		@ args = 0, pretend = 0, frame = 112
 1812              		@ frame_needed = 0, uses_anonymous_args = 0
 1813              	.LVL162:
 1814              		.loc 3 547 0
 1815 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1816              		.cfi_def_cfa_offset 28
 1817              		.cfi_offset 4, -28
 1818              		.cfi_offset 5, -24
 1819              		.cfi_offset 6, -20
 1820              		.cfi_offset 7, -16
 1821              		.cfi_offset 8, -12
 1822              		.cfi_offset 9, -8
 1823              		.cfi_offset 14, -4
 1824 0004 0446     		mov	r4, r0
 1825 0006 9DB0     		sub	sp, sp, #116
 1826              		.cfi_def_cfa_offset 144
 1827              	.LVL163:
 1828              	.L93:
 548:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 549:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT32_ANGLE_NORMALIZE(heading);
 1829              		.loc 3 549 0 discriminator 1
 1830 0008 43F24323 		movw	r3, #12867
 1831 000c 9C42     		cmp	r4, r3
 1832 000e 03DD     		ble	.L95
 1833              		.loc 3 549 0 is_stmt 0 discriminator 2
 1834 0010 A4F5C944 		sub	r4, r4, #25728
 1835              	.LVL164:
 1836 0014 073C     		subs	r4, r4, #7
 1837              	.LVL165:
 1838 0016 F7E7     		b	.L93
 1839              	.L95:
 1840              		.loc 3 549 0 discriminator 1
 1841 0018 424B     		ldr	r3, .L100
 1842 001a 9C42     		cmp	r4, r3
 1843 001c 03DA     		bge	.L99
 1844              		.loc 3 549 0 discriminator 2
 1845 001e 04F5C944 		add	r4, r4, #25728
 1846              	.LVL166:
 1847 0022 0734     		adds	r4, r4, #7
 1848              	.LVL167:
 1849 0024 F8E7     		b	.L95
 1850              	.L99:
 1851              	.LVL168:
 1852              	.LBB151:
 1853              	.LBB152:
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 1854              		.loc 6 192 0 is_stmt 1
 1855 0026 404D     		ldr	r5, .L100+4
 1856 0028 95F8B030 		ldrb	r3, [r5, #176]	@ zero_extendqisi2
 1857 002c DB07     		lsls	r3, r3, #31
 1858 002e 03D4     		bmi	.L97
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 1859              		.loc 6 193 0
 1860 0030 05F1B000 		add	r0, r5, #176
 1861 0034 FFF7FEFF 		bl	orientationCalcQuat_i
 1862              	.LVL169:
 1863              	.L97:
 1864              	.LBE152:
 1865              	.LBE151:
 550:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 551:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // row 0 of ltp_to_body_rmat = body x-axis in ltp frame
 552:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // we only consider x and y
 553:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat *body_to_imu_quat = orientationGetQuat_i(&ahrs_icq.body_to_imu);
 554:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat ltp_to_body_quat;
 555:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_inv(&ltp_to_body_quat, &ahrs_icq.ltp_to_imu_quat, body_to_imu_quat);
 1866              		.loc 3 555 0
 1867 0038 3B4E     		ldr	r6, .L100+4
 1868 003a 06A8     		add	r0, sp, #24
 1869 003c 06F1B402 		add	r2, r6, #180
 1870 0040 06F16001 		add	r1, r6, #96
 1871 0044 FFF7FEFF 		bl	int32_quat_comp_inv
 1872              	.LVL170:
 556:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_body_rmat;
 557:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_body_rmat, &ltp_to_body_quat);
 1873              		.loc 3 557 0
 1874 0048 06A9     		add	r1, sp, #24
 1875 004a 0AA8     		add	r0, sp, #40
 1876 004c FFF7FEFF 		bl	int32_rmat_of_quat
 1877              	.LVL171:
 558:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 expected_ltp = {
 559:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 0),
 560:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 1)
 561:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 562:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 563:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t heading_x, heading_y;
 564:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(heading_x, heading); // measured course in x-direction
 1878              		.loc 3 564 0
 1879 0050 2046     		mov	r0, r4
 559:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 0),
 1880              		.loc 3 559 0
 1881 0052 DDF82880 		ldr	r8, [sp, #40]
 1882              	.LVL172:
 560:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 1)
 1883              		.loc 3 560 0
 1884 0056 0B9F     		ldr	r7, [sp, #44]
 1885              	.LVL173:
 1886              		.loc 3 564 0
 1887 0058 FFF7FEFF 		bl	pprz_itrig_cos
 1888              	.LVL174:
 1889 005c 8146     		mov	r9, r0
 1890              	.LVL175:
 565:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(heading_y, heading); // measured course in y-direction
 1891              		.loc 3 565 0
 1892 005e 2046     		mov	r0, r4
 1893              	.LVL176:
 1894 0060 FFF7FEFF 		bl	pprz_itrig_sin
 1895              	.LVL177:
 566:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 567:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // expected_heading cross measured_heading ??
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1896              		.loc 3 568 0
 1897 0064 0023     		movs	r3, #0
 569:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 570:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 571:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     (expected_ltp.x * heading_y - expected_ltp.y * heading_x) / (1 << INT32_ANGLE_FRAC)
 1898              		.loc 3 571 0
 1899 0066 00FB08F0 		mul	r0, r0, r8
 1900              	.LVL178:
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1901              		.loc 3 568 0
 1902 006a 0093     		str	r3, [sp]
 1903 006c 0193     		str	r3, [sp, #4]
 1904              		.loc 3 571 0
 1905 006e 09FB1707 		mls	r7, r9, r7, r0
 1906              	.LVL179:
 1907 0072 4FF48053 		mov	r3, #4096
 1908 0076 97FBF3F7 		sdiv	r7, r7, r3
 572:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 573:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 574:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_imu;
 575:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 576:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 1909              		.loc 3 576 0
 1910 007a 13A8     		add	r0, sp, #76
 1911 007c 06F16001 		add	r1, r6, #96
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1912              		.loc 3 568 0
 1913 0080 0297     		str	r7, [sp, #8]
 1914              		.loc 3 576 0
 1915 0082 FFF7FEFF 		bl	int32_rmat_of_quat
 1916              	.LVL180:
 577:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 1917              		.loc 3 577 0
 1918 0086 03A8     		add	r0, sp, #12
 1919 0088 13A9     		add	r1, sp, #76
 1920 008a 6A46     		mov	r2, sp
 1921 008c FFF7FEFF 		bl	int32_rmat_vmult
 1922              	.LVL181:
 578:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 579:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // residual FRAC = TRIG_FRAC + TRIG_FRAC = 14 + 14 = 28
 580:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // rate_correction FRAC = RATE_FRAC = 12
 581:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // 2^12 / 2^28 * 4.0 = 1/2^14
 582:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // (1<<INT32_ANGLE_FRAC)/2^14 = 1/4
 583:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += residual_imu.x / 4;
 1923              		.loc 3 583 0
 1924 0090 039A     		ldr	r2, [sp, #12]
 1925 0092 0423     		movs	r3, #4
 1926 0094 92FBF3F1 		sdiv	r1, r2, r3
 1927 0098 AA69     		ldr	r2, [r5, #24]
 1928 009a 0A44     		add	r2, r2, r1
 1929 009c AA61     		str	r2, [r5, #24]
 584:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += residual_imu.y / 4;
 1930              		.loc 3 584 0
 1931 009e 049A     		ldr	r2, [sp, #16]
 1932 00a0 92FBF3F1 		sdiv	r1, r2, r3
 1933 00a4 EA69     		ldr	r2, [r5, #28]
 1934 00a6 0A44     		add	r2, r2, r1
 1935 00a8 EA61     		str	r2, [r5, #28]
 585:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual_imu.z / 4;
 1936              		.loc 3 585 0
 1937 00aa 059A     		ldr	r2, [sp, #20]
 1938 00ac 92FBF3F3 		sdiv	r3, r2, r3
 1939 00b0 2A6A     		ldr	r2, [r5, #32]
 586:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 587:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 588:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* crude attempt to only update bias if deviation is small
 589:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * e.g. needed when you only have gps providing heading
 590:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * and the inital heading is totally different from
 591:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * the gps course information you get once you have a gps fix.
 592:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Otherwise the bias will be falsely "corrected".
 593:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 594:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t sin_max_angle_deviation;
 595:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(sin_max_angle_deviation, TRIG_BFP_OF_REAL(RadOfDeg(AHRS_BIAS_UPDATE_HEADING_THRESH
 1940              		.loc 3 595 0
 1941 00b2 40F29550 		movw	r0, #1429
 585:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual_imu.z / 4;
 1942              		.loc 3 585 0
 1943 00b6 1A44     		add	r2, r2, r3
 1944 00b8 2A62     		str	r2, [r5, #32]
 1945              		.loc 3 595 0
 1946 00ba FFF7FEFF 		bl	pprz_itrig_sin
 1947              	.LVL182:
 596:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ABS(residual_ltp.z) < sin_max_angle_deviation) {
 1948              		.loc 3 596 0
 1949 00be 029B     		ldr	r3, [sp, #8]
 1950 00c0 002B     		cmp	r3, #0
 1951 00c2 B8BF     		it	lt
 1952 00c4 5B42     		rsblt	r3, r3, #0
 1953 00c6 8342     		cmp	r3, r0
 1954 00c8 28DA     		bge	.L92
 597:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // residual_ltp FRAC = 2 * TRIG_FRAC = 28
 598:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // high_rez_bias = RATE_FRAC+28 = 40
 599:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // 2^40 / 2^28 * 2.5e-4 = 1
 600:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.p -= residual_imu.x * (1 << INT32_ANGLE_FRAC);
 1955              		.loc 3 600 0
 1956 00ca 039B     		ldr	r3, [sp, #12]
 1957 00cc 1903     		lsls	r1, r3, #12
 1958 00ce D6E91223 		ldrd	r2, [r6, #72]
 601:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.q -= residual_imu.y * (1 << INT32_ANGLE_FRAC);
 1959              		.loc 3 601 0
 1960 00d2 D6E91445 		ldrd	r4, [r6, #80]
 1961              	.LVL183:
 600:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.p -= residual_imu.x * (1 << INT32_ANGLE_FRAC);
 1962              		.loc 3 600 0
 1963 00d6 521A     		subs	r2, r2, r1
 1964 00d8 63EBE173 		sbc	r3, r3, r1, asr #31
 1965              		.loc 3 601 0
 1966 00dc 0499     		ldr	r1, [sp, #16]
 1967 00de 0903     		lsls	r1, r1, #12
 1968 00e0 641A     		subs	r4, r4, r1
 1969 00e2 65EBE175 		sbc	r5, r5, r1, asr #31
 602:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.r -= residual_imu.z * (1 << INT32_ANGLE_FRAC);
 1970              		.loc 3 602 0
 1971 00e6 0599     		ldr	r1, [sp, #20]
 1972 00e8 0F03     		lsls	r7, r1, #12
 1973 00ea D6E91601 		ldrd	r0, [r6, #88]
 1974              	.LVL184:
 603:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 604:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 1975              		.loc 3 604 0
 1976 00ee 4FEA1278 		lsr	r8, r2, #28
 1977              	.LVL185:
 600:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.p -= residual_imu.x * (1 << INT32_ANGLE_FRAC);
 1978              		.loc 3 600 0
 1979 00f2 C6E91223 		strd	r2, [r6, #72]
 1980              		.loc 3 604 0
 1981 00f6 220F     		lsrs	r2, r4, #28
 602:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.r -= residual_imu.z * (1 << INT32_ANGLE_FRAC);
 1982              		.loc 3 602 0
 1983 00f8 C01B     		subs	r0, r0, r7
 1984 00fa 61EBE771 		sbc	r1, r1, r7, asr #31
 1985              		.loc 3 604 0
 1986 00fe 42EA0512 		orr	r2, r2, r5, lsl #4
 1987 0102 7260     		str	r2, [r6, #4]
 601:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.q -= residual_imu.y * (1 << INT32_ANGLE_FRAC);
 1988              		.loc 3 601 0
 1989 0104 C6E91445 		strd	r4, [r6, #80]
 1990              		.loc 3 604 0
 1991 0108 020F     		lsrs	r2, r0, #28
 602:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.r -= residual_imu.z * (1 << INT32_ANGLE_FRAC);
 1992              		.loc 3 602 0
 1993 010a C6E91601 		strd	r0, [r6, #88]
 1994              		.loc 3 604 0
 1995 010e 48EA0318 		orr	r8, r8, r3, lsl #4
 1996 0112 42EA0112 		orr	r2, r2, r1, lsl #4
 1997 0116 C6F80080 		str	r8, [r6]
 1998 011a B260     		str	r2, [r6, #8]
 1999              	.L92:
 605:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 606:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2000              		.loc 3 606 0
 2001 011c 1DB0     		add	sp, sp, #116
 2002              		@ sp needed
 2003 011e BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 2004              	.LVL186:
 2005              	.L101:
 2006 0122 00BF     		.align	2
 2007              	.L100:
 2008 0124 BDCDFFFF 		.word	-12867
 2009 0128 00000000 		.word	.LANCHOR0
 2010              		.cfi_endproc
 2011              	.LFE99:
 2013              		.section	.text.ahrs_icq_realign_heading,"ax",%progbits
 2014              		.align	1
 2015              		.global	ahrs_icq_realign_heading
 2016              		.thumb
 2017              		.thumb_func
 2019              	ahrs_icq_realign_heading:
 2020              	.LFB100:
 607:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 608:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_realign_heading(int32_t heading)
 609:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2021              		.loc 3 609 0
 2022              		.cfi_startproc
 2023              		@ args = 0, pretend = 0, frame = 80
 2024              		@ frame_needed = 0, uses_anonymous_args = 0
 2025              	.LVL187:
 2026 0000 70B5     		push	{r4, r5, r6, lr}
 2027              		.cfi_def_cfa_offset 16
 2028              		.cfi_offset 4, -16
 2029              		.cfi_offset 5, -12
 2030              		.cfi_offset 6, -8
 2031              		.cfi_offset 14, -4
 2032              	.LBB155:
 2033              	.LBB156:
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 2034              		.loc 6 192 0
 2035 0002 224D     		ldr	r5, .L104
 2036 0004 95F8B030 		ldrb	r3, [r5, #176]	@ zero_extendqisi2
 2037 0008 DB07     		lsls	r3, r3, #31
 2038              	.LBE156:
 2039              	.LBE155:
 2040              		.loc 3 609 0
 2041 000a 94B0     		sub	sp, sp, #80
 2042              		.cfi_def_cfa_offset 96
 2043              		.loc 3 609 0
 2044 000c 0646     		mov	r6, r0
 2045              	.LBB158:
 2046              	.LBB157:
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 2047              		.loc 6 192 0
 2048 000e 03D4     		bmi	.L103
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 2049              		.loc 6 193 0
 2050 0010 05F1B000 		add	r0, r5, #176
 2051              	.LVL188:
 2052 0014 FFF7FEFF 		bl	orientationCalcQuat_i
 2053              	.LVL189:
 2054              	.L103:
 2055              	.LBE157:
 2056              	.LBE158:
 610:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat *body_to_imu_quat = orientationGetQuat_i(&ahrs_icq.body_to_imu);
 611:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat ltp_to_body_quat;
 612:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_inv(&ltp_to_body_quat, &ahrs_icq.ltp_to_imu_quat, body_to_imu_quat);
 2057              		.loc 3 612 0
 2058 0018 1D49     		ldr	r1, .L104+4
 2059 001a 6846     		mov	r0, sp
 2060 001c 01F15402 		add	r2, r1, #84
 2061 0020 FFF7FEFF 		bl	int32_quat_comp_inv
 2062              	.LVL190:
 613:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 614:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing only the heading rotation from ltp to body */
 615:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_h_new;
 616:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qx = 0;
 617:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qy = 0;
 618:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(q_h_new.qz, heading / 2);
 2063              		.loc 3 618 0
 2064 0024 0223     		movs	r3, #2
 2065 0026 96FBF3F6 		sdiv	r6, r6, r3
 2066              	.LVL191:
 616:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qx = 0;
 2067              		.loc 3 616 0
 2068 002a 0024     		movs	r4, #0
 2069              		.loc 3 618 0
 2070 002c 3046     		mov	r0, r6
 616:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qx = 0;
 2071              		.loc 3 616 0
 2072 002e 0594     		str	r4, [sp, #20]
 617:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qy = 0;
 2073              		.loc 3 617 0
 2074 0030 0694     		str	r4, [sp, #24]
 2075              		.loc 3 618 0
 2076 0032 FFF7FEFF 		bl	pprz_itrig_sin
 2077              	.LVL192:
 2078 0036 0790     		str	r0, [sp, #28]
 619:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(q_h_new.qi, heading / 2);
 2079              		.loc 3 619 0
 2080 0038 3046     		mov	r0, r6
 2081 003a FFF7FEFF 		bl	pprz_itrig_cos
 2082              	.LVL193:
 620:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 621:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing current heading only */
 622:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_h;
 623:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(q_h, ltp_to_body_quat);
 2083              		.loc 3 623 0
 2084 003e 009B     		ldr	r3, [sp]
 619:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(q_h_new.qi, heading / 2);
 2085              		.loc 3 619 0
 2086 0040 0490     		str	r0, [sp, #16]
 2087              		.loc 3 623 0
 2088 0042 0893     		str	r3, [sp, #32]
 624:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qx = 0;
 625:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qy = 0;
 626:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_normalize(&q_h);
 2089              		.loc 3 626 0
 2090 0044 08A8     		add	r0, sp, #32
 623:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(q_h, ltp_to_body_quat);
 2091              		.loc 3 623 0
 2092 0046 039B     		ldr	r3, [sp, #12]
 2093 0048 0B93     		str	r3, [sp, #44]
 624:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qx = 0;
 2094              		.loc 3 624 0
 2095 004a 0994     		str	r4, [sp, #36]
 625:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qy = 0;
 2096              		.loc 3 625 0
 2097 004c 0A94     		str	r4, [sp, #40]
 2098              		.loc 3 626 0
 2099 004e FFF7FEFF 		bl	int32_quat_normalize
 2100              	.LVL194:
 627:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 628:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing rotation from current to new heading */
 629:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_c;
 630:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_inv_comp_norm_shortest(&q_c, &q_h, &q_h_new);
 2101              		.loc 3 630 0
 2102 0052 0CA8     		add	r0, sp, #48
 2103 0054 08A9     		add	r1, sp, #32
 2104 0056 04AA     		add	r2, sp, #16
 2105 0058 FFF7FEFF 		bl	int32_quat_inv_comp_norm_shortest
 2106              	.LVL195:
 631:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 632:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* correct current heading in body frame */
 633:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q;
 634:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_norm_shortest(&q, &q_c, &ltp_to_body_quat);
 2107              		.loc 3 634 0
 2108 005c 10A8     		add	r0, sp, #64
 2109 005e 0CA9     		add	r1, sp, #48
 2110 0060 6A46     		mov	r2, sp
 2111 0062 FFF7FEFF 		bl	int32_quat_comp_norm_shortest
 2112              	.LVL196:
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2113              		.loc 3 635 0
 2114 0066 109B     		ldr	r3, [sp, #64]
 2115 0068 0093     		str	r3, [sp]
 636:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 637:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* compute ltp to imu rotations */
 638:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp(&ahrs_icq.ltp_to_imu_quat, &ltp_to_body_quat, body_to_imu_quat);
 2116              		.loc 3 638 0
 2117 006a 0948     		ldr	r0, .L104+4
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2118              		.loc 3 635 0
 2119 006c 119B     		ldr	r3, [sp, #68]
 2120 006e 0193     		str	r3, [sp, #4]
 2121 0070 129B     		ldr	r3, [sp, #72]
 2122 0072 0293     		str	r3, [sp, #8]
 2123              		.loc 3 638 0
 2124 0074 6946     		mov	r1, sp
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2125              		.loc 3 635 0
 2126 0076 139B     		ldr	r3, [sp, #76]
 2127 0078 0393     		str	r3, [sp, #12]
 2128              		.loc 3 638 0
 2129 007a 00F15402 		add	r2, r0, #84
 2130 007e FFF7FEFF 		bl	int32_quat_comp
 2131              	.LVL197:
 639:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 640:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = TRUE;
 2132              		.loc 3 640 0
 2133 0082 0123     		movs	r3, #1
 2134 0084 85F88130 		strb	r3, [r5, #129]
 641:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2135              		.loc 3 641 0
 2136 0088 14B0     		add	sp, sp, #80
 2137              		@ sp needed
 2138 008a 70BD     		pop	{r4, r5, r6, pc}
 2139              	.L105:
 2140              		.align	2
 2141              	.L104:
 2142 008c 00000000 		.word	.LANCHOR0
 2143 0090 60000000 		.word	.LANCHOR0+96
 2144              		.cfi_endproc
 2145              	.LFE100:
 2147              		.section	.text.ahrs_icq_set_body_to_imu_quat,"ax",%progbits
 2148              		.align	1
 2149              		.global	ahrs_icq_set_body_to_imu_quat
 2150              		.thumb
 2151              		.thumb_func
 2153              	ahrs_icq_set_body_to_imu_quat:
 2154              	.LFB102:
 642:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 643:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_body_to_imu(struct OrientationReps *body_to_imu)
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 646:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 647:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 648:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_body_to_imu_quat(struct FloatQuat *q_b2i)
 649:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2155              		.loc 3 649 0
 2156              		.cfi_startproc
 2157              		@ args = 0, pretend = 0, frame = 0
 2158              		@ frame_needed = 0, uses_anonymous_args = 0
 2159              	.LVL198:
 2160 0000 38B5     		push	{r3, r4, r5, lr}
 2161              		.cfi_def_cfa_offset 16
 2162              		.cfi_offset 3, -16
 2163              		.cfi_offset 4, -12
 2164              		.cfi_offset 5, -8
 2165              		.cfi_offset 14, -4
 2166              	.LBB163:
 2167              	.LBB164:
 167:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_f, *quat);
 2168              		.loc 6 167 0
 2169 0002 0F4C     		ldr	r4, .L108
 2170 0004 0368     		ldr	r3, [r0]	@ float
 2171 0006 C4F8F430 		str	r3, [r4, #244]	@ float
 2172 000a 4368     		ldr	r3, [r0, #4]	@ float
 2173 000c C4F8F830 		str	r3, [r4, #248]	@ float
 2174 0010 8368     		ldr	r3, [r0, #8]	@ float
 2175 0012 C4F8FC30 		str	r3, [r4, #252]	@ float
 2176 0016 C368     		ldr	r3, [r0, #12]	@ float
 2177 0018 C4F80031 		str	r3, [r4, #256]	@ float
 169:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_F);
 2178              		.loc 6 169 0
 2179 001c 0823     		movs	r3, #8
 2180 001e 84F8B030 		strb	r3, [r4, #176]
 2181              	.LBE164:
 2182              	.LBE163:
 650:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   orientationSetQuat_f(&ahrs_icq.body_to_imu, q_b2i);
 651:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 652:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (!ahrs_icq.is_aligned) {
 2183              		.loc 3 652 0
 2184 0022 94F83531 		ldrb	r3, [r4, #309]	@ zero_extendqisi2
 2185 0026 53B9     		cbnz	r3, .L106
 2186              	.LVL199:
 2187              	.LBB165:
 2188              	.LBB166:
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 2189              		.loc 6 193 0
 2190 0028 04F1B000 		add	r0, r4, #176
 2191              	.LVL200:
 2192              	.LBE166:
 2193              	.LBE165:
 653:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* Set ltp_to_imu so that body is zero */
 654:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     memcpy(&ahrs_icq.ltp_to_imu_quat, orientationGetQuat_i(&ahrs_icq.body_to_imu),
 2194              		.loc 3 654 0
 2195 002c 04F16005 		add	r5, r4, #96
 2196 0030 B434     		adds	r4, r4, #180
 2197              	.LBB168:
 2198              	.LBB167:
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 2199              		.loc 6 193 0
 2200 0032 FFF7FEFF 		bl	orientationCalcQuat_i
 2201              	.LVL201:
 2202              	.LBE167:
 2203              	.LBE168:
 2204              		.loc 3 654 0
 2205 0036 94E80F00 		ldmia	r4, {r0, r1, r2, r3}
 2206 003a 85E80F00 		stmia	r5, {r0, r1, r2, r3}
 2207              	.LVL202:
 2208              	.L106:
 2209 003e 38BD     		pop	{r3, r4, r5, pc}
 2210              	.L109:
 2211              		.align	2
 2212              	.L108:
 2213 0040 00000000 		.word	.LANCHOR0
 2214              		.cfi_endproc
 2215              	.LFE102:
 2217              		.section	.text.ahrs_icq_set_body_to_imu,"ax",%progbits
 2218              		.align	1
 2219              		.global	ahrs_icq_set_body_to_imu
 2220              		.thumb
 2221              		.thumb_func
 2223              	ahrs_icq_set_body_to_imu:
 2224              	.LFB101:
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2225              		.loc 3 644 0
 2226              		.cfi_startproc
 2227              		@ args = 0, pretend = 0, frame = 0
 2228              		@ frame_needed = 0, uses_anonymous_args = 0
 2229              	.LVL203:
 2230 0000 10B5     		push	{r4, lr}
 2231              		.cfi_def_cfa_offset 8
 2232              		.cfi_offset 4, -8
 2233              		.cfi_offset 14, -4
 2234              	.LBB171:
 2235              	.LBB172:
 203:./math/pprz_orientation_conversion.h ****   }
 204:./math/pprz_orientation_conversion.h ****   return &orientation->rmat_i;
 205:./math/pprz_orientation_conversion.h **** }
 206:./math/pprz_orientation_conversion.h **** 
 207:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude euler angles (int).
 208:./math/pprz_orientation_conversion.h **** static inline struct Int32Eulers *orientationGetEulers_i(struct OrientationReps *orientation)
 209:./math/pprz_orientation_conversion.h **** {
 210:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_I)) {
 211:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_i(orientation);
 212:./math/pprz_orientation_conversion.h ****   }
 213:./math/pprz_orientation_conversion.h ****   return &orientation->eulers_i;
 214:./math/pprz_orientation_conversion.h **** }
 215:./math/pprz_orientation_conversion.h **** 
 216:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (float).
 217:./math/pprz_orientation_conversion.h **** static inline struct FloatQuat *orientationGetQuat_f(struct OrientationReps *orientation)
 218:./math/pprz_orientation_conversion.h **** {
 219:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_F)) {
 2236              		.loc 6 219 0
 2237 0002 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2238 0004 1B07     		lsls	r3, r3, #28
 2239              	.LBE172:
 2240              	.LBE171:
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2241              		.loc 3 644 0
 2242 0006 0446     		mov	r4, r0
 2243              	.LBB174:
 2244              	.LBB173:
 2245              		.loc 6 219 0
 2246 0008 01D4     		bmi	.L111
 220:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_f(orientation);
 2247              		.loc 6 220 0
 2248 000a FFF7FEFF 		bl	orientationCalcQuat_f
 2249              	.LVL204:
 2250              	.L111:
 2251              	.LBE173:
 2252              	.LBE174:
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 2253              		.loc 3 645 0
 2254 000e 04F14400 		add	r0, r4, #68
 646:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2255              		.loc 3 646 0
 2256 0012 BDE81040 		pop	{r4, lr}
 2257              	.LVL205:
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 2258              		.loc 3 645 0
 2259 0016 FFF7FEBF 		b	ahrs_icq_set_body_to_imu_quat
 2260              	.LVL206:
 2261              		.cfi_endproc
 2262              	.LFE101:
 2264              		.global	ahrs_icq
 2265              		.section	.bss.filtered_gravity_measurement.7023,"aw",%nobits
 2266              		.align	2
 2267              		.set	.LANCHOR1,. + 0
 2270              	filtered_gravity_measurement.7023:
 2271 0000 00000000 		.space	12
 2271      00000000 
 2271      00000000 
 2272              		.section	.bss.ahrs_icq,"aw",%nobits
 2273              		.align	3
 2274              		.set	.LANCHOR0,. + 0
 2277              	ahrs_icq:
 2278 0000 00000000 		.space	312
 2278      00000000 
 2278      00000000 
 2278      00000000 
 2278      00000000 
 2279              		.text
 2280              	.Letext0:
 2281              		.file 7 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_default_types.h"
 2282              		.file 8 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2283              		.file 9 "/home/lsk/paparazzi/sw/include/std.h"
 2284              		.file 10 "./math/pprz_geodetic_int.h"
 2285              		.file 11 "./mcu_periph/sys_time.h"
 2286              		.file 12 "./mcu_periph/link_device.h"
 2287              		.file 13 "./mcu_periph/uart.h"
 2288              		.file 14 "./subsystems/gps/gps_ubx.h"
 2289              		.file 15 "./subsystems/gps.h"
 2290              		.file 16 "./subsystems/ahrs/ahrs_int_cmpl_quat.h"
 2291              		.file 17 "/home/lsk/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
 2292              		.file 18 "./math/pprz_trig_int.h"
 2293              		.file 19 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ahrs_int_cmpl_quat.c
     /tmp/ccXJfwoa.s:20     .text.float_quat_normalize:00000000 $t
     /tmp/ccXJfwoa.s:24     .text.float_quat_normalize:00000000 float_quat_normalize
     /tmp/ccXJfwoa.s:100    .text.float_quat_normalize:00000070 $d
     /tmp/ccXJfwoa.s:105    .text.int32_quat_normalize:00000000 $t
     /tmp/ccXJfwoa.s:109    .text.int32_quat_normalize:00000000 int32_quat_normalize
     /tmp/ccXJfwoa.s:188    .text.ahrs_icq_align:00000000 $t
     /tmp/ccXJfwoa.s:193    .text.ahrs_icq_align:00000000 ahrs_icq_align
     /tmp/ccXJfwoa.s:688    .text.ahrs_icq_align:000002a8 $d
     /tmp/ccXJfwoa.s:708    .text.ahrs_icq_propagate:00000000 $t
     /tmp/ccXJfwoa.s:713    .text.ahrs_icq_propagate:00000000 ahrs_icq_propagate
     /tmp/ccXJfwoa.s:825    .text.ahrs_icq_propagate:000000a0 $d
     /tmp/ccXJfwoa.s:831    .text.ahrs_icq_set_accel_gains:00000000 $t
     /tmp/ccXJfwoa.s:836    .text.ahrs_icq_set_accel_gains:00000000 ahrs_icq_set_accel_gains
     /tmp/ccXJfwoa.s:893    .text.ahrs_icq_set_accel_gains:00000060 $d
     /tmp/ccXJfwoa.s:903    .text.ahrs_icq_update_accel:00000000 $t
     /tmp/ccXJfwoa.s:908    .text.ahrs_icq_update_accel:00000000 ahrs_icq_update_accel
     /tmp/ccXJfwoa.s:1338   .text.ahrs_icq_update_accel:000002a8 $d
     /tmp/ccXJfwoa.s:1353   .text.ahrs_icq_update_mag:00000000 $t
     /tmp/ccXJfwoa.s:1358   .text.ahrs_icq_update_mag:00000000 ahrs_icq_update_mag
     /tmp/ccXJfwoa.s:1621   .text.ahrs_icq_update_mag:0000015c $d
     /tmp/ccXJfwoa.s:1629   .text.ahrs_icq_set_mag_gains:00000000 $t
     /tmp/ccXJfwoa.s:1634   .text.ahrs_icq_set_mag_gains:00000000 ahrs_icq_set_mag_gains
     /tmp/ccXJfwoa.s:1657   .text.ahrs_icq_set_mag_gains:00000020 $d
     /tmp/ccXJfwoa.s:1662   .text.ahrs_icq_init:00000000 $t
     /tmp/ccXJfwoa.s:1667   .text.ahrs_icq_init:00000000 ahrs_icq_init
     /tmp/ccXJfwoa.s:1776   .text.ahrs_icq_init:00000088 $d
     /tmp/ccXJfwoa.s:1784   .text.ahrs_icq_update_gps:00000000 $t
     /tmp/ccXJfwoa.s:1789   .text.ahrs_icq_update_gps:00000000 ahrs_icq_update_gps
     /tmp/ccXJfwoa.s:1802   .text.ahrs_icq_update_heading:00000000 $t
     /tmp/ccXJfwoa.s:1807   .text.ahrs_icq_update_heading:00000000 ahrs_icq_update_heading
     /tmp/ccXJfwoa.s:2008   .text.ahrs_icq_update_heading:00000124 $d
     /tmp/ccXJfwoa.s:2014   .text.ahrs_icq_realign_heading:00000000 $t
     /tmp/ccXJfwoa.s:2019   .text.ahrs_icq_realign_heading:00000000 ahrs_icq_realign_heading
     /tmp/ccXJfwoa.s:2142   .text.ahrs_icq_realign_heading:0000008c $d
     /tmp/ccXJfwoa.s:2148   .text.ahrs_icq_set_body_to_imu_quat:00000000 $t
     /tmp/ccXJfwoa.s:2153   .text.ahrs_icq_set_body_to_imu_quat:00000000 ahrs_icq_set_body_to_imu_quat
     /tmp/ccXJfwoa.s:2213   .text.ahrs_icq_set_body_to_imu_quat:00000040 $d
     /tmp/ccXJfwoa.s:2218   .text.ahrs_icq_set_body_to_imu:00000000 $t
     /tmp/ccXJfwoa.s:2223   .text.ahrs_icq_set_body_to_imu:00000000 ahrs_icq_set_body_to_imu
     /tmp/ccXJfwoa.s:2277   .bss.ahrs_icq:00000000 ahrs_icq
     /tmp/ccXJfwoa.s:2266   .bss.filtered_gravity_measurement.7023:00000000 $d
     /tmp/ccXJfwoa.s:2270   .bss.filtered_gravity_measurement.7023:00000000 filtered_gravity_measurement.7023
     /tmp/ccXJfwoa.s:2273   .bss.ahrs_icq:00000000 $d
                     .debug_frame:00000010 $d
     /tmp/ccXJfwoa.s:902    .text.ahrs_icq_set_accel_gains:00000074 $t
     /tmp/ccXJfwoa.s:1352   .text.ahrs_icq_update_accel:000002d4 $t
                           .group:00000000 wm4.0.61e172dafa1e7adfbd840ee8b103061f
                           .group:00000000 wm4.airframe.h.5.1b65f22e2c90217dfc42bdae27fe483a
                           .group:00000000 wm4.features.h.22.6a4ca7cd053637cc1d0db6c16f39b2d7
                           .group:00000000 wm4._default_types.h.6.9e4229723f5523536bc8f574589d6a99
                           .group:00000000 wm4.stdint.h.20.796e373797e732130a803d4c0338fa1b
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.24.4db40689d622c4d3b547b5801303bdae
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.newlib.h.8.fec018e441fee7bfa1923812ad010f97
                           .group:00000000 wm4.config.h.212.4163ef2871a828c674038d036b081cfd
                           .group:00000000 wm4._ansi.h.23.2147fde150631f5584b9dc29b914d1b8
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.13c5bec129ef04ad1bb0a1152b29c624
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.krooz_sd.h.2.013366a614baabbe44cc2bbd3205e3d1
                           .group:00000000 wm4.actuators_pwm_arch.h.41.fa66469024778df593e0e3d83e4a3c37
                           .group:00000000 wm4.airframe.h.14.f46e30d413878b482f16a5abf2127a4b
                           .group:00000000 wm4.pprz_geodetic.h.35.f7fdb5d11659b92d11c7ce67b6317005
                           .group:00000000 wm4.float.h.29.1cf88a0527b6b1225d49fbee2b32acb7
                           .group:00000000 wm4.cdefs.h.56.a2d04de9d47039852021e66fca39bb58
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.string.h.126.6ff3aa59129e7f66b2c273baf353e066
                           .group:00000000 wm4.pprz_algebra.h.47.d249264ea6bacf2198e290d461cf6dbe
                           .group:00000000 wm4.pprz_trig_int.h.28.b756be608c9d9f3092a41321446e5fa2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.1a82a3cc35cb0a04319c41bcf41d2a02
                           .group:00000000 wm4.pprz_algebra_int.h.68.04ac162ae1e1d94f716d0bb402062624
                           .group:00000000 wm4.pprz_geodetic_int.h.127.8e737bed5ba4468e470311184b1fca7f
                           .group:00000000 wm4.sys_time.h.31.454ffebb4f6baf6e87ab8a60104a5808
                           .group:00000000 wm4.common.h.21.22efaac882611267214d0a36f6f15e74
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.systick.h.44.34e759e1f218a187b07e9a617cb1d556
                           .group:00000000 wm4.sys_time.h.213.4ee43452c5934214134db56488f53299
                           .group:00000000 wm4.uart_arch.h.30.cb8e70feae0b6afe250750f6c1439671
                           .group:00000000 wm4.uart.h.35.4345324d45fae43faace58e743d48e42
                           .group:00000000 wm4.gps_ubx.h.36.d4183b0b154441c99ce352aae50967b5
                           .group:00000000 wm4.gps.h.41.79d1c69e44dd427f855100ff8e932fbe
                           .group:00000000 wm4.pprz_algebra_float.h.98.bb035bcbfa66bb186e7ea81143fd64bc
                           .group:00000000 wm4.pprz_orientation_conversion.h.69.5cce798fefad8bb761767fd414e61db5

UNDEFINED SYMBOLS
sqrtf
int32_sqrt
__aeabi_f2d
__aeabi_dsub
__aeabi_dcmplt
__aeabi_dcmpgt
__aeabi_dmul
__aeabi_dadd
__aeabi_d2f
float_rmat_of_quat
float_rmat_transp_vmult
float_quat_comp_norm_shortest
__aeabi_ddiv
__aeabi_d2iz
int32_quat_integrate_fi
__aeabi_i2d
int32_rmat_of_quat
orientationCalcRMat_i
int32_rmat_transp_ratemult
int32_rmat_vmult
int32_rmat_transp_vmult
orientationCalcQuat_i
int32_quat_comp_inv
pprz_itrig_cos
pprz_itrig_sin
int32_quat_inv_comp_norm_shortest
int32_quat_comp_norm_shortest
int32_quat_comp
orientationCalcQuat_f
