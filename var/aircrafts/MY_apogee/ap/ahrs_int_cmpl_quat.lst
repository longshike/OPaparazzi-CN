   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"ahrs_int_cmpl_quat.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.float_quat_normalize,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	float_quat_normalize:
  25              	.LFB43:
  26              		.file 1 "./math/pprz_algebra_float.h"
   1:./math/pprz_algebra_float.h **** /*
   2:./math/pprz_algebra_float.h ****  * Copyright (C) 2008-2014 The Paparazzi Team
   3:./math/pprz_algebra_float.h ****  *
   4:./math/pprz_algebra_float.h ****  * This file is part of paparazzi.
   5:./math/pprz_algebra_float.h ****  *
   6:./math/pprz_algebra_float.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_algebra_float.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_algebra_float.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_algebra_float.h ****  * any later version.
  10:./math/pprz_algebra_float.h ****  *
  11:./math/pprz_algebra_float.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_algebra_float.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_algebra_float.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_algebra_float.h ****  * GNU General Public License for more details.
  15:./math/pprz_algebra_float.h ****  *
  16:./math/pprz_algebra_float.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_algebra_float.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_algebra_float.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_algebra_float.h ****  */
  20:./math/pprz_algebra_float.h **** 
  21:./math/pprz_algebra_float.h **** /**
  22:./math/pprz_algebra_float.h ****  * @file pprz_algebra_float.h
  23:./math/pprz_algebra_float.h ****  * @brief Paparazzi floating point algebra.
  24:./math/pprz_algebra_float.h ****  *
  25:./math/pprz_algebra_float.h ****  * @addtogroup math_algebra
  26:./math/pprz_algebra_float.h ****  * @{
  27:./math/pprz_algebra_float.h ****  * @defgroup math_algebra_float Float Algebra
  28:./math/pprz_algebra_float.h ****  * @{
  29:./math/pprz_algebra_float.h ****  */
  30:./math/pprz_algebra_float.h **** 
  31:./math/pprz_algebra_float.h **** #ifndef PPRZ_ALGEBRA_FLOAT_H
  32:./math/pprz_algebra_float.h **** #define PPRZ_ALGEBRA_FLOAT_H
  33:./math/pprz_algebra_float.h **** 
  34:./math/pprz_algebra_float.h **** #ifdef __cplusplus
  35:./math/pprz_algebra_float.h **** extern "C" {
  36:./math/pprz_algebra_float.h **** #endif
  37:./math/pprz_algebra_float.h **** 
  38:./math/pprz_algebra_float.h **** #include "pprz_algebra.h"
  39:./math/pprz_algebra_float.h **** 
  40:./math/pprz_algebra_float.h **** #include <math.h>
  41:./math/pprz_algebra_float.h **** #include <float.h> // for FLT_MIN
  42:./math/pprz_algebra_float.h **** 
  43:./math/pprz_algebra_float.h **** /* this seems to be missing for some arch */
  44:./math/pprz_algebra_float.h **** #ifndef M_SQRT2
  45:./math/pprz_algebra_float.h **** #define M_SQRT2         1.41421356237309504880
  46:./math/pprz_algebra_float.h **** #endif
  47:./math/pprz_algebra_float.h **** 
  48:./math/pprz_algebra_float.h **** struct FloatVect2 {
  49:./math/pprz_algebra_float.h ****   float x;
  50:./math/pprz_algebra_float.h ****   float y;
  51:./math/pprz_algebra_float.h **** };
  52:./math/pprz_algebra_float.h **** 
  53:./math/pprz_algebra_float.h **** struct FloatVect3 {
  54:./math/pprz_algebra_float.h ****   float x;
  55:./math/pprz_algebra_float.h ****   float y;
  56:./math/pprz_algebra_float.h ****   float z;
  57:./math/pprz_algebra_float.h **** };
  58:./math/pprz_algebra_float.h **** 
  59:./math/pprz_algebra_float.h **** /**
  60:./math/pprz_algebra_float.h ****  * @brief Roation quaternion
  61:./math/pprz_algebra_float.h ****  */
  62:./math/pprz_algebra_float.h **** struct FloatQuat {
  63:./math/pprz_algebra_float.h ****   float qi;
  64:./math/pprz_algebra_float.h ****   float qx;
  65:./math/pprz_algebra_float.h ****   float qy;
  66:./math/pprz_algebra_float.h ****   float qz;
  67:./math/pprz_algebra_float.h **** };
  68:./math/pprz_algebra_float.h **** 
  69:./math/pprz_algebra_float.h **** struct FloatMat33 {
  70:./math/pprz_algebra_float.h ****   float m[3 * 3];
  71:./math/pprz_algebra_float.h **** };
  72:./math/pprz_algebra_float.h **** 
  73:./math/pprz_algebra_float.h **** /**
  74:./math/pprz_algebra_float.h ****  * @brief rotation matrix
  75:./math/pprz_algebra_float.h ****  */
  76:./math/pprz_algebra_float.h **** struct FloatRMat {
  77:./math/pprz_algebra_float.h ****   float m[3 * 3];
  78:./math/pprz_algebra_float.h **** };
  79:./math/pprz_algebra_float.h **** 
  80:./math/pprz_algebra_float.h **** /**
  81:./math/pprz_algebra_float.h ****  * @brief euler angles
  82:./math/pprz_algebra_float.h ****  * @details Units: radians */
  83:./math/pprz_algebra_float.h **** struct FloatEulers {
  84:./math/pprz_algebra_float.h ****   float phi; ///< in radians
  85:./math/pprz_algebra_float.h ****   float theta; ///< in radians
  86:./math/pprz_algebra_float.h ****   float psi; ///< in radians
  87:./math/pprz_algebra_float.h **** };
  88:./math/pprz_algebra_float.h **** 
  89:./math/pprz_algebra_float.h **** /**
  90:./math/pprz_algebra_float.h ****  * @brief angular rates
  91:./math/pprz_algebra_float.h ****  * @details Units: rad/s */
  92:./math/pprz_algebra_float.h **** struct FloatRates {
  93:./math/pprz_algebra_float.h ****   float p; ///< in rad/s
  94:./math/pprz_algebra_float.h ****   float q; ///< in rad/s
  95:./math/pprz_algebra_float.h ****   float r; ///< in rad/s
  96:./math/pprz_algebra_float.h **** };
  97:./math/pprz_algebra_float.h **** 
  98:./math/pprz_algebra_float.h **** #define FLOAT_ANGLE_NORMALIZE(_a) {             \
  99:./math/pprz_algebra_float.h ****     while (_a >  M_PI) _a -= (2.*M_PI);             \
 100:./math/pprz_algebra_float.h ****     while (_a < -M_PI) _a += (2.*M_PI);             \
 101:./math/pprz_algebra_float.h ****   }
 102:./math/pprz_algebra_float.h **** 
 103:./math/pprz_algebra_float.h **** //
 104:./math/pprz_algebra_float.h **** //
 105:./math/pprz_algebra_float.h **** // Vector algebra
 106:./math/pprz_algebra_float.h **** //
 107:./math/pprz_algebra_float.h **** //
 108:./math/pprz_algebra_float.h **** 
 109:./math/pprz_algebra_float.h **** 
 110:./math/pprz_algebra_float.h **** /*
 111:./math/pprz_algebra_float.h ****  * Dimension 2 Vectors
 112:./math/pprz_algebra_float.h ****  */
 113:./math/pprz_algebra_float.h **** 
 114:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_ZERO(_v) VECT2_ASSIGN(_v, 0., 0.)
 115:./math/pprz_algebra_float.h **** 
 116:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect2, but a different struct with x,y members */
 117:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORM(_v) sqrtf(VECT2_NORM2(_v))
 118:./math/pprz_algebra_float.h **** 
 119:./math/pprz_algebra_float.h **** static inline float float_vect2_norm2(struct FloatVect2 *v)
 120:./math/pprz_algebra_float.h **** {
 121:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y;
 122:./math/pprz_algebra_float.h **** }
 123:./math/pprz_algebra_float.h **** 
 124:./math/pprz_algebra_float.h **** static inline float float_vect2_norm(struct FloatVect2 *v)
 125:./math/pprz_algebra_float.h **** {
 126:./math/pprz_algebra_float.h ****   return sqrtf(float_vect2_norm2(v));
 127:./math/pprz_algebra_float.h **** }
 128:./math/pprz_algebra_float.h **** 
 129:./math/pprz_algebra_float.h **** /** normalize 2D vector in place */
 130:./math/pprz_algebra_float.h **** static inline void float_vect2_normalize(struct FloatVect2 *v)
 131:./math/pprz_algebra_float.h **** {
 132:./math/pprz_algebra_float.h ****   const float n = float_vect2_norm(v);
 133:./math/pprz_algebra_float.h ****   if (n > 0) {
 134:./math/pprz_algebra_float.h ****     v->x /= n;
 135:./math/pprz_algebra_float.h ****     v->y /= n;
 136:./math/pprz_algebra_float.h ****   }
 137:./math/pprz_algebra_float.h **** }
 138:./math/pprz_algebra_float.h **** 
 139:./math/pprz_algebra_float.h **** #define FLOAT_VECT2_NORMALIZE(_v) float_vect2_normalize(&(_v))
 140:./math/pprz_algebra_float.h **** 
 141:./math/pprz_algebra_float.h **** 
 142:./math/pprz_algebra_float.h **** /*
 143:./math/pprz_algebra_float.h ****  * Dimension 3 Vectors
 144:./math/pprz_algebra_float.h ****  */
 145:./math/pprz_algebra_float.h **** 
 146:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0., 0., 0.)
 147:./math/pprz_algebra_float.h **** 
 148:./math/pprz_algebra_float.h **** /* macros also usable if _v is not a FloatVect3, but a different struct with x,y,z members */
 149:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORM(_v) sqrtf(VECT3_NORM2(_v))
 150:./math/pprz_algebra_float.h **** 
 151:./math/pprz_algebra_float.h **** static inline float float_vect3_norm2(struct FloatVect3 *v)
 152:./math/pprz_algebra_float.h **** {
 153:./math/pprz_algebra_float.h ****   return v->x * v->x + v->y * v->y + v->z * v->z;
 154:./math/pprz_algebra_float.h **** }
 155:./math/pprz_algebra_float.h **** 
 156:./math/pprz_algebra_float.h **** static inline float float_vect3_norm(struct FloatVect3 *v)
 157:./math/pprz_algebra_float.h **** {
 158:./math/pprz_algebra_float.h ****   return sqrtf(float_vect3_norm2(v));
 159:./math/pprz_algebra_float.h **** }
 160:./math/pprz_algebra_float.h **** 
 161:./math/pprz_algebra_float.h **** /** normalize 3D vector in place */
 162:./math/pprz_algebra_float.h **** static inline void float_vect3_normalize(struct FloatVect3 *v)
 163:./math/pprz_algebra_float.h **** {
 164:./math/pprz_algebra_float.h ****   const float n = float_vect3_norm(v);
 165:./math/pprz_algebra_float.h ****   if (n > 0) {
 166:./math/pprz_algebra_float.h ****     v->x /= n;
 167:./math/pprz_algebra_float.h ****     v->y /= n;
 168:./math/pprz_algebra_float.h ****     v->z /= n;
 169:./math/pprz_algebra_float.h ****   }
 170:./math/pprz_algebra_float.h **** }
 171:./math/pprz_algebra_float.h **** 
 172:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_NORMALIZE(_v) float_vect3_normalize(&(_v))
 173:./math/pprz_algebra_float.h **** 
 174:./math/pprz_algebra_float.h **** 
 175:./math/pprz_algebra_float.h **** 
 176:./math/pprz_algebra_float.h **** #define FLOAT_RATES_ZERO(_r) {          \
 177:./math/pprz_algebra_float.h ****     RATES_ASSIGN(_r, 0., 0., 0.);       \
 178:./math/pprz_algebra_float.h ****   }
 179:./math/pprz_algebra_float.h **** 
 180:./math/pprz_algebra_float.h **** #define FLOAT_RATES_NORM(_v) (sqrtf((_v).p*(_v).p + (_v).q*(_v).q + (_v).r*(_v).r))
 181:./math/pprz_algebra_float.h **** 
 182:./math/pprz_algebra_float.h **** #define FLOAT_RATES_LIN_CMB(_ro, _r1, _s1, _r2, _s2) {          \
 183:./math/pprz_algebra_float.h ****     _ro.p = _s1 * _r1.p + _s2 * _r2.p;                  \
 184:./math/pprz_algebra_float.h ****     _ro.q = _s1 * _r1.q + _s2 * _r2.q;                  \
 185:./math/pprz_algebra_float.h ****     _ro.r = _s1 * _r1.r + _s2 * _r2.r;                  \
 186:./math/pprz_algebra_float.h ****   }
 187:./math/pprz_algebra_float.h **** 
 188:./math/pprz_algebra_float.h **** 
 189:./math/pprz_algebra_float.h **** extern void float_vect3_integrate_fi(struct FloatVect3 *vec, struct FloatVect3 *dv,
 190:./math/pprz_algebra_float.h ****                                      float dt);
 191:./math/pprz_algebra_float.h **** 
 192:./math/pprz_algebra_float.h **** extern void float_rates_integrate_fi(struct FloatRates *r, struct FloatRates *dr,
 193:./math/pprz_algebra_float.h ****                                      float dt);
 194:./math/pprz_algebra_float.h **** 
 195:./math/pprz_algebra_float.h **** extern void float_rates_of_euler_dot(struct FloatRates *r, struct FloatEulers *e,
 196:./math/pprz_algebra_float.h ****                                      struct FloatEulers *edot);
 197:./math/pprz_algebra_float.h **** 
 198:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 199:./math/pprz_algebra_float.h **** #define FLOAT_VECT3_INTEGRATE_FI(_vo, _dv, _dt) float_vect3_integrate_fi(&(_vo), &(_dv), _dt)
 200:./math/pprz_algebra_float.h **** #define FLOAT_RATES_INTEGRATE_FI(_ra, _racc, _dt) float_rates_integrate_fi(&(_ra), &(_racc), _dt)
 201:./math/pprz_algebra_float.h **** #define FLOAT_RATES_OF_EULER_DOT(_ra, _e, _ed) float_rates_of_euler_dot(&(_ra), &(_e), &(_ed))
 202:./math/pprz_algebra_float.h **** 
 203:./math/pprz_algebra_float.h **** 
 204:./math/pprz_algebra_float.h **** /*
 205:./math/pprz_algebra_float.h ****  * 3x3 matrices
 206:./math/pprz_algebra_float.h ****  */
 207:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_ZERO(_m) {                      \
 208:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = 0.;                      \
 209:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 210:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 211:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 212:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = 0.;                      \
 213:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 214:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 215:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 216:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = 0.;                      \
 217:./math/pprz_algebra_float.h ****   }
 218:./math/pprz_algebra_float.h **** 
 219:./math/pprz_algebra_float.h **** #define FLOAT_MAT33_DIAG(_m, _d00, _d11, _d22) {    \
 220:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 0) = _d00;                    \
 221:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 1) = 0.;                      \
 222:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 0, 2) = 0.;                      \
 223:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 0) = 0.;                      \
 224:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 1) = _d11;                    \
 225:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 1, 2) = 0.;                      \
 226:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 0) = 0.;                      \
 227:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 1) = 0.;                      \
 228:./math/pprz_algebra_float.h ****     MAT33_ELMT(_m, 2, 2) = _d22;                    \
 229:./math/pprz_algebra_float.h ****   }
 230:./math/pprz_algebra_float.h **** 
 231:./math/pprz_algebra_float.h **** 
 232:./math/pprz_algebra_float.h **** //
 233:./math/pprz_algebra_float.h **** //
 234:./math/pprz_algebra_float.h **** // Rotation Matrices
 235:./math/pprz_algebra_float.h **** //
 236:./math/pprz_algebra_float.h **** //
 237:./math/pprz_algebra_float.h **** 
 238:./math/pprz_algebra_float.h **** 
 239:./math/pprz_algebra_float.h **** /** initialises a rotation matrix to identity */
 240:./math/pprz_algebra_float.h **** static inline void float_rmat_identity(struct FloatRMat *rm)
 241:./math/pprz_algebra_float.h **** {
 242:./math/pprz_algebra_float.h ****   FLOAT_MAT33_DIAG(*rm, 1., 1., 1.);
 243:./math/pprz_algebra_float.h **** }
 244:./math/pprz_algebra_float.h **** 
 245:./math/pprz_algebra_float.h **** /** Inverse/transpose of a rotation matrix.
 246:./math/pprz_algebra_float.h ****  * m_b2a = inv(_m_a2b) = transp(_m_a2b)
 247:./math/pprz_algebra_float.h ****  */
 248:./math/pprz_algebra_float.h **** extern void float_rmat_inv(struct FloatRMat *m_b2a, struct FloatRMat *m_a2b);
 249:./math/pprz_algebra_float.h **** 
 250:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 251:./math/pprz_algebra_float.h ****  * m_a2c = m_a2b comp m_b2c , aka  m_a2c = m_b2c * m_a2b
 252:./math/pprz_algebra_float.h ****  */
 253:./math/pprz_algebra_float.h **** extern void float_rmat_comp(struct FloatRMat *m_a2c, struct FloatRMat *m_a2b,
 254:./math/pprz_algebra_float.h ****                             struct FloatRMat *m_b2c);
 255:./math/pprz_algebra_float.h **** 
 256:./math/pprz_algebra_float.h **** /** Composition (multiplication) of two rotation matrices.
 257:./math/pprz_algebra_float.h ****  * m_a2b = m_a2c comp_inv m_b2c , aka  m_a2b = inv(_m_b2c) * m_a2c
 258:./math/pprz_algebra_float.h ****  */
 259:./math/pprz_algebra_float.h **** extern void float_rmat_comp_inv(struct FloatRMat *m_a2b, struct FloatRMat *m_a2c,
 260:./math/pprz_algebra_float.h ****                                 struct FloatRMat *m_b2c);
 261:./math/pprz_algebra_float.h **** 
 262:./math/pprz_algebra_float.h **** /// Norm of a rotation matrix.
 263:./math/pprz_algebra_float.h **** extern float float_rmat_norm(struct FloatRMat *rm);
 264:./math/pprz_algebra_float.h **** 
 265:./math/pprz_algebra_float.h **** /** rotate 3D vector by rotation matrix.
 266:./math/pprz_algebra_float.h ****  * vb = m_a2b * va
 267:./math/pprz_algebra_float.h ****  */
 268:./math/pprz_algebra_float.h **** extern void float_rmat_vmult(struct FloatVect3 *vb, struct FloatRMat *m_a2b,
 269:./math/pprz_algebra_float.h ****                              struct FloatVect3 *va);
 270:./math/pprz_algebra_float.h **** 
 271:./math/pprz_algebra_float.h **** /** rotate 3D vector by transposed rotation matrix.
 272:./math/pprz_algebra_float.h ****  * vb = m_b2a^T * va
 273:./math/pprz_algebra_float.h ****  */
 274:./math/pprz_algebra_float.h **** extern void float_rmat_transp_vmult(struct FloatVect3 *vb, struct FloatRMat *m_b2a,
 275:./math/pprz_algebra_float.h ****                                     struct FloatVect3 *va);
 276:./math/pprz_algebra_float.h **** 
 277:./math/pprz_algebra_float.h **** /** rotate anglular rates by rotation matrix.
 278:./math/pprz_algebra_float.h ****  * rb = m_a2b * ra
 279:./math/pprz_algebra_float.h ****  */
 280:./math/pprz_algebra_float.h **** extern void float_rmat_ratemult(struct FloatRates *rb, struct FloatRMat *m_a2b,
 281:./math/pprz_algebra_float.h ****                                 struct FloatRates *ra);
 282:./math/pprz_algebra_float.h **** 
 283:./math/pprz_algebra_float.h **** /** rotate anglular rates by transposed rotation matrix.
 284:./math/pprz_algebra_float.h ****  * rb = m_b2a^T * ra
 285:./math/pprz_algebra_float.h ****  */
 286:./math/pprz_algebra_float.h **** extern void float_rmat_transp_ratemult(struct FloatRates *rb, struct FloatRMat *m_b2a,
 287:./math/pprz_algebra_float.h ****                                        struct FloatRates *ra);
 288:./math/pprz_algebra_float.h **** 
 289:./math/pprz_algebra_float.h **** /** initialises a rotation matrix from unit vector axis and angle */
 290:./math/pprz_algebra_float.h **** extern void float_rmat_of_axis_angle(struct FloatRMat *rm, struct FloatVect3 *uv, float angle);
 291:./math/pprz_algebra_float.h **** 
 292:./math/pprz_algebra_float.h **** /** Rotation matrix from 321 Euler angles (float).
 293:./math/pprz_algebra_float.h ****  * The Euler angles are interpreted as zy'x'' (intrinsic) rotation.
 294:./math/pprz_algebra_float.h ****  * First rotate around z with psi, then around the new y' with theta,
 295:./math/pprz_algebra_float.h ****  * then around new x'' with phi.
 296:./math/pprz_algebra_float.h ****  * This is the same as a xyz (extrinsic) rotation,
 297:./math/pprz_algebra_float.h ****  * rotating around the fixed x, then y then z axis.
 298:./math/pprz_algebra_float.h ****  * - psi range: -pi < psi <= pi
 299:./math/pprz_algebra_float.h ****  * - theta range: -pi/2 <= theta <= pi/2
 300:./math/pprz_algebra_float.h ****  * - phi range: -pi < phi <= pi
 301:./math/pprz_algebra_float.h ****  * @param[out] rm pointer to rotation matrix
 302:./math/pprz_algebra_float.h ****  * @param[in]  e pointer to Euler angles
 303:./math/pprz_algebra_float.h ****  */
 304:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_321(struct FloatRMat *rm, struct FloatEulers *e);
 305:./math/pprz_algebra_float.h **** extern void float_rmat_of_eulers_312(struct FloatRMat *rm, struct FloatEulers *e);
 306:./math/pprz_algebra_float.h **** #define float_rmat_of_eulers float_rmat_of_eulers_321
 307:./math/pprz_algebra_float.h **** 
 308:./math/pprz_algebra_float.h **** extern void float_rmat_of_quat(struct FloatRMat *rm, struct FloatQuat *q);
 309:./math/pprz_algebra_float.h **** /** in place first order integration of a rotation matrix */
 310:./math/pprz_algebra_float.h **** extern void float_rmat_integrate_fi(struct FloatRMat *rm, struct FloatRates *omega, float dt);
 311:./math/pprz_algebra_float.h **** extern float float_rmat_reorthogonalize(struct FloatRMat *rm);
 312:./math/pprz_algebra_float.h **** 
 313:./math/pprz_algebra_float.h **** /* defines for backwards compatibility */
 314:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INV(_m_b2a, _m_a2b) float_rmat_inv(&(_m_b2a), &(_m_a2b))
 315:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_NORM(_m) float_rmat_norm(&(_m))
 316:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP(_m_a2c, _m_a2b, _m_b2c) float_rmat_comp(&(_m_a2c), &(_m_a2b), &(_m_b2c))
 317:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_COMP_INV(_m_a2b, _m_a2c, _m_b2c) float_rmat_comp_inv(&(_m_a2b), &(_m_a2c), &(_m_
 318:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_VMULT(_vb, _m_a2b, _va) float_rmat_vmult(&(_vb), &(_m_a2b), &(_va))
 319:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_VMULT(_vb, _m_b2a, _va) float_rmat_transp_vmult(&(_vb), &(_m_b2a), &(_va)
 320:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_RATEMULT(_rb, _m_a2b, _ra) float_rmat_ratemult(&(_rb), &(_m_a2b), &(_ra))
 321:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_TRANSP_RATEMULT(_rb, _m_b2a, _ra) float_rmat_ratemult(&(_rb), &(_m_b2a), &(_ra))
 322:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_AXIS_ANGLE(_rm, _uv, _an) float_rmat_of_axis_angle(&(_rm), &(_uv), _an)
 323:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS(_rm, _e)     float_rmat_of_eulers_321(&(_rm), &(_e))
 324:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_321(_rm, _e) float_rmat_of_eulers_321(&(_rm), &(_e))
 325:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_EULERS_312(_rm, _e) float_rmat_of_eulers_312(&(_rm), &(_e))
 326:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_OF_QUAT(_rm, _q)       float_rmat_of_quat(&(_rm), &(_q))
 327:./math/pprz_algebra_float.h **** #define FLOAT_RMAT_INTEGRATE_FI(_rm, _omega, _dt) float_rmat_integrate_fi(&(_rm), &(_omega), &(_dt)
 328:./math/pprz_algebra_float.h **** 
 329:./math/pprz_algebra_float.h **** 
 330:./math/pprz_algebra_float.h **** 
 331:./math/pprz_algebra_float.h **** //
 332:./math/pprz_algebra_float.h **** //
 333:./math/pprz_algebra_float.h **** // Quaternion algebras
 334:./math/pprz_algebra_float.h **** //
 335:./math/pprz_algebra_float.h **** //
 336:./math/pprz_algebra_float.h **** 
 337:./math/pprz_algebra_float.h **** /** initialises a quaternion to identity */
 338:./math/pprz_algebra_float.h **** static inline void float_quat_identity(struct FloatQuat *q)
 339:./math/pprz_algebra_float.h **** {
 340:./math/pprz_algebra_float.h ****   q->qi = 1.0;
 341:./math/pprz_algebra_float.h ****   q->qx = 0;
 342:./math/pprz_algebra_float.h ****   q->qy = 0;
 343:./math/pprz_algebra_float.h ****   q->qz = 0;
 344:./math/pprz_algebra_float.h **** }
 345:./math/pprz_algebra_float.h **** 
 346:./math/pprz_algebra_float.h **** #define FLOAT_QUAT_NORM2(_q) (SQUARE((_q).qi) + SQUARE((_q).qx) + SQUARE((_q).qy) + SQUARE((_q).qz)
 347:./math/pprz_algebra_float.h **** 
 348:./math/pprz_algebra_float.h **** static inline float float_quat_norm(struct FloatQuat *q)
 349:./math/pprz_algebra_float.h **** {
 350:./math/pprz_algebra_float.h ****   return sqrtf(SQUARE(q->qi) + SQUARE(q->qx) +  SQUARE(q->qy) + SQUARE(q->qz));
 351:./math/pprz_algebra_float.h **** }
 352:./math/pprz_algebra_float.h **** 
 353:./math/pprz_algebra_float.h **** static inline void float_quat_normalize(struct FloatQuat *q)
 354:./math/pprz_algebra_float.h **** {
  27              		.loc 1 354 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32              	.LBB7:
  33              	.LBB8:
 350:./math/pprz_algebra_float.h **** }
  34              		.loc 1 350 0
  35 0000 D0ED017A 		flds	s15, [r0, #4]
  36 0004 90ED006A 		flds	s12, [r0]
  37 0008 D0ED026A 		flds	s13, [r0, #8]
  38 000c 90ED037A 		flds	s14, [r0, #12]
  39 0010 67EEA77A 		fmuls	s15, s15, s15
  40              	.LBE8:
  41              	.LBE7:
  42              		.loc 1 354 0
  43 0014 10B5     		push	{r4, lr}
  44              		.cfi_def_cfa_offset 8
  45              		.cfi_offset 4, -8
  46              		.cfi_offset 14, -4
  47              	.LBB12:
  48              	.LBB9:
 350:./math/pprz_algebra_float.h **** }
  49              		.loc 1 350 0
  50 0016 E6EE067A 		vfma.f32	s15, s12, s12
  51              	.LBE9:
  52              	.LBE12:
  53              		.loc 1 354 0
  54 001a 0446     		mov	r4, r0
  55              	.LBB13:
  56              	.LBB10:
 350:./math/pprz_algebra_float.h **** }
  57              		.loc 1 350 0
  58 001c E6EEA67A 		vfma.f32	s15, s13, s13
  59 0020 E7EE077A 		vfma.f32	s15, s14, s14
  60 0024 17EE900A 		fmrs	r0, s15
  61              	.LVL1:
  62 0028 FFF7FEFF 		bl	sqrtf
  63              	.LVL2:
  64              	.LBE10:
  65              	.LBE13:
 355:./math/pprz_algebra_float.h ****   float qnorm = float_quat_norm(q);
 356:./math/pprz_algebra_float.h ****   if (qnorm > FLT_MIN) {
  66              		.loc 1 356 0
  67 002c 9FED107A 		flds	s14, .L6
  68              	.LBB14:
  69              	.LBB11:
 350:./math/pprz_algebra_float.h **** }
  70              		.loc 1 350 0
  71 0030 07EE900A 		fmsr	s15, r0
  72              	.LBE11:
  73              	.LBE14:
  74              		.loc 1 356 0
  75 0034 F4EEC77A 		fcmpes	s15, s14
  76 0038 F1EE10FA 		fmstat
  77 003c 17DD     		ble	.L1
 357:./math/pprz_algebra_float.h ****     q->qi = q->qi / qnorm;
  78              		.loc 1 357 0
  79 003e 94ED007A 		flds	s14, [r4]
  80 0042 87EE277A 		fdivs	s14, s14, s15
  81 0046 84ED007A 		fsts	s14, [r4]
 358:./math/pprz_algebra_float.h ****     q->qx = q->qx / qnorm;
  82              		.loc 1 358 0
  83 004a 94ED017A 		flds	s14, [r4, #4]
  84 004e 87EE277A 		fdivs	s14, s14, s15
  85 0052 84ED017A 		fsts	s14, [r4, #4]
 359:./math/pprz_algebra_float.h ****     q->qy = q->qy / qnorm;
  86              		.loc 1 359 0
  87 0056 94ED027A 		flds	s14, [r4, #8]
  88 005a 87EE277A 		fdivs	s14, s14, s15
  89 005e 84ED027A 		fsts	s14, [r4, #8]
 360:./math/pprz_algebra_float.h ****     q->qz = q->qz / qnorm;
  90              		.loc 1 360 0
  91 0062 94ED037A 		flds	s14, [r4, #12]
  92 0066 C7EE277A 		fdivs	s15, s14, s15
  93 006a C4ED037A 		fsts	s15, [r4, #12]
  94              	.L1:
  95 006e 10BD     		pop	{r4, pc}
  96              	.LVL3:
  97              	.L7:
  98              		.align	2
  99              	.L6:
 100 0070 00008000 		.word	8388608
 101              		.cfi_endproc
 102              	.LFE43:
 104              		.section	.text.int32_quat_normalize,"ax",%progbits
 105              		.align	1
 106              		.thumb
 107              		.thumb_func
 109              	int32_quat_normalize:
 110              	.LFB8:
 111              		.file 2 "./math/pprz_algebra_int.h"
   1:./math/pprz_algebra_int.h **** /*
   2:./math/pprz_algebra_int.h ****  * Copyright (C) 2008-2014 The Paparazzi Team
   3:./math/pprz_algebra_int.h ****  *
   4:./math/pprz_algebra_int.h ****  * This file is part of paparazzi.
   5:./math/pprz_algebra_int.h ****  *
   6:./math/pprz_algebra_int.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_algebra_int.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_algebra_int.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_algebra_int.h ****  * any later version.
  10:./math/pprz_algebra_int.h ****  *
  11:./math/pprz_algebra_int.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_algebra_int.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_algebra_int.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_algebra_int.h ****  * GNU General Public License for more details.
  15:./math/pprz_algebra_int.h ****  *
  16:./math/pprz_algebra_int.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_algebra_int.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_algebra_int.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_algebra_int.h ****  */
  20:./math/pprz_algebra_int.h **** 
  21:./math/pprz_algebra_int.h **** /**
  22:./math/pprz_algebra_int.h ****  * @file pprz_algebra_int.h
  23:./math/pprz_algebra_int.h ****  * @brief Paparazzi fixed point algebra.
  24:./math/pprz_algebra_int.h ****  *
  25:./math/pprz_algebra_int.h ****  * @addtogroup math_algebra
  26:./math/pprz_algebra_int.h ****  * @{
  27:./math/pprz_algebra_int.h ****  * @addtogroup math_algebra_int Fixed Point Algebra
  28:./math/pprz_algebra_int.h ****  * @{
  29:./math/pprz_algebra_int.h ****  */
  30:./math/pprz_algebra_int.h **** 
  31:./math/pprz_algebra_int.h **** #ifndef PPRZ_ALGEBRA_INT_H
  32:./math/pprz_algebra_int.h **** #define PPRZ_ALGEBRA_INT_H
  33:./math/pprz_algebra_int.h **** 
  34:./math/pprz_algebra_int.h **** #ifdef __cplusplus
  35:./math/pprz_algebra_int.h **** extern "C" {
  36:./math/pprz_algebra_int.h **** #endif
  37:./math/pprz_algebra_int.h **** 
  38:./math/pprz_algebra_int.h **** #include "std.h"
  39:./math/pprz_algebra_int.h **** #include "math/pprz_algebra.h"
  40:./math/pprz_algebra_int.h **** #include "math/pprz_trig_int.h"
  41:./math/pprz_algebra_int.h **** #include <stdlib.h>
  42:./math/pprz_algebra_int.h **** 
  43:./math/pprz_algebra_int.h **** 
  44:./math/pprz_algebra_int.h **** struct Uint8Vect3 {
  45:./math/pprz_algebra_int.h ****   uint8_t x;
  46:./math/pprz_algebra_int.h ****   uint8_t y;
  47:./math/pprz_algebra_int.h ****   uint8_t z;
  48:./math/pprz_algebra_int.h **** };
  49:./math/pprz_algebra_int.h **** 
  50:./math/pprz_algebra_int.h **** struct Int8Vect3 {
  51:./math/pprz_algebra_int.h ****   int8_t x;
  52:./math/pprz_algebra_int.h ****   int8_t y;
  53:./math/pprz_algebra_int.h ****   int8_t z;
  54:./math/pprz_algebra_int.h **** };
  55:./math/pprz_algebra_int.h **** 
  56:./math/pprz_algebra_int.h **** struct Uint16Vect3 {
  57:./math/pprz_algebra_int.h ****   uint16_t x;
  58:./math/pprz_algebra_int.h ****   uint16_t y;
  59:./math/pprz_algebra_int.h ****   uint16_t z;
  60:./math/pprz_algebra_int.h **** };
  61:./math/pprz_algebra_int.h **** 
  62:./math/pprz_algebra_int.h **** struct Int16Vect3 {
  63:./math/pprz_algebra_int.h ****   int16_t x;
  64:./math/pprz_algebra_int.h ****   int16_t y;
  65:./math/pprz_algebra_int.h ****   int16_t z;
  66:./math/pprz_algebra_int.h **** };
  67:./math/pprz_algebra_int.h **** 
  68:./math/pprz_algebra_int.h **** #define INT32_POS_FRAC 8
  69:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM 2.56
  70:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM_NUM 64
  71:./math/pprz_algebra_int.h **** #define INT32_POS_OF_CM_DEN 25
  72:./math/pprz_algebra_int.h **** 
  73:./math/pprz_algebra_int.h **** #define INT32_SPEED_FRAC 19
  74:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S 5242.88
  75:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S_NUM 41943
  76:./math/pprz_algebra_int.h **** #define INT32_SPEED_OF_CM_S_DEN 8
  77:./math/pprz_algebra_int.h **** 
  78:./math/pprz_algebra_int.h **** #define INT32_ACCEL_FRAC 10
  79:./math/pprz_algebra_int.h **** #define INT32_MAG_FRAC 11
  80:./math/pprz_algebra_int.h **** 
  81:./math/pprz_algebra_int.h **** #define INT32_PERCENTAGE_FRAC 10
  82:./math/pprz_algebra_int.h **** 
  83:./math/pprz_algebra_int.h **** struct Int32Vect2 {
  84:./math/pprz_algebra_int.h ****   int32_t x;
  85:./math/pprz_algebra_int.h ****   int32_t y;
  86:./math/pprz_algebra_int.h **** };
  87:./math/pprz_algebra_int.h **** 
  88:./math/pprz_algebra_int.h **** struct Int32Vect3 {
  89:./math/pprz_algebra_int.h ****   int32_t x;
  90:./math/pprz_algebra_int.h ****   int32_t y;
  91:./math/pprz_algebra_int.h ****   int32_t z;
  92:./math/pprz_algebra_int.h **** };
  93:./math/pprz_algebra_int.h **** 
  94:./math/pprz_algebra_int.h **** /* Rotation quaternions                         */
  95:./math/pprz_algebra_int.h **** #define INT32_QUAT_FRAC 15
  96:./math/pprz_algebra_int.h **** /**
  97:./math/pprz_algebra_int.h ****  * @brief Rotation quaternion
  98:./math/pprz_algebra_int.h ****  * @details Units: BFP with #INT32_QUAT_FRAC */
  99:./math/pprz_algebra_int.h **** struct Int32Quat {
 100:./math/pprz_algebra_int.h ****   int32_t qi;
 101:./math/pprz_algebra_int.h ****   int32_t qx;
 102:./math/pprz_algebra_int.h ****   int32_t qy;
 103:./math/pprz_algebra_int.h ****   int32_t qz;
 104:./math/pprz_algebra_int.h **** };
 105:./math/pprz_algebra_int.h **** 
 106:./math/pprz_algebra_int.h **** 
 107:./math/pprz_algebra_int.h **** struct Int64Quat {
 108:./math/pprz_algebra_int.h ****   int64_t qi;
 109:./math/pprz_algebra_int.h ****   int64_t qx;
 110:./math/pprz_algebra_int.h ****   int64_t qy;
 111:./math/pprz_algebra_int.h ****   int64_t qz;
 112:./math/pprz_algebra_int.h **** };
 113:./math/pprz_algebra_int.h **** 
 114:./math/pprz_algebra_int.h **** 
 115:./math/pprz_algebra_int.h **** /* Euler angles                                 */
 116:./math/pprz_algebra_int.h **** #define INT32_ANGLE_FRAC 12
 117:./math/pprz_algebra_int.h **** #define INT32_RATE_FRAC 12
 118:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI_4   (int32_t)ANGLE_BFP_OF_REAL(   0.7853981633974483096156608458198757)
 119:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI_2   (int32_t)ANGLE_BFP_OF_REAL(   1.5707963267948966192313216916397514)
 120:./math/pprz_algebra_int.h **** #define INT32_ANGLE_PI     (int32_t)ANGLE_BFP_OF_REAL(   3.1415926535897932384626433832795029)
 121:./math/pprz_algebra_int.h **** #define INT32_ANGLE_2_PI   (int32_t)ANGLE_BFP_OF_REAL(2.*3.1415926535897932384626433832795029)
 122:./math/pprz_algebra_int.h **** 
 123:./math/pprz_algebra_int.h **** #define INT32_RAD_OF_DEG(_deg) (int32_t)(((int64_t)(_deg) * 14964008)/857374503)
 124:./math/pprz_algebra_int.h **** #define INT32_DEG_OF_RAD(_rad) (int32_t)(((int64_t)(_rad) * 857374503)/14964008)
 125:./math/pprz_algebra_int.h **** 
 126:./math/pprz_algebra_int.h **** #define INT32_ANGLE_NORMALIZE(_a) {             \
 127:./math/pprz_algebra_int.h ****     while ((_a) > INT32_ANGLE_PI)  (_a) -= INT32_ANGLE_2_PI;    \
 128:./math/pprz_algebra_int.h ****     while ((_a) < -INT32_ANGLE_PI) (_a) += INT32_ANGLE_2_PI;    \
 129:./math/pprz_algebra_int.h ****   }
 130:./math/pprz_algebra_int.h **** 
 131:./math/pprz_algebra_int.h **** #define INT32_COURSE_NORMALIZE(_a) {                \
 132:./math/pprz_algebra_int.h ****     while ((_a) < 0) (_a) += INT32_ANGLE_2_PI;                  \
 133:./math/pprz_algebra_int.h ****     while ((_a) >= INT32_ANGLE_2_PI)  (_a) -= INT32_ANGLE_2_PI; \
 134:./math/pprz_algebra_int.h ****   }
 135:./math/pprz_algebra_int.h **** 
 136:./math/pprz_algebra_int.h **** 
 137:./math/pprz_algebra_int.h **** struct Int16Eulers {
 138:./math/pprz_algebra_int.h ****   int16_t phi;
 139:./math/pprz_algebra_int.h ****   int16_t theta;
 140:./math/pprz_algebra_int.h ****   int16_t psi;
 141:./math/pprz_algebra_int.h **** };
 142:./math/pprz_algebra_int.h **** 
 143:./math/pprz_algebra_int.h **** /**
 144:./math/pprz_algebra_int.h ****  * @brief euler angles
 145:./math/pprz_algebra_int.h ****  * @details Units: rad in BFP with #INT32_ANGLE_FRAC */
 146:./math/pprz_algebra_int.h **** struct Int32Eulers {
 147:./math/pprz_algebra_int.h ****   int32_t phi;   ///< in rad with #INT32_ANGLE_FRAC
 148:./math/pprz_algebra_int.h ****   int32_t theta; ///< in rad with #INT32_ANGLE_FRAC
 149:./math/pprz_algebra_int.h ****   int32_t psi;   ///< in rad with #INT32_ANGLE_FRAC
 150:./math/pprz_algebra_int.h **** };
 151:./math/pprz_algebra_int.h **** 
 152:./math/pprz_algebra_int.h **** 
 153:./math/pprz_algebra_int.h **** /* Rotation matrix. */
 154:./math/pprz_algebra_int.h **** #define INT32_TRIG_FRAC 14
 155:./math/pprz_algebra_int.h **** 
 156:./math/pprz_algebra_int.h **** /**
 157:./math/pprz_algebra_int.h ****  * @brief rotation matrix
 158:./math/pprz_algebra_int.h ****  * @details Units: rad in BFP with #INT32_TRIG_FRAC */
 159:./math/pprz_algebra_int.h **** struct Int32RMat {
 160:./math/pprz_algebra_int.h ****   int32_t m[3 * 3];
 161:./math/pprz_algebra_int.h **** };
 162:./math/pprz_algebra_int.h **** 
 163:./math/pprz_algebra_int.h **** /* 3x3 matrix                                    */
 164:./math/pprz_algebra_int.h **** struct Int32Mat33 {
 165:./math/pprz_algebra_int.h ****   int32_t m[3 * 3];
 166:./math/pprz_algebra_int.h **** };
 167:./math/pprz_algebra_int.h **** 
 168:./math/pprz_algebra_int.h **** /* Rotational speed                              */
 169:./math/pprz_algebra_int.h **** struct Int16Rates {
 170:./math/pprz_algebra_int.h ****   int16_t p;
 171:./math/pprz_algebra_int.h ****   int16_t q;
 172:./math/pprz_algebra_int.h ****   int16_t r;
 173:./math/pprz_algebra_int.h **** };
 174:./math/pprz_algebra_int.h **** 
 175:./math/pprz_algebra_int.h **** /* Rotational speed                              */
 176:./math/pprz_algebra_int.h **** /**
 177:./math/pprz_algebra_int.h ****  * @brief angular rates
 178:./math/pprz_algebra_int.h ****  * @details Units: rad/s in BFP with #INT32_RATE_FRAC */
 179:./math/pprz_algebra_int.h **** struct Int32Rates {
 180:./math/pprz_algebra_int.h ****   int32_t p; ///< in rad/s with #INT32_RATE_FRAC
 181:./math/pprz_algebra_int.h ****   int32_t q; ///< in rad/s with #INT32_RATE_FRAC
 182:./math/pprz_algebra_int.h ****   int32_t r; ///< in rad/s with #INT32_RATE_FRAC
 183:./math/pprz_algebra_int.h **** };
 184:./math/pprz_algebra_int.h **** 
 185:./math/pprz_algebra_int.h **** struct Int64Rates {
 186:./math/pprz_algebra_int.h ****   int64_t p;
 187:./math/pprz_algebra_int.h ****   int64_t q;
 188:./math/pprz_algebra_int.h ****   int64_t r;
 189:./math/pprz_algebra_int.h **** };
 190:./math/pprz_algebra_int.h **** 
 191:./math/pprz_algebra_int.h **** 
 192:./math/pprz_algebra_int.h **** struct Int64Vect2 {
 193:./math/pprz_algebra_int.h ****   int64_t x;
 194:./math/pprz_algebra_int.h ****   int64_t y;
 195:./math/pprz_algebra_int.h **** };
 196:./math/pprz_algebra_int.h **** 
 197:./math/pprz_algebra_int.h **** struct Int64Vect3 {
 198:./math/pprz_algebra_int.h ****   int64_t x;
 199:./math/pprz_algebra_int.h ****   int64_t y;
 200:./math/pprz_algebra_int.h ****   int64_t z;
 201:./math/pprz_algebra_int.h **** };
 202:./math/pprz_algebra_int.h **** 
 203:./math/pprz_algebra_int.h **** 
 204:./math/pprz_algebra_int.h **** // Real (floating point) ->  Binary Fixed Point  (int)
 205:./math/pprz_algebra_int.h **** #define BFP_OF_REAL(_vr, _frac)    ((_vr)*(1<<(_frac)))
 206:./math/pprz_algebra_int.h **** #define FLOAT_OF_BFP(_vbfp, _frac) ((float)(_vbfp)/(1<<(_frac)))
 207:./math/pprz_algebra_int.h **** #define DOUBLE_OF_BFP(_vbfp, _frac) ((double)(_vbfp)/(1<<(_frac)))
 208:./math/pprz_algebra_int.h **** #define RATE_BFP_OF_REAL(_af)   BFP_OF_REAL((_af), INT32_RATE_FRAC)
 209:./math/pprz_algebra_int.h **** #define RATE_FLOAT_OF_BFP(_ai)  FLOAT_OF_BFP((_ai), INT32_RATE_FRAC)
 210:./math/pprz_algebra_int.h **** #define ANGLE_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_ANGLE_FRAC)
 211:./math/pprz_algebra_int.h **** #define ANGLE_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_ANGLE_FRAC)
 212:./math/pprz_algebra_int.h **** #define QUAT1_BFP_OF_REAL(_qf)  BFP_OF_REAL((_qf), INT32_QUAT_FRAC)
 213:./math/pprz_algebra_int.h **** #define QUAT1_FLOAT_OF_BFP(_qi) FLOAT_OF_BFP((_qi), INT32_QUAT_FRAC)
 214:./math/pprz_algebra_int.h **** #define TRIG_BFP_OF_REAL(_tf)   BFP_OF_REAL((_tf), INT32_TRIG_FRAC)
 215:./math/pprz_algebra_int.h **** #define TRIG_FLOAT_OF_BFP(_ti)  FLOAT_OF_BFP((_ti),INT32_TRIG_FRAC)
 216:./math/pprz_algebra_int.h **** #define POS_BFP_OF_REAL(_af)    BFP_OF_REAL((_af), INT32_POS_FRAC)
 217:./math/pprz_algebra_int.h **** #define POS_FLOAT_OF_BFP(_ai)   FLOAT_OF_BFP((_ai), INT32_POS_FRAC)
 218:./math/pprz_algebra_int.h **** #define SPEED_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_SPEED_FRAC)
 219:./math/pprz_algebra_int.h **** #define SPEED_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_SPEED_FRAC)
 220:./math/pprz_algebra_int.h **** #define ACCEL_BFP_OF_REAL(_af)  BFP_OF_REAL((_af), INT32_ACCEL_FRAC)
 221:./math/pprz_algebra_int.h **** #define ACCEL_FLOAT_OF_BFP(_ai) FLOAT_OF_BFP((_ai), INT32_ACCEL_FRAC)
 222:./math/pprz_algebra_int.h **** #define MAG_BFP_OF_REAL(_af)    BFP_OF_REAL((_af), INT32_MAG_FRAC)
 223:./math/pprz_algebra_int.h **** #define MAG_FLOAT_OF_BFP(_ai)   FLOAT_OF_BFP((_ai), INT32_MAG_FRAC)
 224:./math/pprz_algebra_int.h **** 
 225:./math/pprz_algebra_int.h **** #define INT_MULT_RSHIFT(_a, _b, _r) (((_a)*(_b))>>(_r))
 226:./math/pprz_algebra_int.h **** 
 227:./math/pprz_algebra_int.h **** 
 228:./math/pprz_algebra_int.h **** extern uint32_t int32_sqrt(uint32_t in);
 229:./math/pprz_algebra_int.h **** #define INT32_SQRT(_out,_in) { _out = int32_sqrt(_in); }
 230:./math/pprz_algebra_int.h **** 
 231:./math/pprz_algebra_int.h **** 
 232:./math/pprz_algebra_int.h **** /*
 233:./math/pprz_algebra_int.h ****  * Dimension 2 Vectors
 234:./math/pprz_algebra_int.h ****  */
 235:./math/pprz_algebra_int.h **** 
 236:./math/pprz_algebra_int.h **** #define INT_VECT2_ZERO(_v) VECT2_ASSIGN(_v, 0, 0)
 237:./math/pprz_algebra_int.h **** 
 238:./math/pprz_algebra_int.h **** /* macros also usable if _v is not a Int32Vect2, but a different struct with x,y members */
 239:./math/pprz_algebra_int.h **** #define INT32_VECT2_NORM(_v) int32_sqrt(VECT2_NORM2(_v))
 240:./math/pprz_algebra_int.h **** 
 241:./math/pprz_algebra_int.h **** /** return squared norm of 2D vector */
 242:./math/pprz_algebra_int.h **** static inline uint32_t int32_vect2_norm2(struct Int32Vect2 *v)
 243:./math/pprz_algebra_int.h **** {
 244:./math/pprz_algebra_int.h ****   return v->x * v->x + v->y * v->y;
 245:./math/pprz_algebra_int.h **** }
 246:./math/pprz_algebra_int.h **** 
 247:./math/pprz_algebra_int.h **** /** return norm of 2D vector */
 248:./math/pprz_algebra_int.h **** static inline uint32_t int32_vect2_norm(struct Int32Vect2 *v)
 249:./math/pprz_algebra_int.h **** {
 250:./math/pprz_algebra_int.h ****   return int32_sqrt(int32_vect2_norm2(v));
 251:./math/pprz_algebra_int.h **** }
 252:./math/pprz_algebra_int.h **** 
 253:./math/pprz_algebra_int.h **** /** normalize 2D vector inplace */
 254:./math/pprz_algebra_int.h **** static inline void int32_vect2_normalize(struct Int32Vect2 *v, uint8_t frac)
 255:./math/pprz_algebra_int.h **** {
 256:./math/pprz_algebra_int.h ****   const uint32_t n = int32_vect2_norm(v);
 257:./math/pprz_algebra_int.h ****   if (n > 0) {
 258:./math/pprz_algebra_int.h ****     const int32_t f = BFP_OF_REAL((1.), frac);
 259:./math/pprz_algebra_int.h ****     v->x = v->x * f / (int32_t)n;
 260:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 261:./math/pprz_algebra_int.h ****   }
 262:./math/pprz_algebra_int.h **** }
 263:./math/pprz_algebra_int.h **** 
 264:./math/pprz_algebra_int.h **** #define INT32_VECT2_NORMALIZE(_v,_frac) int32_vect2_normalize(&(_v), _frac)
 265:./math/pprz_algebra_int.h **** 
 266:./math/pprz_algebra_int.h **** 
 267:./math/pprz_algebra_int.h **** #define INT32_VECT2_RSHIFT(_o, _i, _r) { \
 268:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x >> (_r)); \
 269:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y >> (_r)); \
 270:./math/pprz_algebra_int.h ****   }
 271:./math/pprz_algebra_int.h **** 
 272:./math/pprz_algebra_int.h **** #define INT32_VECT2_LSHIFT(_o, _i, _l) { \
 273:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x << (_l)); \
 274:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y << (_l)); \
 275:./math/pprz_algebra_int.h ****   }
 276:./math/pprz_algebra_int.h **** 
 277:./math/pprz_algebra_int.h **** #define INT32_VECT2_SCALE_2(_a, _b, _num, _den) {   \
 278:./math/pprz_algebra_int.h ****     (_a).x = ((_b).x * (_num)) / (_den);        \
 279:./math/pprz_algebra_int.h ****     (_a).y = ((_b).y * (_num)) / (_den);        \
 280:./math/pprz_algebra_int.h ****   }
 281:./math/pprz_algebra_int.h **** 
 282:./math/pprz_algebra_int.h **** /*
 283:./math/pprz_algebra_int.h ****  * Dimension 3 Vectors
 284:./math/pprz_algebra_int.h ****  */
 285:./math/pprz_algebra_int.h **** 
 286:./math/pprz_algebra_int.h **** #define INT_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0, 0, 0)
 287:./math/pprz_algebra_int.h **** #define INT32_VECT3_ZERO(_v) VECT3_ASSIGN(_v, 0, 0, 0)
 288:./math/pprz_algebra_int.h **** 
 289:./math/pprz_algebra_int.h **** #define INT32_VECT3_SCALE_2(_a, _b, _num, _den) {   \
 290:./math/pprz_algebra_int.h ****     (_a).x = ((_b).x * (_num)) / (_den);        \
 291:./math/pprz_algebra_int.h ****     (_a).y = ((_b).y * (_num)) / (_den);        \
 292:./math/pprz_algebra_int.h ****     (_a).z = ((_b).z * (_num)) / (_den);        \
 293:./math/pprz_algebra_int.h ****   }
 294:./math/pprz_algebra_int.h **** 
 295:./math/pprz_algebra_int.h **** #define INT32_VECT3_NORM(_v) int32_sqrt(VECT3_NORM2(_v))
 296:./math/pprz_algebra_int.h **** 
 297:./math/pprz_algebra_int.h **** #define INT32_VECT3_RSHIFT(_o, _i, _r) { \
 298:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x >> (_r));       \
 299:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y >> (_r));       \
 300:./math/pprz_algebra_int.h ****     (_o).z = ((_i).z >> (_r));       \
 301:./math/pprz_algebra_int.h ****   }
 302:./math/pprz_algebra_int.h **** 
 303:./math/pprz_algebra_int.h **** #define INT32_VECT3_LSHIFT(_o, _i, _l) { \
 304:./math/pprz_algebra_int.h ****     (_o).x = ((_i).x << (_l));       \
 305:./math/pprz_algebra_int.h ****     (_o).y = ((_i).y << (_l));       \
 306:./math/pprz_algebra_int.h ****     (_o).z = ((_i).z << (_l));       \
 307:./math/pprz_algebra_int.h ****   }
 308:./math/pprz_algebra_int.h **** 
 309:./math/pprz_algebra_int.h **** 
 310:./math/pprz_algebra_int.h **** 
 311:./math/pprz_algebra_int.h **** /*
 312:./math/pprz_algebra_int.h ****  * 3x3 Matrices
 313:./math/pprz_algebra_int.h ****  */
 314:./math/pprz_algebra_int.h **** #define INT32_MAT33_ZERO(_m) {                      \
 315:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 0) = 0;                     \
 316:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 1) = 0;                     \
 317:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 2) = 0;                     \
 318:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 0) = 0;                     \
 319:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 1) = 0;                     \
 320:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 2) = 0;                     \
 321:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 0) = 0;                     \
 322:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 1) = 0;                     \
 323:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 2) = 0;                     \
 324:./math/pprz_algebra_int.h ****   }
 325:./math/pprz_algebra_int.h **** 
 326:./math/pprz_algebra_int.h **** #define INT32_MAT33_DIAG(_m, _d00, _d11, _d22) {    \
 327:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 0) = (_d00);                \
 328:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 1) = 0;                     \
 329:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 0, 2) = 0;                     \
 330:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 0) = 0;                     \
 331:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 1) = (_d11);                \
 332:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 1, 2) = 0;                     \
 333:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 0) = 0;                     \
 334:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 1) = 0;                     \
 335:./math/pprz_algebra_int.h ****     MAT33_ELMT((_m), 2, 2) = (_d22);                \
 336:./math/pprz_algebra_int.h ****   }
 337:./math/pprz_algebra_int.h **** 
 338:./math/pprz_algebra_int.h **** 
 339:./math/pprz_algebra_int.h **** 
 340:./math/pprz_algebra_int.h **** /*
 341:./math/pprz_algebra_int.h ****  * Rotation matrices
 342:./math/pprz_algebra_int.h ****  */
 343:./math/pprz_algebra_int.h **** 
 344:./math/pprz_algebra_int.h **** /** initialises a rotation matrix to identity */
 345:./math/pprz_algebra_int.h **** static inline void int32_rmat_identity(struct Int32RMat *rm)
 346:./math/pprz_algebra_int.h **** {
 347:./math/pprz_algebra_int.h ****   INT32_MAT33_DIAG(*rm, TRIG_BFP_OF_REAL(1.), TRIG_BFP_OF_REAL(1.), TRIG_BFP_OF_REAL(1.));
 348:./math/pprz_algebra_int.h **** }
 349:./math/pprz_algebra_int.h **** 
 350:./math/pprz_algebra_int.h **** /** Composition (multiplication) of two rotation matrices.
 351:./math/pprz_algebra_int.h ****  * m_a2c = m_a2b comp m_b2c , aka  m_a2c = m_b2c * m_a2b
 352:./math/pprz_algebra_int.h ****  */
 353:./math/pprz_algebra_int.h **** extern void int32_rmat_comp(struct Int32RMat *m_a2c, struct Int32RMat *m_a2b,
 354:./math/pprz_algebra_int.h ****                             struct Int32RMat *m_b2c);
 355:./math/pprz_algebra_int.h **** 
 356:./math/pprz_algebra_int.h **** /** Composition (multiplication) of two rotation matrices.
 357:./math/pprz_algebra_int.h ****  * m_a2b = m_a2c comp_inv m_b2c , aka  m_a2b = inv(_m_b2c) * m_a2c
 358:./math/pprz_algebra_int.h ****  */
 359:./math/pprz_algebra_int.h **** extern void int32_rmat_comp_inv(struct Int32RMat *m_a2b, struct Int32RMat *m_a2c,
 360:./math/pprz_algebra_int.h ****                                 struct Int32RMat *m_b2c);
 361:./math/pprz_algebra_int.h **** 
 362:./math/pprz_algebra_int.h **** /** rotate 3D vector by rotation matrix.
 363:./math/pprz_algebra_int.h ****  * vb = m_a2b * va
 364:./math/pprz_algebra_int.h ****  */
 365:./math/pprz_algebra_int.h **** extern void int32_rmat_vmult(struct Int32Vect3 *vb, struct Int32RMat *m_a2b,
 366:./math/pprz_algebra_int.h ****                              struct Int32Vect3 *va);
 367:./math/pprz_algebra_int.h **** 
 368:./math/pprz_algebra_int.h **** /** rotate 3D vector by transposed rotation matrix.
 369:./math/pprz_algebra_int.h ****  * vb = m_b2a^T * va
 370:./math/pprz_algebra_int.h ****  */
 371:./math/pprz_algebra_int.h **** extern void int32_rmat_transp_vmult(struct Int32Vect3 *vb, struct Int32RMat *m_b2a,
 372:./math/pprz_algebra_int.h ****                                     struct Int32Vect3 *va);
 373:./math/pprz_algebra_int.h **** 
 374:./math/pprz_algebra_int.h **** /** rotate anglular rates by rotation matrix.
 375:./math/pprz_algebra_int.h ****  * rb = m_a2b * ra
 376:./math/pprz_algebra_int.h ****  */
 377:./math/pprz_algebra_int.h **** extern void int32_rmat_ratemult(struct Int32Rates *rb, struct Int32RMat *m_a2b,
 378:./math/pprz_algebra_int.h ****                                 struct Int32Rates *ra);
 379:./math/pprz_algebra_int.h **** 
 380:./math/pprz_algebra_int.h **** /** rotate anglular rates by transposed rotation matrix.
 381:./math/pprz_algebra_int.h ****  * rb = m_b2a^T * ra
 382:./math/pprz_algebra_int.h ****  */
 383:./math/pprz_algebra_int.h **** extern void int32_rmat_transp_ratemult(struct Int32Rates *rb, struct Int32RMat *m_b2a,
 384:./math/pprz_algebra_int.h ****                                        struct Int32Rates *ra);
 385:./math/pprz_algebra_int.h **** 
 386:./math/pprz_algebra_int.h **** /// Convert unit quaternion to rotation matrix.
 387:./math/pprz_algebra_int.h **** extern void int32_rmat_of_quat(struct Int32RMat *rm, struct Int32Quat *q);
 388:./math/pprz_algebra_int.h **** 
 389:./math/pprz_algebra_int.h **** /** Rotation matrix from 321 Euler angles (int).
 390:./math/pprz_algebra_int.h ****  * The Euler angles are interpreted as zy'x'' (intrinsic) rotation.
 391:./math/pprz_algebra_int.h ****  * First rotate around z with psi, then around the new y' with theta,
 392:./math/pprz_algebra_int.h ****  * then around new x'' with phi.
 393:./math/pprz_algebra_int.h ****  * This is the same as a xyz (extrinsic) rotation,
 394:./math/pprz_algebra_int.h ****  * rotating around the fixed x, then y then z axis.
 395:./math/pprz_algebra_int.h ****  * - psi range: -pi < psi <= pi
 396:./math/pprz_algebra_int.h ****  * - theta range: -pi/2 <= theta <= pi/2
 397:./math/pprz_algebra_int.h ****  * - phi range: -pi < phi <= pi
 398:./math/pprz_algebra_int.h ****  * @param[out] rm pointer to rotation matrix
 399:./math/pprz_algebra_int.h ****  * @param[in]  e pointer to Euler angles
 400:./math/pprz_algebra_int.h ****  */
 401:./math/pprz_algebra_int.h **** extern void int32_rmat_of_eulers_321(struct Int32RMat *rm, struct Int32Eulers *e);
 402:./math/pprz_algebra_int.h **** 
 403:./math/pprz_algebra_int.h **** /// Rotation matrix from 312 Euler angles.
 404:./math/pprz_algebra_int.h **** extern void int32_rmat_of_eulers_312(struct Int32RMat *rm, struct Int32Eulers *e);
 405:./math/pprz_algebra_int.h **** 
 406:./math/pprz_algebra_int.h **** /// Rotation matrix from Euler angles.
 407:./math/pprz_algebra_int.h **** #define int32_rmat_of_eulers int32_rmat_of_eulers_321
 408:./math/pprz_algebra_int.h **** 
 409:./math/pprz_algebra_int.h **** /* defines for backwards compatibility */
 410:./math/pprz_algebra_int.h **** #define INT32_RMAT_COMP(_m_a2c, _m_a2b, _m_b2c) int32_rmat_comp(&(_m_a2c), &(_m_a2b), &(_m_b2c))
 411:./math/pprz_algebra_int.h **** #define INT32_RMAT_COMP_INV(_m_a2b, _m_a2c, _m_b2c) int32_rmat_comp_inv(&(_m_a2b), &(_m_a2c), &(_m_
 412:./math/pprz_algebra_int.h **** #define INT32_RMAT_VMULT(_vb, _m_a2b, _va) int32_rmat_vmult(&(_vb), &(_m_a2b), &(_va))
 413:./math/pprz_algebra_int.h **** #define INT32_RMAT_TRANSP_VMULT(_vb, _m_b2a, _va) int32_rmat_transp_vmult(&(_vb), &(_m_b2a), &(_va)
 414:./math/pprz_algebra_int.h **** #define INT32_RMAT_RATEMULT(_rb, _m_a2b, _ra) int32_rmat_ratemult(&(_rb), &(_m_a2b), &(_ra))
 415:./math/pprz_algebra_int.h **** #define INT32_RMAT_TRANSP_RATEMULT(_rb, _m_b2a, _ra) int32_rmat_ratemult(&(_rb), &(_m_b2a), &(_ra))
 416:./math/pprz_algebra_int.h **** 
 417:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_QUAT(_rm, _q) int32_rmat_of_quat(&(_rm), &(_q))
 418:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS(_rm, _e) int32_rmat_of_eulers_321(&(_rm), &(_e))
 419:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS_321(_rm, _e) int32_rmat_of_eulers_321(&(_rm), &(_e))
 420:./math/pprz_algebra_int.h **** #define INT32_RMAT_OF_EULERS_312(_rm, _e) int32_rmat_of_eulers_312(&(_rm), &(_e))
 421:./math/pprz_algebra_int.h **** 
 422:./math/pprz_algebra_int.h **** 
 423:./math/pprz_algebra_int.h **** /*
 424:./math/pprz_algebra_int.h ****  *
 425:./math/pprz_algebra_int.h ****  * Quaternions
 426:./math/pprz_algebra_int.h ****  *
 427:./math/pprz_algebra_int.h ****  */
 428:./math/pprz_algebra_int.h **** 
 429:./math/pprz_algebra_int.h **** /** initialises a quaternion to identity */
 430:./math/pprz_algebra_int.h **** static inline void int32_quat_identity(struct Int32Quat *q)
 431:./math/pprz_algebra_int.h **** {
 432:./math/pprz_algebra_int.h ****   q->qi = QUAT1_BFP_OF_REAL(1);
 433:./math/pprz_algebra_int.h ****   q->qx = 0;
 434:./math/pprz_algebra_int.h ****   q->qy = 0;
 435:./math/pprz_algebra_int.h ****   q->qz = 0;
 436:./math/pprz_algebra_int.h **** }
 437:./math/pprz_algebra_int.h **** 
 438:./math/pprz_algebra_int.h **** /** Norm of a quaternion.
 439:./math/pprz_algebra_int.h ****  */
 440:./math/pprz_algebra_int.h **** static inline uint32_t int32_quat_norm(struct Int32Quat *q)
 441:./math/pprz_algebra_int.h **** {
 442:./math/pprz_algebra_int.h ****   uint32_t n2 = q->qi * q->qi + q->qx * q->qx + q->qy * q->qy + q->qz * q->qz;
 443:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 444:./math/pprz_algebra_int.h **** }
 445:./math/pprz_algebra_int.h **** 
 446:./math/pprz_algebra_int.h **** static inline void int32_quat_wrap_shortest(struct Int32Quat *q)
 447:./math/pprz_algebra_int.h **** {
 448:./math/pprz_algebra_int.h ****   if (q->qi < 0) {
 449:./math/pprz_algebra_int.h ****     QUAT_EXPLEMENTARY(*q, *q);
 450:./math/pprz_algebra_int.h ****   }
 451:./math/pprz_algebra_int.h **** }
 452:./math/pprz_algebra_int.h **** 
 453:./math/pprz_algebra_int.h **** /** normalize a quaternion inplace */
 454:./math/pprz_algebra_int.h **** static inline void int32_quat_normalize(struct Int32Quat *q)
 455:./math/pprz_algebra_int.h **** {
 112              		.loc 2 455 0
 113              		.cfi_startproc
 114              		@ args = 0, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              	.LVL4:
 117              	.LBB17:
 118              	.LBB18:
 442:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 119              		.loc 2 442 0
 120 0000 4168     		ldr	r1, [r0, #4]
 121 0002 0268     		ldr	r2, [r0]
 122 0004 8368     		ldr	r3, [r0, #8]
 123 0006 4943     		muls	r1, r1, r1
 124              	.LBE18:
 125              	.LBE17:
 126              		.loc 2 455 0
 127 0008 10B5     		push	{r4, lr}
 128              		.cfi_def_cfa_offset 8
 129              		.cfi_offset 4, -8
 130              		.cfi_offset 14, -4
 131              	.LBB21:
 132              	.LBB19:
 442:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 133              		.loc 2 442 0
 134 000a 02FB0212 		mla	r2, r2, r2, r1
 135              	.LBE19:
 136              	.LBE21:
 137              		.loc 2 455 0
 138 000e 0446     		mov	r4, r0
 139              	.LBB22:
 140              	.LBB20:
 442:./math/pprz_algebra_int.h ****   return int32_sqrt(n2);
 141              		.loc 2 442 0
 142 0010 C068     		ldr	r0, [r0, #12]
 143              	.LVL5:
 144 0012 03FB0323 		mla	r3, r3, r3, r2
 443:./math/pprz_algebra_int.h **** }
 145              		.loc 2 443 0
 146 0016 00FB0030 		mla	r0, r0, r0, r3
 147 001a FFF7FEFF 		bl	int32_sqrt
 148              	.LVL6:
 149              	.LBE20:
 150              	.LBE22:
 456:./math/pprz_algebra_int.h ****   int32_t n = int32_quat_norm(q);
 457:./math/pprz_algebra_int.h ****   if (n > 0) {
 151              		.loc 2 457 0
 152 001e 0028     		cmp	r0, #0
 153 0020 13DD     		ble	.L8
 458:./math/pprz_algebra_int.h ****     q->qi = q->qi * QUAT1_BFP_OF_REAL(1) / n;
 154              		.loc 2 458 0
 155 0022 2268     		ldr	r2, [r4]
 459:./math/pprz_algebra_int.h ****     q->qx = q->qx * QUAT1_BFP_OF_REAL(1) / n;
 460:./math/pprz_algebra_int.h ****     q->qy = q->qy * QUAT1_BFP_OF_REAL(1) / n;
 461:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 156              		.loc 2 461 0
 157 0024 E368     		ldr	r3, [r4, #12]
 458:./math/pprz_algebra_int.h ****     q->qi = q->qi * QUAT1_BFP_OF_REAL(1) / n;
 158              		.loc 2 458 0
 159 0026 D203     		lsls	r2, r2, #15
 160 0028 92FBF0F2 		sdiv	r2, r2, r0
 161 002c 2260     		str	r2, [r4]
 459:./math/pprz_algebra_int.h ****     q->qx = q->qx * QUAT1_BFP_OF_REAL(1) / n;
 162              		.loc 2 459 0
 163 002e 6268     		ldr	r2, [r4, #4]
 164 0030 D203     		lsls	r2, r2, #15
 165 0032 92FBF0F2 		sdiv	r2, r2, r0
 166 0036 6260     		str	r2, [r4, #4]
 460:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 167              		.loc 2 460 0
 168 0038 A268     		ldr	r2, [r4, #8]
 169              		.loc 2 461 0
 170 003a DB03     		lsls	r3, r3, #15
 460:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 171              		.loc 2 460 0
 172 003c D203     		lsls	r2, r2, #15
 173              		.loc 2 461 0
 174 003e 93FBF0F3 		sdiv	r3, r3, r0
 460:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 175              		.loc 2 460 0
 176 0042 92FBF0F2 		sdiv	r2, r2, r0
 177              		.loc 2 461 0
 178 0046 E360     		str	r3, [r4, #12]
 460:./math/pprz_algebra_int.h ****     q->qz = q->qz * QUAT1_BFP_OF_REAL(1) / n;
 179              		.loc 2 460 0
 180 0048 A260     		str	r2, [r4, #8]
 181              	.L8:
 182 004a 10BD     		pop	{r4, pc}
 183              		.cfi_endproc
 184              	.LFE8:
 186              		.global	__aeabi_f2d
 187              		.global	__aeabi_dsub
 188              		.global	__aeabi_dcmplt
 189              		.global	__aeabi_dcmpgt
 190              		.global	__aeabi_dmul
 191              		.global	__aeabi_dadd
 192              		.global	__aeabi_d2f
 193              		.section	.text.ahrs_icq_align,"ax",%progbits
 194              		.align	1
 195              		.global	ahrs_icq_align
 196              		.thumb
 197              		.thumb_func
 199              	ahrs_icq_align:
 200              	.LFB90:
 201              		.file 3 "subsystems/ahrs/ahrs_int_cmpl_quat.c"
   1:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /*
   2:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Copyright (C) 2008-2013 The Paparazzi Team
   3:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
   4:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * This file is part of paparazzi.
   5:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
   6:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * it under the terms of the GNU General Public License as published by
   8:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * any later version.
  10:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  11:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * GNU General Public License for more details.
  15:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  16:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * You should have received a copy of the GNU General Public License
  17:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Boston, MA 02111-1307, USA.
  20:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  21:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  22:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /**
  23:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * @file subsystems/ahrs/ahrs_int_cmpl_quat.c
  24:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  25:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Quaternion complementary filter (fixed-point).
  26:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  27:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Estimate the attitude, heading and gyro bias.
  28:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  *
  29:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  30:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  31:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "generated/airframe.h"
  32:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  33:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/ahrs/ahrs_int_cmpl_quat.h"
  34:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/ahrs/ahrs_int_utils.h"
  35:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  36:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_GPS
  37:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "subsystems/gps.h"
  38:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  39:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "math/pprz_trig_int.h"
  40:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #include "math/pprz_algebra_int.h"
  41:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  42:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_PROPAGATE_LOW_PASS_RATES
  43:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_MSG("LOW PASS FILTER ON GYRO RATES")
  44:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  45:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  46:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_MAG_UPDATE_YAW_ONLY
  47:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #error "The define AHRS_MAG_UPDATE_YAW_ONLY doesn't exist anymore, please remove it. This is the de
  48:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  49:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  50:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER && AHRS_USE_GPS_HEADING
  51:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #warning "Using both magnetometer and GPS course to update heading. Probably better to configure US
  52:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  53:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  54:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if !USE_MAGNETOMETER && !AHRS_USE_GPS_HEADING
  55:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #warning "Please use either USE_MAGNETOMETER or AHRS_USE_GPS_HEADING."
  56:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  57:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  58:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_USE_GPS_HEADING && !USE_GPS
  59:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #error "AHRS_USE_GPS_HEADING needs USE_GPS to be TRUE"
  60:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  61:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  62:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /*
  63:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * default gains for correcting attitude and bias from accel/mag
  64:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  65:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_ACCEL_OMEGA
  66:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_ACCEL_OMEGA 0.063
  67:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  68:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_ACCEL_ZETA
  69:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_ACCEL_ZETA 0.9
  70:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  71:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_ACCEL_OMEGA)
  72:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_ACCEL_ZETA)
  73:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  74:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  75:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_MAG_OMEGA
  76:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_MAG_OMEGA 0.04
  77:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  78:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_MAG_ZETA
  79:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_MAG_ZETA 0.9
  80:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  81:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER
  82:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_MAG_OMEGA)
  83:subsystems/ahrs/ahrs_int_cmpl_quat.c **** PRINT_CONFIG_VAR(AHRS_MAG_ZETA)
  84:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  85:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  86:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** by default use the gravity heuristic to reduce gain */
  87:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_GRAVITY_HEURISTIC_FACTOR
  88:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_GRAVITY_HEURISTIC_FACTOR 30
  89:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  90:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  91:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** don't update gyro bias if heading deviation is above this threshold in degrees */
  92:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_BIAS_UPDATE_HEADING_THRESHOLD
  93:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_BIAS_UPDATE_HEADING_THRESHOLD 5.0
  94:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
  95:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
  96:subsystems/ahrs/ahrs_int_cmpl_quat.c **** /** Minimum speed in m/s for heading update via GPS.
  97:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  * Don't update heading from GPS course if GPS ground speed is below is this threshold
  98:subsystems/ahrs/ahrs_int_cmpl_quat.c ****  */
  99:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifndef AHRS_HEADING_UPDATE_GPS_MIN_SPEED
 100:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define AHRS_HEADING_UPDATE_GPS_MIN_SPEED 5.0
 101:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 102:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 103:subsystems/ahrs/ahrs_int_cmpl_quat.c **** struct AhrsIntCmplQuat ahrs_icq;
 104:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 105:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void UNUSED ahrs_icq_update_mag_full(struct Int32Vect3 *mag, float dt);
 106:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_2d(struct Int32Vect3 *mag, float dt);
 107:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 108:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_init(void)
 109:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 110:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_UNINIT;
 112:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 113:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 114:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.ltp_vel_norm_valid = FALSE;
 115:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 116:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 117:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* init ltp_to_imu quaternion as zero/identity rotation */
 118:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_identity(&ahrs_icq.ltp_to_imu_quat);
 119:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 120:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.imu_rate);
 121:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 122:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.gyro_bias);
 123:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.high_rez_bias);
 125:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 126:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* set default filter cut-off frequency and damping */
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_omega = AHRS_ACCEL_OMEGA;
 128:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_zeta = AHRS_ACCEL_ZETA;
 129:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_accel_gains();
 130:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_omega = AHRS_MAG_OMEGA;
 131:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_zeta = AHRS_MAG_ZETA;
 132:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_mag_gains();
 133:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 134:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* set default gravity heuristic */
 135:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.gravity_heuristic_factor = AHRS_GRAVITY_HEURISTIC_FACTOR;
 136:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 137:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_GRAVITY_UPDATE_COORDINATED_TURN
 138:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.correct_gravity = TRUE;
 139:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 140:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.correct_gravity = FALSE;
 141:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 142:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 143:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ASSIGN(ahrs_icq.mag_h, MAG_BFP_OF_REAL(AHRS_H_X),
 144:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                MAG_BFP_OF_REAL(AHRS_H_Y), MAG_BFP_OF_REAL(AHRS_H_Z));
 145:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 146:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 147:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 148:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 149:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 150:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 151:subsystems/ahrs/ahrs_int_cmpl_quat.c **** bool_t ahrs_icq_align(struct Int32Rates *lp_gyro, struct Int32Vect3 *lp_accel,
 152:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                       struct Int32Vect3 *lp_mag)
 153:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 202              		.loc 3 153 0
 203              		.cfi_startproc
 204              		@ args = 0, pretend = 0, frame = 112
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              	.LVL7:
 207 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 208              		.cfi_def_cfa_offset 36
 209              		.cfi_offset 4, -36
 210              		.cfi_offset 5, -32
 211              		.cfi_offset 6, -28
 212              		.cfi_offset 7, -24
 213              		.cfi_offset 8, -20
 214              		.cfi_offset 9, -16
 215              		.cfi_offset 10, -12
 216              		.cfi_offset 11, -8
 217              		.cfi_offset 14, -4
 218              	.LBB35:
 219              	.LBB36:
 220              	.LBB37:
 221              	.LBB38:
 222              	.LBB39:
 223              	.LBB40:
 224              		.file 4 "./subsystems/ahrs/ahrs_float_utils.h"
   1:./subsystems/ahrs/ahrs_float_utils.h **** /*
   2:./subsystems/ahrs/ahrs_float_utils.h ****  * Copyright (C) 2009 Felix Ruess <felix.ruess@gmail.com>
   3:./subsystems/ahrs/ahrs_float_utils.h ****  * Copyright (C) 2009 Antoine Drouin <poinix@gmail.com>
   4:./subsystems/ahrs/ahrs_float_utils.h ****  *
   5:./subsystems/ahrs/ahrs_float_utils.h ****  * This file is part of paparazzi.
   6:./subsystems/ahrs/ahrs_float_utils.h ****  *
   7:./subsystems/ahrs/ahrs_float_utils.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./subsystems/ahrs/ahrs_float_utils.h ****  * it under the terms of the GNU General Public License as published by
   9:./subsystems/ahrs/ahrs_float_utils.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./subsystems/ahrs/ahrs_float_utils.h ****  * any later version.
  11:./subsystems/ahrs/ahrs_float_utils.h ****  *
  12:./subsystems/ahrs/ahrs_float_utils.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./subsystems/ahrs/ahrs_float_utils.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./subsystems/ahrs/ahrs_float_utils.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./subsystems/ahrs/ahrs_float_utils.h ****  * GNU General Public License for more details.
  16:./subsystems/ahrs/ahrs_float_utils.h ****  *
  17:./subsystems/ahrs/ahrs_float_utils.h ****  * You should have received a copy of the GNU General Public License
  18:./subsystems/ahrs/ahrs_float_utils.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./subsystems/ahrs/ahrs_float_utils.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./subsystems/ahrs/ahrs_float_utils.h ****  * Boston, MA 02111-1307, USA.
  21:./subsystems/ahrs/ahrs_float_utils.h ****  */
  22:./subsystems/ahrs/ahrs_float_utils.h **** 
  23:./subsystems/ahrs/ahrs_float_utils.h **** /**
  24:./subsystems/ahrs/ahrs_float_utils.h ****  * @file subsystems/ahrs/ahrs_float_utils.h
  25:./subsystems/ahrs/ahrs_float_utils.h ****  *
  26:./subsystems/ahrs/ahrs_float_utils.h ****  * Utility functions for floating point AHRS implementations.
  27:./subsystems/ahrs/ahrs_float_utils.h ****  *
  28:./subsystems/ahrs/ahrs_float_utils.h ****  */
  29:./subsystems/ahrs/ahrs_float_utils.h **** 
  30:./subsystems/ahrs/ahrs_float_utils.h **** #ifndef AHRS_FLOAT_UTILS_H
  31:./subsystems/ahrs/ahrs_float_utils.h **** #define AHRS_FLOAT_UTILS_H
  32:./subsystems/ahrs/ahrs_float_utils.h **** 
  33:./subsystems/ahrs/ahrs_float_utils.h **** #include "math/pprz_algebra_float.h"
  34:./subsystems/ahrs/ahrs_float_utils.h **** #include "subsystems/ahrs/ahrs_magnetic_field_model.h"
  35:./subsystems/ahrs/ahrs_float_utils.h **** 
  36:./subsystems/ahrs/ahrs_float_utils.h **** #include "std.h" // for ABS
  37:./subsystems/ahrs/ahrs_float_utils.h **** 
  38:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_euler_from_accel_mag(struct FloatEulers *e, struct Int32Vect3 *ac
  39:./subsystems/ahrs/ahrs_float_utils.h ****     struct Int32Vect3 *mag)
  40:./subsystems/ahrs/ahrs_float_utils.h **** {
  41:./subsystems/ahrs/ahrs_float_utils.h ****   /* get phi and theta from accelerometer */
  42:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 accelf;
  43:./subsystems/ahrs/ahrs_float_utils.h ****   ACCELS_FLOAT_OF_BFP(accelf, *accel);
  44:./subsystems/ahrs/ahrs_float_utils.h ****   const float phi   = atan2f(-accelf.y, -accelf.z);
  45:./subsystems/ahrs/ahrs_float_utils.h ****   const float cphi = cosf(phi);
  46:./subsystems/ahrs/ahrs_float_utils.h ****   const float theta = atan2f(cphi * accelf.x, -accelf.z);
  47:./subsystems/ahrs/ahrs_float_utils.h **** 
  48:./subsystems/ahrs/ahrs_float_utils.h ****   /* get psi from magnetometer */
  49:./subsystems/ahrs/ahrs_float_utils.h ****   /* project mag on local tangeant plane */
  50:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 magf;
  51:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(magf, *mag);
  52:./subsystems/ahrs/ahrs_float_utils.h ****   const float sphi   = sinf(phi);
  53:./subsystems/ahrs/ahrs_float_utils.h ****   const float ctheta = cosf(theta);
  54:./subsystems/ahrs/ahrs_float_utils.h ****   const float stheta = sinf(theta);
  55:./subsystems/ahrs/ahrs_float_utils.h ****   const float mn = ctheta * magf.x + sphi * stheta * magf.y + cphi * stheta * magf.z;
  56:./subsystems/ahrs/ahrs_float_utils.h ****   const float me =     0. * magf.x + cphi       * magf.y - sphi       * magf.z;
  57:./subsystems/ahrs/ahrs_float_utils.h ****   float psi = -atan2f(me, mn) + atan2(AHRS_H_Y, AHRS_H_X);
  58:./subsystems/ahrs/ahrs_float_utils.h ****   if (psi > M_PI) { psi -= 2.*M_PI; } if (psi < -M_PI) { psi += 2.*M_PI; }
  59:./subsystems/ahrs/ahrs_float_utils.h ****   EULERS_ASSIGN(*e, phi, theta, psi);
  60:./subsystems/ahrs/ahrs_float_utils.h **** 
  61:./subsystems/ahrs/ahrs_float_utils.h **** }
  62:./subsystems/ahrs/ahrs_float_utils.h **** 
  63:./subsystems/ahrs/ahrs_float_utils.h **** /** Compute a quaternion representing roll and pitch from an accelerometer measurement. */
  64:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_quat_from_accel(struct FloatQuat *q, struct Int32Vect3 *accel)
  65:./subsystems/ahrs/ahrs_float_utils.h **** {
  66:./subsystems/ahrs/ahrs_float_utils.h ****   /* normalized accel measurement in floating point */
  67:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 acc_normalized;
  68:./subsystems/ahrs/ahrs_float_utils.h ****   ACCELS_FLOAT_OF_BFP(acc_normalized, *accel);
 225              		.loc 4 68 0
 226 0004 91ED017A 		flds	s14, [r1, #4]	@ int
 227 0008 D1ED007A 		flds	s15, [r1]	@ int
 228              	.LBE40:
 229              	.LBE39:
 230              	.LBE38:
 231              	.LBE37:
 232              	.LBE36:
 233              	.LBE35:
 234              		.loc 3 153 0
 235 000c 2DED048B 		fstmfdd	sp!, {d8, d9}
 236              		.cfi_def_cfa_offset 52
 237              		.cfi_offset 80, -52
 238              		.cfi_offset 81, -48
 239              		.cfi_offset 82, -44
 240              		.cfi_offset 83, -40
 241              	.LBB83:
 242              	.LBB71:
 243              	.LBB68:
 244              	.LBB65:
 245              	.LBB62:
 246              	.LBB59:
 247              		.loc 4 68 0
 248 0010 F8EEC78A 		fsitos	s17, s14
 249 0014 91ED028A 		flds	s16, [r1, #8]	@ int
 250 0018 B8EEE79A 		fsitos	s18, s15
 251 001c DFEDA87A 		flds	s15, .L32+16
 252 0020 B8EEC88A 		fsitos	s16, s16
 253 0024 68EEA78A 		fmuls	s17, s17, s15
 254 0028 28EE278A 		fmuls	s16, s16, s15
 255 002c 29EE279A 		fmuls	s18, s18, s15
 256              	.LBB41:
 257              	.LBB42:
 258              	.LBB43:
 259              	.LBB44:
 260              	.LBB45:
 261              	.LBB46:
 153:./math/pprz_algebra_float.h **** }
 262              		.loc 1 153 0
 263 0030 68EEA87A 		fmuls	s15, s17, s17
 264              	.LBE46:
 265              	.LBE45:
 266              	.LBE44:
 267              	.LBE43:
 268              	.LBE42:
 269              	.LBE41:
 270              	.LBE59:
 271              	.LBE62:
 272              	.LBE65:
 273              	.LBE68:
 274              	.LBE71:
 275              	.LBE83:
 276              		.loc 3 153 0
 277 0034 9DB0     		sub	sp, sp, #116
 278              		.cfi_def_cfa_offset 168
 279              	.LBB84:
 280              	.LBB72:
 281              	.LBB69:
 282              	.LBB66:
 283              	.LBB63:
 284              	.LBB60:
 285              	.LBB56:
 286              	.LBB53:
 287              	.LBB51:
 288              	.LBB49:
 289              	.LBB48:
 290              	.LBB47:
 153:./math/pprz_algebra_float.h **** }
 291              		.loc 1 153 0
 292 0036 E9EE097A 		vfma.f32	s15, s18, s18
 293              	.LBE47:
 294              	.LBE48:
 295              	.LBE49:
 296              	.LBE51:
 297              	.LBE53:
 298              	.LBE56:
 299              	.LBE60:
 300              	.LBE63:
 301              	.LBE66:
 302              	.LBE69:
 303              	.LBE72:
 304              	.LBE84:
 305              		.loc 3 153 0
 306 003a 0546     		mov	r5, r0
 307 003c 9046     		mov	r8, r2
 308              	.LVL8:
 309              	.LBB85:
 310              	.LBB73:
 311              	.LBB70:
 312              	.LBB67:
 313              	.LBB64:
 314              	.LBB61:
  69:./subsystems/ahrs/ahrs_float_utils.h ****   FLOAT_VECT3_NORMALIZE(acc_normalized);
  70:./subsystems/ahrs/ahrs_float_utils.h **** 
  71:./subsystems/ahrs/ahrs_float_utils.h ****   /* check for 180deg case */
  72:./subsystems/ahrs/ahrs_float_utils.h ****   if (ABS(acc_normalized.z - 1.0) < 5 * FLT_MIN) {
 315              		.loc 4 72 0
 316 003e 4FF00104 		mov	r4, #1
 317              	.LBB57:
 318              	.LBB54:
 319              	.LBB52:
 320              	.LBB50:
 158:./math/pprz_algebra_float.h **** }
 321              		.loc 1 158 0
 322 0042 E8EE087A 		vfma.f32	s15, s16, s16
 323 0046 17EE900A 		fmrs	r0, s15
 324              	.LVL9:
 325 004a FFF7FEFF 		bl	sqrtf
 326              	.LVL10:
 327 004e 07EE900A 		fmsr	s15, r0
 328              	.LBE50:
 329              	.LBE52:
 165:./math/pprz_algebra_float.h ****     v->x /= n;
 330              		.loc 1 165 0
 331 0052 F5EEC07A 		fcmpezs	s15
 332 0056 F1EE10FA 		fmstat
 168:./math/pprz_algebra_float.h ****   }
 333              		.loc 1 168 0
 334 005a C4BF     		itt	gt
 335 005c 88EE278A 		fdivsgt	s16, s16, s15
 336              	.LVL11:
 166:./math/pprz_algebra_float.h ****     v->y /= n;
 337              		.loc 1 166 0
 338 0060 89EE279A 		fdivsgt	s18, s18, s15
 339              	.LVL12:
 340              	.LBE54:
 341              	.LBE57:
 342              		.loc 4 72 0
 343 0064 18EE100A 		fmrs	r0, s16
 344              	.LBB58:
 345              	.LBB55:
 167:./math/pprz_algebra_float.h ****     v->z /= n;
 346              		.loc 1 167 0
 347 0068 C8BF     		it	gt
 348 006a C8EEA78A 		fdivsgt	s17, s17, s15
 349              	.LVL13:
 350              	.LBE55:
 351              	.LBE58:
 352              		.loc 4 72 0
 353 006e FFF7FEFF 		bl	__aeabi_f2d
 354              	.LVL14:
 355 0072 0022     		movs	r2, #0
 356 0074 934B     		ldr	r3, .L32+20
 357 0076 FFF7FEFF 		bl	__aeabi_dsub
 358              	.LVL15:
 359 007a 0022     		movs	r2, #0
 360 007c 0023     		movs	r3, #0
 361 007e 0646     		mov	r6, r0
 362 0080 0F46     		mov	r7, r1
 363 0082 FFF7FEFF 		bl	__aeabi_dcmplt
 364              	.LVL16:
 365 0086 30B1     		cbz	r0, .L28
 366 0088 3046     		mov	r0, r6
 367 008a 3946     		mov	r1, r7
 368 008c 0022     		movs	r2, #0
 369 008e 8E4B     		ldr	r3, .L32+24
 370 0090 FFF7FEFF 		bl	__aeabi_dcmpgt
 371              	.LVL17:
 372 0094 05E0     		b	.L31
 373              	.L28:
 374 0096 3046     		mov	r0, r6
 375 0098 3946     		mov	r1, r7
 376 009a 0022     		movs	r2, #0
 377 009c 8B4B     		ldr	r3, .L32+28
 378 009e FFF7FEFF 		bl	__aeabi_dcmplt
 379              	.LVL18:
 380              	.L31:
 381 00a2 00B9     		cbnz	r0, .L17
 382 00a4 0446     		mov	r4, r0
 383              	.L17:
 384 00a6 E3B2     		uxtb	r3, r4
 385 00a8 F7EE009A 		fconsts	s19, #112
 386 00ac 0024     		movs	r4, #0
 387 00ae 2BB1     		cbz	r3, .L18
  73:./subsystems/ahrs/ahrs_float_utils.h ****     QUAT_ASSIGN(*q, 0.0, 1.0, 0.0, 0.0);
 388              		.loc 4 73 0
 389 00b0 0B94     		str	r4, [sp, #44]	@ float
 390 00b2 CDED0C9A 		fsts	s19, [sp, #48]
 391 00b6 0D94     		str	r4, [sp, #52]	@ float
 392 00b8 0E94     		str	r4, [sp, #56]	@ float
 393 00ba 0DE0     		b	.L19
 394              	.L18:
  74:./subsystems/ahrs/ahrs_float_utils.h ****   } else {
  75:./subsystems/ahrs/ahrs_float_utils.h ****     /*
  76:./subsystems/ahrs/ahrs_float_utils.h ****      * axis we want to rotate around is cross product of accel and reference [0,0,-g]
  77:./subsystems/ahrs/ahrs_float_utils.h ****      * normalized: cross(acc_normalized, [0,0,-1])
  78:./subsystems/ahrs/ahrs_float_utils.h ****      * vector part of quaternion is the axis
  79:./subsystems/ahrs/ahrs_float_utils.h ****      * scalar part (angle): 1.0 + dot(acc_normalized, [0,0,-1])
  80:./subsystems/ahrs/ahrs_float_utils.h ****      */
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qx = - acc_normalized.y;
  82:./subsystems/ahrs/ahrs_float_utils.h ****     q->qy = acc_normalized.x;
  83:./subsystems/ahrs/ahrs_float_utils.h ****     q->qz = 0.0;
  84:./subsystems/ahrs/ahrs_float_utils.h ****     q->qi = 1.0 - acc_normalized.z;
 395              		.loc 4 84 0
 396 00bc 39EEC88A 		fsubs	s16, s19, s16
 397              	.LVL19:
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qy = acc_normalized.x;
 398              		.loc 4 81 0
 399 00c0 F1EE688A 		fnegs	s17, s17
 400              	.LVL20:
  85:./subsystems/ahrs/ahrs_float_utils.h ****     float_quat_normalize(q);
 401              		.loc 4 85 0
 402 00c4 0BA8     		add	r0, sp, #44
 403              	.LVL21:
  81:./subsystems/ahrs/ahrs_float_utils.h ****     q->qy = acc_normalized.x;
 404              		.loc 4 81 0
 405 00c6 CDED0C8A 		fsts	s17, [sp, #48]
  82:./subsystems/ahrs/ahrs_float_utils.h ****     q->qz = 0.0;
 406              		.loc 4 82 0
 407 00ca 8DED0D9A 		fsts	s18, [sp, #52]
  83:./subsystems/ahrs/ahrs_float_utils.h ****     q->qi = 1.0 - acc_normalized.z;
 408              		.loc 4 83 0
 409 00ce 0E94     		str	r4, [sp, #56]	@ float
  84:./subsystems/ahrs/ahrs_float_utils.h ****     float_quat_normalize(q);
 410              		.loc 4 84 0
 411 00d0 8DED0B8A 		fsts	s16, [sp, #44]
 412              		.loc 4 85 0
 413 00d4 FFF7FEFF 		bl	float_quat_normalize
 414              	.LVL22:
 415              	.L19:
 416              	.LBE61:
 417              	.LBE64:
  86:./subsystems/ahrs/ahrs_float_utils.h ****   }
  87:./subsystems/ahrs/ahrs_float_utils.h **** }
  88:./subsystems/ahrs/ahrs_float_utils.h **** 
  89:./subsystems/ahrs/ahrs_float_utils.h **** static inline void ahrs_float_get_quat_from_accel_mag(struct FloatQuat *q, struct Int32Vect3 *accel
  90:./subsystems/ahrs/ahrs_float_utils.h ****     struct Int32Vect3 *mag)
  91:./subsystems/ahrs/ahrs_float_utils.h **** {
  92:./subsystems/ahrs/ahrs_float_utils.h **** 
  93:./subsystems/ahrs/ahrs_float_utils.h ****   /* the quaternion representing roll and pitch from acc measurement */
  94:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatQuat q_a;
  95:./subsystems/ahrs/ahrs_float_utils.h ****   ahrs_float_get_quat_from_accel(&q_a, accel);
  96:./subsystems/ahrs/ahrs_float_utils.h **** 
  97:./subsystems/ahrs/ahrs_float_utils.h **** 
  98:./subsystems/ahrs/ahrs_float_utils.h ****   /* convert mag measurement to float */
  99:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 mag_float;
 100:./subsystems/ahrs/ahrs_float_utils.h ****   MAGS_FLOAT_OF_BFP(mag_float, *mag);
 418              		.loc 4 100 0
 419 00d8 D8ED007A 		flds	s15, [r8]	@ int
 420 00dc DFED7C6A 		flds	s13, .L32+32
 421 00e0 B8EEE77A 		fsitos	s14, s15
 422 00e4 D8ED017A 		flds	s15, [r8, #4]	@ int
 423 00e8 27EE267A 		fmuls	s14, s14, s13
 101:./subsystems/ahrs/ahrs_float_utils.h **** 
 102:./subsystems/ahrs/ahrs_float_utils.h ****   /* and rotate to horizontal plane using the quat from above */
 103:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatRMat rmat_phi_theta;
 104:./subsystems/ahrs/ahrs_float_utils.h ****   float_rmat_of_quat(&rmat_phi_theta, &q_a);
 424              		.loc 4 104 0
 425 00ec 13A8     		add	r0, sp, #76
 100:./subsystems/ahrs/ahrs_float_utils.h **** 
 426              		.loc 4 100 0
 427 00ee 8DED017A 		fsts	s14, [sp, #4]
 428 00f2 B8EEE77A 		fsitos	s14, s15
 429 00f6 D8ED027A 		flds	s15, [r8, #8]	@ int
 430 00fa F8EEE77A 		fsitos	s15, s15
 431 00fe 27EE267A 		fmuls	s14, s14, s13
 432 0102 67EEA67A 		fmuls	s15, s15, s13
 433              		.loc 4 104 0
 434 0106 0BA9     		add	r1, sp, #44
 435              	.LVL23:
 100:./subsystems/ahrs/ahrs_float_utils.h **** 
 436              		.loc 4 100 0
 437 0108 8DED027A 		fsts	s14, [sp, #8]
 438 010c CDED037A 		fsts	s15, [sp, #12]
 439              		.loc 4 104 0
 440 0110 FFF7FEFF 		bl	float_rmat_of_quat
 441              	.LVL24:
 105:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatVect3 mag_ltp;
 106:./subsystems/ahrs/ahrs_float_utils.h ****   float_rmat_transp_vmult(&mag_ltp, &rmat_phi_theta, &mag_float);
 442              		.loc 4 106 0
 443 0114 01AA     		add	r2, sp, #4
 444 0116 13A9     		add	r1, sp, #76
 445 0118 04A8     		add	r0, sp, #16
 446 011a FFF7FEFF 		bl	float_rmat_transp_vmult
 447              	.LVL25:
 107:./subsystems/ahrs/ahrs_float_utils.h **** 
 108:./subsystems/ahrs/ahrs_float_utils.h ****   /* heading from mag -> make quaternion to rotate around ltp z axis*/
 109:./subsystems/ahrs/ahrs_float_utils.h ****   struct FloatQuat q_m;
 110:./subsystems/ahrs/ahrs_float_utils.h **** 
 111:./subsystems/ahrs/ahrs_float_utils.h ****   /* dot([mag_n.x, mag_n.x, 0], [AHRS_H_X, AHRS_H_Y, 0]) */
 112:./subsystems/ahrs/ahrs_float_utils.h ****   float dot = mag_ltp.x * AHRS_H_X + mag_ltp.y * AHRS_H_Y;
 448              		.loc 4 112 0
 449 011e 9DED058A 		flds	s16, [sp, #20]
 450 0122 DDED048A 		flds	s17, [sp, #16]
 451              	.LVL26:
 113:./subsystems/ahrs/ahrs_float_utils.h **** 
 114:./subsystems/ahrs/ahrs_float_utils.h ****   /* |v1||v2| */
 115:./subsystems/ahrs/ahrs_float_utils.h ****   float norm2 = sqrtf(SQUARE(mag_ltp.x) + SQUARE(mag_ltp.y))
 452              		.loc 4 115 0
 453 0126 68EE087A 		fmuls	s15, s16, s16
 454 012a E8EEA87A 		vfma.f32	s15, s17, s17
 455 012e 17EE900A 		fmrs	r0, s15
 456 0132 FFF7FEFF 		bl	sqrtf
 457              	.LVL27:
 458 0136 09EE100A 		fmsr	s18, r0
 459              	.LVL28:
 112:./subsystems/ahrs/ahrs_float_utils.h **** 
 460              		.loc 4 112 0
 461 013a 18EE900A 		fmrs	r0, s17
 462              	.LVL29:
 463 013e FFF7FEFF 		bl	__aeabi_f2d
 464              	.LVL30:
 465 0142 5BA3     		adr	r3, .L32
 466 0144 D3E90023 		ldrd	r2, [r3]
 467 0148 FFF7FEFF 		bl	__aeabi_dmul
 468              	.LVL31:
 469 014c 0646     		mov	r6, r0
 470 014e 18EE100A 		fmrs	r0, s16
 471 0152 0F46     		mov	r7, r1
 472 0154 FFF7FEFF 		bl	__aeabi_f2d
 473              	.LVL32:
 474 0158 57A3     		adr	r3, .L32+8
 475 015a D3E90023 		ldrd	r2, [r3]
 476 015e FFF7FEFF 		bl	__aeabi_dmul
 477              	.LVL33:
 478 0162 0246     		mov	r2, r0
 479 0164 0B46     		mov	r3, r1
 480 0166 3046     		mov	r0, r6
 481 0168 3946     		mov	r1, r7
 482 016a FFF7FEFF 		bl	__aeabi_dadd
 483              	.LVL34:
 484 016e FFF7FEFF 		bl	__aeabi_d2f
 485              	.LVL35:
 116:./subsystems/ahrs/ahrs_float_utils.h ****                 * sqrtf(SQUARE(AHRS_H_X) + SQUARE(AHRS_H_Y));
 117:./subsystems/ahrs/ahrs_float_utils.h **** 
 118:./subsystems/ahrs/ahrs_float_utils.h ****   // catch 180deg case
 119:./subsystems/ahrs/ahrs_float_utils.h ****   if (ABS(norm2 + dot) < 5 * FLT_MIN) {
 486              		.loc 4 119 0
 487 0172 DFED587A 		flds	s15, .L32+36
 488 0176 08EE100A 		fmsr	s16, r0
 489              	.LVL36:
 490 017a A9EE278A 		vfma.f32	s16, s18, s15
 491 017e B5EEC08A 		fcmpezs	s16
 492 0182 F1EE10FA 		fmstat
 493 0186 09D5     		bpl	.L29
 494 0188 DFED537A 		flds	s15, .L32+40
 495 018c B4EEE78A 		fcmpes	s16, s15
 496 0190 F1EE10FA 		fmstat
 497 0194 CCBF     		ite	gt
 498 0196 0123     		movgt	r3, #1
 499 0198 0023     		movle	r3, #0
 500 019a 08E0     		b	.L22
 501              	.L29:
 502 019c DFED4F7A 		flds	s15, .L32+44
 503 01a0 B4EEE78A 		fcmpes	s16, s15
 504 01a4 F1EE10FA 		fmstat
 505 01a8 4CBF     		ite	mi
 506 01aa 0123     		movmi	r3, #1
 507 01ac 0023     		movpl	r3, #0
 508              	.L22:
 509 01ae 2BB1     		cbz	r3, .L23
 120:./subsystems/ahrs/ahrs_float_utils.h ****     QUAT_ASSIGN(q_m, 0.0, 0.0, 0.0, 1.0);
 510              		.loc 4 120 0
 511 01b0 0F94     		str	r4, [sp, #60]	@ float
 512 01b2 1094     		str	r4, [sp, #64]	@ float
 513 01b4 1194     		str	r4, [sp, #68]	@ float
 514 01b6 CDED129A 		fsts	s19, [sp, #72]
 515 01ba 21E0     		b	.L24
 516              	.L23:
 121:./subsystems/ahrs/ahrs_float_utils.h ****   } else {
 122:./subsystems/ahrs/ahrs_float_utils.h ****     /* q_xyz = cross([mag_n.x, mag_n.y, 0], [AHRS_H_X, AHRS_H_Y, 0]) */
 123:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qx = 0.0;
 124:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qy = 0.0;
 125:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qz = mag_ltp.x * AHRS_H_Y - mag_ltp.y * AHRS_H_X;
 517              		.loc 4 125 0
 518 01bc 0498     		ldr	r0, [sp, #16]	@ float
 123:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qy = 0.0;
 519              		.loc 4 123 0
 520 01be 1094     		str	r4, [sp, #64]	@ float
 124:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qz = mag_ltp.x * AHRS_H_Y - mag_ltp.y * AHRS_H_X;
 521              		.loc 4 124 0
 522 01c0 1194     		str	r4, [sp, #68]	@ float
 523              		.loc 4 125 0
 524 01c2 FFF7FEFF 		bl	__aeabi_f2d
 525              	.LVL37:
 526 01c6 3CA3     		adr	r3, .L32+8
 527 01c8 D3E90023 		ldrd	r2, [r3]
 528 01cc FFF7FEFF 		bl	__aeabi_dmul
 529              	.LVL38:
 530 01d0 0646     		mov	r6, r0
 531 01d2 0598     		ldr	r0, [sp, #20]	@ float
 532 01d4 0F46     		mov	r7, r1
 533 01d6 FFF7FEFF 		bl	__aeabi_f2d
 534              	.LVL39:
 535 01da 35A3     		adr	r3, .L32
 536 01dc D3E90023 		ldrd	r2, [r3]
 537 01e0 FFF7FEFF 		bl	__aeabi_dmul
 538              	.LVL40:
 539 01e4 0246     		mov	r2, r0
 540 01e6 0B46     		mov	r3, r1
 541 01e8 3046     		mov	r0, r6
 542 01ea 3946     		mov	r1, r7
 543 01ec FFF7FEFF 		bl	__aeabi_dsub
 544              	.LVL41:
 545 01f0 FFF7FEFF 		bl	__aeabi_d2f
 546              	.LVL42:
 547 01f4 1290     		str	r0, [sp, #72]	@ float
 126:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qi = norm2 + dot;
 127:./subsystems/ahrs/ahrs_float_utils.h ****     float_quat_normalize(&q_m);
 548              		.loc 4 127 0
 549 01f6 0FA8     		add	r0, sp, #60
 126:./subsystems/ahrs/ahrs_float_utils.h ****     q_m.qi = norm2 + dot;
 550              		.loc 4 126 0
 551 01f8 8DED0F8A 		fsts	s16, [sp, #60]
 552              		.loc 4 127 0
 553 01fc FFF7FEFF 		bl	float_quat_normalize
 554              	.LVL43:
 555              	.L24:
 128:./subsystems/ahrs/ahrs_float_utils.h ****   }
 129:./subsystems/ahrs/ahrs_float_utils.h **** 
 130:./subsystems/ahrs/ahrs_float_utils.h ****   // q_ltp2imu = q_a * q_m
 131:./subsystems/ahrs/ahrs_float_utils.h ****   // and wrap and normalize
 132:./subsystems/ahrs/ahrs_float_utils.h ****   float_quat_comp_norm_shortest(q, &q_m, &q_a);
 556              		.loc 4 132 0
 557 0200 07A8     		add	r0, sp, #28
 558              	.LVL44:
 559 0202 0FA9     		add	r1, sp, #60
 560 0204 0BAA     		add	r2, sp, #44
 561              	.LVL45:
 562 0206 FFF7FEFF 		bl	float_quat_comp_norm_shortest
 563              	.LVL46:
 564              	.LBE67:
 565              	.LBE70:
 566              		.file 5 "./subsystems/ahrs/ahrs_int_utils.h"
   1:./subsystems/ahrs/ahrs_int_utils.h **** /*
   2:./subsystems/ahrs/ahrs_int_utils.h ****  * Copyright (C) 2009 Felix Ruess <felix.ruess@gmail.com>
   3:./subsystems/ahrs/ahrs_int_utils.h ****  * Copyright (C) 2009 Antoine Drouin <poinix@gmail.com>
   4:./subsystems/ahrs/ahrs_int_utils.h ****  *
   5:./subsystems/ahrs/ahrs_int_utils.h ****  * This file is part of paparazzi.
   6:./subsystems/ahrs/ahrs_int_utils.h ****  *
   7:./subsystems/ahrs/ahrs_int_utils.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./subsystems/ahrs/ahrs_int_utils.h ****  * it under the terms of the GNU General Public License as published by
   9:./subsystems/ahrs/ahrs_int_utils.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./subsystems/ahrs/ahrs_int_utils.h ****  * any later version.
  11:./subsystems/ahrs/ahrs_int_utils.h ****  *
  12:./subsystems/ahrs/ahrs_int_utils.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./subsystems/ahrs/ahrs_int_utils.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./subsystems/ahrs/ahrs_int_utils.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./subsystems/ahrs/ahrs_int_utils.h ****  * GNU General Public License for more details.
  16:./subsystems/ahrs/ahrs_int_utils.h ****  *
  17:./subsystems/ahrs/ahrs_int_utils.h ****  * You should have received a copy of the GNU General Public License
  18:./subsystems/ahrs/ahrs_int_utils.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./subsystems/ahrs/ahrs_int_utils.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./subsystems/ahrs/ahrs_int_utils.h ****  * Boston, MA 02111-1307, USA.
  21:./subsystems/ahrs/ahrs_int_utils.h ****  */
  22:./subsystems/ahrs/ahrs_int_utils.h **** 
  23:./subsystems/ahrs/ahrs_int_utils.h **** /**
  24:./subsystems/ahrs/ahrs_int_utils.h ****  * @file subsystems/ahrs/ahrs_int_utils.h
  25:./subsystems/ahrs/ahrs_int_utils.h ****  *
  26:./subsystems/ahrs/ahrs_int_utils.h ****  * Utility functions for fixed point AHRS implementations.
  27:./subsystems/ahrs/ahrs_int_utils.h ****  *
  28:./subsystems/ahrs/ahrs_int_utils.h ****  */
  29:./subsystems/ahrs/ahrs_int_utils.h **** 
  30:./subsystems/ahrs/ahrs_int_utils.h **** #ifndef AHRS_INT_UTILS_H
  31:./subsystems/ahrs/ahrs_int_utils.h **** #define AHRS_INT_UTILS_H
  32:./subsystems/ahrs/ahrs_int_utils.h **** 
  33:./subsystems/ahrs/ahrs_int_utils.h **** //#include "../../test/pprz_algebra_print.h"
  34:./subsystems/ahrs/ahrs_int_utils.h **** #include "math/pprz_algebra_int.h"
  35:./subsystems/ahrs/ahrs_int_utils.h **** 
  36:./subsystems/ahrs/ahrs_int_utils.h **** #include "subsystems/ahrs/ahrs_magnetic_field_model.h"
  37:./subsystems/ahrs/ahrs_int_utils.h **** 
  38:./subsystems/ahrs/ahrs_int_utils.h **** #include "subsystems/ahrs/ahrs_float_utils.h"
  39:./subsystems/ahrs/ahrs_int_utils.h **** 
  40:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_euler_from_accel_mag(struct Int32Eulers *e, struct Int32Vect3 *acce
  41:./subsystems/ahrs/ahrs_int_utils.h ****     struct Int32Vect3 *mag)
  42:./subsystems/ahrs/ahrs_int_utils.h **** {
  43:./subsystems/ahrs/ahrs_int_utils.h ****   //  DISPLAY_INT32_VECT3("# accel", (*accel));
  44:./subsystems/ahrs/ahrs_int_utils.h ****   const float fphi = atan2f(-accel->y, -accel->z);
  45:./subsystems/ahrs/ahrs_int_utils.h ****   //  printf("# atan float %f\n", DegOfRad(fphi));
  46:./subsystems/ahrs/ahrs_int_utils.h ****   e->phi = ANGLE_BFP_OF_REAL(fphi);
  47:./subsystems/ahrs/ahrs_int_utils.h **** 
  48:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi;
  49:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_COS(cphi, e->phi);
  50:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi_ax = -INT_MULT_RSHIFT(cphi, accel->x, INT32_TRIG_FRAC);
  51:./subsystems/ahrs/ahrs_int_utils.h ****   const float ftheta = atan2f(-cphi_ax, -accel->z);
  52:./subsystems/ahrs/ahrs_int_utils.h ****   e->theta = ANGLE_BFP_OF_REAL(ftheta);
  53:./subsystems/ahrs/ahrs_int_utils.h **** 
  54:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t sphi;
  55:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_SIN(sphi, e->phi);
  56:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t stheta;
  57:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_SIN(stheta, e->theta);
  58:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t ctheta;
  59:./subsystems/ahrs/ahrs_int_utils.h ****   PPRZ_ITRIG_COS(ctheta, e->theta);
  60:./subsystems/ahrs/ahrs_int_utils.h **** 
  61:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t sphi_stheta = (sphi * stheta) >> INT32_TRIG_FRAC;
  62:./subsystems/ahrs/ahrs_int_utils.h ****   int32_t cphi_stheta = (cphi * stheta) >> INT32_TRIG_FRAC;
  63:./subsystems/ahrs/ahrs_int_utils.h ****   //int32_t sphi_ctheta = (sphi*ctheta)>>INT32_TRIG_FRAC;
  64:./subsystems/ahrs/ahrs_int_utils.h ****   //int32_t cphi_ctheta = (cphi*ctheta)>>INT32_TRIG_FRAC;
  65:./subsystems/ahrs/ahrs_int_utils.h **** 
  66:./subsystems/ahrs/ahrs_int_utils.h ****   const int32_t mn = ctheta * mag->x + sphi_stheta * mag->y + cphi_stheta * mag->z;
  67:./subsystems/ahrs/ahrs_int_utils.h ****   const int32_t me = 0      * mag->x + cphi        * mag->y - sphi        * mag->z;
  68:./subsystems/ahrs/ahrs_int_utils.h ****   //const int32_t md =
  69:./subsystems/ahrs/ahrs_int_utils.h ****   //  -stheta     * imu.mag.x +
  70:./subsystems/ahrs/ahrs_int_utils.h ****   //  sphi_ctheta * imu.mag.y +
  71:./subsystems/ahrs/ahrs_int_utils.h ****   //  cphi_ctheta * imu.mag.z;
  72:./subsystems/ahrs/ahrs_int_utils.h ****   //  float m_psi = -atan2(me, mn);
  73:./subsystems/ahrs/ahrs_int_utils.h ****   const float mag_dec = atan2(-AHRS_H_Y, AHRS_H_X);
  74:./subsystems/ahrs/ahrs_int_utils.h ****   const float fpsi = atan2f(-me, mn) - mag_dec;
  75:./subsystems/ahrs/ahrs_int_utils.h ****   e->psi = ANGLE_BFP_OF_REAL(fpsi);
  76:./subsystems/ahrs/ahrs_int_utils.h ****   INT32_ANGLE_NORMALIZE(e->psi);
  77:./subsystems/ahrs/ahrs_int_utils.h **** 
  78:./subsystems/ahrs/ahrs_int_utils.h **** }
  79:./subsystems/ahrs/ahrs_int_utils.h **** 
  80:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_quat_from_accel(struct Int32Quat *q, struct Int32Vect3 *accel)
  81:./subsystems/ahrs/ahrs_int_utils.h **** {
  82:./subsystems/ahrs/ahrs_int_utils.h ****   struct FloatQuat q_f;
  83:./subsystems/ahrs/ahrs_int_utils.h ****   ahrs_float_get_quat_from_accel(&q_f, accel);
  84:./subsystems/ahrs/ahrs_int_utils.h ****   QUAT_BFP_OF_REAL(*q, q_f);
  85:./subsystems/ahrs/ahrs_int_utils.h **** }
  86:./subsystems/ahrs/ahrs_int_utils.h **** 
  87:./subsystems/ahrs/ahrs_int_utils.h **** static inline void ahrs_int_get_quat_from_accel_mag(struct Int32Quat *q, struct Int32Vect3 *accel,
  88:./subsystems/ahrs/ahrs_int_utils.h ****     struct Int32Vect3 *mag)
  89:./subsystems/ahrs/ahrs_int_utils.h **** {
  90:./subsystems/ahrs/ahrs_int_utils.h **** 
  91:./subsystems/ahrs/ahrs_int_utils.h ****   struct FloatQuat q_f;
  92:./subsystems/ahrs/ahrs_int_utils.h ****   ahrs_float_get_quat_from_accel_mag(&q_f, accel, mag);
  93:./subsystems/ahrs/ahrs_int_utils.h ****   QUAT_BFP_OF_REAL(*q, q_f);
 567              		.loc 5 93 0
 568 020a DFED356A 		flds	s13, .L32+48
 569 020e 9DED077A 		flds	s14, [sp, #28]
 570 0212 344B     		ldr	r3, .L32+52
 571 0214 DDED0A7A 		flds	s15, [sp, #40]
 572 0218 27EE267A 		fmuls	s14, s14, s13
 573              	.LBE73:
 574              	.LBE85:
 154:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 155:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if USE_MAGNETOMETER
 156:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Compute an initial orientation from accel and mag directly as quaternion */
 157:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_int_get_quat_from_accel_mag(&ahrs_icq.ltp_to_imu_quat,
 158:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                    lp_accel, lp_mag);
 159:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = TRUE;
 575              		.loc 3 159 0
 576 021c 0120     		movs	r0, #1
 577              	.LBB86:
 578              	.LBB74:
 579              		.loc 5 93 0
 580 021e BDEEC77A 		ftosizs	s14, s14
 581              	.LBE74:
 582              	.LBE86:
 583              		.loc 3 159 0
 584 0222 83F88100 		strb	r0, [r3, #129]
 585              	.LBB87:
 586              	.LBB75:
 587              		.loc 5 93 0
 588 0226 83ED187A 		fsts	s14, [r3, #96]	@ int
 589 022a 9DED087A 		flds	s14, [sp, #32]
 590              	.LBE75:
 591              	.LBE87:
 160:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 161:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Compute an initial orientation from accel and just set heading to zero */
 162:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_int_get_quat_from_accel(&ahrs_icq.ltp_to_imu_quat, lp_accel);
 163:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 164:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // supress unused arg warning
 165:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   lp_mag = lp_mag;
 166:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 167:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 168:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Use low passed gyro value as initial bias */
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.gyro_bias, *lp_gyro);
 592              		.loc 3 169 0
 593 022e 2A68     		ldr	r2, [r5]
 594 0230 1A60     		str	r2, [r3]
 595              	.LBB88:
 596              	.LBB76:
 597              		.loc 5 93 0
 598 0232 27EE267A 		fmuls	s14, s14, s13
 599              	.LBE76:
 600              	.LBE88:
 601              		.loc 3 169 0
 602 0236 6A68     		ldr	r2, [r5, #4]
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 603              		.loc 3 170 0
 604 0238 2C68     		ldr	r4, [r5]
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 605              		.loc 3 169 0
 606 023a 5A60     		str	r2, [r3, #4]
 607              	.LBB89:
 608              	.LBB77:
 609              		.loc 5 93 0
 610 023c BDEEC77A 		ftosizs	s14, s14
 611              	.LBE77:
 612              	.LBE89:
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 613              		.loc 3 169 0
 614 0240 AA68     		ldr	r2, [r5, #8]
 615              		.loc 3 170 0
 616 0242 6968     		ldr	r1, [r5, #4]
 169:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.high_rez_bias, *lp_gyro);
 617              		.loc 3 169 0
 618 0244 9A60     		str	r2, [r3, #8]
 619              		.loc 3 170 0
 620 0246 4FEAE47B 		asr	fp, r4, #31
 621 024a AA68     		ldr	r2, [r5, #8]
 622              	.LBB90:
 623              	.LBB78:
 624              		.loc 5 93 0
 625 024c 83ED197A 		fsts	s14, [r3, #100]	@ int
 626              	.LBE78:
 627              	.LBE90:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 628              		.loc 3 171 0
 629 0250 4FEA0B75 		lsl	r5, fp, #28
 630              	.LVL47:
 631              	.LBB91:
 632              	.LBB79:
 633              		.loc 5 93 0
 634 0254 9DED097A 		flds	s14, [sp, #36]
 635              	.LBE79:
 636              	.LBE91:
 172:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 173:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.status = AHRS_ICQ_RUNNING;
 637              		.loc 3 173 0
 638 0258 83F83401 		strb	r0, [r3, #308]
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 639              		.loc 3 170 0
 640 025c 4FEAE179 		asr	r9, r1, #31
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 641              		.loc 3 171 0
 642 0260 45EA1415 		orr	r5, r5, r4, lsr #4
 643 0264 2407     		lsls	r4, r4, #28
 644              	.LBB92:
 645              	.LBB80:
 646              		.loc 5 93 0
 647 0266 27EE267A 		fmuls	s14, s14, s13
 648 026a 67EEA67A 		fmuls	s15, s15, s13
 649              	.LBE80:
 650              	.LBE92:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 651              		.loc 3 171 0
 652 026e 9C64     		str	r4, [r3, #72]
 653 0270 4FEA0974 		lsl	r4, r9, #28
 170:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 654              		.loc 3 170 0
 655 0274 D717     		asrs	r7, r2, #31
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 656              		.loc 3 171 0
 657 0276 44EA1114 		orr	r4, r4, r1, lsr #4
 658 027a 0907     		lsls	r1, r1, #28
 659              	.LBB93:
 660              	.LBB81:
 661              		.loc 5 93 0
 662 027c BDEEC77A 		ftosizs	s14, s14
 663 0280 FDEEE77A 		ftosizs	s15, s15
 664              	.LBE81:
 665              	.LBE93:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 666              		.loc 3 171 0
 667 0284 1965     		str	r1, [r3, #80]
 668 0286 3907     		lsls	r1, r7, #28
 669 0288 41EA1211 		orr	r1, r1, r2, lsr #4
 670 028c 1207     		lsls	r2, r2, #28
 671              	.LBB94:
 672              	.LBB82:
 673              		.loc 5 93 0
 674 028e 83ED1A7A 		fsts	s14, [r3, #104]	@ int
 675 0292 C3ED1B7A 		fsts	s15, [r3, #108]	@ int
 676              	.LBE82:
 677              	.LBE94:
 171:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_LSHIFT(ahrs_icq.high_rez_bias, ahrs_icq.high_rez_bias, 28);
 678              		.loc 3 171 0
 679 0296 DD64     		str	r5, [r3, #76]
 680 0298 5C65     		str	r4, [r3, #84]
 681 029a D965     		str	r1, [r3, #92]
 682 029c 9A65     		str	r2, [r3, #88]
 174:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = TRUE;
 683              		.loc 3 174 0
 684 029e 83F83501 		strb	r0, [r3, #309]
 175:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 176:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   return TRUE;
 177:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 685              		.loc 3 177 0
 686 02a2 1DB0     		add	sp, sp, #116
 687              		.cfi_def_cfa_offset 52
 688              		@ sp needed
 689 02a4 BDEC048B 		fldmfdd	sp!, {d8-d9}
 690              		.cfi_restore 82
 691              		.cfi_restore 83
 692              		.cfi_restore 80
 693              		.cfi_restore 81
 694              		.cfi_def_cfa_offset 36
 695              	.LVL48:
 696 02a8 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 697              	.LVL49:
 698              	.L33:
 699 02ac AFF30080 		.align	3
 700              	.L32:
 701 02b0 27053E88 		.word	-2009201369
 702 02b4 6257E13F 		.word	1071732578
 703 02b8 ABAF9FDF 		.word	-543182933
 704 02bc A6A8B2BF 		.word	-1078810458
 705 02c0 0000803A 		.word	981467136
 706 02c4 0000F03F 		.word	1072693248
 707 02c8 000034B8 		.word	-1204551680
 708 02cc 00003438 		.word	942931968
 709 02d0 0000003A 		.word	973078528
 710 02d4 DCFA0B3F 		.word	1057749724
 711 02d8 0000A081 		.word	-2120220672
 712 02dc 0000A001 		.word	27262976
 713 02e0 00000047 		.word	1191182336
 714 02e4 00000000 		.word	.LANCHOR0
 715              		.cfi_endproc
 716              	.LFE90:
 718              		.global	__aeabi_ddiv
 719              		.global	__aeabi_d2iz
 720              		.section	.text.ahrs_icq_propagate,"ax",%progbits
 721              		.align	1
 722              		.global	ahrs_icq_propagate
 723              		.thumb
 724              		.thumb_func
 726              	ahrs_icq_propagate:
 727              	.LFB91:
 178:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 179:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 180:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_propagate(struct Int32Rates *gyro, float dt)
 181:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 728              		.loc 3 181 0
 729              		.cfi_startproc
 730              		@ args = 0, pretend = 0, frame = 16
 731              		@ frame_needed = 0, uses_anonymous_args = 0
 732              	.LVL50:
 733 0000 30B5     		push	{r4, r5, lr}
 734              		.cfi_def_cfa_offset 12
 735              		.cfi_offset 4, -12
 736              		.cfi_offset 5, -8
 737              		.cfi_offset 14, -4
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 183:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 184:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* unbias gyro             */
 185:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Rates omega;
 186:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_DIFF(omega, *gyro, ahrs_icq.gyro_bias);
 738              		.loc 3 186 0
 739 0002 1F4C     		ldr	r4, .L35
 740 0004 0368     		ldr	r3, [r0]
 741 0006 2568     		ldr	r5, [r4]
 742 0008 6268     		ldr	r2, [r4, #4]
 743 000a 5D1B     		subs	r5, r3, r5
 744 000c 4368     		ldr	r3, [r0, #4]
 745 000e 9A1A     		subs	r2, r3, r2
 746 0010 8368     		ldr	r3, [r0, #8]
 747 0012 A068     		ldr	r0, [r4, #8]
 748              	.LVL51:
 187:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 188:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* low pass rate */
 189:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #ifdef AHRS_PROPAGATE_LOW_PASS_RATES
 190:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SMUL(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 2);
 191:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(ahrs_icq.imu_rate, omega);
 192:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_SDIV(ahrs_icq.imu_rate, ahrs_icq.imu_rate, 3);
 193:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 194:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_COPY(ahrs_icq.imu_rate, omega);
 749              		.loc 3 194 0
 750 0014 E560     		str	r5, [r4, #12]
 186:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 751              		.loc 3 186 0
 752 0016 1B1A     		subs	r3, r3, r0
 195:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 196:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 197:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* add correction */
 198:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   RATES_ADD(omega, ahrs_icq.rate_correction);
 753              		.loc 3 198 0
 754 0018 A069     		ldr	r0, [r4, #24]
 194:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 755              		.loc 3 194 0
 756 001a 2261     		str	r2, [r4, #16]
 757              		.loc 3 198 0
 758 001c 0544     		add	r5, r5, r0
 759 001e E069     		ldr	r0, [r4, #28]
 194:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 760              		.loc 3 194 0
 761 0020 6361     		str	r3, [r4, #20]
 181:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t freq = (int32_t)(1. / dt);
 762              		.loc 3 181 0
 763 0022 85B0     		sub	sp, sp, #20
 764              		.cfi_def_cfa_offset 32
 765              		.loc 3 198 0
 766 0024 0244     		add	r2, r2, r0
 767 0026 0292     		str	r2, [sp, #8]
 768 0028 226A     		ldr	r2, [r4, #32]
 769 002a 0195     		str	r5, [sp, #4]
 770 002c 1344     		add	r3, r3, r2
 771 002e 0393     		str	r3, [sp, #12]
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 772              		.loc 3 182 0
 773 0030 0846     		mov	r0, r1	@ float
 199:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* and zeros it */
 200:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 774              		.loc 3 200 0
 775 0032 0023     		movs	r3, #0
 776 0034 A361     		str	r3, [r4, #24]
 777 0036 E361     		str	r3, [r4, #28]
 778 0038 2362     		str	r3, [r4, #32]
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 779              		.loc 3 182 0
 780 003a FFF7FEFF 		bl	__aeabi_f2d
 781              	.LVL52:
 782 003e 0246     		mov	r2, r0
 783 0040 0B46     		mov	r3, r1
 784 0042 0020     		movs	r0, #0
 785 0044 0F49     		ldr	r1, .L35+4
 786 0046 FFF7FEFF 		bl	__aeabi_ddiv
 787              	.LVL53:
 788 004a FFF7FEFF 		bl	__aeabi_d2iz
 789              	.LVL54:
 201:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 202:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* integrate quaternion */
 203:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_integrate_fi(&ahrs_icq.ltp_to_imu_quat, &ahrs_icq.high_rez_quat,
 790              		.loc 3 203 0
 791 004e 04F16005 		add	r5, r4, #96
 182:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 792              		.loc 3 182 0
 793 0052 0346     		mov	r3, r0
 794              		.loc 3 203 0
 795 0054 A5F13801 		sub	r1, r5, #56
 796 0058 2846     		mov	r0, r5
 797 005a 01AA     		add	r2, sp, #4
 798 005c FFF7FEFF 		bl	int32_quat_integrate_fi
 799              	.LVL55:
 204:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           &omega, freq);
 205:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_normalize(&ahrs_icq.ltp_to_imu_quat);
 800              		.loc 3 205 0
 801 0060 2846     		mov	r0, r5
 802 0062 FFF7FEFF 		bl	int32_quat_normalize
 803              	.LVL56:
 206:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 207:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // increase accel and mag propagation counters
 208:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt++;
 804              		.loc 3 208 0
 805 0066 B4F8AC30 		ldrh	r3, [r4, #172]
 806 006a 0133     		adds	r3, r3, #1
 807 006c A4F8AC30 		strh	r3, [r4, #172]	@ movhi
 209:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt++;
 808              		.loc 3 209 0
 809 0070 B4F8AE30 		ldrh	r3, [r4, #174]
 810 0074 0133     		adds	r3, r3, #1
 811 0076 A4F8AE30 		strh	r3, [r4, #174]	@ movhi
 210:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 812              		.loc 3 210 0
 813 007a 05B0     		add	sp, sp, #20
 814              		.cfi_def_cfa_offset 12
 815              		@ sp needed
 816 007c 30BD     		pop	{r4, r5, pc}
 817              	.L36:
 818 007e 00BF     		.align	2
 819              	.L35:
 820 0080 00000000 		.word	.LANCHOR0
 821 0084 0000F03F 		.word	1072693248
 822              		.cfi_endproc
 823              	.LFE91:
 825              		.section	.text.ahrs_icq_set_accel_gains,"ax",%progbits
 826              		.align	1
 827              		.global	ahrs_icq_set_accel_gains
 828              		.thumb
 829              		.thumb_func
 831              	ahrs_icq_set_accel_gains:
 832              	.LFB92:
 211:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 212:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 213:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_accel_gains(void)
 214:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 833              		.loc 3 214 0
 834              		.cfi_startproc
 835              		@ args = 0, pretend = 0, frame = 0
 836              		@ frame_needed = 0, uses_anonymous_args = 0
 837 0000 10B5     		push	{r4, lr}
 838              		.cfi_def_cfa_offset 8
 839              		.cfi_offset 4, -8
 840              		.cfi_offset 14, -4
 215:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain (without frequency correction)
 216:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * omega * zeta
 217:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 218:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 1 / (Kp * FRAC_conversion / cross_product_gain)
 219:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 4096 * 9.81 / Kp
 220:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 221:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_kp = 4096 * 9.81 /
 222:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           (2 * ahrs_icq.accel_omega * ahrs_icq.accel_zeta);
 841              		.loc 3 222 0
 842 0002 1B4C     		ldr	r4, .L38+16
 214:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain (without frequency correction)
 843              		.loc 3 214 0
 844 0004 2DED028B 		fstmfdd	sp!, {d8}
 845              		.cfi_def_cfa_offset 16
 846              		.cfi_offset 80, -16
 847              		.cfi_offset 81, -12
 848              		.loc 3 222 0
 849 0008 94ED278A 		flds	s16, [r4, #156]
 850 000c D4ED287A 		flds	s15, [r4, #160]
 851 0010 38EE087A 		fadds	s14, s16, s16
 221:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           (2 * ahrs_icq.accel_omega * ahrs_icq.accel_zeta);
 852              		.loc 3 221 0
 853 0014 67EE277A 		fmuls	s15, s14, s15
 854 0018 17EE900A 		fmrs	r0, s15
 855 001c FFF7FEFF 		bl	__aeabi_f2d
 856              	.LVL57:
 857 0020 0246     		mov	r2, r0
 858 0022 0B46     		mov	r3, r1
 859 0024 0EA1     		adr	r1, .L38
 860 0026 D1E90001 		ldrd	r0, [r1]
 861 002a FFF7FEFF 		bl	__aeabi_ddiv
 862              	.LVL58:
 863 002e FFF7FEFF 		bl	__aeabi_d2f
 864              	.LVL59:
 223:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 224:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 225:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2
 226:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 227:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / (Ki * FRAC_conversion / cross_product_gain)
 228:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / 2^16 * 9.81 / Ki
 229:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 9.81 / 2048 / Ki
 230:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 231:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_inv_ki = 9.81 / 2048 / (ahrs_icq.accel_omega * ahrs_icq.accel_omega);
 865              		.loc 3 231 0
 866 0032 68EE087A 		fmuls	s15, s16, s16
 221:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                           (2 * ahrs_icq.accel_omega * ahrs_icq.accel_zeta);
 867              		.loc 3 221 0
 868 0036 C4F88800 		str	r0, [r4, #136]	@ float
 869              		.loc 3 231 0
 870 003a 17EE900A 		fmrs	r0, s15
 871 003e FFF7FEFF 		bl	__aeabi_f2d
 872              	.LVL60:
 873 0042 0246     		mov	r2, r0
 874 0044 0B46     		mov	r3, r1
 875 0046 08A1     		adr	r1, .L38+8
 876 0048 D1E90001 		ldrd	r0, [r1]
 877 004c FFF7FEFF 		bl	__aeabi_ddiv
 878              	.LVL61:
 879 0050 FFF7FEFF 		bl	__aeabi_d2f
 880              	.LVL62:
 232:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 881              		.loc 3 232 0
 882 0054 BDEC028B 		fldmfdd	sp!, {d8}
 883              		.cfi_restore 80
 884              		.cfi_restore 81
 885              		.cfi_def_cfa_offset 8
 231:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 886              		.loc 3 231 0
 887 0058 C4F88C00 		str	r0, [r4, #140]	@ float
 888              		.loc 3 232 0
 889 005c 10BD     		pop	{r4, pc}
 890              	.L39:
 891 005e 00BF     		.align	3
 892              	.L38:
 893 0060 1F85EB51 		.word	1374389535
 894 0064 B89EE340 		.word	1088659128
 895 0068 1F85EB51 		.word	1374389535
 896 006c B89E733F 		.word	1064541880
 897 0070 00000000 		.word	.LANCHOR0
 898              		.cfi_endproc
 899              	.LFE92:
 901              		.global	__aeabi_i2d
 902              		.section	.text.ahrs_icq_update_accel,"ax",%progbits
 903              		.align	1
 904              		.global	ahrs_icq_update_accel
 905              		.thumb
 906              		.thumb_func
 908              	ahrs_icq_update_accel:
 909              	.LFB93:
 233:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 234:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_accel(struct Int32Vect3 *accel, float dt)
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 910              		.loc 3 235 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 72
 913              		@ frame_needed = 0, uses_anonymous_args = 0
 914              	.LVL63:
 915 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 916              		.cfi_def_cfa_offset 36
 917              		.cfi_offset 4, -36
 918              		.cfi_offset 5, -32
 919              		.cfi_offset 6, -28
 920              		.cfi_offset 7, -24
 921              		.cfi_offset 8, -20
 922              		.cfi_offset 9, -16
 923              		.cfi_offset 10, -12
 924              		.cfi_offset 11, -8
 925              		.cfi_offset 14, -4
 236:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 237:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.accel_cnt == 0) {
 926              		.loc 3 237 0
 927 0004 AE4C     		ldr	r4, .L69+16
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 928              		.loc 3 235 0
 929 0006 2DED028B 		fstmfdd	sp!, {d8}
 930              		.cfi_def_cfa_offset 44
 931              		.cfi_offset 80, -44
 932              		.cfi_offset 81, -40
 933              		.loc 3 237 0
 934 000a B4F8AC30 		ldrh	r3, [r4, #172]
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 935              		.loc 3 235 0
 936 000e 93B0     		sub	sp, sp, #76
 937              		.cfi_def_cfa_offset 120
 235:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 938              		.loc 3 235 0
 939 0010 0746     		mov	r7, r0
 940 0012 08EE101A 		fmsr	s16, r1
 941              		.loc 3 237 0
 942 0016 002B     		cmp	r3, #0
 943 0018 00F04281 		beq	.L40
 238:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     return;
 239:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 240:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 241:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // c2 = ltp z-axis in imu-frame
 242:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 243:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 944              		.loc 3 243 0
 945 001c 09A8     		add	r0, sp, #36
 946              	.LVL64:
 947 001e 04F16001 		add	r1, r4, #96
 948              	.LVL65:
 949 0022 FFF7FEFF 		bl	int32_rmat_of_quat
 950              	.LVL66:
 244:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 c2 = { RMAT_ELMT(ltp_to_imu_rmat, 0, 2),
 245:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 1, 2),
 246:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 2, 2)
 247:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 248:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual;
 249:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 250:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 pseudo_gravity_measurement;
 251:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 252:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.correct_gravity && ahrs_icq.ltp_vel_norm_valid) {
 951              		.loc 3 252 0
 952 0026 94F89830 		ldrb	r3, [r4, #152]	@ zero_extendqisi2
 244:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 c2 = { RMAT_ELMT(ltp_to_imu_rmat, 0, 2),
 953              		.loc 3 244 0
 954 002a DDF82C80 		ldr	r8, [sp, #44]
 955              	.LVL67:
 245:subsystems/ahrs/ahrs_int_cmpl_quat.c ****            RMAT_ELMT(ltp_to_imu_rmat, 2, 2)
 956              		.loc 3 245 0
 957 002e 0E9D     		ldr	r5, [sp, #56]
 958              	.LVL68:
 246:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 959              		.loc 3 246 0
 960 0030 119E     		ldr	r6, [sp, #68]
 961              	.LVL69:
 962              		.loc 3 252 0
 963 0032 73B3     		cbz	r3, .L42
 964              		.loc 3 252 0 is_stmt 0 discriminator 1
 965 0034 94F88030 		ldrb	r3, [r4, #128]	@ zero_extendqisi2
 966 0038 5BB3     		cbz	r3, .L42
 967              	.LBB99:
 968              	.LBB100:
 969              	.LBB101:
 970              		.file 6 "./math/pprz_orientation_conversion.h"
   1:./math/pprz_orientation_conversion.h **** /*
   2:./math/pprz_orientation_conversion.h ****  * Copyright (C) 2011-2012 The Paparazzi Team
   3:./math/pprz_orientation_conversion.h ****  *
   4:./math/pprz_orientation_conversion.h ****  * This file is part of paparazzi.
   5:./math/pprz_orientation_conversion.h ****  *
   6:./math/pprz_orientation_conversion.h ****  * paparazzi is free software; you can redistribute it and/or modify
   7:./math/pprz_orientation_conversion.h ****  * it under the terms of the GNU General Public License as published by
   8:./math/pprz_orientation_conversion.h ****  * the Free Software Foundation; either version 2, or (at your option)
   9:./math/pprz_orientation_conversion.h ****  * any later version.
  10:./math/pprz_orientation_conversion.h ****  *
  11:./math/pprz_orientation_conversion.h ****  * paparazzi is distributed in the hope that it will be useful,
  12:./math/pprz_orientation_conversion.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:./math/pprz_orientation_conversion.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:./math/pprz_orientation_conversion.h ****  * GNU General Public License for more details.
  15:./math/pprz_orientation_conversion.h ****  *
  16:./math/pprz_orientation_conversion.h ****  * You should have received a copy of the GNU General Public License
  17:./math/pprz_orientation_conversion.h ****  * along with paparazzi; see the file COPYING.  If not, see
  18:./math/pprz_orientation_conversion.h ****  * <http://www.gnu.org/licenses/>.
  19:./math/pprz_orientation_conversion.h ****  */
  20:./math/pprz_orientation_conversion.h **** 
  21:./math/pprz_orientation_conversion.h **** /**
  22:./math/pprz_orientation_conversion.h ****  * @file math/pprz_orientation_conversion.h
  23:./math/pprz_orientation_conversion.h ****  * Generic orientation representation and conversions.
  24:./math/pprz_orientation_conversion.h ****  *
  25:./math/pprz_orientation_conversion.h ****  * This file contains the functions to automatically convert between
  26:./math/pprz_orientation_conversion.h ****  * the different representations. They should normally not be used
  27:./math/pprz_orientation_conversion.h ****  * directly and instead the stateGet/Set interfaces used.
  28:./math/pprz_orientation_conversion.h ****  * Also see the @ref math_orientation_representation "Generic Orientation Representation" page.
  29:./math/pprz_orientation_conversion.h ****  *
  30:./math/pprz_orientation_conversion.h ****  * @author Felix Ruess <felix.ruess@gmail.com>
  31:./math/pprz_orientation_conversion.h ****  */
  32:./math/pprz_orientation_conversion.h **** 
  33:./math/pprz_orientation_conversion.h **** /**
  34:./math/pprz_orientation_conversion.h ****  * @addtogroup math
  35:./math/pprz_orientation_conversion.h ****  * @{
  36:./math/pprz_orientation_conversion.h ****  */
  37:./math/pprz_orientation_conversion.h **** 
  38:./math/pprz_orientation_conversion.h **** /**
  39:./math/pprz_orientation_conversion.h ****  * This generic orientation representation consists of a struct, containing the 6 orientation
  40:./math/pprz_orientation_conversion.h ****  * representations, and a status variable. The bits in the status variable indicate  which
  41:./math/pprz_orientation_conversion.h ****  * representations of the orientation are up-to-date.
  42:./math/pprz_orientation_conversion.h ****  *
  43:./math/pprz_orientation_conversion.h ****  * When a getter is used to get a certain representation, the status bit is checked to see if
  44:./math/pprz_orientation_conversion.h ****  * the current value is already available in the desired orientation representation.
  45:./math/pprz_orientation_conversion.h ****  * If the desired representation is not available, it will be calculated.
  46:./math/pprz_orientation_conversion.h ****  *
  47:./math/pprz_orientation_conversion.h ****  * When a setter is used to set a representation, all status bits are cleared, and only the
  48:./math/pprz_orientation_conversion.h ****  * status bit for the set representation is set to one.
  49:./math/pprz_orientation_conversion.h ****  */
  50:./math/pprz_orientation_conversion.h **** 
  51:./math/pprz_orientation_conversion.h **** /**
  52:./math/pprz_orientation_conversion.h ****  * @defgroup math_orientation_representation Generic Orientation Representations
  53:./math/pprz_orientation_conversion.h ****  * @{
  54:./math/pprz_orientation_conversion.h ****  */
  55:./math/pprz_orientation_conversion.h **** 
  56:./math/pprz_orientation_conversion.h **** #ifndef PPRZ_ORIENTATION_CONVERSION_H
  57:./math/pprz_orientation_conversion.h **** #define PPRZ_ORIENTATION_CONVERSION_H
  58:./math/pprz_orientation_conversion.h **** 
  59:./math/pprz_orientation_conversion.h **** #ifdef __cplusplus
  60:./math/pprz_orientation_conversion.h **** extern "C" {
  61:./math/pprz_orientation_conversion.h **** #endif
  62:./math/pprz_orientation_conversion.h **** 
  63:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_int.h"
  64:./math/pprz_orientation_conversion.h **** #include "math/pprz_algebra_float.h"
  65:./math/pprz_orientation_conversion.h **** 
  66:./math/pprz_orientation_conversion.h **** #include "std.h"
  67:./math/pprz_orientation_conversion.h **** 
  68:./math/pprz_orientation_conversion.h **** 
  69:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_I  0  ///< Quaternion (BFP int)
  70:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_I 1  ///< zyx Euler (BFP int)
  71:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_I  2  ///< Rotation Matrix (BFP int)
  72:./math/pprz_orientation_conversion.h **** #define ORREP_QUAT_F  3  ///< Quaternion (float)
  73:./math/pprz_orientation_conversion.h **** #define ORREP_EULER_F 4  ///< zyx Euler (float)
  74:./math/pprz_orientation_conversion.h **** #define ORREP_RMAT_F  5  ///< Rotation Matrix (float)
  75:./math/pprz_orientation_conversion.h **** 
  76:./math/pprz_orientation_conversion.h **** /*
  77:./math/pprz_orientation_conversion.h ****  * @brief Struct with euler/rmat/quaternion orientation representations in BFP int and float
  78:./math/pprz_orientation_conversion.h ****  */
  79:./math/pprz_orientation_conversion.h **** struct OrientationReps {
  80:./math/pprz_orientation_conversion.h ****   /**
  81:./math/pprz_orientation_conversion.h ****    * Holds the status bits for all orientation representations.
  82:./math/pprz_orientation_conversion.h ****    * When the corresponding bit is set, the representation
  83:./math/pprz_orientation_conversion.h ****    * is already computed.
  84:./math/pprz_orientation_conversion.h ****    */
  85:./math/pprz_orientation_conversion.h ****   uint8_t status;
  86:./math/pprz_orientation_conversion.h **** 
  87:./math/pprz_orientation_conversion.h ****   /**
  88:./math/pprz_orientation_conversion.h ****    * Orientation quaternion.
  89:./math/pprz_orientation_conversion.h ****    * Units: #INT32_QUAT_FRAC
  90:./math/pprz_orientation_conversion.h ****    */
  91:./math/pprz_orientation_conversion.h ****   struct Int32Quat quat_i;
  92:./math/pprz_orientation_conversion.h **** 
  93:./math/pprz_orientation_conversion.h ****   /**
  94:./math/pprz_orientation_conversion.h ****    * Orientation in zyx euler angles.
  95:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_ANGLE_FRAC
  96:./math/pprz_orientation_conversion.h ****    */
  97:./math/pprz_orientation_conversion.h ****   struct Int32Eulers eulers_i;
  98:./math/pprz_orientation_conversion.h **** 
  99:./math/pprz_orientation_conversion.h ****   /**
 100:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 101:./math/pprz_orientation_conversion.h ****    * Units: rad in BFP with #INT32_TRIG_FRAC
 102:./math/pprz_orientation_conversion.h ****    */
 103:./math/pprz_orientation_conversion.h ****   struct Int32RMat rmat_i;
 104:./math/pprz_orientation_conversion.h **** 
 105:./math/pprz_orientation_conversion.h ****   /**
 106:./math/pprz_orientation_conversion.h ****    * Orientation as quaternion.
 107:./math/pprz_orientation_conversion.h ****    * Units: unit length quaternion
 108:./math/pprz_orientation_conversion.h ****    */
 109:./math/pprz_orientation_conversion.h ****   struct FloatQuat quat_f;
 110:./math/pprz_orientation_conversion.h **** 
 111:./math/pprz_orientation_conversion.h ****   /**
 112:./math/pprz_orientation_conversion.h ****    * Orienation in zyx euler angles.
 113:./math/pprz_orientation_conversion.h ****    * Units: rad
 114:./math/pprz_orientation_conversion.h ****    */
 115:./math/pprz_orientation_conversion.h ****   struct FloatEulers eulers_f;
 116:./math/pprz_orientation_conversion.h **** 
 117:./math/pprz_orientation_conversion.h ****   /**
 118:./math/pprz_orientation_conversion.h ****    * Orientation rotation matrix.
 119:./math/pprz_orientation_conversion.h ****    * Units: rad
 120:./math/pprz_orientation_conversion.h ****    */
 121:./math/pprz_orientation_conversion.h ****   struct FloatRMat   rmat_f;
 122:./math/pprz_orientation_conversion.h **** };
 123:./math/pprz_orientation_conversion.h **** 
 124:./math/pprz_orientation_conversion.h **** /************* declaration of transformation functions ************/
 125:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_i(struct OrientationReps *orientation);
 126:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_i(struct OrientationReps *orientation);
 127:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_i(struct OrientationReps *orientation);
 128:./math/pprz_orientation_conversion.h **** extern void orientationCalcQuat_f(struct OrientationReps *orientation);
 129:./math/pprz_orientation_conversion.h **** extern void orientationCalcRMat_f(struct OrientationReps *orientation);
 130:./math/pprz_orientation_conversion.h **** extern void orientationCalcEulers_f(struct OrientationReps *orientation);
 131:./math/pprz_orientation_conversion.h **** 
 132:./math/pprz_orientation_conversion.h **** 
 133:./math/pprz_orientation_conversion.h **** /*********************** validity test functions ******************/
 134:./math/pprz_orientation_conversion.h **** /// Test if orientations are valid.
 135:./math/pprz_orientation_conversion.h **** static inline bool_t orienationCheckValid(struct OrientationReps *orientation)
 136:./math/pprz_orientation_conversion.h **** {
 137:./math/pprz_orientation_conversion.h ****   return (orientation->status);
 138:./math/pprz_orientation_conversion.h **** }
 139:./math/pprz_orientation_conversion.h **** 
 140:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (int).
 141:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_i(struct OrientationReps *orientation, struct Int32Quat *quat
 142:./math/pprz_orientation_conversion.h **** {
 143:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_i, *quat);
 144:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 145:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_I);
 146:./math/pprz_orientation_conversion.h **** }
 147:./math/pprz_orientation_conversion.h **** 
 148:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (int).
 149:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_i(struct OrientationReps *orientation, struct Int32RMat *rmat
 150:./math/pprz_orientation_conversion.h **** {
 151:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_i, *rmat);
 152:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 153:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_I);
 154:./math/pprz_orientation_conversion.h **** }
 155:./math/pprz_orientation_conversion.h **** 
 156:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (int).
 157:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_i(struct OrientationReps *orientation, struct Int32Eulers *
 158:./math/pprz_orientation_conversion.h **** {
 159:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_i, *eulers);
 160:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 161:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_I);
 162:./math/pprz_orientation_conversion.h **** }
 163:./math/pprz_orientation_conversion.h **** 
 164:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from quaternion (float).
 165:./math/pprz_orientation_conversion.h **** static inline void orientationSetQuat_f(struct OrientationReps *orientation, struct FloatQuat *quat
 166:./math/pprz_orientation_conversion.h **** {
 167:./math/pprz_orientation_conversion.h ****   QUAT_COPY(orientation->quat_f, *quat);
 168:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 169:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_QUAT_F);
 170:./math/pprz_orientation_conversion.h **** }
 171:./math/pprz_orientation_conversion.h **** 
 172:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from rotation matrix (float).
 173:./math/pprz_orientation_conversion.h **** static inline void orientationSetRMat_f(struct OrientationReps *orientation, struct FloatRMat *rmat
 174:./math/pprz_orientation_conversion.h **** {
 175:./math/pprz_orientation_conversion.h ****   RMAT_COPY(orientation->rmat_f, *rmat);
 176:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 177:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_RMAT_F);
 178:./math/pprz_orientation_conversion.h **** }
 179:./math/pprz_orientation_conversion.h **** 
 180:./math/pprz_orientation_conversion.h **** /// Set vehicle body attitude from euler angles (float).
 181:./math/pprz_orientation_conversion.h **** static inline void orientationSetEulers_f(struct OrientationReps *orientation, struct FloatEulers *
 182:./math/pprz_orientation_conversion.h **** {
 183:./math/pprz_orientation_conversion.h ****   EULERS_COPY(orientation->eulers_f, *eulers);
 184:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 185:./math/pprz_orientation_conversion.h ****   orientation->status = (1 << ORREP_EULER_F);
 186:./math/pprz_orientation_conversion.h **** }
 187:./math/pprz_orientation_conversion.h **** 
 188:./math/pprz_orientation_conversion.h **** 
 189:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (int).
 190:./math/pprz_orientation_conversion.h **** static inline struct Int32Quat *orientationGetQuat_i(struct OrientationReps *orientation)
 191:./math/pprz_orientation_conversion.h **** {
 192:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_I)) {
 193:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 194:./math/pprz_orientation_conversion.h ****   }
 195:./math/pprz_orientation_conversion.h ****   return &orientation->quat_i;
 196:./math/pprz_orientation_conversion.h **** }
 197:./math/pprz_orientation_conversion.h **** 
 198:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude rotation matrix (int).
 199:./math/pprz_orientation_conversion.h **** static inline struct Int32RMat *orientationGetRMat_i(struct OrientationReps *orientation)
 200:./math/pprz_orientation_conversion.h **** {
 201:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_RMAT_I)) {
 971              		.loc 6 201 0 is_stmt 1
 972 003a 94F8B030 		ldrb	r3, [r4, #176]	@ zero_extendqisi2
 973              	.LBE101:
 974              	.LBE100:
 253:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /*
 254:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * centrifugal acceleration in body frame
 255:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * a_c_body = omega x (omega x r)
 256:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * (omega x r) = tangential velocity in body frame
 257:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * a_c_body = omega x vel_tangential_body
 258:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * assumption: tangential velocity only along body x-axis
 259:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      */
 260:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 261:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // FIXME: check overflows !
 262:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define COMPUTATION_FRAC 16
 263:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define ACC_FROM_CROSS_FRAC INT32_RATE_FRAC + INT32_SPEED_FRAC - INT32_ACCEL_FRAC - COMPUTATION_FRA
 264:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 265:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const struct Int32Vect3 vel_tangential_body =
 266:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       {ahrs_icq.ltp_vel_norm >> COMPUTATION_FRAC, 0, 0};
 975              		.loc 3 266 0
 976 003e B4F97E90 		ldrsh	r9, [r4, #126]
 977              	.LVL70:
 978              	.LBB103:
 979              	.LBB102:
 980              		.loc 6 201 0
 981 0042 5B07     		lsls	r3, r3, #29
 982 0044 03D4     		bmi	.L43
 202:./math/pprz_orientation_conversion.h ****     orientationCalcRMat_i(orientation);
 983              		.loc 6 202 0
 984 0046 04F1B000 		add	r0, r4, #176
 985 004a FFF7FEFF 		bl	orientationCalcRMat_i
 986              	.LVL71:
 987              	.L43:
 988              	.LBE102:
 989              	.LBE103:
 267:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32RMat *body_to_imu_rmat = orientationGetRMat_i(&ahrs_icq.body_to_imu);
 268:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Rates body_rate;
 269:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_rmat_transp_ratemult(&body_rate, body_to_imu_rmat, &ahrs_icq.imu_rate);
 990              		.loc 3 269 0
 991 004e 9D49     		ldr	r1, .L69+20
 992 0050 6846     		mov	r0, sp
 993 0052 A1F1C402 		sub	r2, r1, #196
 994 0056 FFF7FEFF 		bl	int32_rmat_transp_ratemult
 995              	.LVL72:
 270:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Vect3 acc_c_body;
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_RATES_CROSS_VECT3(acc_c_body, body_rate, vel_tangential_body);
 996              		.loc 3 271 0
 997 005a 0023     		movs	r3, #0
 998 005c 0393     		str	r3, [sp, #12]
 999 005e 029B     		ldr	r3, [sp, #8]
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 273:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 274:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* convert centrifucal acceleration from body to imu frame */
 275:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct Int32Vect3 acc_c_imu;
 276:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_rmat_vmult(&acc_c_imu, body_to_imu_rmat, &acc_c_body);
 1000              		.loc 3 276 0
 1001 0060 9849     		ldr	r1, .L69+20
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1002              		.loc 3 271 0
 1003 0062 09FB03F3 		mul	r3, r9, r3
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1004              		.loc 3 272 0
 1005 0066 5B11     		asrs	r3, r3, #5
 1006 0068 0493     		str	r3, [sp, #16]
 271:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1007              		.loc 3 271 0
 1008 006a 019B     		ldr	r3, [sp, #4]
 1009 006c 09FB03F3 		mul	r3, r9, r3
 1010 0070 5B42     		negs	r3, r3
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1011              		.loc 3 272 0
 1012 0072 5B11     		asrs	r3, r3, #5
 1013              		.loc 3 276 0
 1014 0074 06A8     		add	r0, sp, #24
 1015 0076 03AA     		add	r2, sp, #12
 272:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT32_VECT3_RSHIFT(acc_c_body, acc_c_body, ACC_FROM_CROSS_FRAC);
 1016              		.loc 3 272 0
 1017 0078 0593     		str	r3, [sp, #20]
 1018              		.loc 3 276 0
 1019 007a FFF7FEFF 		bl	int32_rmat_vmult
 1020              	.LVL73:
 277:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 278:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* and subtract it from imu measurement to get a corrected measurement
 279:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * of the gravity vector */
 280:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_DIFF(pseudo_gravity_measurement, *accel, acc_c_imu);
 1021              		.loc 3 280 0
 1022 007e 069B     		ldr	r3, [sp, #24]
 1023 0080 3A68     		ldr	r2, [r7]
 1024 0082 7868     		ldr	r0, [r7, #4]
 1025 0084 B968     		ldr	r1, [r7, #8]
 1026 0086 D21A     		subs	r2, r2, r3
 1027              	.LVL74:
 1028 0088 079B     		ldr	r3, [sp, #28]
 1029 008a C01A     		subs	r0, r0, r3
 1030              	.LVL75:
 1031 008c 089B     		ldr	r3, [sp, #32]
 1032 008e CB1A     		subs	r3, r1, r3
 1033              	.LVL76:
 1034              	.LBE99:
 252:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /*
 1035              		.loc 3 252 0
 1036 0090 02E0     		b	.L44
 1037              	.LVL77:
 1038              	.L42:
 281:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 282:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     VECT3_COPY(pseudo_gravity_measurement, *accel);
 1039              		.loc 3 282 0
 1040 0092 3A68     		ldr	r2, [r7]
 1041              	.LVL78:
 1042 0094 7868     		ldr	r0, [r7, #4]
 1043              	.LVL79:
 1044 0096 BB68     		ldr	r3, [r7, #8]
 1045              	.LVL80:
 1046              	.L44:
 283:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 284:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 285:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* compute the residual of the pseudo gravity vector in imu frame */
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, pseudo_gravity_measurement, c2);
 287:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 288:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 289:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* FIR filtered pseudo_gravity_measurement */
 290:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #define FIR_FILTER_SIZE 8
 291:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   static struct Int32Vect3 filtered_gravity_measurement = {0, 0, 0};
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_SMUL(filtered_gravity_measurement, filtered_gravity_measurement, FIR_FILTER_SIZE - 1);
 1047              		.loc 3 292 0
 1048 0098 DFF83CE2 		ldr	lr, .L69+40
 293:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 294:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_SDIV(filtered_gravity_measurement, filtered_gravity_measurement, FIR_FILTER_SIZE);
 295:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 296:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 297:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.gravity_heuristic_factor) {
 1049              		.loc 3 297 0
 1050 009c DFF820A2 		ldr	r10, .L69+16
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1051              		.loc 3 286 0
 1052 00a0 08FB03F1 		mul	r1, r8, r3
 1053 00a4 06FB00F7 		mul	r7, r6, r0
 1054              	.LVL81:
 1055 00a8 06FB1216 		mls	r6, r6, r2, r1
 1056              	.LVL82:
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1057              		.loc 3 292 0
 1058 00ac DEF80410 		ldr	r1, [lr, #4]
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1059              		.loc 3 286 0
 1060 00b0 05FB1377 		mls	r7, r5, r3, r7
 1061              	.LVL83:
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1062              		.loc 3 292 0
 1063 00b4 C1EBC101 		rsb	r1, r1, r1, lsl #3
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1064              		.loc 3 286 0
 1065 00b8 5543     		muls	r5, r2, r5
 1066              	.LVL84:
 293:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1067              		.loc 3 293 0
 1068 00ba 0144     		add	r1, r1, r0
 286:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1069              		.loc 3 286 0
 1070 00bc 08FB1055 		mls	r5, r8, r0, r5
 1071              	.LVL85:
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1072              		.loc 3 292 0
 1073 00c0 DEF80800 		ldr	r0, [lr, #8]
 1074              	.LVL86:
 1075 00c4 C0EBC000 		rsb	r0, r0, r0, lsl #3
 293:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1076              		.loc 3 293 0
 1077 00c8 0344     		add	r3, r3, r0
 1078              	.LVL87:
 292:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1079              		.loc 3 292 0
 1080 00ca DEF80000 		ldr	r0, [lr]
 1081 00ce C0EBC000 		rsb	r0, r0, r0, lsl #3
 293:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_ADD(filtered_gravity_measurement, pseudo_gravity_measurement);
 1082              		.loc 3 293 0
 1083 00d2 0244     		add	r2, r2, r0
 1084              	.LVL88:
 294:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1085              		.loc 3 294 0
 1086 00d4 0820     		movs	r0, #8
 1087 00d6 92FBF0F2 		sdiv	r2, r2, r0
 1088 00da 91FBF0F1 		sdiv	r1, r1, r0
 1089 00de 93FBF0F3 		sdiv	r3, r3, r0
 1090              		.loc 3 297 0
 1091 00e2 94F89900 		ldrb	r0, [r4, #153]	@ zero_extendqisi2
 294:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1092              		.loc 3 294 0
 1093 00e6 CEF80020 		str	r2, [lr]
 1094 00ea CEF80410 		str	r1, [lr, #4]
 1095 00ee CEF80830 		str	r3, [lr, #8]
 1096 00f2 F7EE008A 		fconsts	s17, #112
 1097              		.loc 3 297 0
 1098 00f6 0028     		cmp	r0, #0
 1099 00f8 52D0     		beq	.L45
 1100              	.LBB104:
 298:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* heuristic on acceleration (gravity estimate) norm */
 299:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* Factor how strongly to change the weight.
 300:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * e.g. for gravity_heuristic_factor 30:
 301:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      * <0.66G = 0, 1G = 1.0, >1.33G = 0
 302:subsystems/ahrs/ahrs_int_cmpl_quat.c ****      */
 303:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 304:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     struct FloatVect3 g_meas_f;
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ACCELS_FLOAT_OF_BFP(g_meas_f, filtered_gravity_measurement);
 1101              		.loc 3 305 0
 1102 00fa 07EE902A 		fmsr	s15, r2	@ int
 1103 00fe B8EEE77A 		fsitos	s14, s15
 1104 0102 07EE901A 		fmsr	s15, r1	@ int
 1105 0106 9FED706A 		flds	s12, .L69+24
 1106 010a F8EEE76A 		fsitos	s13, s15
 1107 010e 27EE067A 		fmuls	s14, s14, s12
 1108              	.LVL89:
 1109 0112 66EE866A 		fmuls	s13, s13, s12
 1110              	.LVL90:
 1111 0116 07EE903A 		fmsr	s15, r3	@ int
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1112              		.loc 3 306 0
 1113 011a 66EEA66A 		fmuls	s13, s13, s13
 1114              	.LVL91:
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1115              		.loc 3 305 0
 1116 011e F8EEE77A 		fsitos	s15, s15
 1117              		.loc 3 306 0
 1118 0122 E7EE076A 		vfma.f32	s13, s14, s14
 305:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1119              		.loc 3 305 0
 1120 0126 67EE867A 		fmuls	s15, s15, s12
 1121              	.LVL92:
 1122              		.loc 3 306 0
 1123 012a E7EEA76A 		vfma.f32	s13, s15, s15
 1124 012e 16EE900A 		fmrs	r0, s13
 1125 0132 FFF7FEFF 		bl	sqrtf
 1126              	.LVL93:
 1127 0136 8346     		mov	fp, r0	@ float
 1128              	.LVL94:
 307:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0 - ahrs_icq.gravity_heuristic_factor * fabs(1.0 - g_meas_norm) / 10;
 1129              		.loc 3 307 0
 1130 0138 9AF89900 		ldrb	r0, [r10, #153]	@ zero_extendqisi2
 1131              	.LVL95:
 1132 013c FFF7FEFF 		bl	__aeabi_i2d
 1133              	.LVL96:
 1134 0140 8046     		mov	r8, r0
 1135              	.LVL97:
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1136              		.loc 3 306 0
 1137 0142 5846     		mov	r0, fp	@ float
 1138              		.loc 3 307 0
 1139 0144 8946     		mov	r9, r1
 306:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     const float g_meas_norm = FLOAT_VECT3_NORM(g_meas_f) / 9.81;
 1140              		.loc 3 306 0
 1141 0146 FFF7FEFF 		bl	__aeabi_f2d
 1142              	.LVL98:
 1143 014a 59A3     		adr	r3, .L69
 1144 014c D3E90023 		ldrd	r2, [r3]
 1145 0150 FFF7FEFF 		bl	__aeabi_ddiv
 1146              	.LVL99:
 1147 0154 FFF7FEFF 		bl	__aeabi_d2f
 1148              	.LVL100:
 1149              		.loc 3 307 0
 1150 0158 FFF7FEFF 		bl	__aeabi_f2d
 1151              	.LVL101:
 1152 015c 0246     		mov	r2, r0
 1153 015e 0B46     		mov	r3, r1
 1154 0160 0020     		movs	r0, #0
 1155 0162 5A49     		ldr	r1, .L69+28
 1156 0164 FFF7FEFF 		bl	__aeabi_dsub
 1157              	.LVL102:
 1158 0168 0246     		mov	r2, r0
 1159 016a 21F00043 		bic	r3, r1, #-2147483648
 1160 016e 4046     		mov	r0, r8
 1161 0170 4946     		mov	r1, r9
 1162 0172 FFF7FEFF 		bl	__aeabi_dmul
 1163              	.LVL103:
 1164 0176 0022     		movs	r2, #0
 1165 0178 554B     		ldr	r3, .L69+32
 1166 017a FFF7FEFF 		bl	__aeabi_ddiv
 1167              	.LVL104:
 1168 017e 0246     		mov	r2, r0
 1169 0180 0B46     		mov	r3, r1
 1170 0182 0020     		movs	r0, #0
 1171 0184 5149     		ldr	r1, .L69+28
 1172 0186 FFF7FEFF 		bl	__aeabi_dsub
 1173              	.LVL105:
 1174 018a FFF7FEFF 		bl	__aeabi_d2f
 1175              	.LVL106:
 1176 018e 07EE900A 		fmsr	s15, r0
 308:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     Bound(ahrs_icq.weight, 0.15, 1.0);
 1177              		.loc 3 308 0
 1178 0192 F4EEE87A 		fcmpes	s15, s17
 1179 0196 F1EE10FA 		fmstat
 307:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0 - ahrs_icq.gravity_heuristic_factor * fabs(1.0 - g_meas_norm) / 10;
 1180              		.loc 3 307 0
 1181 019a CAF88400 		str	r0, [r10, #132]	@ float
 1182              		.loc 3 308 0
 1183 019e 02DD     		ble	.L68
 1184              	.LVL107:
 1185              	.L45:
 1186              		.loc 3 308 0 is_stmt 0 discriminator 1
 1187 01a0 C4ED218A 		fsts	s17, [r4, #132]
 1188 01a4 0AE0     		b	.L48
 1189              	.LVL108:
 1190              	.L68:
 1191              		.loc 3 308 0 discriminator 2
 1192 01a6 FFF7FEFF 		bl	__aeabi_f2d
 1193              	.LVL109:
 1194 01aa 43A3     		adr	r3, .L69+8
 1195 01ac D3E90023 		ldrd	r2, [r3]
 1196 01b0 FFF7FEFF 		bl	__aeabi_dcmplt
 1197              	.LVL110:
 1198 01b4 10B1     		cbz	r0, .L48
 1199              		.loc 3 308 0 discriminator 3
 1200 01b6 474B     		ldr	r3, .L69+36
 1201 01b8 CAF88430 		str	r3, [r10, #132]	@ float
 1202              	.LVL111:
 1203              	.L48:
 1204              	.LBE104:
 309:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 310:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.weight = 1.0;
 311:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 312:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 313:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportional gain.
 314:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * zeta * omega
 315:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.accel_cnt
 316:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.accel_cnt beeing the number of propagations since last update
 317:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 318:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC : ACCEL_FRAC + TRIG_FRAC = 10 + 14 = 24
 319:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 320:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC_conversion: 2^12 / 2^24 = 1 / 4096
 321:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * cross_product_gain : 9.81 m/s2
 322:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 323:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 1 / (Kp * FRAC_conversion / cross_product_gain)
 324:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_kp = 4096 * 9.81 / Kp
 325:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 326:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = 1 / (weight * Kp * FRAC_conversion / cross_product_gain)
 327:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = 1 / Kp / weight
 328:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_scale = accel_inv_kp / accel_cnt / weight
 329:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_scale = (int32_t)(ahrs_icq.accel_inv_kp / ahrs_icq.accel_cnt
 1205              		.loc 3 330 0 is_stmt 1
 1206 01bc B4F8AC30 		ldrh	r3, [r4, #172]
 1207 01c0 94ED227A 		flds	s14, [r4, #136]
 331:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                      / ahrs_icq.weight);
 1208              		.loc 3 331 0
 1209 01c4 D4ED216A 		flds	s13, [r4, #132]
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                      / ahrs_icq.weight);
 1210              		.loc 3 330 0
 1211 01c8 07EE903A 		fmsr	s15, r3	@ int
 1212 01cc F8EEE77A 		fsitos	s15, s15
 1213 01d0 C7EE277A 		fdivs	s15, s14, s15
 1214              		.loc 3 331 0
 1215 01d4 C7EEA67A 		fdivs	s15, s15, s13
 330:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                      / ahrs_icq.weight);
 1216              		.loc 3 330 0
 1217 01d8 FDEEE77A 		ftosizs	s15, s15
 1218 01dc 17EE903A 		fmrs	r3, s15	@ int
 1219              	.LVL112:
 332:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   Bound(inv_rate_scale, 8192, 4194304);
 1220              		.loc 3 332 0
 1221 01e0 B3F5800F 		cmp	r3, #4194304
 1222 01e4 05DC     		bgt	.L53
 1223              		.loc 3 332 0 is_stmt 0 discriminator 2
 1224 01e6 B3F5005F 		cmp	r3, #8192
 1225 01ea B8BF     		it	lt
 1226 01ec 4FF40053 		movlt	r3, #8192
 1227              	.LVL113:
 1228 01f0 01E0     		b	.L50
 1229              	.LVL114:
 1230              	.L53:
 1231              		.loc 3 332 0
 1232 01f2 4FF48003 		mov	r3, #4194304
 1233              	.LVL115:
 1234              	.L50:
 333:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p -= residual.x / inv_rate_scale;
 335:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 336:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r -= residual.z / inv_rate_scale;
 337:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 338:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // reset accel propagation counter
 339:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_cnt = 0;
 340:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 341:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 342:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 343:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 344:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 345:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC = ACCEL_FRAC + TRIG_FRAC = 10 + 14 = 24
 346:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias = RATE_FRAC+28 = 40
 347:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC_conversion: 2^40 / 2^24 = 2^16
 348:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * cross_product_gain : 9.81 m/s2
 349:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 350:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / (Ki * FRAC_conversion / cross_product_gain)
 351:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * accel_inv_ki = 2^5 / 2^16 * 9.81 * Ki = 9.81 / 2^11 * Ki
 352:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 353:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_bias_gain = 2^5 / (weight^2 * Ki * FRAC_conversion / cross_product_gain)
 354:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_bias_gain = accel_inv_ki / weight^2
 355:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 356:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_bias_gain = (int32_t)(ahrs_icq.accel_inv_ki /
 358:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                     (dt * ahrs_icq.weight * ahrs_icq.weight));
 1235              		.loc 3 358 0 is_stmt 1
 1236 01f6 28EE268A 		fmuls	s16, s16, s13
 1237              	.LVL116:
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                     (dt * ahrs_icq.weight * ahrs_icq.weight));
 1238              		.loc 3 357 0
 1239 01fa D4ED237A 		flds	s15, [r4, #140]
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 1240              		.loc 3 334 0
 1241 01fe A269     		ldr	r2, [r4, #24]
 1242 0200 97FBF3F1 		sdiv	r1, r7, r3
 1243              		.loc 3 358 0
 1244 0204 28EE268A 		fmuls	s16, s16, s13
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 1245              		.loc 3 334 0
 1246 0208 521A     		subs	r2, r2, r1
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                     (dt * ahrs_icq.weight * ahrs_icq.weight));
 1247              		.loc 3 357 0
 1248 020a 87EE888A 		fdivs	s16, s15, s16
 334:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q -= residual.y / inv_rate_scale;
 1249              		.loc 3 334 0
 1250 020e A261     		str	r2, [r4, #24]
 335:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r -= residual.z / inv_rate_scale;
 1251              		.loc 3 335 0
 1252 0210 E269     		ldr	r2, [r4, #28]
 1253 0212 96FBF3F1 		sdiv	r1, r6, r3
 1254 0216 521A     		subs	r2, r2, r1
 1255 0218 E261     		str	r2, [r4, #28]
 336:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1256              		.loc 3 336 0
 1257 021a 226A     		ldr	r2, [r4, #32]
 1258 021c 95FBF3F3 		sdiv	r3, r5, r3
 1259              	.LVL117:
 1260 0220 D31A     		subs	r3, r2, r3
 1261 0222 2362     		str	r3, [r4, #32]
 339:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1262              		.loc 3 339 0
 1263 0224 0023     		movs	r3, #0
 1264 0226 A4F8AC30 		strh	r3, [r4, #172]	@ movhi
 357:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                                     (dt * ahrs_icq.weight * ahrs_icq.weight));
 1265              		.loc 3 357 0
 1266 022a FDEEC87A 		ftosizs	s15, s16
 1267 022e 17EE901A 		fmrs	r1, s15	@ int
 1268              	.LVL118:
 359:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   Bound(inv_bias_gain, 8, 65536)
 1269              		.loc 3 359 0
 1270 0232 B1F5803F 		cmp	r1, #65536
 1271 0236 03DC     		bgt	.L54
 1272              		.loc 3 359 0 is_stmt 0 discriminator 2
 1273 0238 0829     		cmp	r1, #8
 1274 023a B8BF     		it	lt
 1275 023c 0821     		movlt	r1, #8
 1276              	.LVL119:
 1277 023e 01E0     		b	.L51
 1278              	.LVL120:
 1279              	.L54:
 1280              		.loc 3 359 0
 1281 0240 4FF48031 		mov	r1, #65536
 1282              	.LVL121:
 1283              	.L51:
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1284              		.loc 3 360 0 is_stmt 1
 1285 0244 D4E91223 		ldrd	r2, [r4, #72]
 1286 0248 97FBF1F7 		sdiv	r7, r7, r1
 1287              	.LVL122:
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1288              		.loc 3 361 0
 1289 024c 96FBF1F6 		sdiv	r6, r6, r1
 1290              	.LVL123:
 1291 0250 D4E91489 		ldrd	r8, [r4, #80]
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1292              		.loc 3 362 0
 1293 0254 95FBF1F5 		sdiv	r5, r5, r1
 1294              	.LVL124:
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1295              		.loc 3 360 0
 1296 0258 7F01     		lsls	r7, r7, #5
 1297 025a D219     		adds	r2, r2, r7
 1298              		.loc 3 362 0
 1299 025c D4E91601 		ldrd	r0, [r4, #88]
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1300              		.loc 3 360 0
 1301 0260 43EBE773 		adc	r3, r3, r7, asr #31
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q += (residual.y / inv_bias_gain) << 5;
 1302              		.loc 3 361 0
 1303 0264 7601     		lsls	r6, r6, #5
 1304 0266 18EB0608 		adds	r8, r8, r6
 360:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p += (residual.x / inv_bias_gain) << 5;
 1305              		.loc 3 360 0
 1306 026a C4E91223 		strd	r2, [r4, #72]
 1307              		.loc 3 362 0
 1308 026e 4FEA4515 		lsl	r5, r5, #5
 363:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 364:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 1309              		.loc 3 364 0
 1310 0272 4FEA1272 		lsr	r2, r2, #28
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1311              		.loc 3 361 0
 1312 0276 49EBE679 		adc	r9, r9, r6, asr #31
 1313              		.loc 3 364 0
 1314 027a 42EA0312 		orr	r2, r2, r3, lsl #4
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1315              		.loc 3 362 0
 1316 027e 4019     		adds	r0, r0, r5
 1317              		.loc 3 364 0
 1318 0280 4FEA1873 		lsr	r3, r8, #28
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1319              		.loc 3 362 0
 1320 0284 41EBE571 		adc	r1, r1, r5, asr #31
 1321              	.LVL125:
 1322              		.loc 3 364 0
 1323 0288 43EA0913 		orr	r3, r3, r9, lsl #4
 1324 028c 6360     		str	r3, [r4, #4]
 361:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1325              		.loc 3 361 0
 1326 028e C4E91489 		strd	r8, [r4, #80]
 1327              		.loc 3 364 0
 1328 0292 030F     		lsrs	r3, r0, #28
 362:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r += (residual.z / inv_bias_gain) << 5;
 1329              		.loc 3 362 0
 1330 0294 C4E91601 		strd	r0, [r4, #88]
 1331              		.loc 3 364 0
 1332 0298 43EA0113 		orr	r3, r3, r1, lsl #4
 1333 029c 2260     		str	r2, [r4]
 1334 029e A360     		str	r3, [r4, #8]
 1335              	.L40:
 365:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 366:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1336              		.loc 3 366 0
 1337 02a0 13B0     		add	sp, sp, #76
 1338              		.cfi_def_cfa_offset 44
 1339              		@ sp needed
 1340 02a2 BDEC028B 		fldmfdd	sp!, {d8}
 1341              		.cfi_restore 80
 1342              		.cfi_restore 81
 1343              		.cfi_def_cfa_offset 36
 1344 02a6 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1345              	.L70:
 1346 02aa 00BFAFF3 		.align	3
 1346      0080
 1347              	.L69:
 1348 02b0 1F85EB51 		.word	1374389535
 1349 02b4 B89E2340 		.word	1076076216
 1350 02b8 33333333 		.word	858993459
 1351 02bc 3333C33F 		.word	1069757235
 1352 02c0 00000000 		.word	.LANCHOR0
 1353 02c4 D0000000 		.word	.LANCHOR0+208
 1354 02c8 0000803A 		.word	981467136
 1355 02cc 0000F03F 		.word	1072693248
 1356 02d0 00002440 		.word	1076101120
 1357 02d4 9A99193E 		.word	1041865114
 1358 02d8 00000000 		.word	.LANCHOR1
 1359              		.cfi_endproc
 1360              	.LFE93:
 1362              		.section	.text.ahrs_icq_update_mag,"ax",%progbits
 1363              		.align	1
 1364              		.global	ahrs_icq_update_mag
 1365              		.thumb
 1366              		.thumb_func
 1368              	ahrs_icq_update_mag:
 1369              	.LFB94:
 367:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 368:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 369:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_mag(struct Int32Vect3 *mag, float dt)
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1370              		.loc 3 370 0
 1371              		.cfi_startproc
 1372              		@ args = 0, pretend = 0, frame = 72
 1373              		@ frame_needed = 0, uses_anonymous_args = 0
 1374              	.LVL126:
 1375 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1376              		.cfi_def_cfa_offset 28
 1377              		.cfi_offset 4, -28
 1378              		.cfi_offset 5, -24
 1379              		.cfi_offset 6, -20
 1380              		.cfi_offset 7, -16
 1381              		.cfi_offset 8, -12
 1382              		.cfi_offset 9, -8
 1383              		.cfi_offset 14, -4
 371:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 372:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ahrs_icq.mag_cnt == 0) {
 1384              		.loc 3 372 0
 1385 0004 534C     		ldr	r4, .L84
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 1386              		.loc 3 370 0
 1387 0006 2DED028B 		fstmfdd	sp!, {d8}
 1388              		.cfi_def_cfa_offset 36
 1389              		.cfi_offset 80, -36
 1390              		.cfi_offset 81, -32
 1391              		.loc 3 372 0
 1392 000a B4F8AE30 		ldrh	r3, [r4, #174]
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 1393              		.loc 3 370 0
 1394 000e 93B0     		sub	sp, sp, #76
 1395              		.cfi_def_cfa_offset 112
 370:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // check if we had at least one propagation since last update
 1396              		.loc 3 370 0
 1397 0010 0746     		mov	r7, r0
 1398 0012 08EE101A 		fmsr	s16, r1
 1399              		.loc 3 372 0
 1400 0016 002B     		cmp	r3, #0
 1401 0018 00F09780 		beq	.L71
 1402              	.LVL127:
 1403              	.LBB121:
 1404              	.LBB122:
 373:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     return;
 374:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 375:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_MAG_UPDATE_ALL_AXES
 376:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_update_mag_full(mag, dt);
 377:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 378:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_update_mag_2d(mag, dt);
 379:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 380:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // reset mag propagation counter
 381:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 382:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 383:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 384:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_mag_gains(void)
 385:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 386:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain = 2*omega*zeta */
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_kp = 2 * ahrs_icq.mag_zeta * ahrs_icq.mag_omega;
 388:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain = omega^2 */
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_ki = ahrs_icq.mag_omega * ahrs_icq.mag_omega;
 390:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 391:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 392:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 393:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_full(struct Int32Vect3 *mag, float dt)
 394:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 395:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 396:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 397:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 398:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 399:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 expected_imu;
 400:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&expected_imu, &ltp_to_imu_rmat, &ahrs_icq.mag_h);
 401:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 402:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual;
 403:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   VECT3_CROSS_PRODUCT(residual, *mag, expected_imu);
 404:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 405:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain.
 406:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * mag_zeta * mag_omega
 407:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.mag_cnt
 408:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.mag_cnt beeing the number of propagations since last update
 409:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 410:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC: 2 * MAG_FRAC = 22
 411:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 412:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^12 / 2^22 = 1/1024
 413:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 414:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1 / Kp / FRAC_conversion
 415:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1024 / Kp
 416:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 417:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 418:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   const int32_t inv_rate_gain = (int32_t)(1024.0 / (ahrs_icq.mag_kp * ahrs_icq.mag_cnt));
 419:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 420:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += residual.x / inv_rate_gain;
 421:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += residual.y / inv_rate_gain;
 422:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual.z / inv_rate_gain;
 423:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 424:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 425:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 426:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 427:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 428:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual FRAC: 2* MAG_FRAC = 22
 429:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias FRAC: RATE_FRAC+28 = 40
 430:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^40 / 2^22 = 2^18
 431:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 432:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * bias_gain = Ki * FRAC_conversion = Ki * 2^18
 433:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 434:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   const int32_t bias_gain = (int32_t)(ahrs_icq.mag_ki * dt * (1 << 18));
 435:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 436:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= residual.x * bias_gain;
 437:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= residual.y * bias_gain;
 438:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r -= residual.z * bias_gain;
 439:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 440:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 441:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 442:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 443:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 444:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 445:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 446:subsystems/ahrs/ahrs_int_cmpl_quat.c **** static inline void ahrs_icq_update_mag_2d(struct Int32Vect3 *mag, float dt)
 447:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 448:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 449:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 expected_ltp = {ahrs_icq.mag_h.x, ahrs_icq.mag_h.y};
 1405              		.loc 3 449 0
 1406 001c 666F     		ldr	r6, [r4, #116]
 1407 001e D4F87080 		ldr	r8, [r4, #112]
 1408              	.LVL128:
 1409              	.LBB123:
 1410              	.LBB124:
 1411              	.LBB125:
 1412              	.LBB126:
 1413              	.LBB127:
 1414              	.LBB128:
 244:./math/pprz_algebra_int.h **** }
 1415              		.loc 2 244 0
 1416 0022 06FB06F0 		mul	r0, r6, r6
 1417              	.LVL129:
 1418              	.LBE128:
 1419              	.LBE127:
 250:./math/pprz_algebra_int.h **** }
 1420              		.loc 2 250 0
 1421 0026 08FB0800 		mla	r0, r8, r8, r0
 1422 002a FFF7FEFF 		bl	int32_sqrt
 1423              	.LVL130:
 1424              	.LBE126:
 1425              	.LBE125:
 257:./math/pprz_algebra_int.h ****     const int32_t f = BFP_OF_REAL((1.), frac);
 1426              		.loc 2 257 0
 1427 002e 30B1     		cbz	r0, .L73
 1428              	.LVL131:
 1429              	.LBB129:
 259:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1430              		.loc 2 259 0
 1431 0030 4FEAC825 		lsl	r5, r8, #11
 260:./math/pprz_algebra_int.h ****   }
 1432              		.loc 2 260 0
 1433 0034 F602     		lsls	r6, r6, #11
 1434              	.LVL132:
 259:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1435              		.loc 2 259 0
 1436 0036 95FBF0F8 		sdiv	r8, r5, r0
 1437              	.LVL133:
 260:./math/pprz_algebra_int.h ****   }
 1438              		.loc 2 260 0
 1439 003a 96FBF0F6 		sdiv	r6, r6, r0
 1440              	.LVL134:
 1441              	.L73:
 1442              	.LBE129:
 1443              	.LBE124:
 1444              	.LBE123:
 450:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* normalize expected ltp in 2D (x,y) */
 451:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_vect2_normalize(&expected_ltp, INT32_MAG_FRAC);
 452:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 453:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 454:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 1445              		.loc 3 454 0
 1446 003e 09A8     		add	r0, sp, #36
 1447 0040 4549     		ldr	r1, .L84+4
 1448 0042 FFF7FEFF 		bl	int32_rmat_of_quat
 1449              	.LVL135:
 455:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 456:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 measured_ltp;
 457:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_transp_vmult(&measured_ltp, &ltp_to_imu_rmat, mag);
 1450              		.loc 3 457 0
 1451 0046 6846     		mov	r0, sp
 1452 0048 09A9     		add	r1, sp, #36
 1453 004a 3A46     		mov	r2, r7
 1454 004c FFF7FEFF 		bl	int32_rmat_transp_vmult
 1455              	.LVL136:
 458:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 459:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* normalize measured ltp in 2D (x,y) */
 460:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 measured_ltp_2d = {measured_ltp.x, measured_ltp.y};
 1456              		.loc 3 460 0
 1457 0050 019D     		ldr	r5, [sp, #4]
 1458 0052 DDF80090 		ldr	r9, [sp]
 1459              	.LVL137:
 1460              	.LBB130:
 1461              	.LBB131:
 1462              	.LBB132:
 1463              	.LBB133:
 1464              	.LBB134:
 1465              	.LBB135:
 244:./math/pprz_algebra_int.h **** }
 1466              		.loc 2 244 0
 1467 0056 05FB05F0 		mul	r0, r5, r5
 1468              	.LBE135:
 1469              	.LBE134:
 250:./math/pprz_algebra_int.h **** }
 1470              		.loc 2 250 0
 1471 005a 09FB0900 		mla	r0, r9, r9, r0
 1472 005e FFF7FEFF 		bl	int32_sqrt
 1473              	.LVL138:
 1474              	.LBE133:
 1475              	.LBE132:
 257:./math/pprz_algebra_int.h ****     const int32_t f = BFP_OF_REAL((1.), frac);
 1476              		.loc 2 257 0
 1477 0062 30B1     		cbz	r0, .L74
 1478              	.LVL139:
 1479              	.LBB136:
 259:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1480              		.loc 2 259 0
 1481 0064 4FEAC929 		lsl	r9, r9, #11
 1482              	.LVL140:
 260:./math/pprz_algebra_int.h ****   }
 1483              		.loc 2 260 0
 1484 0068 EB02     		lsls	r3, r5, #11
 259:./math/pprz_algebra_int.h ****     v->y = v->y * f / (int32_t)n;
 1485              		.loc 2 259 0
 1486 006a 99FBF0F9 		sdiv	r9, r9, r0
 1487              	.LVL141:
 260:./math/pprz_algebra_int.h ****   }
 1488              		.loc 2 260 0
 1489 006e 93FBF0F5 		sdiv	r5, r3, r0
 1490              	.LVL142:
 1491              	.L74:
 1492              	.LBE136:
 1493              	.LBE131:
 1494              	.LBE130:
 461:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_vect2_normalize(&measured_ltp_2d, INT32_MAG_FRAC);
 462:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 463:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* residual_ltp FRAC: 2 * MAG_FRAC - 5 = 17 */
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 1495              		.loc 3 464 0
 1496 0072 0027     		movs	r7, #0
 1497              	.LVL143:
 465:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 466:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     (measured_ltp_2d.x * expected_ltp.y - measured_ltp_2d.y * expected_ltp.x) / (1 << 5)
 468:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 469:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 470:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 471:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_imu;
 472:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 1498              		.loc 3 472 0
 1499 0074 03AA     		add	r2, sp, #12
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 1500              		.loc 3 467 0
 1501 0076 06FB09F6 		mul	r6, r6, r9
 1502              	.LVL144:
 1503              		.loc 3 472 0
 1504 007a 06A8     		add	r0, sp, #24
 1505 007c 09A9     		add	r1, sp, #36
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 1506              		.loc 3 467 0
 1507 007e 2023     		movs	r3, #32
 1508 0080 08FB1565 		mls	r5, r8, r5, r6
 1509              	.LVL145:
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 1510              		.loc 3 464 0
 1511 0084 0397     		str	r7, [sp, #12]
 467:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 1512              		.loc 3 467 0
 1513 0086 95FBF3F5 		sdiv	r5, r5, r3
 464:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 1514              		.loc 3 464 0
 1515 008a 0497     		str	r7, [sp, #16]
 1516 008c 0595     		str	r5, [sp, #20]
 1517              		.loc 3 472 0
 1518 008e FFF7FEFF 		bl	int32_rmat_vmult
 1519              	.LVL146:
 473:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 474:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain.
 475:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Kp = 2 * mag_zeta * mag_omega
 476:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * final Kp with frequency correction = Kp * ahrs_icq.mag_cnt
 477:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * with ahrs_icq.mag_cnt beeing the number of propagations since last update
 478:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 479:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual_imu FRAC = residual_ltp FRAC = 17
 480:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * rate_correction FRAC: RATE_FRAC = 12
 481:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^12 / 2^17 = 1/32
 482:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 483:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 1 / Kp / FRAC_conversion
 484:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * inv_rate_gain = 32 / Kp
 485:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 486:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t inv_rate_gain = (int32_t)(32.0 / (ahrs_icq.mag_kp * ahrs_icq.mag_cnt));
 1520              		.loc 3 486 0
 1521 0092 B4F8AE30 		ldrh	r3, [r4, #174]
 1522 0096 94ED247A 		flds	s14, [r4, #144]
 1523 009a 07EE903A 		fmsr	s15, r3	@ int
 1524 009e F8EEE77A 		fsitos	s15, s15
 1525 00a2 67EE877A 		fmuls	s15, s15, s14
 1526 00a6 17EE900A 		fmrs	r0, s15
 1527 00aa FFF7FEFF 		bl	__aeabi_f2d
 1528              	.LVL147:
 1529 00ae 0246     		mov	r2, r0
 1530 00b0 0B46     		mov	r3, r1
 1531 00b2 0020     		movs	r0, #0
 1532 00b4 2949     		ldr	r1, .L84+8
 1533 00b6 FFF7FEFF 		bl	__aeabi_ddiv
 1534              	.LVL148:
 1535 00ba FFF7FEFF 		bl	__aeabi_d2iz
 1536              	.LVL149:
 487:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += (residual_imu.x / inv_rate_gain);
 1537              		.loc 3 488 0
 1538 00be A269     		ldr	r2, [r4, #24]
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += (residual_imu.z / inv_rate_gain);
 491:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 492:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain
 493:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Correct the gyro bias.
 494:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Ki = omega^2 * dt
 495:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 496:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * residual_imu FRAC = residual_ltp FRAC = 17
 497:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * high_rez_bias FRAC: RATE_FRAC+28 = 40
 498:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * FRAC conversion: 2^40 / 2^17 = 2^23
 499:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    *
 500:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * bias_gain = Ki * FRAC_conversion = Ki * 2^23
 501:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 502:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t bias_gain = (int32_t)(ahrs_icq.mag_ki * dt * (1 << 23));
 1539              		.loc 3 502 0
 1540 00c0 D4ED257A 		flds	s15, [r4, #148]
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1541              		.loc 3 488 0
 1542 00c4 069D     		ldr	r5, [sp, #24]
 1543 00c6 95FBF0F3 		sdiv	r3, r5, r0
 1544              		.loc 3 502 0
 1545 00ca 28EE278A 		fmuls	s16, s16, s15
 1546              	.LVL150:
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1547              		.loc 3 488 0
 1548 00ce 1344     		add	r3, r3, r2
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1549              		.loc 3 489 0
 1550 00d0 E269     		ldr	r2, [r4, #28]
 1551 00d2 0799     		ldr	r1, [sp, #28]
 488:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1552              		.loc 3 488 0
 1553 00d4 A361     		str	r3, [r4, #24]
 1554              		.loc 3 502 0
 1555 00d6 F0EE487A 		fcpys	s15, s16
 489:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += (residual_imu.y / inv_rate_gain);
 1556              		.loc 3 489 0
 1557 00da 91FBF0F3 		sdiv	r3, r1, r0
 1558 00de 1344     		add	r3, r3, r2
 1559 00e0 E361     		str	r3, [r4, #28]
 1560              		.loc 3 502 0
 1561 00e2 FEEEE47A 		vcvt.s32.f32	s15, s15, #23
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1562              		.loc 3 490 0
 1563 00e6 236A     		ldr	r3, [r4, #32]
 1564 00e8 089A     		ldr	r2, [sp, #32]
 1565 00ea 92FBF0F0 		sdiv	r0, r2, r0
 1566              	.LVL151:
 503:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 504:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.p -= (residual_imu.x * bias_gain);
 1567              		.loc 3 504 0
 1568 00ee D4E91289 		ldrd	r8, [r4, #72]
 1569              	.LVL152:
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1570              		.loc 3 490 0
 1571 00f2 1844     		add	r0, r0, r3
 502:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1572              		.loc 3 502 0
 1573 00f4 17EE903A 		fmrs	r3, s15	@ int
 1574              	.LVL153:
 1575              		.loc 3 504 0
 1576 00f8 5D43     		muls	r5, r3, r5
 1577 00fa B8EB0508 		subs	r8, r8, r5
 1578 00fe 69EBE579 		sbc	r9, r9, r5, asr #31
 1579              	.LVL154:
 490:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1580              		.loc 3 490 0
 1581 0102 2062     		str	r0, [r4, #32]
 505:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= (residual_imu.y * bias_gain);
 1582              		.loc 3 505 0
 1583 0104 03FB01F5 		mul	r5, r3, r1
 1584 0108 D4E91401 		ldrd	r0, [r4, #80]
 1585 010c 401B     		subs	r0, r0, r5
 1586 010e 61EBE571 		sbc	r1, r1, r5, asr #31
 506:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.r -= (residual_imu.z * bias_gain);
 1587              		.loc 3 506 0
 1588 0112 03FB02F5 		mul	r5, r3, r2
 1589 0116 D4E91623 		ldrd	r2, [r4, #88]
 1590 011a 521B     		subs	r2, r2, r5
 1591 011c 63EBE573 		sbc	r3, r3, r5, asr #31
 1592              	.LVL155:
 505:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= (residual_imu.y * bias_gain);
 1593              		.loc 3 505 0
 1594 0120 C4E91401 		strd	r0, [r4, #80]
 1595              		.loc 3 506 0
 1596 0124 C4E91623 		strd	r2, [r4, #88]
 507:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 508:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 1597              		.loc 3 508 0
 1598 0128 4FEA1875 		lsr	r5, r8, #28
 1599 012c 000F     		lsrs	r0, r0, #28
 1600 012e 120F     		lsrs	r2, r2, #28
 504:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.high_rez_bias.q -= (residual_imu.y * bias_gain);
 1601              		.loc 3 504 0
 1602 0130 C4E91289 		strd	r8, [r4, #72]
 1603              		.loc 3 508 0
 1604 0134 45EA0915 		orr	r5, r5, r9, lsl #4
 1605 0138 40EA0110 		orr	r0, r0, r1, lsl #4
 1606 013c 42EA0312 		orr	r2, r2, r3, lsl #4
 1607 0140 2560     		str	r5, [r4]
 1608 0142 6060     		str	r0, [r4, #4]
 1609 0144 A260     		str	r2, [r4, #8]
 1610              	.LBE122:
 1611              	.LBE121:
 381:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1612              		.loc 3 381 0
 1613 0146 A4F8AE70 		strh	r7, [r4, #174]	@ movhi
 1614              	.LVL156:
 1615              	.L71:
 382:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1616              		.loc 3 382 0
 1617 014a 13B0     		add	sp, sp, #76
 1618              		.cfi_def_cfa_offset 36
 1619              		@ sp needed
 1620 014c BDEC028B 		fldmfdd	sp!, {d8}
 1621              		.cfi_restore 80
 1622              		.cfi_restore 81
 1623              		.cfi_def_cfa_offset 28
 1624 0150 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 1625              	.L85:
 1626              		.align	2
 1627              	.L84:
 1628 0154 00000000 		.word	.LANCHOR0
 1629 0158 60000000 		.word	.LANCHOR0+96
 1630 015c 00004040 		.word	1077936128
 1631              		.cfi_endproc
 1632              	.LFE94:
 1634              		.section	.text.ahrs_icq_set_mag_gains,"ax",%progbits
 1635              		.align	1
 1636              		.global	ahrs_icq_set_mag_gains
 1637              		.thumb
 1638              		.thumb_func
 1640              	ahrs_icq_set_mag_gains:
 1641              	.LFB95:
 385:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter proportionnal gain = 2*omega*zeta */
 1642              		.loc 3 385 0
 1643              		.cfi_startproc
 1644              		@ args = 0, pretend = 0, frame = 0
 1645              		@ frame_needed = 0, uses_anonymous_args = 0
 1646              		@ link register save eliminated.
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain = omega^2 */
 1647              		.loc 3 387 0
 1648 0000 074B     		ldr	r3, .L87
 1649 0002 D3ED2A7A 		flds	s15, [r3, #168]
 1650 0006 93ED297A 		flds	s14, [r3, #164]
 1651 000a 77EEA77A 		fadds	s15, s15, s15
 1652 000e 67EE877A 		fmuls	s15, s15, s14
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1653              		.loc 3 389 0
 1654 0012 27EE077A 		fmuls	s14, s14, s14
 387:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* Complementary filter integral gain = omega^2 */
 1655              		.loc 3 387 0
 1656 0016 C3ED247A 		fsts	s15, [r3, #144]
 389:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1657              		.loc 3 389 0
 1658 001a 83ED257A 		fsts	s14, [r3, #148]
 1659 001e 7047     		bx	lr
 1660              	.L88:
 1661              		.align	2
 1662              	.L87:
 1663 0020 00000000 		.word	.LANCHOR0
 1664              		.cfi_endproc
 1665              	.LFE95:
 1667              		.section	.text.ahrs_icq_init,"ax",%progbits
 1668              		.align	1
 1669              		.global	ahrs_icq_init
 1670              		.thumb
 1671              		.thumb_func
 1673              	ahrs_icq_init:
 1674              	.LFB89:
 109:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1675              		.loc 3 109 0
 1676              		.cfi_startproc
 1677              		@ args = 0, pretend = 0, frame = 0
 1678              		@ frame_needed = 0, uses_anonymous_args = 0
 1679 0000 70B5     		push	{r4, r5, r6, lr}
 1680              		.cfi_def_cfa_offset 16
 1681              		.cfi_offset 4, -16
 1682              		.cfi_offset 5, -12
 1683              		.cfi_offset 6, -8
 1684              		.cfi_offset 14, -4
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 1685              		.loc 3 111 0
 1686 0002 224C     		ldr	r4, .L90
 128:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_accel_gains();
 1687              		.loc 3 128 0
 1688 0004 224E     		ldr	r6, .L90+4
 1689 0006 C4F8A060 		str	r6, [r4, #160]	@ float
 1690              	.LBB137:
 1691              	.LBB138:
 432:./math/pprz_algebra_int.h ****   q->qx = 0;
 1692              		.loc 2 432 0
 1693 000a 4FF40043 		mov	r3, #32768
 1694              	.LBE138:
 1695              	.LBE137:
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 1696              		.loc 3 111 0
 1697 000e 0025     		movs	r5, #0
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1698              		.loc 3 124 0
 1699 0010 0022     		movs	r2, #0
 1700              	.LBB142:
 1701              	.LBB139:
 432:./math/pprz_algebra_int.h ****   q->qx = 0;
 1702              		.loc 2 432 0
 1703 0012 2366     		str	r3, [r4, #96]
 1704              	.LBE139:
 1705              	.LBE142:
 124:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1706              		.loc 3 124 0
 1707 0014 0023     		movs	r3, #0
 1708 0016 C4E91223 		strd	r2, [r4, #72]
 1709 001a C4E91423 		strd	r2, [r4, #80]
 1710 001e C4E91623 		strd	r2, [r4, #88]
 1711              	.LBB143:
 1712              	.LBB140:
 433:./math/pprz_algebra_int.h ****   q->qy = 0;
 1713              		.loc 2 433 0
 1714 0022 6566     		str	r5, [r4, #100]
 1715              	.LBE140:
 1716              	.LBE143:
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_zeta = AHRS_ACCEL_ZETA;
 1717              		.loc 3 127 0
 1718 0024 1B4B     		ldr	r3, .L90+8
 1719              	.LBB144:
 1720              	.LBB141:
 434:./math/pprz_algebra_int.h ****   q->qz = 0;
 1721              		.loc 2 434 0
 1722 0026 A566     		str	r5, [r4, #104]
 435:./math/pprz_algebra_int.h **** }
 1723              		.loc 2 435 0
 1724 0028 E566     		str	r5, [r4, #108]
 1725              	.LBE141:
 1726              	.LBE144:
 127:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.accel_zeta = AHRS_ACCEL_ZETA;
 1727              		.loc 3 127 0
 1728 002a C4F89C30 		str	r3, [r4, #156]	@ float
 111:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.is_aligned = FALSE;
 1729              		.loc 3 111 0
 1730 002e 84F83451 		strb	r5, [r4, #308]
 112:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1731              		.loc 3 112 0
 1732 0032 84F83551 		strb	r5, [r4, #309]
 114:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = FALSE;
 1733              		.loc 3 114 0
 1734 0036 84F88050 		strb	r5, [r4, #128]
 115:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1735              		.loc 3 115 0
 1736 003a 84F88150 		strb	r5, [r4, #129]
 1737              	.LVL157:
 120:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1738              		.loc 3 120 0
 1739 003e E560     		str	r5, [r4, #12]
 1740 0040 2561     		str	r5, [r4, #16]
 1741 0042 6561     		str	r5, [r4, #20]
 122:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.rate_correction);
 1742              		.loc 3 122 0
 1743 0044 2560     		str	r5, [r4]
 1744 0046 6560     		str	r5, [r4, #4]
 1745 0048 A560     		str	r5, [r4, #8]
 123:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT_RATES_ZERO(ahrs_icq.high_rez_bias);
 1746              		.loc 3 123 0
 1747 004a A561     		str	r5, [r4, #24]
 1748 004c E561     		str	r5, [r4, #28]
 1749 004e 2562     		str	r5, [r4, #32]
 129:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_omega = AHRS_MAG_OMEGA;
 1750              		.loc 3 129 0
 1751 0050 FFF7FEFF 		bl	ahrs_icq_set_accel_gains
 1752              	.LVL158:
 130:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_zeta = AHRS_MAG_ZETA;
 1753              		.loc 3 130 0
 1754 0054 104B     		ldr	r3, .L90+12
 1755 0056 C4F8A430 		str	r3, [r4, #164]	@ float
 131:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_mag_gains();
 1756              		.loc 3 131 0
 1757 005a C4F8A860 		str	r6, [r4, #168]	@ float
 132:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1758              		.loc 3 132 0
 1759 005e FFF7FEFF 		bl	ahrs_icq_set_mag_gains
 1760              	.LVL159:
 135:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 1761              		.loc 3 135 0
 1762 0062 1E23     		movs	r3, #30
 1763 0064 84F89930 		strb	r3, [r4, #153]
 138:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #else
 1764              		.loc 3 138 0
 1765 0068 0123     		movs	r3, #1
 1766 006a 84F89830 		strb	r3, [r4, #152]
 143:subsystems/ahrs/ahrs_int_cmpl_quat.c ****                MAG_BFP_OF_REAL(AHRS_H_Y), MAG_BFP_OF_REAL(AHRS_H_Z));
 1767              		.loc 3 143 0
 1768 006e 40F25543 		movw	r3, #1109
 1769 0072 2367     		str	r3, [r4, #112]
 1770 0074 6FF09403 		mvn	r3, #148
 1771 0078 6367     		str	r3, [r4, #116]
 1772 007a 40F2B263 		movw	r3, #1714
 1773 007e A367     		str	r3, [r4, #120]
 146:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.mag_cnt = 0;
 1774              		.loc 3 146 0
 1775 0080 A4F8AC50 		strh	r5, [r4, #172]	@ movhi
 147:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 1776              		.loc 3 147 0
 1777 0084 A4F8AE50 		strh	r5, [r4, #174]	@ movhi
 1778 0088 70BD     		pop	{r4, r5, r6, pc}
 1779              	.L91:
 1780 008a 00BF     		.align	2
 1781              	.L90:
 1782 008c 00000000 		.word	.LANCHOR0
 1783 0090 6666663F 		.word	1063675494
 1784 0094 2506813D 		.word	1031865893
 1785 0098 0AD7233D 		.word	1025758986
 1786              		.cfi_endproc
 1787              	.LFE89:
 1789              		.section	.text.ahrs_icq_update_gps,"ax",%progbits
 1790              		.align	1
 1791              		.global	ahrs_icq_update_gps
 1792              		.thumb
 1793              		.thumb_func
 1795              	ahrs_icq_update_gps:
 1796              	.LFB98:
 509:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 510:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 511:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 512:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_gps(struct GpsState *gps_s __attribute__((unused)))
 513:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1797              		.loc 3 513 0
 1798              		.cfi_startproc
 1799              		@ args = 0, pretend = 0, frame = 0
 1800              		@ frame_needed = 0, uses_anonymous_args = 0
 1801              	.LVL160:
 1802 0000 10B5     		push	{r4, lr}
 1803              		.cfi_def_cfa_offset 8
 1804              		.cfi_offset 4, -8
 1805              		.cfi_offset 14, -4
 514:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_GRAVITY_UPDATE_COORDINATED_TURN && USE_GPS
 515:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (gps_s->fix == GPS_FIX_3D) {
 1806              		.loc 3 515 0
 1807 0002 90F85B30 		ldrb	r3, [r0, #91]	@ zero_extendqisi2
 1808 0006 0C4C     		ldr	r4, .L96
 1809 0008 032B     		cmp	r3, #3
 1810 000a 10D1     		bne	.L93
 516:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm = SPEED_BFP_OF_REAL(gps_s->speed_3d / 100.);
 1811              		.loc 3 516 0
 1812 000c B0F84600 		ldrh	r0, [r0, #70]
 1813              	.LVL161:
 1814 0010 FFF7FEFF 		bl	__aeabi_i2d
 1815              	.LVL162:
 1816 0014 0022     		movs	r2, #0
 1817 0016 094B     		ldr	r3, .L96+4
 1818 0018 FFF7FEFF 		bl	__aeabi_ddiv
 1819              	.LVL163:
 1820 001c 084B     		ldr	r3, .L96+8
 1821 001e 0022     		movs	r2, #0
 1822 0020 FFF7FEFF 		bl	__aeabi_dmul
 1823              	.LVL164:
 1824 0024 FFF7FEFF 		bl	__aeabi_d2iz
 1825              	.LVL165:
 517:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm_valid = TRUE;
 1826              		.loc 3 517 0
 1827 0028 0123     		movs	r3, #1
 516:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm = SPEED_BFP_OF_REAL(gps_s->speed_3d / 100.);
 1828              		.loc 3 516 0
 1829 002a E067     		str	r0, [r4, #124]
 1830 002c 00E0     		b	.L95
 1831              	.LVL166:
 1832              	.L93:
 518:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   } else {
 519:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.ltp_vel_norm_valid = FALSE;
 1833              		.loc 3 519 0
 1834 002e 0023     		movs	r3, #0
 1835              	.LVL167:
 1836              	.L95:
 1837 0030 84F88030 		strb	r3, [r4, #128]
 1838 0034 10BD     		pop	{r4, pc}
 1839              	.L97:
 1840 0036 00BF     		.align	2
 1841              	.L96:
 1842 0038 00000000 		.word	.LANCHOR0
 1843 003c 00005940 		.word	1079574528
 1844 0040 00002041 		.word	1092616192
 1845              		.cfi_endproc
 1846              	.LFE98:
 1848              		.section	.text.ahrs_icq_update_heading,"ax",%progbits
 1849              		.align	1
 1850              		.global	ahrs_icq_update_heading
 1851              		.thumb
 1852              		.thumb_func
 1854              	ahrs_icq_update_heading:
 1855              	.LFB99:
 520:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 521:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 522:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 523:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #if AHRS_USE_GPS_HEADING && USE_GPS
 524:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // got a 3d fix, ground speed > AHRS_HEADING_UPDATE_GPS_MIN_SPEED (default 5.0 m/s)
 525:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // and course accuracy is better than 10deg
 526:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (gps_s->fix == GPS_FIX_3D &&
 527:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       gps_s->gspeed >= (AHRS_HEADING_UPDATE_GPS_MIN_SPEED * 100) &&
 528:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       gps_s->cacc <= RadOfDeg(10 * 1e7)) {
 529:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 530:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // gps_s->course is in rad * 1e7, we need it in rad * 2^INT32_ANGLE_FRAC
 531:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     int32_t course = gps_s->course * ((1 << INT32_ANGLE_FRAC) / 1e7);
 532:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 533:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* the assumption here is that there is no side-slip, so heading=course */
 534:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 535:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     if (ahrs_icq.heading_aligned) {
 536:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       ahrs_icq_update_heading(course);
 537:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     } else {
 538:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       /* hard reset the heading if this is the first measurement */
 539:subsystems/ahrs/ahrs_int_cmpl_quat.c ****       ahrs_icq_realign_heading(course);
 540:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     }
 541:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 542:subsystems/ahrs/ahrs_int_cmpl_quat.c **** #endif
 543:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 544:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 545:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 546:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_update_heading(int32_t heading)
 547:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 1856              		.loc 3 547 0
 1857              		.cfi_startproc
 1858              		@ args = 0, pretend = 0, frame = 112
 1859              		@ frame_needed = 0, uses_anonymous_args = 0
 1860              	.LVL168:
 1861 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 1862              		.cfi_def_cfa_offset 28
 1863              		.cfi_offset 4, -28
 1864              		.cfi_offset 5, -24
 1865              		.cfi_offset 6, -20
 1866              		.cfi_offset 7, -16
 1867              		.cfi_offset 8, -12
 1868              		.cfi_offset 9, -8
 1869              		.cfi_offset 14, -4
 1870 0004 0546     		mov	r5, r0
 1871 0006 9DB0     		sub	sp, sp, #116
 1872              		.cfi_def_cfa_offset 144
 1873              	.LVL169:
 1874              	.L99:
 548:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 549:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   INT32_ANGLE_NORMALIZE(heading);
 1875              		.loc 3 549 0 discriminator 1
 1876 0008 43F24323 		movw	r3, #12867
 1877 000c 9D42     		cmp	r5, r3
 1878 000e 03DD     		ble	.L101
 1879              		.loc 3 549 0 is_stmt 0 discriminator 2
 1880 0010 A5F5C945 		sub	r5, r5, #25728
 1881              	.LVL170:
 1882 0014 073D     		subs	r5, r5, #7
 1883              	.LVL171:
 1884 0016 F7E7     		b	.L99
 1885              	.L101:
 1886              		.loc 3 549 0 discriminator 3
 1887 0018 424B     		ldr	r3, .L106
 1888 001a 9D42     		cmp	r5, r3
 1889 001c 03DA     		bge	.L105
 1890              		.loc 3 549 0 discriminator 4
 1891 001e 05F5C945 		add	r5, r5, #25728
 1892              	.LVL172:
 1893 0022 0735     		adds	r5, r5, #7
 1894              	.LVL173:
 1895 0024 F8E7     		b	.L101
 1896              	.L105:
 1897              	.LVL174:
 1898              	.LBB147:
 1899              	.LBB148:
 192:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 1900              		.loc 6 192 0 is_stmt 1
 1901 0026 404E     		ldr	r6, .L106+4
 1902 0028 96F8B030 		ldrb	r3, [r6, #176]	@ zero_extendqisi2
 1903 002c DB07     		lsls	r3, r3, #31
 1904 002e 03D4     		bmi	.L103
 193:./math/pprz_orientation_conversion.h ****   }
 1905              		.loc 6 193 0
 1906 0030 06F1B000 		add	r0, r6, #176
 1907 0034 FFF7FEFF 		bl	orientationCalcQuat_i
 1908              	.LVL175:
 1909              	.L103:
 1910              	.LBE148:
 1911              	.LBE147:
 550:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 551:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // row 0 of ltp_to_body_rmat = body x-axis in ltp frame
 552:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // we only consider x and y
 553:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat *body_to_imu_quat = orientationGetQuat_i(&ahrs_icq.body_to_imu);
 554:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat ltp_to_body_quat;
 555:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_inv(&ltp_to_body_quat, &ahrs_icq.ltp_to_imu_quat, body_to_imu_quat);
 1912              		.loc 3 555 0
 1913 0038 3B4C     		ldr	r4, .L106+4
 1914 003a 06A8     		add	r0, sp, #24
 1915 003c 04F1B402 		add	r2, r4, #180
 1916 0040 04F16001 		add	r1, r4, #96
 1917 0044 FFF7FEFF 		bl	int32_quat_comp_inv
 1918              	.LVL176:
 556:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_body_rmat;
 557:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_body_rmat, &ltp_to_body_quat);
 1919              		.loc 3 557 0
 1920 0048 06A9     		add	r1, sp, #24
 1921 004a 0AA8     		add	r0, sp, #40
 1922 004c FFF7FEFF 		bl	int32_rmat_of_quat
 1923              	.LVL177:
 558:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect2 expected_ltp = {
 559:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 0),
 560:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 1)
 561:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 562:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 563:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t heading_x, heading_y;
 564:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(heading_x, heading); // measured course in x-direction
 1924              		.loc 3 564 0
 1925 0050 2846     		mov	r0, r5
 559:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     RMAT_ELMT(ltp_to_body_rmat, 0, 1)
 1926              		.loc 3 559 0
 1927 0052 DDF82880 		ldr	r8, [sp, #40]
 1928              	.LVL178:
 560:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 1929              		.loc 3 560 0
 1930 0056 0B9F     		ldr	r7, [sp, #44]
 1931              	.LVL179:
 1932              		.loc 3 564 0
 1933 0058 FFF7FEFF 		bl	pprz_itrig_cos
 1934              	.LVL180:
 1935 005c 8146     		mov	r9, r0
 1936              	.LVL181:
 565:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(heading_y, heading); // measured course in y-direction
 1937              		.loc 3 565 0
 1938 005e 2846     		mov	r0, r5
 1939              	.LVL182:
 1940 0060 FFF7FEFF 		bl	pprz_itrig_sin
 1941              	.LVL183:
 566:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 567:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // expected_heading cross measured_heading ??
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_ltp = {
 569:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 570:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 571:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     (expected_ltp.x * heading_y - expected_ltp.y * heading_x) / (1 << INT32_ANGLE_FRAC)
 1942              		.loc 3 571 0
 1943 0064 00FB08F0 		mul	r0, r0, r8
 1944              	.LVL184:
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 1945              		.loc 3 568 0
 1946 0068 0023     		movs	r3, #0
 1947              		.loc 3 571 0
 1948 006a 09FB1707 		mls	r7, r9, r7, r0
 1949              	.LVL185:
 572:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 573:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 574:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Vect3 residual_imu;
 575:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32RMat ltp_to_imu_rmat;
 576:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_of_quat(&ltp_to_imu_rmat, &ahrs_icq.ltp_to_imu_quat);
 1950              		.loc 3 576 0
 1951 006e 04F16001 		add	r1, r4, #96
 571:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   };
 1952              		.loc 3 571 0
 1953 0072 4FF48050 		mov	r0, #4096
 1954 0076 97FBF0F7 		sdiv	r7, r7, r0
 1955              		.loc 3 576 0
 1956 007a 13A8     		add	r0, sp, #76
 568:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     0,
 1957              		.loc 3 568 0
 1958 007c 0093     		str	r3, [sp]
 1959 007e 0193     		str	r3, [sp, #4]
 1960 0080 0297     		str	r7, [sp, #8]
 1961              		.loc 3 576 0
 1962 0082 FFF7FEFF 		bl	int32_rmat_of_quat
 1963              	.LVL186:
 577:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_rmat_vmult(&residual_imu, &ltp_to_imu_rmat, &residual_ltp);
 1964              		.loc 3 577 0
 1965 0086 03A8     		add	r0, sp, #12
 1966 0088 13A9     		add	r1, sp, #76
 1967 008a 6A46     		mov	r2, sp
 1968 008c FFF7FEFF 		bl	int32_rmat_vmult
 1969              	.LVL187:
 578:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 579:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // residual FRAC = TRIG_FRAC + TRIG_FRAC = 14 + 14 = 28
 580:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // rate_correction FRAC = RATE_FRAC = 12
 581:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // 2^12 / 2^28 * 4.0 = 1/2^14
 582:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   // (1<<INT32_ANGLE_FRAC)/2^14 = 1/4
 583:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.p += residual_imu.x / 4;
 1970              		.loc 3 583 0
 1971 0090 B369     		ldr	r3, [r6, #24]
 1972 0092 039A     		ldr	r2, [sp, #12]
 1973 0094 0421     		movs	r1, #4
 1974 0096 92FBF1F2 		sdiv	r2, r2, r1
 1975 009a 1A44     		add	r2, r2, r3
 584:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += residual_imu.y / 4;
 1976              		.loc 3 584 0
 1977 009c F369     		ldr	r3, [r6, #28]
 583:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.q += residual_imu.y / 4;
 1978              		.loc 3 583 0
 1979 009e B261     		str	r2, [r6, #24]
 1980              		.loc 3 584 0
 1981 00a0 049A     		ldr	r2, [sp, #16]
 1982 00a2 92FBF1F2 		sdiv	r2, r2, r1
 1983 00a6 1A44     		add	r2, r2, r3
 1984 00a8 F261     		str	r2, [r6, #28]
 585:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual_imu.z / 4;
 1985              		.loc 3 585 0
 1986 00aa 326A     		ldr	r2, [r6, #32]
 1987 00ac 059B     		ldr	r3, [sp, #20]
 1988 00ae 93FBF1F3 		sdiv	r3, r3, r1
 586:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 587:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 588:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* crude attempt to only update bias if deviation is small
 589:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * e.g. needed when you only have gps providing heading
 590:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * and the inital heading is totally different from
 591:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * the gps course information you get once you have a gps fix.
 592:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    * Otherwise the bias will be falsely "corrected".
 593:subsystems/ahrs/ahrs_int_cmpl_quat.c ****    */
 594:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_t sin_max_angle_deviation;
 595:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(sin_max_angle_deviation, TRIG_BFP_OF_REAL(RadOfDeg(AHRS_BIAS_UPDATE_HEADING_THRESH
 1989              		.loc 3 595 0
 1990 00b2 40F29550 		movw	r0, #1429
 585:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.rate_correction.r += residual_imu.z / 4;
 1991              		.loc 3 585 0
 1992 00b6 1344     		add	r3, r3, r2
 1993 00b8 3362     		str	r3, [r6, #32]
 1994              		.loc 3 595 0
 1995 00ba FFF7FEFF 		bl	pprz_itrig_sin
 1996              	.LVL188:
 596:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (ABS(residual_ltp.z) < sin_max_angle_deviation) {
 1997              		.loc 3 596 0
 1998 00be 029B     		ldr	r3, [sp, #8]
 1999 00c0 002B     		cmp	r3, #0
 2000 00c2 B8BF     		it	lt
 2001 00c4 5B42     		rsblt	r3, r3, #0
 2002 00c6 8342     		cmp	r3, r0
 2003 00c8 28DA     		bge	.L98
 597:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // residual_ltp FRAC = 2 * TRIG_FRAC = 28
 598:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // high_rez_bias = RATE_FRAC+28 = 40
 599:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     // 2^40 / 2^28 * 2.5e-4 = 1
 600:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.p -= residual_imu.x * (1 << INT32_ANGLE_FRAC);
 2004              		.loc 3 600 0
 2005 00ca D4E91267 		ldrd	r6, [r4, #72]
 2006 00ce 039B     		ldr	r3, [sp, #12]
 2007 00d0 1B03     		lsls	r3, r3, #12
 2008 00d2 F61A     		subs	r6, r6, r3
 2009 00d4 67EBE377 		sbc	r7, r7, r3, asr #31
 601:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.q -= residual_imu.y * (1 << INT32_ANGLE_FRAC);
 2010              		.loc 3 601 0
 2011 00d8 D4E91401 		ldrd	r0, [r4, #80]
 2012              	.LVL189:
 2013 00dc 049B     		ldr	r3, [sp, #16]
 2014 00de 1B03     		lsls	r3, r3, #12
 2015 00e0 C01A     		subs	r0, r0, r3
 2016 00e2 61EBE371 		sbc	r1, r1, r3, asr #31
 602:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.r -= residual_imu.z * (1 << INT32_ANGLE_FRAC);
 2017              		.loc 3 602 0
 2018 00e6 059B     		ldr	r3, [sp, #20]
 2019 00e8 1D03     		lsls	r5, r3, #12
 2020              	.LVL190:
 2021 00ea D4E91623 		ldrd	r2, [r4, #88]
 2022 00ee B2EB0508 		subs	r8, r2, r5
 2023              	.LVL191:
 2024 00f2 63EBE579 		sbc	r9, r3, r5, asr #31
 2025              	.LVL192:
 603:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 604:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     INT_RATES_RSHIFT(ahrs_icq.gyro_bias, ahrs_icq.high_rez_bias, 28);
 2026              		.loc 3 604 0
 2027 00f6 330F     		lsrs	r3, r6, #28
 2028 00f8 43EA0713 		orr	r3, r3, r7, lsl #4
 2029 00fc 2360     		str	r3, [r4]
 2030 00fe 030F     		lsrs	r3, r0, #28
 2031 0100 43EA0113 		orr	r3, r3, r1, lsl #4
 2032 0104 6360     		str	r3, [r4, #4]
 600:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.q -= residual_imu.y * (1 << INT32_ANGLE_FRAC);
 2033              		.loc 3 600 0
 2034 0106 C4E91267 		strd	r6, [r4, #72]
 2035              		.loc 3 604 0
 2036 010a 4FEA1873 		lsr	r3, r8, #28
 601:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     ahrs_icq.high_rez_bias.r -= residual_imu.z * (1 << INT32_ANGLE_FRAC);
 2037              		.loc 3 601 0
 2038 010e C4E91401 		strd	r0, [r4, #80]
 602:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 2039              		.loc 3 602 0
 2040 0112 C4E91689 		strd	r8, [r4, #88]
 2041              		.loc 3 604 0
 2042 0116 43EA0913 		orr	r3, r3, r9, lsl #4
 2043 011a A360     		str	r3, [r4, #8]
 2044              	.L98:
 605:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   }
 606:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2045              		.loc 3 606 0
 2046 011c 1DB0     		add	sp, sp, #116
 2047              		.cfi_def_cfa_offset 28
 2048              		@ sp needed
 2049 011e BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 2050              	.L107:
 2051 0122 00BF     		.align	2
 2052              	.L106:
 2053 0124 BDCDFFFF 		.word	-12867
 2054 0128 00000000 		.word	.LANCHOR0
 2055              		.cfi_endproc
 2056              	.LFE99:
 2058              		.section	.text.ahrs_icq_realign_heading,"ax",%progbits
 2059              		.align	1
 2060              		.global	ahrs_icq_realign_heading
 2061              		.thumb
 2062              		.thumb_func
 2064              	ahrs_icq_realign_heading:
 2065              	.LFB100:
 607:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 608:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_realign_heading(int32_t heading)
 609:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2066              		.loc 3 609 0
 2067              		.cfi_startproc
 2068              		@ args = 0, pretend = 0, frame = 80
 2069              		@ frame_needed = 0, uses_anonymous_args = 0
 2070              	.LVL193:
 2071 0000 70B5     		push	{r4, r5, r6, lr}
 2072              		.cfi_def_cfa_offset 16
 2073              		.cfi_offset 4, -16
 2074              		.cfi_offset 5, -12
 2075              		.cfi_offset 6, -8
 2076              		.cfi_offset 14, -4
 2077              	.LBB151:
 2078              	.LBB152:
 192:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 2079              		.loc 6 192 0
 2080 0002 224C     		ldr	r4, .L110
 2081 0004 94F8B030 		ldrb	r3, [r4, #176]	@ zero_extendqisi2
 2082 0008 DB07     		lsls	r3, r3, #31
 2083              	.LBE152:
 2084              	.LBE151:
 2085              		.loc 3 609 0
 2086 000a 94B0     		sub	sp, sp, #80
 2087              		.cfi_def_cfa_offset 96
 2088              		.loc 3 609 0
 2089 000c 0646     		mov	r6, r0
 2090              	.LBB154:
 2091              	.LBB153:
 192:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_i(orientation);
 2092              		.loc 6 192 0
 2093 000e 03D4     		bmi	.L109
 193:./math/pprz_orientation_conversion.h ****   }
 2094              		.loc 6 193 0
 2095 0010 04F1B000 		add	r0, r4, #176
 2096              	.LVL194:
 2097 0014 FFF7FEFF 		bl	orientationCalcQuat_i
 2098              	.LVL195:
 2099              	.L109:
 2100              	.LBE153:
 2101              	.LBE154:
 610:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat *body_to_imu_quat = orientationGetQuat_i(&ahrs_icq.body_to_imu);
 611:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat ltp_to_body_quat;
 612:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_inv(&ltp_to_body_quat, &ahrs_icq.ltp_to_imu_quat, body_to_imu_quat);
 2102              		.loc 3 612 0
 2103 0018 1D49     		ldr	r1, .L110+4
 2104 001a 6846     		mov	r0, sp
 2105 001c 01F15402 		add	r2, r1, #84
 2106 0020 FFF7FEFF 		bl	int32_quat_comp_inv
 2107              	.LVL196:
 613:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 614:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing only the heading rotation from ltp to body */
 615:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_h_new;
 616:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qx = 0;
 2108              		.loc 3 616 0
 2109 0024 0025     		movs	r5, #0
 617:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qy = 0;
 618:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_SIN(q_h_new.qz, heading / 2);
 2110              		.loc 3 618 0
 2111 0026 0223     		movs	r3, #2
 2112 0028 96FBF3F6 		sdiv	r6, r6, r3
 2113              	.LVL197:
 2114 002c 3046     		mov	r0, r6
 616:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qy = 0;
 2115              		.loc 3 616 0
 2116 002e 0595     		str	r5, [sp, #20]
 617:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h_new.qy = 0;
 2117              		.loc 3 617 0
 2118 0030 0695     		str	r5, [sp, #24]
 2119              		.loc 3 618 0
 2120 0032 FFF7FEFF 		bl	pprz_itrig_sin
 2121              	.LVL198:
 2122 0036 0790     		str	r0, [sp, #28]
 619:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(q_h_new.qi, heading / 2);
 2123              		.loc 3 619 0
 2124 0038 3046     		mov	r0, r6
 2125 003a FFF7FEFF 		bl	pprz_itrig_cos
 2126              	.LVL199:
 620:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 621:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing current heading only */
 622:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_h;
 623:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(q_h, ltp_to_body_quat);
 2127              		.loc 3 623 0
 2128 003e 009B     		ldr	r3, [sp]
 619:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   PPRZ_ITRIG_COS(q_h_new.qi, heading / 2);
 2129              		.loc 3 619 0
 2130 0040 0490     		str	r0, [sp, #16]
 2131              		.loc 3 623 0
 2132 0042 0893     		str	r3, [sp, #32]
 624:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qx = 0;
 625:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qy = 0;
 626:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_normalize(&q_h);
 2133              		.loc 3 626 0
 2134 0044 08A8     		add	r0, sp, #32
 623:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qx = 0;
 2135              		.loc 3 623 0
 2136 0046 039B     		ldr	r3, [sp, #12]
 2137 0048 0B93     		str	r3, [sp, #44]
 624:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   q_h.qx = 0;
 2138              		.loc 3 624 0
 2139 004a 0995     		str	r5, [sp, #36]
 625:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_normalize(&q_h);
 2140              		.loc 3 625 0
 2141 004c 0A95     		str	r5, [sp, #40]
 2142              		.loc 3 626 0
 2143 004e FFF7FEFF 		bl	int32_quat_normalize
 2144              	.LVL200:
 627:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 628:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* quaternion representing rotation from current to new heading */
 629:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q_c;
 630:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_inv_comp_norm_shortest(&q_c, &q_h, &q_h_new);
 2145              		.loc 3 630 0
 2146 0052 0CA8     		add	r0, sp, #48
 2147 0054 08A9     		add	r1, sp, #32
 2148 0056 04AA     		add	r2, sp, #16
 2149 0058 FFF7FEFF 		bl	int32_quat_inv_comp_norm_shortest
 2150              	.LVL201:
 631:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 632:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* correct current heading in body frame */
 633:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   struct Int32Quat q;
 634:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp_norm_shortest(&q, &q_c, &ltp_to_body_quat);
 2151              		.loc 3 634 0
 2152 005c 10A8     		add	r0, sp, #64
 2153 005e 0CA9     		add	r1, sp, #48
 2154 0060 6A46     		mov	r2, sp
 2155 0062 FFF7FEFF 		bl	int32_quat_comp_norm_shortest
 2156              	.LVL202:
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2157              		.loc 3 635 0
 2158 0066 109B     		ldr	r3, [sp, #64]
 2159 0068 0093     		str	r3, [sp]
 636:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 637:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   /* compute ltp to imu rotations */
 638:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   int32_quat_comp(&ahrs_icq.ltp_to_imu_quat, &ltp_to_body_quat, body_to_imu_quat);
 2160              		.loc 3 638 0
 2161 006a 0948     		ldr	r0, .L110+4
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2162              		.loc 3 635 0
 2163 006c 119B     		ldr	r3, [sp, #68]
 2164 006e 0193     		str	r3, [sp, #4]
 2165 0070 129B     		ldr	r3, [sp, #72]
 2166 0072 0293     		str	r3, [sp, #8]
 2167              		.loc 3 638 0
 2168 0074 6946     		mov	r1, sp
 635:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   QUAT_COPY(ltp_to_body_quat, q);
 2169              		.loc 3 635 0
 2170 0076 139B     		ldr	r3, [sp, #76]
 2171 0078 0393     		str	r3, [sp, #12]
 2172              		.loc 3 638 0
 2173 007a 00F15402 		add	r2, r0, #84
 2174 007e FFF7FEFF 		bl	int32_quat_comp
 2175              	.LVL203:
 639:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 640:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq.heading_aligned = TRUE;
 2176              		.loc 3 640 0
 2177 0082 0123     		movs	r3, #1
 2178 0084 84F88130 		strb	r3, [r4, #129]
 641:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2179              		.loc 3 641 0
 2180 0088 14B0     		add	sp, sp, #80
 2181              		.cfi_def_cfa_offset 16
 2182              		@ sp needed
 2183 008a 70BD     		pop	{r4, r5, r6, pc}
 2184              	.L111:
 2185              		.align	2
 2186              	.L110:
 2187 008c 00000000 		.word	.LANCHOR0
 2188 0090 60000000 		.word	.LANCHOR0+96
 2189              		.cfi_endproc
 2190              	.LFE100:
 2192              		.section	.text.ahrs_icq_set_body_to_imu_quat,"ax",%progbits
 2193              		.align	1
 2194              		.global	ahrs_icq_set_body_to_imu_quat
 2195              		.thumb
 2196              		.thumb_func
 2198              	ahrs_icq_set_body_to_imu_quat:
 2199              	.LFB102:
 642:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 643:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_body_to_imu(struct OrientationReps *body_to_imu)
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 646:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 647:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 648:subsystems/ahrs/ahrs_int_cmpl_quat.c **** void ahrs_icq_set_body_to_imu_quat(struct FloatQuat *q_b2i)
 649:subsystems/ahrs/ahrs_int_cmpl_quat.c **** {
 2200              		.loc 3 649 0
 2201              		.cfi_startproc
 2202              		@ args = 0, pretend = 0, frame = 0
 2203              		@ frame_needed = 0, uses_anonymous_args = 0
 2204              	.LVL204:
 2205 0000 38B5     		push	{r3, r4, r5, lr}
 2206              		.cfi_def_cfa_offset 16
 2207              		.cfi_offset 3, -16
 2208              		.cfi_offset 4, -12
 2209              		.cfi_offset 5, -8
 2210              		.cfi_offset 14, -4
 2211              	.LBB161:
 2212              	.LBB162:
 167:./math/pprz_orientation_conversion.h ****   /* clear bits for all attitude representations and only set the new one */
 2213              		.loc 6 167 0
 2214 0002 0F4C     		ldr	r4, .L114
 2215 0004 0368     		ldr	r3, [r0]	@ float
 2216 0006 C4F8F430 		str	r3, [r4, #244]	@ float
 2217 000a 4368     		ldr	r3, [r0, #4]	@ float
 2218 000c C4F8F830 		str	r3, [r4, #248]	@ float
 2219 0010 8368     		ldr	r3, [r0, #8]	@ float
 2220 0012 C4F8FC30 		str	r3, [r4, #252]	@ float
 2221 0016 C368     		ldr	r3, [r0, #12]	@ float
 2222 0018 C4F80031 		str	r3, [r4, #256]	@ float
 169:./math/pprz_orientation_conversion.h **** }
 2223              		.loc 6 169 0
 2224 001c 0823     		movs	r3, #8
 2225 001e 84F8B030 		strb	r3, [r4, #176]
 2226              	.LBE162:
 2227              	.LBE161:
 650:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   orientationSetQuat_f(&ahrs_icq.body_to_imu, q_b2i);
 651:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 652:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   if (!ahrs_icq.is_aligned) {
 2228              		.loc 3 652 0
 2229 0022 94F83531 		ldrb	r3, [r4, #309]	@ zero_extendqisi2
 2230 0026 53B9     		cbnz	r3, .L112
 2231              	.LVL205:
 2232              	.LBB163:
 2233              	.LBB164:
 2234              	.LBB165:
 2235              	.LBB166:
 193:./math/pprz_orientation_conversion.h ****   }
 2236              		.loc 6 193 0
 2237 0028 04F1B000 		add	r0, r4, #176
 2238              	.LVL206:
 2239              	.LBE166:
 2240              	.LBE165:
 653:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     /* Set ltp_to_imu so that body is zero */
 654:subsystems/ahrs/ahrs_int_cmpl_quat.c ****     memcpy(&ahrs_icq.ltp_to_imu_quat, orientationGetQuat_i(&ahrs_icq.body_to_imu),
 2241              		.loc 3 654 0
 2242 002c 04F16005 		add	r5, r4, #96
 2243 0030 B434     		adds	r4, r4, #180
 2244              	.LBB168:
 2245              	.LBB167:
 193:./math/pprz_orientation_conversion.h ****   }
 2246              		.loc 6 193 0
 2247 0032 FFF7FEFF 		bl	orientationCalcQuat_i
 2248              	.LVL207:
 2249              	.LBE167:
 2250              	.LBE168:
 2251              		.loc 3 654 0
 2252 0036 94E80F00 		ldmia	r4, {r0, r1, r2, r3}
 2253 003a 85E80F00 		stmia	r5, {r0, r1, r2, r3}
 2254              	.LVL208:
 2255              	.L112:
 2256 003e 38BD     		pop	{r3, r4, r5, pc}
 2257              	.L115:
 2258              		.align	2
 2259              	.L114:
 2260 0040 00000000 		.word	.LANCHOR0
 2261              	.LBE164:
 2262              	.LBE163:
 2263              		.cfi_endproc
 2264              	.LFE102:
 2266              		.section	.text.ahrs_icq_set_body_to_imu,"ax",%progbits
 2267              		.align	1
 2268              		.global	ahrs_icq_set_body_to_imu
 2269              		.thumb
 2270              		.thumb_func
 2272              	ahrs_icq_set_body_to_imu:
 2273              	.LFB101:
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 2274              		.loc 3 644 0
 2275              		.cfi_startproc
 2276              		@ args = 0, pretend = 0, frame = 0
 2277              		@ frame_needed = 0, uses_anonymous_args = 0
 2278              	.LVL209:
 2279 0000 10B5     		push	{r4, lr}
 2280              		.cfi_def_cfa_offset 8
 2281              		.cfi_offset 4, -8
 2282              		.cfi_offset 14, -4
 2283              	.LBB171:
 2284              	.LBB172:
 203:./math/pprz_orientation_conversion.h ****   }
 204:./math/pprz_orientation_conversion.h ****   return &orientation->rmat_i;
 205:./math/pprz_orientation_conversion.h **** }
 206:./math/pprz_orientation_conversion.h **** 
 207:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude euler angles (int).
 208:./math/pprz_orientation_conversion.h **** static inline struct Int32Eulers *orientationGetEulers_i(struct OrientationReps *orientation)
 209:./math/pprz_orientation_conversion.h **** {
 210:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_EULER_I)) {
 211:./math/pprz_orientation_conversion.h ****     orientationCalcEulers_i(orientation);
 212:./math/pprz_orientation_conversion.h ****   }
 213:./math/pprz_orientation_conversion.h ****   return &orientation->eulers_i;
 214:./math/pprz_orientation_conversion.h **** }
 215:./math/pprz_orientation_conversion.h **** 
 216:./math/pprz_orientation_conversion.h **** /// Get vehicle body attitude quaternion (float).
 217:./math/pprz_orientation_conversion.h **** static inline struct FloatQuat *orientationGetQuat_f(struct OrientationReps *orientation)
 218:./math/pprz_orientation_conversion.h **** {
 219:./math/pprz_orientation_conversion.h ****   if (!bit_is_set(orientation->status, ORREP_QUAT_F)) {
 2285              		.loc 6 219 0
 2286 0002 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 2287 0004 1B07     		lsls	r3, r3, #28
 2288              	.LBE172:
 2289              	.LBE171:
 644:subsystems/ahrs/ahrs_int_cmpl_quat.c ****   ahrs_icq_set_body_to_imu_quat(orientationGetQuat_f(body_to_imu));
 2290              		.loc 3 644 0
 2291 0006 0446     		mov	r4, r0
 2292              	.LBB174:
 2293              	.LBB173:
 2294              		.loc 6 219 0
 2295 0008 01D4     		bmi	.L117
 220:./math/pprz_orientation_conversion.h ****     orientationCalcQuat_f(orientation);
 2296              		.loc 6 220 0
 2297 000a FFF7FEFF 		bl	orientationCalcQuat_f
 2298              	.LVL210:
 2299              	.L117:
 2300              	.LBE173:
 2301              	.LBE174:
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2302              		.loc 3 645 0
 2303 000e 04F14400 		add	r0, r4, #68
 646:subsystems/ahrs/ahrs_int_cmpl_quat.c **** 
 2304              		.loc 3 646 0
 2305 0012 BDE81040 		pop	{r4, lr}
 2306              		.cfi_restore 14
 2307              		.cfi_restore 4
 2308              		.cfi_def_cfa_offset 0
 2309              	.LVL211:
 645:subsystems/ahrs/ahrs_int_cmpl_quat.c **** }
 2310              		.loc 3 645 0
 2311 0016 FFF7FEBF 		b	ahrs_icq_set_body_to_imu_quat
 2312              	.LVL212:
 2313              		.cfi_endproc
 2314              	.LFE101:
 2316              		.global	ahrs_icq
 2317              		.section	.bss.ahrs_icq,"aw",%nobits
 2318              		.align	3
 2319              		.set	.LANCHOR0,. + 0
 2322              	ahrs_icq:
 2323 0000 00000000 		.space	312
 2323      00000000 
 2323      00000000 
 2323      00000000 
 2323      00000000 
 2324              		.section	.bss.filtered_gravity_measurement.7051,"aw",%nobits
 2325              		.align	2
 2326              		.set	.LANCHOR1,. + 0
 2329              	filtered_gravity_measurement.7051:
 2330 0000 00000000 		.space	12
 2330      00000000 
 2330      00000000 
 2331              		.text
 2332              	.Letext0:
 2333              		.file 7 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2334              		.file 8 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2335              		.file 9 "/home/dino/paparazzi/sw/include/std.h"
 2336              		.file 10 "./math/pprz_geodetic_int.h"
 2337              		.file 11 "./mcu_periph/sys_time.h"
 2338              		.file 12 "./mcu_periph/link_device.h"
 2339              		.file 13 "./mcu_periph/uart.h"
 2340              		.file 14 "./subsystems/gps/gps_ubx.h"
 2341              		.file 15 "./subsystems/gps.h"
 2342              		.file 16 "./subsystems/ahrs/ahrs_int_cmpl_quat.h"
 2343              		.file 17 "/usr/arm-none-eabi/include/math.h"
 2344              		.file 18 "./math/pprz_trig_int.h"
 2345              		.file 19 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ahrs_int_cmpl_quat.c
     /tmp/ccDHHo0T.s:20     .text.float_quat_normalize:00000000 $t
     /tmp/ccDHHo0T.s:24     .text.float_quat_normalize:00000000 float_quat_normalize
     /tmp/ccDHHo0T.s:100    .text.float_quat_normalize:00000070 $d
     /tmp/ccDHHo0T.s:105    .text.int32_quat_normalize:00000000 $t
     /tmp/ccDHHo0T.s:109    .text.int32_quat_normalize:00000000 int32_quat_normalize
     /tmp/ccDHHo0T.s:194    .text.ahrs_icq_align:00000000 $t
     /tmp/ccDHHo0T.s:199    .text.ahrs_icq_align:00000000 ahrs_icq_align
     /tmp/ccDHHo0T.s:701    .text.ahrs_icq_align:000002b0 $d
     /tmp/ccDHHo0T.s:721    .text.ahrs_icq_propagate:00000000 $t
     /tmp/ccDHHo0T.s:726    .text.ahrs_icq_propagate:00000000 ahrs_icq_propagate
     /tmp/ccDHHo0T.s:820    .text.ahrs_icq_propagate:00000080 $d
     /tmp/ccDHHo0T.s:826    .text.ahrs_icq_set_accel_gains:00000000 $t
     /tmp/ccDHHo0T.s:831    .text.ahrs_icq_set_accel_gains:00000000 ahrs_icq_set_accel_gains
     /tmp/ccDHHo0T.s:893    .text.ahrs_icq_set_accel_gains:00000060 $d
     /tmp/ccDHHo0T.s:903    .text.ahrs_icq_update_accel:00000000 $t
     /tmp/ccDHHo0T.s:908    .text.ahrs_icq_update_accel:00000000 ahrs_icq_update_accel
     /tmp/ccDHHo0T.s:1348   .text.ahrs_icq_update_accel:000002b0 $d
     /tmp/ccDHHo0T.s:1363   .text.ahrs_icq_update_mag:00000000 $t
     /tmp/ccDHHo0T.s:1368   .text.ahrs_icq_update_mag:00000000 ahrs_icq_update_mag
     /tmp/ccDHHo0T.s:1628   .text.ahrs_icq_update_mag:00000154 $d
     /tmp/ccDHHo0T.s:1635   .text.ahrs_icq_set_mag_gains:00000000 $t
     /tmp/ccDHHo0T.s:1640   .text.ahrs_icq_set_mag_gains:00000000 ahrs_icq_set_mag_gains
     /tmp/ccDHHo0T.s:1663   .text.ahrs_icq_set_mag_gains:00000020 $d
     /tmp/ccDHHo0T.s:1668   .text.ahrs_icq_init:00000000 $t
     /tmp/ccDHHo0T.s:1673   .text.ahrs_icq_init:00000000 ahrs_icq_init
     /tmp/ccDHHo0T.s:1782   .text.ahrs_icq_init:0000008c $d
     /tmp/ccDHHo0T.s:1790   .text.ahrs_icq_update_gps:00000000 $t
     /tmp/ccDHHo0T.s:1795   .text.ahrs_icq_update_gps:00000000 ahrs_icq_update_gps
     /tmp/ccDHHo0T.s:1842   .text.ahrs_icq_update_gps:00000038 $d
     /tmp/ccDHHo0T.s:1849   .text.ahrs_icq_update_heading:00000000 $t
     /tmp/ccDHHo0T.s:1854   .text.ahrs_icq_update_heading:00000000 ahrs_icq_update_heading
     /tmp/ccDHHo0T.s:2053   .text.ahrs_icq_update_heading:00000124 $d
     /tmp/ccDHHo0T.s:2059   .text.ahrs_icq_realign_heading:00000000 $t
     /tmp/ccDHHo0T.s:2064   .text.ahrs_icq_realign_heading:00000000 ahrs_icq_realign_heading
     /tmp/ccDHHo0T.s:2187   .text.ahrs_icq_realign_heading:0000008c $d
     /tmp/ccDHHo0T.s:2193   .text.ahrs_icq_set_body_to_imu_quat:00000000 $t
     /tmp/ccDHHo0T.s:2198   .text.ahrs_icq_set_body_to_imu_quat:00000000 ahrs_icq_set_body_to_imu_quat
     /tmp/ccDHHo0T.s:2260   .text.ahrs_icq_set_body_to_imu_quat:00000040 $d
     /tmp/ccDHHo0T.s:2267   .text.ahrs_icq_set_body_to_imu:00000000 $t
     /tmp/ccDHHo0T.s:2272   .text.ahrs_icq_set_body_to_imu:00000000 ahrs_icq_set_body_to_imu
     /tmp/ccDHHo0T.s:2322   .bss.ahrs_icq:00000000 ahrs_icq
     /tmp/ccDHHo0T.s:2318   .bss.ahrs_icq:00000000 $d
     /tmp/ccDHHo0T.s:2325   .bss.filtered_gravity_measurement.7051:00000000 $d
     /tmp/ccDHHo0T.s:2329   .bss.filtered_gravity_measurement.7051:00000000 filtered_gravity_measurement.7051
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.7f506cdee5614e5fae524d20989ad8c8
                           .group:00000000 wm4.airframe.h.5.55ffe79377b235d0a97162ed16ec170d
                           .group:00000000 wm4.apogee_1.0.h.2.34ab7bb688056eecb54e2e3ffff48ca6
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._intsup.h.10.b2832a532eae49c14d45880be6d4ca65
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.23.a096771aacee9aba4b33c2d04aacc9b1
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4._ansi.h.13.1b5575dc7921a4c0cff7dbaa2f33e670
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.ad242c9287d2217c7d2035216e5d04ca
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.actuators_pwm_arch.h.34.947e403155c6b98639745356c5a88c13
                           .group:00000000 wm4.airframe.h.14.814d9a421a57ec2d434c7b6efc262c4b
                           .group:00000000 wm4.pprz_geodetic.h.35.f7fdb5d11659b92d11c7ce67b6317005
                           .group:00000000 wm4.float.h.29.1cf88a0527b6b1225d49fbee2b32acb7
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.pprz_algebra.h.47.d249264ea6bacf2198e290d461cf6dbe
                           .group:00000000 wm4.pprz_trig_int.h.28.b756be608c9d9f3092a41321446e5fa2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.54.cd3744e0b066087ec8fbb1bdc22d1043
                           .group:00000000 wm4.pprz_algebra_int.h.68.04ac162ae1e1d94f716d0bb402062624
                           .group:00000000 wm4.pprz_geodetic_int.h.127.8e737bed5ba4468e470311184b1fca7f
                           .group:00000000 wm4.sys_time.h.31.454ffebb4f6baf6e87ab8a60104a5808
                           .group:00000000 wm4.common.h.21.22efaac882611267214d0a36f6f15e74
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.systick.h.44.34e759e1f218a187b07e9a617cb1d556
                           .group:00000000 wm4.sys_time.h.213.4ee43452c5934214134db56488f53299
                           .group:00000000 wm4.uart_arch.h.30.cb8e70feae0b6afe250750f6c1439671
                           .group:00000000 wm4.uart.h.35.4345324d45fae43faace58e743d48e42
                           .group:00000000 wm4.gps_ubx.h.36.d4183b0b154441c99ce352aae50967b5
                           .group:00000000 wm4.gps.h.41.79d1c69e44dd427f855100ff8e932fbe
                           .group:00000000 wm4.pprz_algebra_float.h.98.bb035bcbfa66bb186e7ea81143fd64bc
                           .group:00000000 wm4.pprz_orientation_conversion.h.69.5cce798fefad8bb761767fd414e61db5

UNDEFINED SYMBOLS
sqrtf
int32_sqrt
__aeabi_f2d
__aeabi_dsub
__aeabi_dcmplt
__aeabi_dcmpgt
__aeabi_dmul
__aeabi_dadd
__aeabi_d2f
float_rmat_of_quat
float_rmat_transp_vmult
float_quat_comp_norm_shortest
__aeabi_ddiv
__aeabi_d2iz
int32_quat_integrate_fi
__aeabi_i2d
int32_rmat_of_quat
orientationCalcRMat_i
int32_rmat_transp_ratemult
int32_rmat_vmult
int32_rmat_transp_vmult
orientationCalcQuat_i
int32_quat_comp_inv
pprz_itrig_cos
pprz_itrig_sin
int32_quat_inv_comp_norm_shortest
int32_quat_comp_norm_shortest
int32_quat_comp
orientationCalcQuat_f
