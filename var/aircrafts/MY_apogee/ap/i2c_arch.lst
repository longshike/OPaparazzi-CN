   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"i2c_arch.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.i2c_error,"ax",%progbits
  20              		.align	1
  21              		.thumb
  22              		.thumb_func
  24              	i2c_error:
  25              	.LFB14:
  26              		.file 1 "arch/stm32/mcu_periph/i2c_arch.c"
   1:arch/stm32/mcu_periph/i2c_arch.c **** /*
   2:arch/stm32/mcu_periph/i2c_arch.c ****  * Copyright (C) 2009-2012 The Paparazzi Team
   3:arch/stm32/mcu_periph/i2c_arch.c ****  *
   4:arch/stm32/mcu_periph/i2c_arch.c ****  * This file is part of paparazzi.
   5:arch/stm32/mcu_periph/i2c_arch.c ****  *
   6:arch/stm32/mcu_periph/i2c_arch.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:arch/stm32/mcu_periph/i2c_arch.c ****  * it under the terms of the GNU General Public License as published by
   8:arch/stm32/mcu_periph/i2c_arch.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:arch/stm32/mcu_periph/i2c_arch.c ****  * any later version.
  10:arch/stm32/mcu_periph/i2c_arch.c ****  *
  11:arch/stm32/mcu_periph/i2c_arch.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:arch/stm32/mcu_periph/i2c_arch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:arch/stm32/mcu_periph/i2c_arch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:arch/stm32/mcu_periph/i2c_arch.c ****  * GNU General Public License for more details.
  15:arch/stm32/mcu_periph/i2c_arch.c ****  *
  16:arch/stm32/mcu_periph/i2c_arch.c ****  * You should have received a copy of the GNU General Public License
  17:arch/stm32/mcu_periph/i2c_arch.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:arch/stm32/mcu_periph/i2c_arch.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:arch/stm32/mcu_periph/i2c_arch.c ****  * Boston, MA 02111-1307, USA.
  20:arch/stm32/mcu_periph/i2c_arch.c ****  *
  21:arch/stm32/mcu_periph/i2c_arch.c ****  */
  22:arch/stm32/mcu_periph/i2c_arch.c **** 
  23:arch/stm32/mcu_periph/i2c_arch.c **** /**
  24:arch/stm32/mcu_periph/i2c_arch.c ****  * @file arch/stm32/mcu_periph/i2c_arch.c
  25:arch/stm32/mcu_periph/i2c_arch.c ****  * @ingroup stm32_arch
  26:arch/stm32/mcu_periph/i2c_arch.c ****  * Handling of I2C hardware for STM32.
  27:arch/stm32/mcu_periph/i2c_arch.c ****  */
  28:arch/stm32/mcu_periph/i2c_arch.c **** 
  29:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/i2c.h"
  30:arch/stm32/mcu_periph/i2c_arch.c **** 
  31:arch/stm32/mcu_periph/i2c_arch.c **** #include BOARD_CONFIG
  32:arch/stm32/mcu_periph/i2c_arch.c **** 
  33:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/stm32/rcc.h>
  34:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/stm32/gpio.h>
  35:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/cm3/nvic.h>
  36:arch/stm32/mcu_periph/i2c_arch.c **** #include <libopencm3/cm3/scb.h>
  37:arch/stm32/mcu_periph/i2c_arch.c **** 
  38:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/gpio.h"
  39:arch/stm32/mcu_periph/i2c_arch.c **** 
  40:arch/stm32/mcu_periph/i2c_arch.c **** 
  41:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
  42:arch/stm32/mcu_periph/i2c_arch.c **** #include "i2c_debug_led.h"
  43:arch/stm32/mcu_periph/i2c_arch.c **** #endif // I2C_DEBUG_LED
  44:arch/stm32/mcu_periph/i2c_arch.c **** 
  45:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////////////////////////////////////
  46:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////////////////////////////////////
  47:arch/stm32/mcu_periph/i2c_arch.c **** 
  48:arch/stm32/mcu_periph/i2c_arch.c **** 
  49:arch/stm32/mcu_periph/i2c_arch.c **** // Error bit mask
  50:arch/stm32/mcu_periph/i2c_arch.c **** // XXX: consider moving this define into libopencm3
  51:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C_SR1_ERR_MASK (I2C_SR1_SMBALERT | \
  52:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_TIMEOUT |  \
  53:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_PECERR |   \
  54:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_OVR |      \
  55:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_AF |       \
  56:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_ARLO |     \
  57:arch/stm32/mcu_periph/i2c_arch.c ****                           I2C_SR1_BERR)
  58:arch/stm32/mcu_periph/i2c_arch.c **** 
  59:arch/stm32/mcu_periph/i2c_arch.c **** // Bit Control
  60:arch/stm32/mcu_periph/i2c_arch.c **** 
  61:arch/stm32/mcu_periph/i2c_arch.c **** #define BIT_X_IS_SET_IN_REG(X,REG)  (((REG) & (X)) == (X))
  62:arch/stm32/mcu_periph/i2c_arch.c **** 
  63:arch/stm32/mcu_periph/i2c_arch.c **** // disable and enable irq functions are not implemented in libopencm3 defining them here
  64:arch/stm32/mcu_periph/i2c_arch.c **** // XXX: consider moving this definitions into libopencm3
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __disable_irq(void)  { asm volatile("cpsid i"); }
  66:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
  67:arch/stm32/mcu_periph/i2c_arch.c **** 
  68:arch/stm32/mcu_periph/i2c_arch.c **** // Critical Zones
  69:arch/stm32/mcu_periph/i2c_arch.c **** 
  70:arch/stm32/mcu_periph/i2c_arch.c **** #define __I2C_REG_CRITICAL_ZONE_START __disable_irq();
  71:arch/stm32/mcu_periph/i2c_arch.c **** #define __I2C_REG_CRITICAL_ZONE_STOP  __enable_irq();
  72:arch/stm32/mcu_periph/i2c_arch.c **** 
  73:arch/stm32/mcu_periph/i2c_arch.c **** 
  74:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef NVIC_I2C_IRQ_PRIO
  75:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C1_IRQ_PRIO 0
  76:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C2_IRQ_PRIO 0
  77:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C3_IRQ_PRIO 0
  78:arch/stm32/mcu_periph/i2c_arch.c **** #else
  79:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C1_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  80:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C2_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  81:arch/stm32/mcu_periph/i2c_arch.c **** #define NVIC_I2C3_IRQ_PRIO NVIC_I2C_IRQ_PRIO
  82:arch/stm32/mcu_periph/i2c_arch.c **** #endif
  83:arch/stm32/mcu_periph/i2c_arch.c **** 
  84:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1 || USE_I2C2 || USE_I2C3
  85:arch/stm32/mcu_periph/i2c_arch.c **** #if defined(STM32F1)
  86:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_setup_gpio(uint32_t i2c)
  87:arch/stm32/mcu_periph/i2c_arch.c **** {
  88:arch/stm32/mcu_periph/i2c_arch.c ****   switch (i2c) {
  89:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
  90:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C1:
  91:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C1_GPIO_PORT);
  92:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_mode(I2C1_GPIO_PORT, GPIO_MODE_OUTPUT_2_MHZ,
  93:arch/stm32/mcu_periph/i2c_arch.c ****                     GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN,
  94:arch/stm32/mcu_periph/i2c_arch.c ****                     I2C1_GPIO_SCL | I2C1_GPIO_SDA);
  95:arch/stm32/mcu_periph/i2c_arch.c ****       break;
  96:arch/stm32/mcu_periph/i2c_arch.c **** #endif
  97:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
  98:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C2:
  99:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C2_GPIO_PORT);
 100:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_mode(I2C2_GPIO_PORT, GPIO_MODE_OUTPUT_2_MHZ,
 101:arch/stm32/mcu_periph/i2c_arch.c ****                     GPIO_CNF_OUTPUT_ALTFN_OPENDRAIN,
 102:arch/stm32/mcu_periph/i2c_arch.c ****                     I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 103:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 104:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 105:arch/stm32/mcu_periph/i2c_arch.c ****     default:
 106:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 107:arch/stm32/mcu_periph/i2c_arch.c ****   }
 108:arch/stm32/mcu_periph/i2c_arch.c **** }
 109:arch/stm32/mcu_periph/i2c_arch.c **** 
 110:arch/stm32/mcu_periph/i2c_arch.c **** #elif defined(STM32F4)
 111:arch/stm32/mcu_periph/i2c_arch.c **** 
 112:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_setup_gpio(uint32_t i2c)
 113:arch/stm32/mcu_periph/i2c_arch.c **** {
 114:arch/stm32/mcu_periph/i2c_arch.c ****   switch (i2c) {
 115:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 116:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C1:
 117:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C1_GPIO_PORT);
 118:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C1_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 119:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 120:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(GPIOB, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 121:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 122:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C1_GPIO_PORT, GPIO_AF4, I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 123:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 124:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 125:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
 126:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C2:
 127:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C2_GPIO_PORT);
 128:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C2_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 129:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 130:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C2_GPIO_PORT, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 131:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 132:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C2_GPIO_PORT, GPIO_AF4,
 133:arch/stm32/mcu_periph/i2c_arch.c ****                   I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 134:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 135:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 136:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
 137:arch/stm32/mcu_periph/i2c_arch.c ****     case I2C3:
 138:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C3_GPIO_PORT_SCL);
 139:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C3_GPIO_PORT_SCL, GPIO_MODE_AF, GPIO_PUPD_NONE, I2C3_GPIO_SCL);
 140:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C3_GPIO_PORT_SCL, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 141:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C3_GPIO_SCL);
 142:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C3_GPIO_PORT_SCL, GPIO_AF4, I2C3_GPIO_SCL);
 143:arch/stm32/mcu_periph/i2c_arch.c **** 
 144:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_enable_clock(I2C3_GPIO_PORT_SDA);
 145:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C3_GPIO_PORT_SDA, GPIO_MODE_AF, GPIO_PUPD_NONE, I2C3_GPIO_SDA);
 146:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_output_options(I2C3_GPIO_PORT_SDA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ,
 147:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C3_GPIO_SDA);
 148:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_set_af(I2C3_GPIO_PORT_SDA, GPIO_AF4, I2C3_GPIO_SDA);
 149:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 150:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 151:arch/stm32/mcu_periph/i2c_arch.c ****     default:
 152:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 153:arch/stm32/mcu_periph/i2c_arch.c ****   }
 154:arch/stm32/mcu_periph/i2c_arch.c **** }
 155:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 156:arch/stm32/mcu_periph/i2c_arch.c **** #endif // USE_I2Cx
 157:arch/stm32/mcu_periph/i2c_arch.c **** 
 158:arch/stm32/mcu_periph/i2c_arch.c **** static inline void PPRZ_I2C_SEND_STOP(uint32_t i2c)
 159:arch/stm32/mcu_periph/i2c_arch.c **** {
 160:arch/stm32/mcu_periph/i2c_arch.c ****   // Man: p722:  Stop generation after the current byte transfer or after the current Start conditi
 161:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_stop(i2c);
 162:arch/stm32/mcu_periph/i2c_arch.c **** 
 163:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 164:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_ON();
 165:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 166:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 167:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_OFF();
 168:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 169:arch/stm32/mcu_periph/i2c_arch.c **** }
 170:arch/stm32/mcu_periph/i2c_arch.c **** 
 171:arch/stm32/mcu_periph/i2c_arch.c **** // (RE)START
 172:arch/stm32/mcu_periph/i2c_arch.c **** 
 173:arch/stm32/mcu_periph/i2c_arch.c **** static inline void PPRZ_I2C_SEND_START(struct i2c_periph *periph)
 174:arch/stm32/mcu_periph/i2c_arch.c **** {
 175:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 176:arch/stm32/mcu_periph/i2c_arch.c **** 
 177:arch/stm32/mcu_periph/i2c_arch.c ****   // Reset the buffer pointer to the first byte
 178:arch/stm32/mcu_periph/i2c_arch.c ****   periph->idx_buf = 0;
 179:arch/stm32/mcu_periph/i2c_arch.c **** 
 180:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 181:arch/stm32/mcu_periph/i2c_arch.c ****   LED_SHOW_ACTIVE_BITS(regs);
 182:arch/stm32/mcu_periph/i2c_arch.c **** 
 183:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_ON();
 184:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 185:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 186:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 187:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 188:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 189:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 190:arch/stm32/mcu_periph/i2c_arch.c ****   LED2_OFF();
 191:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 192:arch/stm32/mcu_periph/i2c_arch.c **** 
 193:arch/stm32/mcu_periph/i2c_arch.c ****   // Enable Error IRQ, Event IRQ but disable Buffer IRQ
 194:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 195:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 196:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 197:arch/stm32/mcu_periph/i2c_arch.c **** 
 198:arch/stm32/mcu_periph/i2c_arch.c ****   // Issue a new start
 199:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_nack_current(i2c);
 200:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_ack(i2c);
 201:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_clear_stop(i2c);
 202:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(i2c);
 203:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_start(i2c);
 204:arch/stm32/mcu_periph/i2c_arch.c ****   periph->status = I2CStartRequested;
 205:arch/stm32/mcu_periph/i2c_arch.c **** 
 206:arch/stm32/mcu_periph/i2c_arch.c **** }
 207:arch/stm32/mcu_periph/i2c_arch.c **** 
 208:arch/stm32/mcu_periph/i2c_arch.c **** // STOP
 209:arch/stm32/mcu_periph/i2c_arch.c **** 
 210:arch/stm32/mcu_periph/i2c_arch.c **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 211:arch/stm32/mcu_periph/i2c_arch.c **** ///////////////////////////////////////////////////////////////////////////////////////////////////
 212:arch/stm32/mcu_periph/i2c_arch.c **** //
 213:arch/stm32/mcu_periph/i2c_arch.c **** //  SUBTRANSACTION SEQUENCES
 214:arch/stm32/mcu_periph/i2c_arch.c **** //  -We arrive here every time a ISR is called with no error
 215:arch/stm32/mcu_periph/i2c_arch.c **** 
 216:arch/stm32/mcu_periph/i2c_arch.c **** enum STMI2CSubTransactionStatus {
 217:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Busy,
 218:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Ready_StopRequested,
 219:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Ready,
 220:arch/stm32/mcu_periph/i2c_arch.c ****   STMI2C_SubTra_Error
 221:arch/stm32/mcu_periph/i2c_arch.c **** };
 222:arch/stm32/mcu_periph/i2c_arch.c **** 
 223:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 710/1072
 224:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Transmitter
 225:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_send(uint32_t i2c, struct i2c_periph *periph,
 226:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 227:arch/stm32/mcu_periph/i2c_arch.c **** {
 228:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 229:arch/stm32/mcu_periph/i2c_arch.c **** 
 230:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 231:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 232:arch/stm32/mcu_periph/i2c_arch.c ****     // Disable buffer interrupt
 233:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 234:arch/stm32/mcu_periph/i2c_arch.c ****     // Send Slave address and wait for ADDR interrupt
 235:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr);
 236:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 237:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrWrSent;
 238:arch/stm32/mcu_periph/i2c_arch.c ****   }
 239:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 240:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 241:arch/stm32/mcu_periph/i2c_arch.c ****     // Now read SR2 to clear the ADDR status Bit
 242:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2  __attribute__((unused)) = I2C_SR2(i2c);
 243:arch/stm32/mcu_periph/i2c_arch.c **** 
 244:arch/stm32/mcu_periph/i2c_arch.c ****     // Maybe check we are transmitting (did not loose arbitration for instance)
 245:arch/stm32/mcu_periph/i2c_arch.c ****     // if (! BIT_X_IS_SET_IN_REG(I2C_SR2_TRA, SR2)) { }
 246:arch/stm32/mcu_periph/i2c_arch.c ****     // update: this should be caught by the ARLO error: so we will not arrive here
 247:arch/stm32/mcu_periph/i2c_arch.c **** 
 248:arch/stm32/mcu_periph/i2c_arch.c ****     // Send First max 2 bytes
 249:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[0]);
 250:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->len_w > 1) {
 251:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, trans->buf[1]);
 252:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 2;
 253:arch/stm32/mcu_periph/i2c_arch.c ****     } else {
 254:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 1;
 255:arch/stm32/mcu_periph/i2c_arch.c ****     }
 256:arch/stm32/mcu_periph/i2c_arch.c **** 
 257:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable buffer-space available interrupt
 258:arch/stm32/mcu_periph/i2c_arch.c ****     // only if there is more to send: wait for TXE, no more to send: wait for BTF
 259:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < trans->len_w) {
 260:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 261:arch/stm32/mcu_periph/i2c_arch.c ****     }
 262:arch/stm32/mcu_periph/i2c_arch.c **** 
 263:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 264:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CSendingByte;
 265:arch/stm32/mcu_periph/i2c_arch.c ****   }
 266:arch/stm32/mcu_periph/i2c_arch.c ****   // The buffer is not full anymore AND we were not waiting for BTF
 267:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_TxE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR2
 268:arch/stm32/mcu_periph/i2c_arch.c ****     // Send the next byte
 269:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->buf[periph->idx_buf]);
 270:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf++;
 271:arch/stm32/mcu_periph/i2c_arch.c **** 
 272:arch/stm32/mcu_periph/i2c_arch.c ****     // All bytes Sent? Then wait for BTF instead
 273:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf >= trans->len_w) {
 274:arch/stm32/mcu_periph/i2c_arch.c ****       // Not interested anymore to know the buffer has space left
 275:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 276:arch/stm32/mcu_periph/i2c_arch.c ****       // Next interrupt will be BTF (or error)
 277:arch/stm32/mcu_periph/i2c_arch.c ****     }
 278:arch/stm32/mcu_periph/i2c_arch.c ****   }
 279:arch/stm32/mcu_periph/i2c_arch.c ****   // BTF: means last byte was sent
 280:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 281:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTx) {
 282:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell the driver we are ready
 283:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 284:arch/stm32/mcu_periph/i2c_arch.c ****     }
 285:arch/stm32/mcu_periph/i2c_arch.c ****     // Otherwise we still need to do the receiving part
 286:arch/stm32/mcu_periph/i2c_arch.c **** 
 287:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready;
 288:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 289:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 290:arch/stm32/mcu_periph/i2c_arch.c ****   }
 291:arch/stm32/mcu_periph/i2c_arch.c **** 
 292:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 293:arch/stm32/mcu_periph/i2c_arch.c **** }
 294:arch/stm32/mcu_periph/i2c_arch.c **** 
 295:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 714/1072
 296:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N=1
 297:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_read1(uint32_t i2c, struct i2c_periph *periph,
 298:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 299:arch/stm32/mcu_periph/i2c_arch.c **** {
 300:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 301:arch/stm32/mcu_periph/i2c_arch.c **** 
 302:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 303:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 304:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 305:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 306:arch/stm32/mcu_periph/i2c_arch.c **** 
 307:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 308:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 309:arch/stm32/mcu_periph/i2c_arch.c ****   }
 310:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 311:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 312:arch/stm32/mcu_periph/i2c_arch.c ****     // First Clear the ACK bit: after the next byte we do not want new bytes
 313:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 314:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 315:arch/stm32/mcu_periph/i2c_arch.c **** 
 316:arch/stm32/mcu_periph/i2c_arch.c ****     // --- next to steps MUST be executed together to avoid missing the stop
 317:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 318:arch/stm32/mcu_periph/i2c_arch.c **** 
 319:arch/stm32/mcu_periph/i2c_arch.c ****     // Only after setting ACK, read SR2 to clear the ADDR (next byte will start arriving)
 320:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 321:arch/stm32/mcu_periph/i2c_arch.c **** 
 322:arch/stm32/mcu_periph/i2c_arch.c ****     // Schedule a Stop
 323:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 324:arch/stm32/mcu_periph/i2c_arch.c **** 
 325:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 326:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 327:arch/stm32/mcu_periph/i2c_arch.c **** 
 328:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable the RXNE: it will trigger as soon as the 1 byte is received to get the result
 329:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 330:arch/stm32/mcu_periph/i2c_arch.c **** 
 331:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 332:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingLastByte;
 333:arch/stm32/mcu_periph/i2c_arch.c ****   }
 334:arch/stm32/mcu_periph/i2c_arch.c ****   // As soon as there is 1 byte ready to read, we have our byte
 335:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) {
 336:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 337:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 338:arch/stm32/mcu_periph/i2c_arch.c **** 
 339:arch/stm32/mcu_periph/i2c_arch.c ****     // We got all the results (stop condition might still be in progress but this is the last inter
 340:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 341:arch/stm32/mcu_periph/i2c_arch.c **** 
 342:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status:
 343:arch/stm32/mcu_periph/i2c_arch.c ****     // -the stop was actually already requested in the previous step
 344:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 345:arch/stm32/mcu_periph/i2c_arch.c **** 
 346:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready_StopRequested;
 347:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 348:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 349:arch/stm32/mcu_periph/i2c_arch.c ****   }
 350:arch/stm32/mcu_periph/i2c_arch.c **** 
 351:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 352:arch/stm32/mcu_periph/i2c_arch.c **** }
 353:arch/stm32/mcu_periph/i2c_arch.c **** 
 354:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 713/1072
 355:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N=2
 356:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_read2(uint32_t i2c, struct i2c_periph *periph,
 357:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 358:arch/stm32/mcu_periph/i2c_arch.c **** {
 359:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 360:arch/stm32/mcu_periph/i2c_arch.c **** 
 361:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 362:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 363:arch/stm32/mcu_periph/i2c_arch.c ****     // according to the datasheet: instantly shedule a NAK on the second received byte:
 364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 365:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 366:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_next(i2c);
 367:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 368:arch/stm32/mcu_periph/i2c_arch.c **** 
 369:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 370:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 371:arch/stm32/mcu_periph/i2c_arch.c ****   }
 372:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 373:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 374:arch/stm32/mcu_periph/i2c_arch.c ****     // --- make absolutely sure this command is not delayed too much after the previous:
 375:arch/stm32/mcu_periph/i2c_arch.c ****     // --- the NAK bits must be set before the first byte arrived: allow other interrupts here
 376:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 377:arch/stm32/mcu_periph/i2c_arch.c **** 
 378:arch/stm32/mcu_periph/i2c_arch.c ****     //       if transfer of DR was finished already then we will get too many bytes
 379:arch/stm32/mcu_periph/i2c_arch.c ****     // BEFORE clearing ACK, read SR2 to clear the ADDR (next byte will start arriving)
 380:arch/stm32/mcu_periph/i2c_arch.c ****     // clearing ACK after the byte transfer has already started will NACK the next (2nd)
 381:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 382:arch/stm32/mcu_periph/i2c_arch.c **** 
 383:arch/stm32/mcu_periph/i2c_arch.c ****     // NOT First Clear the ACK bit but only AFTER clearing ADDR
 384:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 385:arch/stm32/mcu_periph/i2c_arch.c **** 
 386:arch/stm32/mcu_periph/i2c_arch.c ****     // Disable the RXNE and wait for BTF
 387:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 388:arch/stm32/mcu_periph/i2c_arch.c **** 
 389:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 390:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 391:arch/stm32/mcu_periph/i2c_arch.c **** 
 392:arch/stm32/mcu_periph/i2c_arch.c ****     // We do not set the RxE but wait for both bytes to arrive using BTF
 393:arch/stm32/mcu_periph/i2c_arch.c **** 
 394:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 395:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 396:arch/stm32/mcu_periph/i2c_arch.c ****   }
 397:arch/stm32/mcu_periph/i2c_arch.c ****   // Receive buffer if full, master is halted: BTF
 398:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 399:arch/stm32/mcu_periph/i2c_arch.c ****     // Stop condition MUST be set BEFORE reading the DR
 400:arch/stm32/mcu_periph/i2c_arch.c ****     // otherwise since there is new buffer space a new byte will be read
 401:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 402:arch/stm32/mcu_periph/i2c_arch.c **** 
 403:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 404:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 405:arch/stm32/mcu_periph/i2c_arch.c **** 
 406:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 407:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[1] = I2C_DR(i2c);
 408:arch/stm32/mcu_periph/i2c_arch.c **** 
 409:arch/stm32/mcu_periph/i2c_arch.c ****     // We got all the results
 410:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransSuccess;
 411:arch/stm32/mcu_periph/i2c_arch.c **** 
 412:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Ready_StopRequested;
 413:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 414:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 415:arch/stm32/mcu_periph/i2c_arch.c ****   }
 416:arch/stm32/mcu_periph/i2c_arch.c **** 
 417:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 418:arch/stm32/mcu_periph/i2c_arch.c **** }
 419:arch/stm32/mcu_periph/i2c_arch.c **** 
 420:arch/stm32/mcu_periph/i2c_arch.c **** // Doc ID 13902 Rev 11 p 712/1072
 421:arch/stm32/mcu_periph/i2c_arch.c **** // Transfer Sequence Diagram for Master Receiver for N>2
 422:arch/stm32/mcu_periph/i2c_arch.c **** static inline enum STMI2CSubTransactionStatus stmi2c_readmany(uint32_t i2c, struct i2c_periph *peri
 423:arch/stm32/mcu_periph/i2c_arch.c ****     struct i2c_transaction *trans)
 424:arch/stm32/mcu_periph/i2c_arch.c **** {
 425:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 426:arch/stm32/mcu_periph/i2c_arch.c **** 
 427:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Just Generated
 428:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 429:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 430:arch/stm32/mcu_periph/i2c_arch.c ****     // The first data byte will be acked in read many so the slave knows it should send more
 431:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_current(i2c);
 432:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 433:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear the SB flag
 434:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 435:arch/stm32/mcu_periph/i2c_arch.c **** 
 436:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 437:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CAddrRdSent;
 438:arch/stm32/mcu_periph/i2c_arch.c ****   }
 439:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 440:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 441:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf = 0;
 442:arch/stm32/mcu_periph/i2c_arch.c **** 
 443:arch/stm32/mcu_periph/i2c_arch.c ****     // Enable RXNE: receive an interrupt any time a byte is available
 444:arch/stm32/mcu_periph/i2c_arch.c ****     // only enable if MORE than 3 bytes need to be read
 445:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 446:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 447:arch/stm32/mcu_periph/i2c_arch.c ****     }
 448:arch/stm32/mcu_periph/i2c_arch.c **** 
 449:arch/stm32/mcu_periph/i2c_arch.c ****     // ACK is still on to get more DATA
 450:arch/stm32/mcu_periph/i2c_arch.c ****     // Read SR2 to clear the ADDR (next byte will start arriving)
 451:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 452:arch/stm32/mcu_periph/i2c_arch.c **** 
 453:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 454:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CReadingByte;
 455:arch/stm32/mcu_periph/i2c_arch.c ****   }
 456:arch/stm32/mcu_periph/i2c_arch.c ****   // one or more bytes are available AND we were interested in Buffer interrupts
 457:arch/stm32/mcu_periph/i2c_arch.c ****   else if ((BIT_X_IS_SET_IN_REG(I2C_SR1_RxNE, SR1)) && (BIT_X_IS_SET_IN_REG(I2C_CR2_ITBUFEN, I2C_CR
 458:arch/stm32/mcu_periph/i2c_arch.c ****     // read byte until 3 bytes remain to be read (e.g. len_r = 6, -> idx=3 means idx 3,4,5 = 3 rema
 459:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 460:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = I2C_DR(i2c);
 461:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 462:arch/stm32/mcu_periph/i2c_arch.c ****     }
 463:arch/stm32/mcu_periph/i2c_arch.c ****     // from : 3bytes -> last byte: do nothing
 464:arch/stm32/mcu_periph/i2c_arch.c ****     //
 465:arch/stm32/mcu_periph/i2c_arch.c ****     // finally: this was the last byte
 466:arch/stm32/mcu_periph/i2c_arch.c ****     else if (periph->idx_buf >= (trans->len_r - 1)) {
 467:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 468:arch/stm32/mcu_periph/i2c_arch.c **** 
 469:arch/stm32/mcu_periph/i2c_arch.c ****       // Last Value
 470:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 471:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 472:arch/stm32/mcu_periph/i2c_arch.c **** 
 473:arch/stm32/mcu_periph/i2c_arch.c ****       // We got all the results
 474:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransSuccess;
 475:arch/stm32/mcu_periph/i2c_arch.c **** 
 476:arch/stm32/mcu_periph/i2c_arch.c ****       return STMI2C_SubTra_Ready_StopRequested;
 477:arch/stm32/mcu_periph/i2c_arch.c ****     }
 478:arch/stm32/mcu_periph/i2c_arch.c **** 
 479:arch/stm32/mcu_periph/i2c_arch.c ****     // Check for end of transaction: start waiting for BTF instead of RXNE
 480:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->idx_buf < (trans->len_r - 3)) {
 481:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 482:arch/stm32/mcu_periph/i2c_arch.c ****     } else { // idx >= len-3: there are 3 bytes to be read
 483:arch/stm32/mcu_periph/i2c_arch.c ****       // We want to halt I2C to have sufficient time to clear ACK, so:
 484:arch/stm32/mcu_periph/i2c_arch.c ****       // Stop listening to RXNE as it will be triggered infinitely since we did not empty the buffe
 485:arch/stm32/mcu_periph/i2c_arch.c ****       // on the next (second in buffer) received byte BTF will be set (buffer full and I2C halted)
 486:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 487:arch/stm32/mcu_periph/i2c_arch.c ****     }
 488:arch/stm32/mcu_periph/i2c_arch.c ****   }
 489:arch/stm32/mcu_periph/i2c_arch.c ****   // Buffer is full while this was not a RXNE interrupt
 490:arch/stm32/mcu_periph/i2c_arch.c ****   else if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 491:arch/stm32/mcu_periph/i2c_arch.c ****     // Now the shift register and data register contain data(n-2) and data(n-1)
 492:arch/stm32/mcu_periph/i2c_arch.c ****     // And I2C is halted so we have time
 493:arch/stm32/mcu_periph/i2c_arch.c **** 
 494:arch/stm32/mcu_periph/i2c_arch.c ****     // --- Make absolutely sure the next 2 I2C actions are performed with no delay
 495:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_START;
 496:arch/stm32/mcu_periph/i2c_arch.c **** 
 497:arch/stm32/mcu_periph/i2c_arch.c ****     // First we clear the ACK while the SCL is held low by BTF
 498:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 499:arch/stm32/mcu_periph/i2c_arch.c **** 
 500:arch/stm32/mcu_periph/i2c_arch.c ****     // Now that ACK is cleared we read one byte: instantly the last byte is being clocked in...
 501:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 502:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 503:arch/stm32/mcu_periph/i2c_arch.c **** 
 504:arch/stm32/mcu_periph/i2c_arch.c ****     // Now the last byte is being clocked. Stop in MUST be set BEFORE the transfer of the last byte
 505:arch/stm32/mcu_periph/i2c_arch.c ****     PPRZ_I2C_SEND_STOP(i2c);
 506:arch/stm32/mcu_periph/i2c_arch.c **** 
 507:arch/stm32/mcu_periph/i2c_arch.c ****     __I2C_REG_CRITICAL_ZONE_STOP;
 508:arch/stm32/mcu_periph/i2c_arch.c **** 
 509:arch/stm32/mcu_periph/i2c_arch.c **** 
 510:arch/stm32/mcu_periph/i2c_arch.c ****     // --- end of critical zone -----------
 511:arch/stm32/mcu_periph/i2c_arch.c **** 
 512:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 513:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CStopRequested;
 514:arch/stm32/mcu_periph/i2c_arch.c **** 
 515:arch/stm32/mcu_periph/i2c_arch.c ****     // read the byte2 we had in the buffer (BTF means 2 bytes available)
 516:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[periph->idx_buf] = i2c_get_data(i2c);
 517:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 518:arch/stm32/mcu_periph/i2c_arch.c **** 
 519:arch/stm32/mcu_periph/i2c_arch.c ****     // Ask for an interrupt to read the last byte (which is normally still busy now)
 520:arch/stm32/mcu_periph/i2c_arch.c ****     // The last byte will be received with RXNE
 521:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 522:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 523:arch/stm32/mcu_periph/i2c_arch.c ****     return STMI2C_SubTra_Error;
 524:arch/stm32/mcu_periph/i2c_arch.c ****   }
 525:arch/stm32/mcu_periph/i2c_arch.c **** 
 526:arch/stm32/mcu_periph/i2c_arch.c ****   return STMI2C_SubTra_Busy;
 527:arch/stm32/mcu_periph/i2c_arch.c **** }
 528:arch/stm32/mcu_periph/i2c_arch.c **** 
 529:arch/stm32/mcu_periph/i2c_arch.c **** ////////////////////////////////////////////////
 530:arch/stm32/mcu_periph/i2c_arch.c **** // Restore bus conditions to normal after errors
 531:arch/stm32/mcu_periph/i2c_arch.c **** 
 532:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_error(struct i2c_periph *periph)
 533:arch/stm32/mcu_periph/i2c_arch.c **** {
  27              		.loc 1 533 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
 534:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 535:arch/stm32/mcu_periph/i2c_arch.c ****   uint8_t err_nr = 0;
 536:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 537:arch/stm32/mcu_periph/i2c_arch.c ****   periph->errors->er_irq_cnt;
  33              		.loc 1 537 0
  34 0000 C26A     		ldr	r2, [r0, #44]
  35 0002 9369     		ldr	r3, [r2, #24]
 538:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_AF) != 0) { /* Acknowledge failure */
  36              		.loc 1 538 0
  37 0004 436A     		ldr	r3, [r0, #36]
  38 0006 5969     		ldr	r1, [r3, #20]
  39 0008 4905     		lsls	r1, r1, #21
  40 000a 07D5     		bpl	.L2
 539:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->ack_fail_cnt++;
  41              		.loc 1 539 0
  42 000c 5188     		ldrh	r1, [r2, #2]
  43 000e 0131     		adds	r1, r1, #1
  44 0010 89B2     		uxth	r1, r1
  45 0012 5180     		strh	r1, [r2, #2]	@ movhi
 540:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_AF;
  46              		.loc 1 540 0
  47 0014 5969     		ldr	r1, [r3, #20]
  48 0016 21F48061 		bic	r1, r1, #1024
  49 001a 5961     		str	r1, [r3, #20]
  50              	.L2:
 541:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 542:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 1;
 543:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 544:arch/stm32/mcu_periph/i2c_arch.c ****   }
 545:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_BERR) != 0) {     /* Misplaced Start or Stop c
  51              		.loc 1 545 0
  52 001c 5969     		ldr	r1, [r3, #20]
  53 001e C805     		lsls	r0, r1, #23
  54              	.LVL1:
  55 0020 07D5     		bpl	.L3
 546:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->miss_start_stop_cnt++;
  56              		.loc 1 546 0
  57 0022 9188     		ldrh	r1, [r2, #4]
  58 0024 0131     		adds	r1, r1, #1
  59 0026 89B2     		uxth	r1, r1
  60 0028 9180     		strh	r1, [r2, #4]	@ movhi
 547:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_BERR;
  61              		.loc 1 547 0
  62 002a 5969     		ldr	r1, [r3, #20]
  63 002c 21F48071 		bic	r1, r1, #256
  64 0030 5961     		str	r1, [r3, #20]
  65              	.L3:
 548:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 549:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 2;
 550:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 551:arch/stm32/mcu_periph/i2c_arch.c ****   }
 552:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_ARLO) != 0) {     /* Arbitration lost */
  66              		.loc 1 552 0
  67 0032 5969     		ldr	r1, [r3, #20]
  68 0034 8905     		lsls	r1, r1, #22
  69 0036 07D5     		bpl	.L4
 553:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->arb_lost_cnt++;
  70              		.loc 1 553 0
  71 0038 D188     		ldrh	r1, [r2, #6]
  72 003a 0131     		adds	r1, r1, #1
  73 003c 89B2     		uxth	r1, r1
  74 003e D180     		strh	r1, [r2, #6]	@ movhi
 554:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_ARLO;
  75              		.loc 1 554 0
  76 0040 5969     		ldr	r1, [r3, #20]
  77 0042 21F40071 		bic	r1, r1, #512
  78 0046 5961     		str	r1, [r3, #20]
  79              	.L4:
 555:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 556:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 3;
 557:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 558:arch/stm32/mcu_periph/i2c_arch.c ****   }
 559:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_OVR) != 0) {      /* Overrun/Underrun */
  80              		.loc 1 559 0
  81 0048 5969     		ldr	r1, [r3, #20]
  82 004a 0805     		lsls	r0, r1, #20
  83 004c 07D5     		bpl	.L5
 560:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->over_under_cnt++;
  84              		.loc 1 560 0
  85 004e 1189     		ldrh	r1, [r2, #8]
  86 0050 0131     		adds	r1, r1, #1
  87 0052 89B2     		uxth	r1, r1
  88 0054 1181     		strh	r1, [r2, #8]	@ movhi
 561:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_OVR;
  89              		.loc 1 561 0
  90 0056 5969     		ldr	r1, [r3, #20]
  91 0058 21F40061 		bic	r1, r1, #2048
  92 005c 5961     		str	r1, [r3, #20]
  93              	.L5:
 562:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 563:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 4;
 564:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 565:arch/stm32/mcu_periph/i2c_arch.c ****   }
 566:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_PECERR) != 0) {   /* PEC Error in reception */
  94              		.loc 1 566 0
  95 005e 5969     		ldr	r1, [r3, #20]
  96 0060 C904     		lsls	r1, r1, #19
  97 0062 07D5     		bpl	.L6
 567:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->pec_recep_cnt++;
  98              		.loc 1 567 0
  99 0064 5189     		ldrh	r1, [r2, #10]
 100 0066 0131     		adds	r1, r1, #1
 101 0068 89B2     		uxth	r1, r1
 102 006a 5181     		strh	r1, [r2, #10]	@ movhi
 568:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_PECERR;
 103              		.loc 1 568 0
 104 006c 5969     		ldr	r1, [r3, #20]
 105 006e 21F48051 		bic	r1, r1, #4096
 106 0072 5961     		str	r1, [r3, #20]
 107              	.L6:
 569:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 570:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 5;
 571:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 572:arch/stm32/mcu_periph/i2c_arch.c ****   }
 573:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_TIMEOUT) != 0) {  /* Timeout or Tlow error */
 108              		.loc 1 573 0
 109 0074 5969     		ldr	r1, [r3, #20]
 110 0076 4804     		lsls	r0, r1, #17
 111 0078 07D5     		bpl	.L7
 574:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->timeout_tlow_cnt++;
 112              		.loc 1 574 0
 113 007a 9189     		ldrh	r1, [r2, #12]
 114 007c 0131     		adds	r1, r1, #1
 115 007e 89B2     		uxth	r1, r1
 116 0080 9181     		strh	r1, [r2, #12]	@ movhi
 575:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_TIMEOUT;
 117              		.loc 1 575 0
 118 0082 5969     		ldr	r1, [r3, #20]
 119 0084 21F48041 		bic	r1, r1, #16384
 120 0088 5961     		str	r1, [r3, #20]
 121              	.L7:
 576:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 577:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 6;
 578:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 579:arch/stm32/mcu_periph/i2c_arch.c ****   }
 580:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1((uint32_t)periph->reg_addr) & I2C_SR1_SMBALERT) != 0) { /* SMBus alert */
 122              		.loc 1 580 0
 123 008a 5969     		ldr	r1, [r3, #20]
 124 008c 0904     		lsls	r1, r1, #16
 125 008e 07D5     		bpl	.L1
 581:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->smbus_alert_cnt++;
 126              		.loc 1 581 0
 127 0090 D189     		ldrh	r1, [r2, #14]
 128 0092 0131     		adds	r1, r1, #1
 129 0094 89B2     		uxth	r1, r1
 130 0096 D181     		strh	r1, [r2, #14]	@ movhi
 582:arch/stm32/mcu_periph/i2c_arch.c ****     I2C_SR1((uint32_t)periph->reg_addr) &= ~I2C_SR1_SMBALERT;
 131              		.loc 1 582 0
 132 0098 5A69     		ldr	r2, [r3, #20]
 133 009a 22F40042 		bic	r2, r2, #32768
 134 009e 5A61     		str	r2, [r3, #20]
 135              	.L1:
 136 00a0 7047     		bx	lr
 137              		.cfi_endproc
 138              	.LFE14:
 140              		.section	.text.PPRZ_I2C_SEND_START,"ax",%progbits
 141              		.align	1
 142              		.thumb
 143              		.thumb_func
 145              	PPRZ_I2C_SEND_START:
 146              	.LFB9:
 174:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 147              		.loc 1 174 0
 148              		.cfi_startproc
 149              		@ args = 0, pretend = 0, frame = 0
 150              		@ frame_needed = 0, uses_anonymous_args = 0
 151              	.LVL2:
 152 0000 38B5     		push	{r3, r4, r5, lr}
 153              		.cfi_def_cfa_offset 16
 154              		.cfi_offset 3, -16
 155              		.cfi_offset 4, -12
 156              		.cfi_offset 5, -8
 157              		.cfi_offset 14, -4
 175:arch/stm32/mcu_periph/i2c_arch.c **** 
 158              		.loc 1 175 0
 159 0002 446A     		ldr	r4, [r0, #36]
 160              	.LVL3:
 178:arch/stm32/mcu_periph/i2c_arch.c **** 
 161              		.loc 1 178 0
 162 0004 0023     		movs	r3, #0
 163 0006 80F82330 		strb	r3, [r0, #35]
 174:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 164              		.loc 1 174 0
 165 000a 0546     		mov	r5, r0
 194:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 166              		.loc 1 194 0
 167 000c 4FF48071 		mov	r1, #256
 168 0010 2046     		mov	r0, r4
 169              	.LVL4:
 170 0012 FFF7FEFF 		bl	i2c_enable_interrupt
 171              	.LVL5:
 195:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 172              		.loc 1 195 0
 173 0016 2046     		mov	r0, r4
 174 0018 4FF40071 		mov	r1, #512
 175 001c FFF7FEFF 		bl	i2c_enable_interrupt
 176              	.LVL6:
 196:arch/stm32/mcu_periph/i2c_arch.c **** 
 177              		.loc 1 196 0
 178 0020 4FF48061 		mov	r1, #1024
 179 0024 2046     		mov	r0, r4
 180 0026 FFF7FEFF 		bl	i2c_disable_interrupt
 181              	.LVL7:
 199:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_ack(i2c);
 182              		.loc 1 199 0
 183 002a 2046     		mov	r0, r4
 184 002c FFF7FEFF 		bl	i2c_nack_current
 185              	.LVL8:
 200:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_clear_stop(i2c);
 186              		.loc 1 200 0
 187 0030 2046     		mov	r0, r4
 188 0032 FFF7FEFF 		bl	i2c_disable_ack
 189              	.LVL9:
 201:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(i2c);
 190              		.loc 1 201 0
 191 0036 2046     		mov	r0, r4
 192 0038 FFF7FEFF 		bl	i2c_clear_stop
 193              	.LVL10:
 202:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_send_start(i2c);
 194              		.loc 1 202 0
 195 003c 2046     		mov	r0, r4
 196 003e FFF7FEFF 		bl	i2c_peripheral_enable
 197              	.LVL11:
 203:arch/stm32/mcu_periph/i2c_arch.c ****   periph->status = I2CStartRequested;
 198              		.loc 1 203 0
 199 0042 2046     		mov	r0, r4
 200 0044 FFF7FEFF 		bl	i2c_send_start
 201              	.LVL12:
 204:arch/stm32/mcu_periph/i2c_arch.c **** 
 202              		.loc 1 204 0
 203 0048 0123     		movs	r3, #1
 204 004a 85F82230 		strb	r3, [r5, #34]
 205 004e 38BD     		pop	{r3, r4, r5, pc}
 206              		.cfi_endproc
 207              	.LFE9:
 209              		.section	.text.get_sys_time_usec,"ax",%progbits
 210              		.align	1
 211              		.thumb
 212              		.thumb_func
 214              	get_sys_time_usec:
 215              	.LFB42:
 216              		.file 2 "/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h"
   1:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /*
   2:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   3:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Copyright (C) 2009-2011 The Paparazzi Team
   4:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   5:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * This file is part of paparazzi.
   6:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
   7:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * it under the terms of the GNU General Public License as published by
   9:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * any later version.
  11:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  12:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * GNU General Public License for more details.
  16:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  17:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * You should have received a copy of the GNU General Public License
  18:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Boston, MA 02111-1307, USA.
  21:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  22:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  23:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  24:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /**
  25:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @file arch/stm32/mcu_periph/sys_time_arch.h
  26:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @ingroup stm32_arch
  27:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  28:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * STM32 timing functions.
  29:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  *
  30:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  31:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  32:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifndef SYS_TIME_ARCH_H
  33:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #define SYS_TIME_ARCH_H
  34:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  35:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "mcu_periph/sys_time.h"
  36:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  37:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/stm32/gpio.h>
  38:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/stm32/rcc.h>
  39:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include <libopencm3/cm3/systick.h>
  40:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "std.h"
  41:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifdef RTOS_IS_CHIBIOS
  42:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "chibios_stub.h"
  43:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #include "chconf.h"
  44:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #endif
  45:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** 
  46:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** /**
  47:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * Get the time in microseconds since startup.
  48:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * WARNING: overflows after 70min!
  49:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  * @return microseconds since startup as uint32_t
  50:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****  */
  51:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** static inline uint32_t get_sys_time_usec(void)
  52:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** {
 217              		.loc 2 52 0
 218              		.cfi_startproc
 219              		@ args = 0, pretend = 0, frame = 0
 220              		@ frame_needed = 0, uses_anonymous_args = 0
 221 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 222              		.cfi_def_cfa_offset 24
 223              		.cfi_offset 3, -24
 224              		.cfi_offset 4, -20
 225              		.cfi_offset 5, -16
 226              		.cfi_offset 6, -12
 227              		.cfi_offset 7, -8
 228              		.cfi_offset 14, -4
  53:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #ifdef RTOS_IS_CHIBIOS
  54:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****   return (chibios_chTimeNow() * (1000000 / CH_FREQUENCY));
  55:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #else
  56:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****   return sys_time.nb_sec * 1000000 +
 229              		.loc 2 56 0
 230 0002 0D4D     		ldr	r5, .L33
 231              	.LBB49:
 232              	.LBB50:
 233              		.file 3 "./mcu_periph/sys_time.h"
   1:./mcu_periph/sys_time.h **** /*
   2:./mcu_periph/sys_time.h ****  *
   3:./mcu_periph/sys_time.h ****  * Copyright (C) 2009-2011 The Paparazzi Team
   4:./mcu_periph/sys_time.h ****  *
   5:./mcu_periph/sys_time.h ****  * This file is part of paparazzi.
   6:./mcu_periph/sys_time.h ****  *
   7:./mcu_periph/sys_time.h ****  * paparazzi is free software; you can redistribute it and/or modify
   8:./mcu_periph/sys_time.h ****  * it under the terms of the GNU General Public License as published by
   9:./mcu_periph/sys_time.h ****  * the Free Software Foundation; either version 2, or (at your option)
  10:./mcu_periph/sys_time.h ****  * any later version.
  11:./mcu_periph/sys_time.h ****  *
  12:./mcu_periph/sys_time.h ****  * paparazzi is distributed in the hope that it will be useful,
  13:./mcu_periph/sys_time.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:./mcu_periph/sys_time.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:./mcu_periph/sys_time.h ****  * GNU General Public License for more details.
  16:./mcu_periph/sys_time.h ****  *
  17:./mcu_periph/sys_time.h ****  * You should have received a copy of the GNU General Public License
  18:./mcu_periph/sys_time.h ****  * along with paparazzi; see the file COPYING.  If not, write to
  19:./mcu_periph/sys_time.h ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  20:./mcu_periph/sys_time.h ****  * Boston, MA 02111-1307, USA.
  21:./mcu_periph/sys_time.h ****  *
  22:./mcu_periph/sys_time.h ****  */
  23:./mcu_periph/sys_time.h **** 
  24:./mcu_periph/sys_time.h **** /**
  25:./mcu_periph/sys_time.h ****  * @file mcu_periph/sys_time.h
  26:./mcu_periph/sys_time.h ****  * @brief Architecture independent timing functions.
  27:./mcu_periph/sys_time.h ****  *
  28:./mcu_periph/sys_time.h ****  */
  29:./mcu_periph/sys_time.h **** 
  30:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_H
  31:./mcu_periph/sys_time.h **** #define SYS_TIME_H
  32:./mcu_periph/sys_time.h **** 
  33:./mcu_periph/sys_time.h **** #include <inttypes.h>
  34:./mcu_periph/sys_time.h **** #include <stdlib.h>
  35:./mcu_periph/sys_time.h **** #include "std.h"
  36:./mcu_periph/sys_time.h **** 
  37:./mcu_periph/sys_time.h **** #include BOARD_CONFIG
  38:./mcu_periph/sys_time.h **** 
  39:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_NB_TIMER
  40:./mcu_periph/sys_time.h **** #define SYS_TIME_NB_TIMER 16
  41:./mcu_periph/sys_time.h **** #endif
  42:./mcu_periph/sys_time.h **** 
  43:./mcu_periph/sys_time.h **** 
  44:./mcu_periph/sys_time.h **** /**
  45:./mcu_periph/sys_time.h ****  * (Default) sys_time timer frequency in Hz.
  46:./mcu_periph/sys_time.h ****  * sys_time.resolution is set from this define.
  47:./mcu_periph/sys_time.h ****  */
  48:./mcu_periph/sys_time.h **** #ifndef SYS_TIME_FREQUENCY
  49:./mcu_periph/sys_time.h **** #if defined PERIODIC_FREQUENCY
  50:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY (2 * PERIODIC_FREQUENCY)
  51:./mcu_periph/sys_time.h **** #else
  52:./mcu_periph/sys_time.h **** #define SYS_TIME_FREQUENCY 1000
  53:./mcu_periph/sys_time.h **** #endif
  54:./mcu_periph/sys_time.h **** #endif
  55:./mcu_periph/sys_time.h **** 
  56:./mcu_periph/sys_time.h **** 
  57:./mcu_periph/sys_time.h **** typedef uint8_t tid_t; ///< sys_time timer id type
  58:./mcu_periph/sys_time.h **** typedef void (*sys_time_cb)(uint8_t id);
  59:./mcu_periph/sys_time.h **** 
  60:./mcu_periph/sys_time.h **** struct sys_time_timer {
  61:./mcu_periph/sys_time.h ****   bool_t          in_use;
  62:./mcu_periph/sys_time.h ****   sys_time_cb     cb;
  63:./mcu_periph/sys_time.h ****   volatile bool_t elapsed;
  64:./mcu_periph/sys_time.h ****   uint32_t        end_time; ///< in SYS_TIME_TICKS
  65:./mcu_periph/sys_time.h ****   uint32_t        duration; ///< in SYS_TIME_TICKS
  66:./mcu_periph/sys_time.h **** };
  67:./mcu_periph/sys_time.h **** 
  68:./mcu_periph/sys_time.h **** struct sys_time {
  69:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec;       ///< full seconds since startup
  70:./mcu_periph/sys_time.h ****   volatile uint32_t nb_sec_rem;   ///< remainder of seconds since startup in CPU_TICKS
  71:./mcu_periph/sys_time.h ****   volatile uint32_t nb_tick;      ///< SYS_TIME_TICKS since startup
  72:./mcu_periph/sys_time.h ****   struct sys_time_timer timer[SYS_TIME_NB_TIMER];
  73:./mcu_periph/sys_time.h **** 
  74:./mcu_periph/sys_time.h ****   float resolution;               ///< sys_time_timer resolution in seconds
  75:./mcu_periph/sys_time.h ****   uint32_t ticks_per_sec;         ///< sys_time ticks per second (SYS_TIME_FREQUENCY)
  76:./mcu_periph/sys_time.h ****   uint32_t resolution_cpu_ticks;  ///< sys_time_timer resolution in cpu ticks
  77:./mcu_periph/sys_time.h ****   uint32_t cpu_ticks_per_sec;     ///< cpu ticks per second
  78:./mcu_periph/sys_time.h **** };
  79:./mcu_periph/sys_time.h **** 
  80:./mcu_periph/sys_time.h **** extern struct sys_time sys_time;
  81:./mcu_periph/sys_time.h **** 
  82:./mcu_periph/sys_time.h **** 
  83:./mcu_periph/sys_time.h **** extern void sys_time_init(void);
  84:./mcu_periph/sys_time.h **** 
  85:./mcu_periph/sys_time.h **** /**
  86:./mcu_periph/sys_time.h ****  * Register a new system timer.
  87:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
  88:./mcu_periph/sys_time.h ****  * @param cb Callback function that is called from the ISR when timer elapses, or NULL
  89:./mcu_periph/sys_time.h ****  * @return -1 if it failed, the timer id otherwise
  90:./mcu_periph/sys_time.h ****  */
  91:./mcu_periph/sys_time.h **** extern int sys_time_register_timer(float duration, sys_time_cb cb);
  92:./mcu_periph/sys_time.h **** 
  93:./mcu_periph/sys_time.h **** /**
  94:./mcu_periph/sys_time.h ****  * Cancel a system timer by id.
  95:./mcu_periph/sys_time.h ****  * @param id Timer id.
  96:./mcu_periph/sys_time.h ****  */
  97:./mcu_periph/sys_time.h **** extern void sys_time_cancel_timer(tid_t id);
  98:./mcu_periph/sys_time.h **** 
  99:./mcu_periph/sys_time.h **** /**
 100:./mcu_periph/sys_time.h ****  * Update the duration until a timer elapses.
 101:./mcu_periph/sys_time.h ****  * @param id Timer id
 102:./mcu_periph/sys_time.h ****  * @param duration Duration in seconds until the timer elapses.
 103:./mcu_periph/sys_time.h ****  */
 104:./mcu_periph/sys_time.h **** extern void sys_time_update_timer(tid_t id, float duration);
 105:./mcu_periph/sys_time.h **** 
 106:./mcu_periph/sys_time.h **** /**
 107:./mcu_periph/sys_time.h ****  * Check if timer has elapsed.
 108:./mcu_periph/sys_time.h ****  * @param id Timer id
 109:./mcu_periph/sys_time.h ****  * @return TRUE if timer has elapsed
 110:./mcu_periph/sys_time.h ****  */
 111:./mcu_periph/sys_time.h **** static inline bool_t sys_time_check_and_ack_timer(tid_t id)
 112:./mcu_periph/sys_time.h **** {
 113:./mcu_periph/sys_time.h ****   if (sys_time.timer[id].elapsed) {
 114:./mcu_periph/sys_time.h ****     sys_time.timer[id].elapsed = FALSE;
 115:./mcu_periph/sys_time.h ****     return TRUE;
 116:./mcu_periph/sys_time.h ****   }
 117:./mcu_periph/sys_time.h ****   return FALSE;
 118:./mcu_periph/sys_time.h **** }
 119:./mcu_periph/sys_time.h **** 
 120:./mcu_periph/sys_time.h **** /**
 121:./mcu_periph/sys_time.h ****  * Get the time in seconds since startup.
 122:./mcu_periph/sys_time.h ****  * @return current system time as float with sys_time.resolution
 123:./mcu_periph/sys_time.h ****  */
 124:./mcu_periph/sys_time.h **** static inline float get_sys_time_float(void)
 125:./mcu_periph/sys_time.h **** {
 126:./mcu_periph/sys_time.h ****   return (float)(sys_time.nb_sec + (float)(sys_time.nb_sec_rem) / sys_time.cpu_ticks_per_sec);
 127:./mcu_periph/sys_time.h **** }
 128:./mcu_periph/sys_time.h **** 
 129:./mcu_periph/sys_time.h **** 
 130:./mcu_periph/sys_time.h **** /*
 131:./mcu_periph/sys_time.h ****  * Convenience functions to convert between seconds and sys_time ticks.
 132:./mcu_periph/sys_time.h ****  */
 133:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_sec(float seconds)
 134:./mcu_periph/sys_time.h **** {
 135:./mcu_periph/sys_time.h ****   return (uint32_t)(seconds * sys_time.ticks_per_sec + 0.5);
 136:./mcu_periph/sys_time.h **** }
 137:./mcu_periph/sys_time.h **** 
 138:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_msec(uint32_t msec)
 139:./mcu_periph/sys_time.h **** {
 140:./mcu_periph/sys_time.h ****   return msec * sys_time.ticks_per_sec / 1000;
 141:./mcu_periph/sys_time.h **** }
 142:./mcu_periph/sys_time.h **** 
 143:./mcu_periph/sys_time.h **** static inline uint32_t sys_time_ticks_of_usec(uint32_t usec)
 144:./mcu_periph/sys_time.h **** {
 145:./mcu_periph/sys_time.h ****   return usec * sys_time.ticks_per_sec / 1000000;
 146:./mcu_periph/sys_time.h **** }
 147:./mcu_periph/sys_time.h **** 
 148:./mcu_periph/sys_time.h **** static inline float sec_of_sys_time_ticks(uint32_t ticks)
 149:./mcu_periph/sys_time.h **** {
 150:./mcu_periph/sys_time.h ****   return (float)ticks * sys_time.resolution;
 151:./mcu_periph/sys_time.h **** }
 152:./mcu_periph/sys_time.h **** 
 153:./mcu_periph/sys_time.h **** static inline uint32_t msec_of_sys_time_ticks(uint32_t ticks)
 154:./mcu_periph/sys_time.h **** {
 155:./mcu_periph/sys_time.h ****   return ticks * 1000 / sys_time.ticks_per_sec;
 156:./mcu_periph/sys_time.h **** }
 157:./mcu_periph/sys_time.h **** 
 158:./mcu_periph/sys_time.h **** static inline uint32_t usec_of_sys_time_ticks(uint32_t ticks)
 159:./mcu_periph/sys_time.h **** {
 160:./mcu_periph/sys_time.h ****   return ticks * 1000 / sys_time.ticks_per_sec * 1000;
 161:./mcu_periph/sys_time.h **** }
 162:./mcu_periph/sys_time.h **** 
 163:./mcu_periph/sys_time.h **** 
 164:./mcu_periph/sys_time.h **** 
 165:./mcu_periph/sys_time.h **** /*
 166:./mcu_periph/sys_time.h ****  * Convenience functions to convert between seconds and CPU ticks.
 167:./mcu_periph/sys_time.h ****  */
 168:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_sec(float seconds)
 169:./mcu_periph/sys_time.h **** {
 170:./mcu_periph/sys_time.h ****   return (uint32_t)(seconds * sys_time.cpu_ticks_per_sec + 0.5);
 171:./mcu_periph/sys_time.h **** }
 172:./mcu_periph/sys_time.h **** 
 173:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_usec(uint32_t usec)
 174:./mcu_periph/sys_time.h **** {
 175:./mcu_periph/sys_time.h ****   return usec * (sys_time.cpu_ticks_per_sec / 1000000);
 176:./mcu_periph/sys_time.h **** }
 177:./mcu_periph/sys_time.h **** 
 178:./mcu_periph/sys_time.h **** static inline int32_t signed_cpu_ticks_of_usec(int32_t usec)
 179:./mcu_periph/sys_time.h **** {
 180:./mcu_periph/sys_time.h ****   return usec * ((int32_t)sys_time.cpu_ticks_per_sec / 1000000);
 181:./mcu_periph/sys_time.h **** }
 182:./mcu_periph/sys_time.h **** 
 183:./mcu_periph/sys_time.h **** static inline uint32_t cpu_ticks_of_nsec(uint32_t nsec)
 184:./mcu_periph/sys_time.h **** {
 185:./mcu_periph/sys_time.h ****   return nsec * (sys_time.cpu_ticks_per_sec / 1000000) / 1000;
 186:./mcu_periph/sys_time.h **** }
 187:./mcu_periph/sys_time.h **** 
 188:./mcu_periph/sys_time.h **** static inline uint32_t msec_of_cpu_ticks(uint32_t cpu_ticks)
 189:./mcu_periph/sys_time.h **** {
 190:./mcu_periph/sys_time.h ****   return cpu_ticks / (sys_time.cpu_ticks_per_sec / 1000);
 191:./mcu_periph/sys_time.h **** }
 192:./mcu_periph/sys_time.h **** 
 193:./mcu_periph/sys_time.h **** static inline uint32_t usec_of_cpu_ticks(uint32_t cpu_ticks)
 194:./mcu_periph/sys_time.h **** {
 195:./mcu_periph/sys_time.h ****   return cpu_ticks / (sys_time.cpu_ticks_per_sec / 1000000);
 234              		.loc 3 195 0
 235 0004 0D4F     		ldr	r7, .L33+4
 236              	.LBE50:
 237              	.LBE49:
 238              		.loc 2 56 0
 239 0006 2B68     		ldr	r3, [r5]
 240              	.LBB53:
 241              	.LBB51:
 242              		.loc 3 195 0
 243 0008 D5F85861 		ldr	r6, [r5, #344]
 244              	.LBE51:
 245              	.LBE53:
  57:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****          usec_of_cpu_ticks(sys_time.nb_sec_rem) +
 246              		.loc 2 57 0
 247 000c 6A68     		ldr	r2, [r5, #4]
 248              	.LVL13:
 249              	.LBB54:
 250              	.LBB52:
 251              		.loc 3 195 0
 252 000e B6FBF7F6 		udiv	r6, r6, r7
 253 0012 B2FBF6F6 		udiv	r6, r2, r6
 254              	.LBE52:
 255              	.LBE54:
  56:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****          usec_of_cpu_ticks(sys_time.nb_sec_rem) +
 256              		.loc 2 56 0
 257 0016 07FB0366 		mla	r6, r7, r3, r6
  58:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h ****          usec_of_cpu_ticks(systick_get_reload() - systick_get_value());
 258              		.loc 2 58 0
 259 001a FFF7FEFF 		bl	systick_get_reload
 260              	.LVL14:
 261 001e 0446     		mov	r4, r0
 262 0020 FFF7FEFF 		bl	systick_get_value
 263              	.LVL15:
 264              	.LBB55:
 265              	.LBB56:
 266              		.loc 3 195 0
 267 0024 D5F85831 		ldr	r3, [r5, #344]
 268              	.LBE56:
 269              	.LBE55:
 270              		.loc 2 58 0
 271 0028 201A     		subs	r0, r4, r0
 272              	.LVL16:
 273              	.LBB58:
 274              	.LBB57:
 275              		.loc 3 195 0
 276 002a B3FBF7F4 		udiv	r4, r3, r7
 277 002e B0FBF4F0 		udiv	r0, r0, r4
 278              	.LVL17:
 279              	.LBE57:
 280              	.LBE58:
  59:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** #endif
  60:/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/sys_time_arch.h **** }
 281              		.loc 2 60 0
 282 0032 3044     		add	r0, r0, r6
 283 0034 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 284              	.L34:
 285 0036 00BF     		.align	2
 286              	.L33:
 287 0038 00000000 		.word	sys_time
 288 003c 40420F00 		.word	1000000
 289              		.cfi_endproc
 290              	.LFE42:
 292              		.section	.text.i2c_setup_gpio.part.0,"ax",%progbits
 293              		.align	1
 294              		.thumb
 295              		.thumb_func
 297              	i2c_setup_gpio.part.0:
 298              	.LFB48:
 112:arch/stm32/mcu_periph/i2c_arch.c **** {
 299              		.loc 1 112 0
 300              		.cfi_startproc
 301              		@ args = 0, pretend = 0, frame = 0
 302              		@ frame_needed = 0, uses_anonymous_args = 0
 303              	.LVL18:
 304 0000 10B5     		push	{r4, lr}
 305              		.cfi_def_cfa_offset 8
 306              		.cfi_offset 4, -8
 307              		.cfi_offset 14, -4
 117:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C1_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 308              		.loc 1 117 0
 309 0002 0D4C     		ldr	r4, .L36
 310 0004 2046     		mov	r0, r4
 311 0006 FFF7FEFF 		bl	gpio_enable_clock
 312              	.LVL19:
 118:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 313              		.loc 1 118 0
 314 000a 2046     		mov	r0, r4
 315 000c 0221     		movs	r1, #2
 316 000e 0022     		movs	r2, #0
 317 0010 4FF4C073 		mov	r3, #384
 318 0014 FFF7FEFF 		bl	gpio_mode_setup
 319              	.LVL20:
 120:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C1_GPIO_SCL | I2C1_GPIO_SDA);
 320              		.loc 1 120 0
 321 0018 0121     		movs	r1, #1
 322 001a 2046     		mov	r0, r4
 323 001c 0A46     		mov	r2, r1
 324 001e 4FF4C073 		mov	r3, #384
 325 0022 FFF7FEFF 		bl	gpio_set_output_options
 326              	.LVL21:
 122:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 327              		.loc 1 122 0
 328 0026 2046     		mov	r0, r4
 329 0028 0421     		movs	r1, #4
 330 002a 4FF4C072 		mov	r2, #384
 154:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 331              		.loc 1 154 0
 332 002e BDE81040 		pop	{r4, lr}
 333              		.cfi_restore 14
 334              		.cfi_restore 4
 335              		.cfi_def_cfa_offset 0
 122:arch/stm32/mcu_periph/i2c_arch.c ****       break;
 336              		.loc 1 122 0
 337 0032 FFF7FEBF 		b	gpio_set_af
 338              	.LVL22:
 339              	.L37:
 340 0036 00BF     		.align	2
 341              	.L36:
 342 0038 00040240 		.word	1073873920
 343              		.cfi_endproc
 344              	.LFE48:
 346              		.section	.text.i2c_setup_gpio,"ax",%progbits
 347              		.align	1
 348              		.thumb
 349              		.thumb_func
 351              	i2c_setup_gpio:
 352              	.LFB7:
 113:arch/stm32/mcu_periph/i2c_arch.c ****   switch (i2c) {
 353              		.loc 1 113 0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              	.LVL23:
 358 0000 08B5     		push	{r3, lr}
 359              		.cfi_def_cfa_offset 8
 360              		.cfi_offset 3, -8
 361              		.cfi_offset 14, -4
 114:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 362              		.loc 1 114 0
 363 0002 124B     		ldr	r3, .L43
 364 0004 9842     		cmp	r0, r3
 365 0006 04D0     		beq	.L40
 366 0008 03F58063 		add	r3, r3, #1024
 367 000c 9842     		cmp	r0, r3
 368 000e 04D0     		beq	.L41
 369 0010 08BD     		pop	{r3, pc}
 370              	.L40:
 154:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 371              		.loc 1 154 0
 372 0012 BDE80840 		pop	{r3, lr}
 373              		.cfi_remember_state
 374              		.cfi_restore 14
 375              		.cfi_restore 3
 376              		.cfi_def_cfa_offset 0
 377 0016 FFF7FEBF 		b	i2c_setup_gpio.part.0
 378              	.LVL24:
 379              	.L41:
 380              		.cfi_restore_state
 127:arch/stm32/mcu_periph/i2c_arch.c ****       gpio_mode_setup(I2C2_GPIO_PORT, GPIO_MODE_AF, GPIO_PUPD_NONE,
 381              		.loc 1 127 0
 382 001a 0D48     		ldr	r0, .L43+4
 383              	.LVL25:
 384 001c FFF7FEFF 		bl	gpio_enable_clock
 385              	.LVL26:
 128:arch/stm32/mcu_periph/i2c_arch.c ****                       I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 386              		.loc 1 128 0
 387 0020 0B48     		ldr	r0, .L43+4
 388 0022 0221     		movs	r1, #2
 389 0024 0022     		movs	r2, #0
 390 0026 4FF44063 		mov	r3, #3072
 391 002a FFF7FEFF 		bl	gpio_mode_setup
 392              	.LVL27:
 130:arch/stm32/mcu_periph/i2c_arch.c ****                               I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 393              		.loc 1 130 0
 394 002e 0121     		movs	r1, #1
 395 0030 0A46     		mov	r2, r1
 396 0032 0748     		ldr	r0, .L43+4
 397 0034 4FF44063 		mov	r3, #3072
 398 0038 FFF7FEFF 		bl	gpio_set_output_options
 399              	.LVL28:
 132:arch/stm32/mcu_periph/i2c_arch.c ****                   I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 400              		.loc 1 132 0
 401 003c 0448     		ldr	r0, .L43+4
 402 003e 0421     		movs	r1, #4
 403 0040 4FF44062 		mov	r2, #3072
 154:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 404              		.loc 1 154 0
 405 0044 BDE80840 		pop	{r3, lr}
 406              		.cfi_restore 14
 407              		.cfi_restore 3
 408              		.cfi_def_cfa_offset 0
 132:arch/stm32/mcu_periph/i2c_arch.c ****                   I2C2_GPIO_SCL | I2C2_GPIO_SDA);
 409              		.loc 1 132 0
 410 0048 FFF7FEBF 		b	gpio_set_af
 411              	.LVL29:
 412              	.L44:
 413              		.align	2
 414              	.L43:
 415 004c 00540040 		.word	1073763328
 416 0050 00040240 		.word	1073873920
 417              		.cfi_endproc
 418              	.LFE7:
 420              		.section	.text.stmi2c_clear_pending_interrupts,"ax",%progbits
 421              		.align	1
 422              		.thumb
 423              		.thumb_func
 425              	stmi2c_clear_pending_interrupts:
 426              	.LFB15:
 583:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 584:arch/stm32/mcu_periph/i2c_arch.c ****     err_nr = 7;
 585:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 586:arch/stm32/mcu_periph/i2c_arch.c ****   }
 587:arch/stm32/mcu_periph/i2c_arch.c **** 
 588:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 589:arch/stm32/mcu_periph/i2c_arch.c ****   LED_ERROR(20, err_nr);
 590:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 591:arch/stm32/mcu_periph/i2c_arch.c **** 
 592:arch/stm32/mcu_periph/i2c_arch.c ****   return;
 593:arch/stm32/mcu_periph/i2c_arch.c **** }
 594:arch/stm32/mcu_periph/i2c_arch.c **** 
 595:arch/stm32/mcu_periph/i2c_arch.c **** 
 596:arch/stm32/mcu_periph/i2c_arch.c **** static inline void stmi2c_clear_pending_interrupts(uint32_t i2c)
 597:arch/stm32/mcu_periph/i2c_arch.c **** {
 427              		.loc 1 597 0
 428              		.cfi_startproc
 429              		@ args = 0, pretend = 0, frame = 0
 430              		@ frame_needed = 0, uses_anonymous_args = 0
 431              	.LVL30:
 432 0000 38B5     		push	{r3, r4, r5, lr}
 433              		.cfi_def_cfa_offset 16
 434              		.cfi_offset 3, -16
 435              		.cfi_offset 4, -12
 436              		.cfi_offset 5, -8
 437              		.cfi_offset 14, -4
 598:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 438              		.loc 1 598 0
 439 0002 4569     		ldr	r5, [r0, #20]
 440              	.LVL31:
 599:arch/stm32/mcu_periph/i2c_arch.c **** 
 600:arch/stm32/mcu_periph/i2c_arch.c ****   // Certainly do not wait for buffer interrupts:
 601:arch/stm32/mcu_periph/i2c_arch.c ****   // -------------------------------------------
 602:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);      // Disable TXE, RXNE
 441              		.loc 1 602 0
 442 0004 4FF48061 		mov	r1, #1024
 443 0008 ADB2     		uxth	r5, r5
 597:arch/stm32/mcu_periph/i2c_arch.c ****   uint16_t SR1 = I2C_SR1(i2c);
 444              		.loc 1 597 0
 445 000a 0446     		mov	r4, r0
 446              		.loc 1 602 0
 447 000c FFF7FEFF 		bl	i2c_disable_interrupt
 448              	.LVL32:
 603:arch/stm32/mcu_periph/i2c_arch.c **** 
 604:arch/stm32/mcu_periph/i2c_arch.c ****   // Error interrupts are handled separately:
 605:arch/stm32/mcu_periph/i2c_arch.c ****   // ---------------------------------------
 606:arch/stm32/mcu_periph/i2c_arch.c **** 
 607:arch/stm32/mcu_periph/i2c_arch.c ****   // Clear Event interrupt conditions:
 608:arch/stm32/mcu_periph/i2c_arch.c ****   // --------------------------------
 609:arch/stm32/mcu_periph/i2c_arch.c **** 
 610:arch/stm32/mcu_periph/i2c_arch.c ****   // Start Condition Was Generated
 611:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_SB, SR1)) {
 449              		.loc 1 611 0
 450 0010 E907     		lsls	r1, r5, #31
 451 0012 03D5     		bpl	.L46
 612:arch/stm32/mcu_periph/i2c_arch.c ****     // SB: cleared by software when reading SR1 and writing to DR
 613:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 452              		.loc 1 613 0
 453 0014 2046     		mov	r0, r4
 454 0016 0021     		movs	r1, #0
 455 0018 FFF7FEFF 		bl	i2c_send_data
 456              	.LVL33:
 457              	.L46:
 614:arch/stm32/mcu_periph/i2c_arch.c ****   }
 615:arch/stm32/mcu_periph/i2c_arch.c ****   // Address Was Sent
 616:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_ADDR, SR1)) {
 458              		.loc 1 616 0
 459 001c AA07     		lsls	r2, r5, #30
 460              	.LBB64:
 617:arch/stm32/mcu_periph/i2c_arch.c ****     // ADDR: Cleared by software when reading SR1 and then SR2
 618:arch/stm32/mcu_periph/i2c_arch.c ****     uint16_t SR2 __attribute__((unused)) = I2C_SR2(i2c);
 461              		.loc 1 618 0
 462 001e 48BF     		it	mi
 463 0020 A369     		ldrmi	r3, [r4, #24]
 464              	.LBE64:
 619:arch/stm32/mcu_periph/i2c_arch.c ****   }
 620:arch/stm32/mcu_periph/i2c_arch.c ****   // Byte Transfer Finished
 621:arch/stm32/mcu_periph/i2c_arch.c ****   if (BIT_X_IS_SET_IN_REG(I2C_SR1_BTF, SR1)) {
 465              		.loc 1 621 0
 466 0022 6B07     		lsls	r3, r5, #29
 467 0024 08D5     		bpl	.L45
 468              	.LVL34:
 469              	.LBB65:
 470              	.LBB66:
 471              	.LBB67:
 622:arch/stm32/mcu_periph/i2c_arch.c ****     // SB: cleared by software when reading SR1 and reading/writing to DR
 623:arch/stm32/mcu_periph/i2c_arch.c ****     uint8_t dummy __attribute__((unused)) = i2c_get_data(i2c);
 472              		.loc 1 623 0
 473 0026 2046     		mov	r0, r4
 474 0028 FFF7FEFF 		bl	i2c_get_data
 475              	.LVL35:
 624:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 476              		.loc 1 624 0
 477 002c 2046     		mov	r0, r4
 478 002e 0021     		movs	r1, #0
 479              	.LBE67:
 480              	.LBE66:
 481              	.LBE65:
 625:arch/stm32/mcu_periph/i2c_arch.c ****   }
 626:arch/stm32/mcu_periph/i2c_arch.c **** 
 627:arch/stm32/mcu_periph/i2c_arch.c **** }
 482              		.loc 1 627 0
 483 0030 BDE83840 		pop	{r3, r4, r5, lr}
 484              		.cfi_remember_state
 485              		.cfi_restore 14
 486              		.cfi_restore 5
 487              		.cfi_restore 4
 488              		.cfi_restore 3
 489              		.cfi_def_cfa_offset 0
 490              	.LVL36:
 491              	.LBB70:
 492              	.LBB69:
 493              	.LBB68:
 624:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, 0x00);
 494              		.loc 1 624 0
 495 0034 FFF7FEBF 		b	i2c_send_data
 496              	.LVL37:
 497              	.L45:
 498              		.cfi_restore_state
 499 0038 38BD     		pop	{r3, r4, r5, pc}
 500              	.LBE68:
 501              	.LBE69:
 502              	.LBE70:
 503              		.cfi_endproc
 504              	.LFE15:
 506              		.section	.text.i2c_scl_clear,"ax",%progbits
 507              		.align	1
 508              		.thumb
 509              		.thumb_func
 511              	i2c_scl_clear:
 512              	.LFB25:
 628:arch/stm32/mcu_periph/i2c_arch.c **** 
 629:arch/stm32/mcu_periph/i2c_arch.c **** 
 630:arch/stm32/mcu_periph/i2c_arch.c **** ////////////////////////////////////////////////
 631:arch/stm32/mcu_periph/i2c_arch.c **** // Restore bus conditions to normal after errors
 632:arch/stm32/mcu_periph/i2c_arch.c **** 
 633:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_irq(struct i2c_periph *periph)
 634:arch/stm32/mcu_periph/i2c_arch.c **** {
 635:arch/stm32/mcu_periph/i2c_arch.c **** 
 636:arch/stm32/mcu_periph/i2c_arch.c ****   /*
 637:arch/stm32/mcu_periph/i2c_arch.c ****     There are 7 possible event reasons to get here + all errors
 638:arch/stm32/mcu_periph/i2c_arch.c **** 
 639:arch/stm32/mcu_periph/i2c_arch.c ****     If IT_EV_FEN
 640:arch/stm32/mcu_periph/i2c_arch.c ****     -------------------------
 641:arch/stm32/mcu_periph/i2c_arch.c **** 
 642:arch/stm32/mcu_periph/i2c_arch.c ****     We are always interested in all IT_EV_FEV: all are required.
 643:arch/stm32/mcu_periph/i2c_arch.c **** 
 644:arch/stm32/mcu_periph/i2c_arch.c ****     1) SB   // Start Condition Success in Master mode
 645:arch/stm32/mcu_periph/i2c_arch.c ****     2) ADDR   // Address sent received Acknowledge
 646:arch/stm32/mcu_periph/i2c_arch.c ****     [ADDR10]  // -- 10bit address stuff: not used
 647:arch/stm32/mcu_periph/i2c_arch.c ****     [STOPF]   // -- only for slaves: master has no stop interrupt: not used
 648:arch/stm32/mcu_periph/i2c_arch.c ****     3) BTF    // I2C has stopped working (it is waiting for new data, all buffers are tx_empty/rx_f
 649:arch/stm32/mcu_periph/i2c_arch.c **** 
 650:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: using the buffered I2C has some interesting properties:
 651:arch/stm32/mcu_periph/i2c_arch.c ****     - in master receive mode: BTF only occurs after the 2nd received byte: after the first byte is 
 652:arch/stm32/mcu_periph/i2c_arch.c ****       in RD but the I2C can still receive a second byte. Only when the 2nd byte is received while t
 653:arch/stm32/mcu_periph/i2c_arch.c ****       then a BTF occurs (I2C can not continue receiving bytes or they will get lost). During BTF I2
 654:arch/stm32/mcu_periph/i2c_arch.c ****     - in master transmit mode: when writing a byte to WD, you instantly get a new TxE interrupt whi
 655:arch/stm32/mcu_periph/i2c_arch.c ****       transmitted yet. The byte was pushed to the I2C shift register and the buffer is ready for mo
 656:arch/stm32/mcu_periph/i2c_arch.c ****       fill new data in the buffer while the first is still being transmitted for max performance tr
 657:arch/stm32/mcu_periph/i2c_arch.c **** 
 658:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: besides data buffering you can/must plan several consecutive actions. You can send 2
 659:arch/stm32/mcu_periph/i2c_arch.c ****     a new start in one go.
 660:arch/stm32/mcu_periph/i2c_arch.c **** 
 661:arch/stm32/mcu_periph/i2c_arch.c ****     - thanks to / because of this buffering and event sheduling there is not 1 interrupt per start 
 662:arch/stm32/mcu_periph/i2c_arch.c ****       This also means you must think more in advance and a transaction could be popped from the tra
 663:arch/stm32/mcu_periph/i2c_arch.c ****       stop condition is actually generated.
 664:arch/stm32/mcu_periph/i2c_arch.c **** 
 665:arch/stm32/mcu_periph/i2c_arch.c ****     // Beware: the order in which Status (and other register) is read determines how flags are clea
 666:arch/stm32/mcu_periph/i2c_arch.c ****     You should NOT simply read SR1 & SR2 every time
 667:arch/stm32/mcu_periph/i2c_arch.c **** 
 668:arch/stm32/mcu_periph/i2c_arch.c ****     If IT_EV_FEN AND IT_EV_BUF
 669:arch/stm32/mcu_periph/i2c_arch.c ****     --------------------------
 670:arch/stm32/mcu_periph/i2c_arch.c **** 
 671:arch/stm32/mcu_periph/i2c_arch.c ****     Buffer event are not always wanted and are typically switched on during longer data transfers. 
 672:arch/stm32/mcu_periph/i2c_arch.c **** 
 673:arch/stm32/mcu_periph/i2c_arch.c ****     4) RxNE
 674:arch/stm32/mcu_periph/i2c_arch.c ****     5) TxE
 675:arch/stm32/mcu_periph/i2c_arch.c **** 
 676:arch/stm32/mcu_periph/i2c_arch.c ****     -----------------------------------------------------------------------------------------------
 677:arch/stm32/mcu_periph/i2c_arch.c **** 
 678:arch/stm32/mcu_periph/i2c_arch.c ****     The STM waits indefinitely (holding SCL low) for user interaction:
 679:arch/stm32/mcu_periph/i2c_arch.c ****     a) after a master-start (waiting for address)
 680:arch/stm32/mcu_periph/i2c_arch.c ****     b) after an address (waiting for data)
 681:arch/stm32/mcu_periph/i2c_arch.c ****        not during data sending when using buffered
 682:arch/stm32/mcu_periph/i2c_arch.c ****     c) after the last byte is transmitted (waiting for either stop or restart)
 683:arch/stm32/mcu_periph/i2c_arch.c ****        not during data receiving when using buffered
 684:arch/stm32/mcu_periph/i2c_arch.c ****        not after the last byte is received
 685:arch/stm32/mcu_periph/i2c_arch.c **** 
 686:arch/stm32/mcu_periph/i2c_arch.c ****     - The STM I2C stalls indefinitely when a stop condition was attempted that
 687:arch/stm32/mcu_periph/i2c_arch.c ****       did not succeed. The BUSY flag remains on.
 688:arch/stm32/mcu_periph/i2c_arch.c ****     - There is no STOP interrupt.
 689:arch/stm32/mcu_periph/i2c_arch.c **** 
 690:arch/stm32/mcu_periph/i2c_arch.c ****     Caution Reading the status:
 691:arch/stm32/mcu_periph/i2c_arch.c ****     - Caution: this clears several flags and can start transmissions etc...
 692:arch/stm32/mcu_periph/i2c_arch.c ****     - Certain flags like STOP / (N)ACK need to be guaranteed to be set before
 693:arch/stm32/mcu_periph/i2c_arch.c ****       the transmission of the byte is finished. At higher clock rates that can be
 694:arch/stm32/mcu_periph/i2c_arch.c ****       quite fast: so we allow no other interrupt to be triggered in between
 695:arch/stm32/mcu_periph/i2c_arch.c ****       reading the status and setting all needed flags
 696:arch/stm32/mcu_periph/i2c_arch.c **** 
 697:arch/stm32/mcu_periph/i2c_arch.c ****   */
 698:arch/stm32/mcu_periph/i2c_arch.c **** 
 699:arch/stm32/mcu_periph/i2c_arch.c ****   // Here we go ...
 700:arch/stm32/mcu_periph/i2c_arch.c **** 
 701:arch/stm32/mcu_periph/i2c_arch.c ****   // Apparently we got an I2C interrupt: EVT BUF or ERR
 702:arch/stm32/mcu_periph/i2c_arch.c **** 
 703:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 704:arch/stm32/mcu_periph/i2c_arch.c ****   // Notify ISR is triggered
 705:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_ON();
 706:arch/stm32/mcu_periph/i2c_arch.c ****   LED1_OFF();
 707:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 708:arch/stm32/mcu_periph/i2c_arch.c **** 
 709:arch/stm32/mcu_periph/i2c_arch.c ****   // Save Some Direct Access to the I2C Registers ...
 710:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 711:arch/stm32/mcu_periph/i2c_arch.c **** 
 712:arch/stm32/mcu_periph/i2c_arch.c ****   /////////////////////////////
 713:arch/stm32/mcu_periph/i2c_arch.c ****   // Check if we were ready ...
 714:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->trans_extract_idx == periph->trans_insert_idx) {
 715:arch/stm32/mcu_periph/i2c_arch.c ****     // Nothing Left To Do
 716:arch/stm32/mcu_periph/i2c_arch.c **** 
 717:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 718:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
 719:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
 720:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
 721:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
 722:arch/stm32/mcu_periph/i2c_arch.c **** 
 723:arch/stm32/mcu_periph/i2c_arch.c ****     // no transaction and also an error?
 724:arch/stm32/mcu_periph/i2c_arch.c ****     LED_SHOW_ACTIVE_BITS(regs);
 725:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 726:arch/stm32/mcu_periph/i2c_arch.c **** 
 727:arch/stm32/mcu_periph/i2c_arch.c ****     // If we still get an interrupt but there are no more things to do
 728:arch/stm32/mcu_periph/i2c_arch.c ****     // (which can happen if an event was sheduled just before a bus error occurs)
 729:arch/stm32/mcu_periph/i2c_arch.c ****     // (or can happen if both error and event interrupts were called together [the 2nd will then ge
 730:arch/stm32/mcu_periph/i2c_arch.c **** 
 731:arch/stm32/mcu_periph/i2c_arch.c ****     // since there is nothing more to do: its easy: just stop: clear all interrupt generating bits
 732:arch/stm32/mcu_periph/i2c_arch.c **** 
 733:arch/stm32/mcu_periph/i2c_arch.c ****     // Count The Errors
 734:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_error(periph);
 735:arch/stm32/mcu_periph/i2c_arch.c **** 
 736:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear Running Events
 737:arch/stm32/mcu_periph/i2c_arch.c ****     stmi2c_clear_pending_interrupts(i2c);
 738:arch/stm32/mcu_periph/i2c_arch.c **** 
 739:arch/stm32/mcu_periph/i2c_arch.c ****     // Mark this as a special error
 740:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->last_unexpected_event++;
 741:arch/stm32/mcu_periph/i2c_arch.c **** 
 742:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 743:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CIdle;
 744:arch/stm32/mcu_periph/i2c_arch.c **** 
 745:arch/stm32/mcu_periph/i2c_arch.c ****     // There are no transactions anymore: return
 746:arch/stm32/mcu_periph/i2c_arch.c ****     // further-on in this routine we need a transaction pointer: so we are not allowed to continue
 747:arch/stm32/mcu_periph/i2c_arch.c ****     return;
 748:arch/stm32/mcu_periph/i2c_arch.c ****   }
 749:arch/stm32/mcu_periph/i2c_arch.c **** 
 750:arch/stm32/mcu_periph/i2c_arch.c ****   // get the I2C transaction we were working on ...
 751:arch/stm32/mcu_periph/i2c_arch.c **** 
 752:arch/stm32/mcu_periph/i2c_arch.c ****   enum STMI2CSubTransactionStatus ret = 0;
 753:arch/stm32/mcu_periph/i2c_arch.c ****   struct i2c_transaction *trans = periph->trans[periph->trans_extract_idx];
 754:arch/stm32/mcu_periph/i2c_arch.c **** 
 755:arch/stm32/mcu_periph/i2c_arch.c ****   ///////////////////////////
 756:arch/stm32/mcu_periph/i2c_arch.c ****   // If there was an error:
 757:arch/stm32/mcu_periph/i2c_arch.c ****   if ((I2C_SR1(i2c) & I2C_SR1_ERR_MASK) != 0x0000) {
 758:arch/stm32/mcu_periph/i2c_arch.c **** 
 759:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 760:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
 761:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
 762:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
 763:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
 764:arch/stm32/mcu_periph/i2c_arch.c **** 
 765:arch/stm32/mcu_periph/i2c_arch.c ****     LED_SHOW_ACTIVE_BITS(regs);
 766:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 767:arch/stm32/mcu_periph/i2c_arch.c **** 
 768:arch/stm32/mcu_periph/i2c_arch.c ****     // Notify everyone about the error ...
 769:arch/stm32/mcu_periph/i2c_arch.c **** 
 770:arch/stm32/mcu_periph/i2c_arch.c ****     // Set result in transaction
 771:arch/stm32/mcu_periph/i2c_arch.c ****     trans->status = I2CTransFailed;
 772:arch/stm32/mcu_periph/i2c_arch.c **** 
 773:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 774:arch/stm32/mcu_periph/i2c_arch.c ****     periph->status = I2CFailed;
 775:arch/stm32/mcu_periph/i2c_arch.c **** 
 776:arch/stm32/mcu_periph/i2c_arch.c ****     // Make sure a TxRx does not Restart
 777:arch/stm32/mcu_periph/i2c_arch.c ****     trans->type = I2CTransRx;
 778:arch/stm32/mcu_periph/i2c_arch.c **** 
 779:arch/stm32/mcu_periph/i2c_arch.c ****     // Count The Errors
 780:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_error(periph);
 781:arch/stm32/mcu_periph/i2c_arch.c **** 
 782:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear Running Events
 783:arch/stm32/mcu_periph/i2c_arch.c ****     stmi2c_clear_pending_interrupts(i2c);
 784:arch/stm32/mcu_periph/i2c_arch.c **** 
 785:arch/stm32/mcu_periph/i2c_arch.c ****     // Now continue as if everything was normal from now on
 786:arch/stm32/mcu_periph/i2c_arch.c ****     ret = STMI2C_SubTra_Ready;
 787:arch/stm32/mcu_periph/i2c_arch.c **** 
 788:arch/stm32/mcu_periph/i2c_arch.c ****   }
 789:arch/stm32/mcu_periph/i2c_arch.c **** 
 790:arch/stm32/mcu_periph/i2c_arch.c ****   ///////////////////////////
 791:arch/stm32/mcu_periph/i2c_arch.c ****   // Normal Event:
 792:arch/stm32/mcu_periph/i2c_arch.c ****   else {
 793:arch/stm32/mcu_periph/i2c_arch.c **** 
 794:arch/stm32/mcu_periph/i2c_arch.c ****     ///////////////////////////////////////////////////////////////////////////////////////////////
 795:arch/stm32/mcu_periph/i2c_arch.c ****     ///////////////////////////////////////////////////////////////////////////////////////////////
 796:arch/stm32/mcu_periph/i2c_arch.c ****     //
 797:arch/stm32/mcu_periph/i2c_arch.c ****     //  SUB-TRANSACTION HANDLER
 798:arch/stm32/mcu_periph/i2c_arch.c **** 
 799:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransRx) { // TxRx are converted to Rx after the Tx Part
 800:arch/stm32/mcu_periph/i2c_arch.c ****       switch (trans->len_r) {
 801:arch/stm32/mcu_periph/i2c_arch.c ****         case 1:
 802:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_read1(i2c, periph, trans);
 803:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 804:arch/stm32/mcu_periph/i2c_arch.c ****         case 2:
 805:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_read2(i2c, periph, trans);
 806:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 807:arch/stm32/mcu_periph/i2c_arch.c ****         default:
 808:arch/stm32/mcu_periph/i2c_arch.c ****           ret = stmi2c_readmany(i2c, periph, trans);
 809:arch/stm32/mcu_periph/i2c_arch.c ****           break;
 810:arch/stm32/mcu_periph/i2c_arch.c ****       }
 811:arch/stm32/mcu_periph/i2c_arch.c ****     } else { // TxRx or Tx
 812:arch/stm32/mcu_periph/i2c_arch.c ****       ret = stmi2c_send(i2c, periph, trans);
 813:arch/stm32/mcu_periph/i2c_arch.c ****     }
 814:arch/stm32/mcu_periph/i2c_arch.c ****   }
 815:arch/stm32/mcu_periph/i2c_arch.c **** 
 816:arch/stm32/mcu_periph/i2c_arch.c ****   /////////////////////////////////
 817:arch/stm32/mcu_periph/i2c_arch.c ****   // Sub-transaction has finished
 818:arch/stm32/mcu_periph/i2c_arch.c ****   if (ret != STMI2C_SubTra_Busy) {
 819:arch/stm32/mcu_periph/i2c_arch.c ****     // Ready or SubTraError
 820:arch/stm32/mcu_periph/i2c_arch.c ****     // -ready: with or without stop already asked
 821:arch/stm32/mcu_periph/i2c_arch.c **** 
 822:arch/stm32/mcu_periph/i2c_arch.c ****     // In case of unexpected event condition during subtransaction handling:
 823:arch/stm32/mcu_periph/i2c_arch.c ****     if (ret == STMI2C_SubTra_Error) {
 824:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell everyone about the subtransaction error:
 825:arch/stm32/mcu_periph/i2c_arch.c ****       // this is the previously called SPURRIOUS INTERRUPT
 826:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CFailed;
 827:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;   // Avoid possible restart
 828:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransFailed; // Notify Ready
 829:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->unexpected_event_cnt++;
 830:arch/stm32/mcu_periph/i2c_arch.c **** 
 831:arch/stm32/mcu_periph/i2c_arch.c ****       // Error
 832:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 833:arch/stm32/mcu_periph/i2c_arch.c ****       LED2_ON();
 834:arch/stm32/mcu_periph/i2c_arch.c ****       LED1_ON();
 835:arch/stm32/mcu_periph/i2c_arch.c ****       LED2_OFF();
 836:arch/stm32/mcu_periph/i2c_arch.c ****       LED1_OFF();
 837:arch/stm32/mcu_periph/i2c_arch.c **** 
 838:arch/stm32/mcu_periph/i2c_arch.c ****       LED_SHOW_ACTIVE_BITS(regs);
 839:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 840:arch/stm32/mcu_periph/i2c_arch.c **** 
 841:arch/stm32/mcu_periph/i2c_arch.c ****       // Clear Running Events
 842:arch/stm32/mcu_periph/i2c_arch.c ****       stmi2c_clear_pending_interrupts(i2c);
 843:arch/stm32/mcu_periph/i2c_arch.c ****     }
 844:arch/stm32/mcu_periph/i2c_arch.c **** 
 845:arch/stm32/mcu_periph/i2c_arch.c ****     // RxTx -> Restart and do Rx part
 846:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTxRx) {
 847:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;
 848:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CStartRequested;
 849:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_start(i2c);
 850:arch/stm32/mcu_periph/i2c_arch.c **** 
 851:arch/stm32/mcu_periph/i2c_arch.c ****       // Silent any BTF that would occur before SB
 852:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, 0x00);
 853:arch/stm32/mcu_periph/i2c_arch.c ****     }
 854:arch/stm32/mcu_periph/i2c_arch.c ****     // If a restart is not needed: Rx part or Tx-only
 855:arch/stm32/mcu_periph/i2c_arch.c ****     else {
 856:arch/stm32/mcu_periph/i2c_arch.c ****       // Ready, no stop condition set yet
 857:arch/stm32/mcu_periph/i2c_arch.c ****       if (ret == STMI2C_SubTra_Ready) {
 858:arch/stm32/mcu_periph/i2c_arch.c **** 
 859:arch/stm32/mcu_periph/i2c_arch.c ****         // Program a stop
 860:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_STOP(i2c);
 861:arch/stm32/mcu_periph/i2c_arch.c **** 
 862:arch/stm32/mcu_periph/i2c_arch.c ****         // Silent any BTF that would occur before STOP is executed
 863:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_send_data(i2c, 0x00);
 864:arch/stm32/mcu_periph/i2c_arch.c ****       }
 865:arch/stm32/mcu_periph/i2c_arch.c **** 
 866:arch/stm32/mcu_periph/i2c_arch.c ****       // Jump to the next transaction
 867:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx++;
 868:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx >= I2C_TRANSACTION_QUEUE_LEN) {
 869:arch/stm32/mcu_periph/i2c_arch.c ****         periph->trans_extract_idx = 0;
 870:arch/stm32/mcu_periph/i2c_arch.c ****       }
 871:arch/stm32/mcu_periph/i2c_arch.c **** 
 872:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell everyone we are ready
 873:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
 874:arch/stm32/mcu_periph/i2c_arch.c **** 
 875:arch/stm32/mcu_periph/i2c_arch.c **** 
 876:arch/stm32/mcu_periph/i2c_arch.c ****       // if we have no more transaction to process, stop here
 877:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx == periph->trans_insert_idx) {
 878:arch/stm32/mcu_periph/i2c_arch.c **** 
 879:arch/stm32/mcu_periph/i2c_arch.c ****         periph->watchdog = -1; // stop watchdog
 880:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 881:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_ON();
 882:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_ON();
 883:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_OFF();
 884:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_ON();
 885:arch/stm32/mcu_periph/i2c_arch.c ****         LED1_OFF();
 886:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_OFF();
 887:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 888:arch/stm32/mcu_periph/i2c_arch.c ****       }
 889:arch/stm32/mcu_periph/i2c_arch.c ****       // if not, start next transaction
 890:arch/stm32/mcu_periph/i2c_arch.c ****       else {
 891:arch/stm32/mcu_periph/i2c_arch.c ****         // Restart transaction doing the Rx part now
 892:arch/stm32/mcu_periph/i2c_arch.c ****         // --- moved to idle function
 893:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_START(periph);
 894:arch/stm32/mcu_periph/i2c_arch.c ****         // ------
 895:arch/stm32/mcu_periph/i2c_arch.c ****       }
 896:arch/stm32/mcu_periph/i2c_arch.c ****     }
 897:arch/stm32/mcu_periph/i2c_arch.c ****   }
 898:arch/stm32/mcu_periph/i2c_arch.c **** 
 899:arch/stm32/mcu_periph/i2c_arch.c ****   return;
 900:arch/stm32/mcu_periph/i2c_arch.c **** }
 901:arch/stm32/mcu_periph/i2c_arch.c **** 
 902:arch/stm32/mcu_periph/i2c_arch.c **** 
 903:arch/stm32/mcu_periph/i2c_arch.c **** /*
 904:arch/stm32/mcu_periph/i2c_arch.c **** // Make sure the bus is free before resetting (p722)
 905:arch/stm32/mcu_periph/i2c_arch.c **** if (regs->SR2 & (I2C_FLAG_BUSY >> 16)) {
 906:arch/stm32/mcu_periph/i2c_arch.c **** // Reset the I2C block
 907:arch/stm32/mcu_periph/i2c_arch.c **** I2C_SoftwareResetCmd(periph->reg_addr, ENABLE);
 908:arch/stm32/mcu_periph/i2c_arch.c **** I2C_SoftwareResetCmd(periph->reg_addr, DISABLE);
 909:arch/stm32/mcu_periph/i2c_arch.c **** }
 910:arch/stm32/mcu_periph/i2c_arch.c **** */
 911:arch/stm32/mcu_periph/i2c_arch.c **** 
 912:arch/stm32/mcu_periph/i2c_arch.c **** 
 913:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C0
 914:arch/stm32/mcu_periph/i2c_arch.c **** #error "The STM32 doesn't have I2C0, use I2C1 or I2C2"
 915:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 916:arch/stm32/mcu_periph/i2c_arch.c **** 
 917:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 918:arch/stm32/mcu_periph/i2c_arch.c **** 
 919:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C1 clock speed */
 920:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C1_CLOCK_SPEED
 921:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C1_CLOCK_SPEED 200000
 922:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 923:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C1_CLOCK_SPEED)
 924:arch/stm32/mcu_periph/i2c_arch.c **** 
 925:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c1_errors;
 926:arch/stm32/mcu_periph/i2c_arch.c **** 
 927:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_hw_init(void)
 928:arch/stm32/mcu_periph/i2c_arch.c **** {
 929:arch/stm32/mcu_periph/i2c_arch.c **** 
 930:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.reg_addr = (void *)I2C1;
 931:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.init_struct = NULL;
 932:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.errors = &i2c1_errors;
 933:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = -1;
 934:arch/stm32/mcu_periph/i2c_arch.c **** 
 935:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
 936:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c1_errors);
 937:arch/stm32/mcu_periph/i2c_arch.c **** 
 938:arch/stm32/mcu_periph/i2c_arch.c ****   // Extra
 939:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 940:arch/stm32/mcu_periph/i2c_arch.c ****   LED_INIT();
 941:arch/stm32/mcu_periph/i2c_arch.c **** #else
 942:arch/stm32/mcu_periph/i2c_arch.c **** 
 943:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
 944:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C1);
 945:arch/stm32/mcu_periph/i2c_arch.c **** 
 946:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C1 event interrupt --------------------------------*/
 947:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C1_EV_IRQ, NVIC_I2C1_IRQ_PRIO);
 948:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_EV_IRQ);
 949:arch/stm32/mcu_periph/i2c_arch.c **** 
 950:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C1 err interrupt ----------------------------------*/
 951:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C1_ER_IRQ, NVIC_I2C1_IRQ_PRIO + 1);
 952:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_ER_IRQ);
 953:arch/stm32/mcu_periph/i2c_arch.c **** 
 954:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
 955:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C1 clock */
 956:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C1);
 957:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
 958:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C1);
 959:arch/stm32/mcu_periph/i2c_arch.c **** 
 960:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C1);
 961:arch/stm32/mcu_periph/i2c_arch.c **** 
 962:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
 963:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C1);
 964:arch/stm32/mcu_periph/i2c_arch.c **** 
 965:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C1, 0);
 966:arch/stm32/mcu_periph/i2c_arch.c **** 
 967:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
 968:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C1, I2C_CR2_ITERREN);
 969:arch/stm32/mcu_periph/i2c_arch.c **** 
 970:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c1, I2C1_CLOCK_SPEED);
 971:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 972:arch/stm32/mcu_periph/i2c_arch.c **** }
 973:arch/stm32/mcu_periph/i2c_arch.c **** 
 974:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_ev_isr(void)
 975:arch/stm32/mcu_periph/i2c_arch.c **** {
 976:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 977:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 978:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 979:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);;
 980:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 981:arch/stm32/mcu_periph/i2c_arch.c **** }
 982:arch/stm32/mcu_periph/i2c_arch.c **** 
 983:arch/stm32/mcu_periph/i2c_arch.c **** void i2c1_er_isr(void)
 984:arch/stm32/mcu_periph/i2c_arch.c **** {
 985:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 986:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 987:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 988:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);
 989:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 990:arch/stm32/mcu_periph/i2c_arch.c **** }
 991:arch/stm32/mcu_periph/i2c_arch.c **** 
 992:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C1 */
 993:arch/stm32/mcu_periph/i2c_arch.c **** 
 994:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
 995:arch/stm32/mcu_periph/i2c_arch.c **** 
 996:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C2 clock speed */
 997:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C2_CLOCK_SPEED
 998:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C2_CLOCK_SPEED 300000
 999:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1000:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C2_CLOCK_SPEED)
1001:arch/stm32/mcu_periph/i2c_arch.c **** 
1002:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c2_errors;
1003:arch/stm32/mcu_periph/i2c_arch.c **** 
1004:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_hw_init(void)
1005:arch/stm32/mcu_periph/i2c_arch.c **** {
1006:arch/stm32/mcu_periph/i2c_arch.c **** 
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.reg_addr = (void *)I2C2;
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
1010:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
1011:arch/stm32/mcu_periph/i2c_arch.c **** 
1012:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
1013:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c2_errors);
1014:arch/stm32/mcu_periph/i2c_arch.c **** 
1015:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
1016:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C2);
1017:arch/stm32/mcu_periph/i2c_arch.c **** 
1018:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C2 event interrupt --------------------------------*/
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_EV_IRQ, NVIC_I2C2_IRQ_PRIO);
1020:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_EV_IRQ);
1021:arch/stm32/mcu_periph/i2c_arch.c **** 
1022:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C2 err interrupt ----------------------------------*/
1023:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C2_ER_IRQ, NVIC_I2C2_IRQ_PRIO + 1);
1024:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_ER_IRQ);
1025:arch/stm32/mcu_periph/i2c_arch.c **** 
1026:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
1027:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C2 clock */
1028:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C2);
1029:arch/stm32/mcu_periph/i2c_arch.c **** 
1030:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
1031:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C2);
1032:arch/stm32/mcu_periph/i2c_arch.c **** 
1033:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C2);
1034:arch/stm32/mcu_periph/i2c_arch.c **** 
1035:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
1036:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C2);
1037:arch/stm32/mcu_periph/i2c_arch.c **** 
1038:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C2, 0);
1039:arch/stm32/mcu_periph/i2c_arch.c **** 
1040:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
1041:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C2, I2C_CR2_ITERREN);
1042:arch/stm32/mcu_periph/i2c_arch.c **** 
1043:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c2, I2C2_CLOCK_SPEED);
1044:arch/stm32/mcu_periph/i2c_arch.c **** }
1045:arch/stm32/mcu_periph/i2c_arch.c **** 
1046:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_ev_isr(void)
1047:arch/stm32/mcu_periph/i2c_arch.c **** {
1048:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
1049:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
1050:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
1051:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
1052:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
1053:arch/stm32/mcu_periph/i2c_arch.c **** }
1054:arch/stm32/mcu_periph/i2c_arch.c **** 
1055:arch/stm32/mcu_periph/i2c_arch.c **** void i2c2_er_isr(void)
1056:arch/stm32/mcu_periph/i2c_arch.c **** {
1057:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
1058:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
1059:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
1060:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
1061:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
1062:arch/stm32/mcu_periph/i2c_arch.c **** }
1063:arch/stm32/mcu_periph/i2c_arch.c **** 
1064:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C2 */
1065:arch/stm32/mcu_periph/i2c_arch.c **** 
1066:arch/stm32/mcu_periph/i2c_arch.c **** 
1067:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3 && defined STM32F4
1068:arch/stm32/mcu_periph/i2c_arch.c **** 
1069:arch/stm32/mcu_periph/i2c_arch.c **** /** default I2C3 clock speed */
1070:arch/stm32/mcu_periph/i2c_arch.c **** #ifndef I2C3_CLOCK_SPEED
1071:arch/stm32/mcu_periph/i2c_arch.c **** #define I2C3_CLOCK_SPEED 300000
1072:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1073:arch/stm32/mcu_periph/i2c_arch.c **** PRINT_CONFIG_VAR(I2C3_CLOCK_SPEED)
1074:arch/stm32/mcu_periph/i2c_arch.c **** 
1075:arch/stm32/mcu_periph/i2c_arch.c **** struct i2c_errors i2c3_errors;
1076:arch/stm32/mcu_periph/i2c_arch.c **** 
1077:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_hw_init(void)
1078:arch/stm32/mcu_periph/i2c_arch.c **** {
1079:arch/stm32/mcu_periph/i2c_arch.c **** 
1080:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.reg_addr = (void *)I2C3;
1081:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.init_struct = NULL;
1082:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.errors = &i2c3_errors;
1083:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = -1;
1084:arch/stm32/mcu_periph/i2c_arch.c **** 
1085:arch/stm32/mcu_periph/i2c_arch.c ****   /* zeros error counter */
1086:arch/stm32/mcu_periph/i2c_arch.c ****   ZEROS_ERR_COUNTER(i2c3_errors);
1087:arch/stm32/mcu_periph/i2c_arch.c **** 
1088:arch/stm32/mcu_periph/i2c_arch.c ****   /* reset peripheral to default state ( sometimes not achieved on reset :(  ) */
1089:arch/stm32/mcu_periph/i2c_arch.c ****   //rcc_periph_reset_pulse(RST_I2C3);
1090:arch/stm32/mcu_periph/i2c_arch.c **** 
1091:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C3 event interrupt --------------------------------*/
1092:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C3_EV_IRQ, NVIC_I2C3_IRQ_PRIO);
1093:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C3_EV_IRQ);
1094:arch/stm32/mcu_periph/i2c_arch.c **** 
1095:arch/stm32/mcu_periph/i2c_arch.c ****   /* Configure and enable I2C3 err interrupt ----------------------------------*/
1096:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_set_priority(NVIC_I2C3_ER_IRQ, NVIC_I2C3_IRQ_PRIO + 1);
1097:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C3_ER_IRQ);
1098:arch/stm32/mcu_periph/i2c_arch.c **** 
1099:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable peripheral clocks -------------------------------------------------*/
1100:arch/stm32/mcu_periph/i2c_arch.c ****   /* Enable I2C3 clock */
1101:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_clock_enable(RCC_I2C3);
1102:arch/stm32/mcu_periph/i2c_arch.c **** 
1103:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
1104:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setup_gpio(I2C3);
1105:arch/stm32/mcu_periph/i2c_arch.c **** 
1106:arch/stm32/mcu_periph/i2c_arch.c ****   rcc_periph_reset_pulse(RST_I2C3);
1107:arch/stm32/mcu_periph/i2c_arch.c **** 
1108:arch/stm32/mcu_periph/i2c_arch.c ****   // enable peripheral
1109:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_peripheral_enable(I2C3);
1110:arch/stm32/mcu_periph/i2c_arch.c **** 
1111:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_set_own_7bit_slave_address(I2C3, 0);
1112:arch/stm32/mcu_periph/i2c_arch.c **** 
1113:arch/stm32/mcu_periph/i2c_arch.c ****   // enable error interrupts
1114:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(I2C3, I2C_CR2_ITERREN);
1115:arch/stm32/mcu_periph/i2c_arch.c **** 
1116:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_setbitrate(&i2c3, I2C3_CLOCK_SPEED);
1117:arch/stm32/mcu_periph/i2c_arch.c **** }
1118:arch/stm32/mcu_periph/i2c_arch.c **** 
1119:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_ev_isr(void)
1120:arch/stm32/mcu_periph/i2c_arch.c **** {
1121:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c3.reg_addr;
1122:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
1123:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = 0; // restart watchdog
1124:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c3);
1125:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
1126:arch/stm32/mcu_periph/i2c_arch.c **** }
1127:arch/stm32/mcu_periph/i2c_arch.c **** 
1128:arch/stm32/mcu_periph/i2c_arch.c **** void i2c3_er_isr(void)
1129:arch/stm32/mcu_periph/i2c_arch.c **** {
1130:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c3.reg_addr;
1131:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
1132:arch/stm32/mcu_periph/i2c_arch.c ****   I2C_CR2(i2c) &= ~I2C_CR2_ITEVTEN;
1133:arch/stm32/mcu_periph/i2c_arch.c ****   i2c3.watchdog = 0;  // restart watchdog
1134:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c3);
1135:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
1136:arch/stm32/mcu_periph/i2c_arch.c **** }
1137:arch/stm32/mcu_periph/i2c_arch.c **** 
1138:arch/stm32/mcu_periph/i2c_arch.c **** #endif /* USE_I2C3 */
1139:arch/stm32/mcu_periph/i2c_arch.c **** 
1140:arch/stm32/mcu_periph/i2c_arch.c **** //////////////////////////////////////////////////
1141:arch/stm32/mcu_periph/i2c_arch.c **** // Set Bitrate to Match your application:
1142:arch/stm32/mcu_periph/i2c_arch.c **** // -short wires, low capacitance bus: IMU: high speed
1143:arch/stm32/mcu_periph/i2c_arch.c **** // -long wires with a lot of capacitance: motor controller: put speed as low as possible
1144:arch/stm32/mcu_periph/i2c_arch.c **** 
1145:arch/stm32/mcu_periph/i2c_arch.c **** void i2c_setbitrate(struct i2c_periph *periph, int bitrate)
1146:arch/stm32/mcu_periph/i2c_arch.c **** {
1147:arch/stm32/mcu_periph/i2c_arch.c ****   // If NOT Busy
1148:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c_idle(periph)) {
1149:arch/stm32/mcu_periph/i2c_arch.c ****     volatile int devider;
1150:arch/stm32/mcu_periph/i2c_arch.c ****     volatile int risetime;
1151:arch/stm32/mcu_periph/i2c_arch.c **** 
1152:arch/stm32/mcu_periph/i2c_arch.c ****     uint32_t i2c = (uint32_t) periph->reg_addr;
1153:arch/stm32/mcu_periph/i2c_arch.c **** 
1154:arch/stm32/mcu_periph/i2c_arch.c ****     /*****************************************************
1155:arch/stm32/mcu_periph/i2c_arch.c ****     Bitrate:
1156:arch/stm32/mcu_periph/i2c_arch.c **** 
1157:arch/stm32/mcu_periph/i2c_arch.c ****     -CR2 + CCR + TRISE registers
1158:arch/stm32/mcu_periph/i2c_arch.c ****     -only change when PE=0
1159:arch/stm32/mcu_periph/i2c_arch.c **** 
1160:arch/stm32/mcu_periph/i2c_arch.c ****     e.g.
1161:arch/stm32/mcu_periph/i2c_arch.c **** 
1162:arch/stm32/mcu_periph/i2c_arch.c ****     10kHz:  36MHz + Standard 0x708 + 0x25
1163:arch/stm32/mcu_periph/i2c_arch.c ****     70kHz:  36MHz + Standard 0x101 +
1164:arch/stm32/mcu_periph/i2c_arch.c ****     400kHz: 36MHz + Fast 0x1E      + 0xb
1165:arch/stm32/mcu_periph/i2c_arch.c **** 
1166:arch/stm32/mcu_periph/i2c_arch.c ****     // 1) Program peripheral input clock CR2: to get correct timings
1167:arch/stm32/mcu_periph/i2c_arch.c ****     // 2) Configure clock control registers
1168:arch/stm32/mcu_periph/i2c_arch.c ****     // 3) Configure rise time register
1169:arch/stm32/mcu_periph/i2c_arch.c ****     ******************************************************/
1170:arch/stm32/mcu_periph/i2c_arch.c **** 
1171:arch/stm32/mcu_periph/i2c_arch.c ****     if (bitrate < 3000) {
1172:arch/stm32/mcu_periph/i2c_arch.c ****       bitrate = 3000;
1173:arch/stm32/mcu_periph/i2c_arch.c ****     }
1174:arch/stm32/mcu_periph/i2c_arch.c **** 
1175:arch/stm32/mcu_periph/i2c_arch.c ****     // rcc_apb1_frequency is normally configured to max: 36MHz on F1 and 42MHz on F4
1176:arch/stm32/mcu_periph/i2c_arch.c ****     // in fast mode: 2counts low 1 count high -> / 3:
1177:arch/stm32/mcu_periph/i2c_arch.c ****     // in standard mode: 1 count low, 1 count high -> /2:
1178:arch/stm32/mcu_periph/i2c_arch.c ****     devider = (rcc_apb1_frequency / 2000) / (bitrate / 1000);
1179:arch/stm32/mcu_periph/i2c_arch.c **** 
1180:arch/stm32/mcu_periph/i2c_arch.c ****     // never allow faster than 600kbps
1181:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider < 20) {
1182:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 20;
1183:arch/stm32/mcu_periph/i2c_arch.c ****     }
1184:arch/stm32/mcu_periph/i2c_arch.c **** 
1185:arch/stm32/mcu_periph/i2c_arch.c ****     // no overflow either
1186:arch/stm32/mcu_periph/i2c_arch.c ****     if (devider >= 4095) {
1187:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 4095;
1188:arch/stm32/mcu_periph/i2c_arch.c ****     }
1189:arch/stm32/mcu_periph/i2c_arch.c **** 
1190:arch/stm32/mcu_periph/i2c_arch.c ****     // risetime can be up to 1/6th of the period
1191:arch/stm32/mcu_periph/i2c_arch.c ****     risetime = 1000000 / (bitrate / 1000) / 6 / 28;
1192:arch/stm32/mcu_periph/i2c_arch.c **** 
1193:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime < 10) {
1194:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 10;
1195:arch/stm32/mcu_periph/i2c_arch.c ****     }
1196:arch/stm32/mcu_periph/i2c_arch.c **** 
1197:arch/stm32/mcu_periph/i2c_arch.c ****     // more will overflow the register: for more you should lower the FREQ
1198:arch/stm32/mcu_periph/i2c_arch.c ****     if (risetime >= 31) {
1199:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 31;
1200:arch/stm32/mcu_periph/i2c_arch.c ****     }
1201:arch/stm32/mcu_periph/i2c_arch.c **** 
1202:arch/stm32/mcu_periph/i2c_arch.c ****     // we do not expect an interrupt as the interface should have been idle, but just in case...
1203:arch/stm32/mcu_periph/i2c_arch.c ****     __disable_irq(); // this code is in user space:
1204:arch/stm32/mcu_periph/i2c_arch.c **** 
1205:arch/stm32/mcu_periph/i2c_arch.c ****     // CCR can only be written when PE is disabled
1206:arch/stm32/mcu_periph/i2c_arch.c ****     // p731 note 5
1207:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_disable(i2c);
1208:arch/stm32/mcu_periph/i2c_arch.c **** 
1209:arch/stm32/mcu_periph/i2c_arch.c ****     // 1)
1210:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef STM32F1
1211:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_clock_frequency(i2c, I2C_CR2_FREQ_36MHZ);
1212:arch/stm32/mcu_periph/i2c_arch.c **** #else // STM32F4
1213:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_clock_frequency(i2c, I2C_CR2_FREQ_42MHZ);
1214:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1215:arch/stm32/mcu_periph/i2c_arch.c ****     // 2)
1216:arch/stm32/mcu_periph/i2c_arch.c ****     //i2c_set_fast_mode(i2c);
1217:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_ccr(i2c, devider);
1218:arch/stm32/mcu_periph/i2c_arch.c ****     // 3)
1219:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_set_trise(i2c, risetime);
1220:arch/stm32/mcu_periph/i2c_arch.c **** 
1221:arch/stm32/mcu_periph/i2c_arch.c ****     // Re-Enable
1222:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_peripheral_enable(i2c);
1223:arch/stm32/mcu_periph/i2c_arch.c **** 
1224:arch/stm32/mcu_periph/i2c_arch.c ****     __enable_irq();
1225:arch/stm32/mcu_periph/i2c_arch.c **** 
1226:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1227:arch/stm32/mcu_periph/i2c_arch.c ****     __disable_irq(); // this code is in user space:
1228:arch/stm32/mcu_periph/i2c_arch.c **** 
1229:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
1230:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
1231:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
1232:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
1233:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_ON();
1234:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_ON();
1235:arch/stm32/mcu_periph/i2c_arch.c ****     LED2_OFF();
1236:arch/stm32/mcu_periph/i2c_arch.c ****     LED1_OFF();
1237:arch/stm32/mcu_periph/i2c_arch.c **** 
1238:arch/stm32/mcu_periph/i2c_arch.c ****     __enable_irq();
1239:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1240:arch/stm32/mcu_periph/i2c_arch.c **** 
1241:arch/stm32/mcu_periph/i2c_arch.c ****   }
1242:arch/stm32/mcu_periph/i2c_arch.c **** }
1243:arch/stm32/mcu_periph/i2c_arch.c **** 
1244:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1 || USE_I2C2 || USE_I2C3
1245:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_scl_set(uint32_t i2c)
1246:arch/stm32/mcu_periph/i2c_arch.c **** {
1247:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1248:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C1) {
1249:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
1250:arch/stm32/mcu_periph/i2c_arch.c ****   }
1251:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1252:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1253:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
1254:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
1255:arch/stm32/mcu_periph/i2c_arch.c ****   }
1256:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1257:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1258:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C3) {
1259:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1260:arch/stm32/mcu_periph/i2c_arch.c ****   }
1261:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1262:arch/stm32/mcu_periph/i2c_arch.c **** }
1263:arch/stm32/mcu_periph/i2c_arch.c **** 
1264:arch/stm32/mcu_periph/i2c_arch.c **** static inline void i2c_scl_clear(uint32_t i2c)
1265:arch/stm32/mcu_periph/i2c_arch.c **** {
 513              		.loc 1 1265 0
 514              		.cfi_startproc
 515              		@ args = 0, pretend = 0, frame = 0
 516              		@ frame_needed = 0, uses_anonymous_args = 0
 517              		@ link register save eliminated.
 518              	.LVL38:
1266:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1267:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C1) {
 519              		.loc 1 1267 0
 520 0000 074B     		ldr	r3, .L59
 521 0002 9842     		cmp	r0, r3
 522 0004 03D1     		bne	.L56
1268:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
 523              		.loc 1 1268 0
 524 0006 0748     		ldr	r0, .L59+4
 525              	.LVL39:
 526 0008 4FF48071 		mov	r1, #256
 527 000c 05E0     		b	.L58
 528              	.LVL40:
 529              	.L56:
1269:arch/stm32/mcu_periph/i2c_arch.c ****   }
1270:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1271:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1272:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C2) {
 530              		.loc 1 1272 0
 531 000e 064B     		ldr	r3, .L59+8
 532 0010 9842     		cmp	r0, r3
 533 0012 04D1     		bne	.L55
 534              	.LVL41:
 535              	.LBB73:
 536              	.LBB74:
1273:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 537              		.loc 1 1273 0
 538 0014 0348     		ldr	r0, .L59+4
 539              	.LVL42:
 540 0016 4FF48061 		mov	r1, #1024
 541              	.LVL43:
 542              	.L58:
 543 001a FFF7FEBF 		b	gpio_clear
 544              	.LVL44:
 545              	.L55:
 546 001e 7047     		bx	lr
 547              	.L60:
 548              		.align	2
 549              	.L59:
 550 0020 00540040 		.word	1073763328
 551 0024 00040240 		.word	1073873920
 552 0028 00580040 		.word	1073764352
 553              	.LBE74:
 554              	.LBE73:
 555              		.cfi_endproc
 556              	.LFE25:
 558              		.section	.text.i2c_scl_set,"ax",%progbits
 559              		.align	1
 560              		.thumb
 561              		.thumb_func
 563              	i2c_scl_set:
 564              	.LFB24:
1246:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
 565              		.loc 1 1246 0
 566              		.cfi_startproc
 567              		@ args = 0, pretend = 0, frame = 0
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              		@ link register save eliminated.
 570              	.LVL45:
1248:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
 571              		.loc 1 1248 0
 572 0000 074B     		ldr	r3, .L65
 573 0002 9842     		cmp	r0, r3
 574 0004 03D1     		bne	.L62
1249:arch/stm32/mcu_periph/i2c_arch.c ****   }
 575              		.loc 1 1249 0
 576 0006 0748     		ldr	r0, .L65+4
 577              	.LVL46:
 578 0008 4FF48071 		mov	r1, #256
 579 000c 05E0     		b	.L64
 580              	.LVL47:
 581              	.L62:
1253:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_set(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 582              		.loc 1 1253 0
 583 000e 064B     		ldr	r3, .L65+8
 584 0010 9842     		cmp	r0, r3
 585 0012 04D1     		bne	.L61
 586              	.LVL48:
 587              	.LBB77:
 588              	.LBB78:
1254:arch/stm32/mcu_periph/i2c_arch.c ****   }
 589              		.loc 1 1254 0
 590 0014 0348     		ldr	r0, .L65+4
 591              	.LVL49:
 592 0016 4FF48061 		mov	r1, #1024
 593              	.LVL50:
 594              	.L64:
 595 001a FFF7FEBF 		b	gpio_set
 596              	.LVL51:
 597              	.L61:
 598 001e 7047     		bx	lr
 599              	.L66:
 600              		.align	2
 601              	.L65:
 602 0020 00540040 		.word	1073763328
 603 0024 00040240 		.word	1073873920
 604 0028 00580040 		.word	1073764352
 605              	.LBE78:
 606              	.LBE77:
 607              		.cfi_endproc
 608              	.LFE24:
 610              		.section	.text.i2c_wd_check,"ax",%progbits
 611              		.align	1
 612              		.thumb
 613              		.thumb_func
 615              	i2c_wd_check:
 616              	.LFB26:
1274:arch/stm32/mcu_periph/i2c_arch.c ****   }
1275:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1276:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1277:arch/stm32/mcu_periph/i2c_arch.c ****   if (i2c == I2C3) {
1278:arch/stm32/mcu_periph/i2c_arch.c ****     gpio_clear(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1279:arch/stm32/mcu_periph/i2c_arch.c ****   }
1280:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1281:arch/stm32/mcu_periph/i2c_arch.c **** }
1282:arch/stm32/mcu_periph/i2c_arch.c **** 
1283:arch/stm32/mcu_periph/i2c_arch.c **** #define WD_DELAY 20           // number of ticks with 2ms - 40ms delay before resetting the bus
1284:arch/stm32/mcu_periph/i2c_arch.c **** #define WD_RECOVERY_TICKS 10  // number of generated SCL clocking pulses
1285:arch/stm32/mcu_periph/i2c_arch.c **** 
1286:arch/stm32/mcu_periph/i2c_arch.c **** static void i2c_wd_check(struct i2c_periph *periph)
1287:arch/stm32/mcu_periph/i2c_arch.c **** {
 617              		.loc 1 1287 0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 0
 620              		@ frame_needed = 0, uses_anonymous_args = 0
 621              	.LVL52:
1288:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
1289:arch/stm32/mcu_periph/i2c_arch.c **** 
1290:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog > WD_DELAY) {
 622              		.loc 1 1290 0
 623 0000 038E     		ldrh	r3, [r0, #48]
 624 0002 1BB2     		sxth	r3, r3
 625 0004 142B     		cmp	r3, #20
1287:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 626              		.loc 1 1287 0
 627 0006 70B5     		push	{r4, r5, r6, lr}
 628              		.cfi_def_cfa_offset 16
 629              		.cfi_offset 4, -16
 630              		.cfi_offset 5, -12
 631              		.cfi_offset 6, -8
 632              		.cfi_offset 14, -4
1287:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 633              		.loc 1 1287 0
 634 0008 0446     		mov	r4, r0
1288:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
 635              		.loc 1 1288 0
 636 000a 456A     		ldr	r5, [r0, #36]
 637              	.LVL53:
 638              		.loc 1 1290 0
 639 000c 59DD     		ble	.L68
1291:arch/stm32/mcu_periph/i2c_arch.c ****     if (periph->watchdog == WD_DELAY + 1) {
 640              		.loc 1 1291 0
 641 000e 038E     		ldrh	r3, [r0, #48]
 642 0010 1BB2     		sxth	r3, r3
 643 0012 152B     		cmp	r3, #21
 644 0014 26D1     		bne	.L69
1292:arch/stm32/mcu_periph/i2c_arch.c **** 
1293:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 645              		.loc 1 1293 0
 646 0016 2846     		mov	r0, r5
 647              	.LVL54:
 648 0018 4FF40071 		mov	r1, #512
 649 001c FFF7FEFF 		bl	i2c_disable_interrupt
 650              	.LVL55:
1294:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 651              		.loc 1 1294 0
 652 0020 2846     		mov	r0, r5
 653 0022 4FF48071 		mov	r1, #256
 654 0026 FFF7FEFF 		bl	i2c_disable_interrupt
 655              	.LVL56:
1295:arch/stm32/mcu_periph/i2c_arch.c **** 
1296:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_disable(i2c);
 656              		.loc 1 1296 0
 657 002a 2846     		mov	r0, r5
 658 002c FFF7FEFF 		bl	i2c_peripheral_disable
 659              	.LVL57:
1297:arch/stm32/mcu_periph/i2c_arch.c **** 
1298:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1299:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C1) {
 660              		.loc 1 1299 0
 661 0030 284B     		ldr	r3, .L77
 662 0032 9D42     		cmp	r5, r3
 663 0034 07D1     		bne	.L70
1300:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C1_GPIO_PORT, I2C1_GPIO_SCL);
 664              		.loc 1 1300 0
 665 0036 2848     		ldr	r0, .L77+4
 666 0038 4FF48071 		mov	r1, #256
 667 003c FFF7FEFF 		bl	gpio_setup_output
 668              	.LVL58:
1301:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C1_GPIO_PORT, I2C1_GPIO_SDA);
 669              		.loc 1 1301 0
 670 0040 2548     		ldr	r0, .L77+4
 671 0042 8021     		movs	r1, #128
 672 0044 0AE0     		b	.L75
 673              	.L70:
1302:arch/stm32/mcu_periph/i2c_arch.c ****       }
1303:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1304:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1305:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C2) {
 674              		.loc 1 1305 0
 675 0046 254B     		ldr	r3, .L77+8
 676 0048 9D42     		cmp	r5, r3
 677 004a 09D1     		bne	.L71
1306:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C2_GPIO_PORT, I2C2_GPIO_SCL);
 678              		.loc 1 1306 0
 679 004c 2248     		ldr	r0, .L77+4
 680 004e 4FF48061 		mov	r1, #1024
 681 0052 FFF7FEFF 		bl	gpio_setup_output
 682              	.LVL59:
1307:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C2_GPIO_PORT, I2C2_GPIO_SDA);
 683              		.loc 1 1307 0
 684 0056 2048     		ldr	r0, .L77+4
 685 0058 4FF40061 		mov	r1, #2048
 686              	.L75:
 687 005c FFF7FEFF 		bl	gpio_setup_input
 688              	.LVL60:
 689              	.L71:
1308:arch/stm32/mcu_periph/i2c_arch.c ****       }
1309:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1310:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1311:arch/stm32/mcu_periph/i2c_arch.c ****       if (i2c == I2C3) {
1312:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_output(I2C3_GPIO_PORT_SCL, I2C3_GPIO_SCL);
1313:arch/stm32/mcu_periph/i2c_arch.c ****         gpio_setup_input(I2C3_GPIO_PORT_SDA, I2C3_GPIO_SDA);
1314:arch/stm32/mcu_periph/i2c_arch.c ****       }
1315:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1316:arch/stm32/mcu_periph/i2c_arch.c **** 
1317:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_scl_clear(i2c);
 690              		.loc 1 1317 0
 691 0060 2846     		mov	r0, r5
 692 0062 07E0     		b	.L76
 693              	.LVL61:
 694              	.L69:
1318:arch/stm32/mcu_periph/i2c_arch.c ****     } else if (periph->watchdog < WD_DELAY + WD_RECOVERY_TICKS) {
 695              		.loc 1 1318 0
 696 0064 038E     		ldrh	r3, [r0, #48]
 697 0066 1BB2     		sxth	r3, r3
 698 0068 1D2B     		cmp	r3, #29
 699 006a 09DC     		bgt	.L72
1319:arch/stm32/mcu_periph/i2c_arch.c ****       if ((periph->watchdog - WD_DELAY) % 2) {
 700              		.loc 1 1319 0
 701 006c 038E     		ldrh	r3, [r0, #48]
 702 006e DB07     		lsls	r3, r3, #31
1320:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_scl_clear(i2c);
 703              		.loc 1 1320 0
 704 0070 2846     		mov	r0, r5
 705              	.LVL62:
1319:arch/stm32/mcu_periph/i2c_arch.c ****       if ((periph->watchdog - WD_DELAY) % 2) {
 706              		.loc 1 1319 0
 707 0072 02D5     		bpl	.L73
 708              	.LVL63:
 709              	.L76:
 710              		.loc 1 1320 0
 711 0074 FFF7FEFF 		bl	i2c_scl_clear
 712              	.LVL64:
 713 0078 23E0     		b	.L68
 714              	.LVL65:
 715              	.L73:
1321:arch/stm32/mcu_periph/i2c_arch.c ****       } else {
1322:arch/stm32/mcu_periph/i2c_arch.c ****         i2c_scl_set(i2c);
 716              		.loc 1 1322 0
 717 007a FFF7FEFF 		bl	i2c_scl_set
 718              	.LVL66:
 719 007e 20E0     		b	.L68
 720              	.LVL67:
 721              	.L72:
1323:arch/stm32/mcu_periph/i2c_arch.c ****       }
1324:arch/stm32/mcu_periph/i2c_arch.c ****     } else {
1325:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_scl_set(i2c);
 722              		.loc 1 1325 0
 723 0080 2846     		mov	r0, r5
 724              	.LVL68:
 725 0082 FFF7FEFF 		bl	i2c_scl_set
 726              	.LVL69:
1326:arch/stm32/mcu_periph/i2c_arch.c **** 
1327:arch/stm32/mcu_periph/i2c_arch.c ****       /* setup gpios for normal i2c operation again */
1328:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_setup_gpio(i2c);
1329:arch/stm32/mcu_periph/i2c_arch.c **** 
1330:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_insert_idx = 0;
 727              		.loc 1 1330 0
 728 0086 0026     		movs	r6, #0
1328:arch/stm32/mcu_periph/i2c_arch.c **** 
 729              		.loc 1 1328 0
 730 0088 2846     		mov	r0, r5
 731 008a FFF7FEFF 		bl	i2c_setup_gpio
 732              	.LVL70:
1331:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx = 0;
1332:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CIdle;
1333:arch/stm32/mcu_periph/i2c_arch.c **** 
1334:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 733              		.loc 1 1334 0
 734 008e 2846     		mov	r0, r5
 735 0090 4FF40071 		mov	r1, #512
1330:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx = 0;
 736              		.loc 1 1330 0
 737 0094 84F82060 		strb	r6, [r4, #32]
1331:arch/stm32/mcu_periph/i2c_arch.c ****       periph->trans_extract_idx = 0;
 738              		.loc 1 1331 0
 739 0098 84F82160 		strb	r6, [r4, #33]
1332:arch/stm32/mcu_periph/i2c_arch.c **** 
 740              		.loc 1 1332 0
 741 009c 84F82260 		strb	r6, [r4, #34]
 742              		.loc 1 1334 0
 743 00a0 FFF7FEFF 		bl	i2c_enable_interrupt
 744              	.LVL71:
1335:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 745              		.loc 1 1335 0
 746 00a4 2846     		mov	r0, r5
 747 00a6 4FF48071 		mov	r1, #256
 748 00aa FFF7FEFF 		bl	i2c_enable_interrupt
 749              	.LVL72:
1336:arch/stm32/mcu_periph/i2c_arch.c **** 
1337:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_peripheral_enable(i2c);
 750              		.loc 1 1337 0
 751 00ae 2846     		mov	r0, r5
 752 00b0 FFF7FEFF 		bl	i2c_peripheral_enable
 753              	.LVL73:
1338:arch/stm32/mcu_periph/i2c_arch.c ****       periph->watchdog = 0; // restart watchdog
1339:arch/stm32/mcu_periph/i2c_arch.c **** 
1340:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->timeout_tlow_cnt++;
 754              		.loc 1 1340 0
 755 00b4 E26A     		ldr	r2, [r4, #44]
1338:arch/stm32/mcu_periph/i2c_arch.c ****       periph->watchdog = 0; // restart watchdog
 756              		.loc 1 1338 0
 757 00b6 2686     		strh	r6, [r4, #48]	@ movhi
 758              		.loc 1 1340 0
 759 00b8 9389     		ldrh	r3, [r2, #12]
 760 00ba 0133     		adds	r3, r3, #1
 761 00bc 9BB2     		uxth	r3, r3
 762 00be 9381     		strh	r3, [r2, #12]	@ movhi
1341:arch/stm32/mcu_periph/i2c_arch.c **** 
1342:arch/stm32/mcu_periph/i2c_arch.c ****       return;
 763              		.loc 1 1342 0
 764 00c0 70BD     		pop	{r4, r5, r6, pc}
 765              	.LVL74:
 766              	.L68:
1343:arch/stm32/mcu_periph/i2c_arch.c ****     }
1344:arch/stm32/mcu_periph/i2c_arch.c ****   }
1345:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->watchdog >= 0) {
 767              		.loc 1 1345 0
 768 00c2 238E     		ldrh	r3, [r4, #48]
 769 00c4 1BB2     		sxth	r3, r3
 770 00c6 002B     		cmp	r3, #0
1346:arch/stm32/mcu_periph/i2c_arch.c ****     periph->watchdog++;
 771              		.loc 1 1346 0
 772 00c8 A1BF     		itttt	ge
 773 00ca 238E     		ldrhge	r3, [r4, #48]
 774 00cc 0133     		addge	r3, r3, #1
 775 00ce 9BB2     		uxthge	r3, r3
 776 00d0 2386     		strhge	r3, [r4, #48]	@ movhi
 777 00d2 70BD     		pop	{r4, r5, r6, pc}
 778              	.LVL75:
 779              	.L78:
 780              		.align	2
 781              	.L77:
 782 00d4 00540040 		.word	1073763328
 783 00d8 00040240 		.word	1073873920
 784 00dc 00580040 		.word	1073764352
 785              		.cfi_endproc
 786              	.LFE26:
 788              		.section	.text.i2c_irq.constprop.6,"ax",%progbits
 789              		.align	1
 790              		.thumb
 791              		.thumb_func
 793              	i2c_irq.constprop.6:
 794              	.LFB54:
 633:arch/stm32/mcu_periph/i2c_arch.c **** {
 795              		.loc 1 633 0
 796              		.cfi_startproc
 797              		@ args = 0, pretend = 0, frame = 0
 798              		@ frame_needed = 0, uses_anonymous_args = 0
 799              	.LVL76:
 800 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 801              		.cfi_def_cfa_offset 24
 802              		.cfi_offset 4, -24
 803              		.cfi_offset 5, -20
 804              		.cfi_offset 6, -16
 805              		.cfi_offset 7, -12
 806              		.cfi_offset 8, -8
 807              		.cfi_offset 14, -4
 714:arch/stm32/mcu_periph/i2c_arch.c ****     // Nothing Left To Do
 808              		.loc 1 714 0
 809 0004 90F82130 		ldrb	r3, [r0, #33]	@ zero_extendqisi2
 810 0008 90F82020 		ldrb	r2, [r0, #32]	@ zero_extendqisi2
 710:arch/stm32/mcu_periph/i2c_arch.c **** 
 811              		.loc 1 710 0
 812 000c 446A     		ldr	r4, [r0, #36]
 813              	.LVL77:
 714:arch/stm32/mcu_periph/i2c_arch.c ****     // Nothing Left To Do
 814              		.loc 1 714 0
 815 000e 9A42     		cmp	r2, r3
 633:arch/stm32/mcu_periph/i2c_arch.c **** {
 816              		.loc 1 633 0
 817 0010 0546     		mov	r5, r0
 714:arch/stm32/mcu_periph/i2c_arch.c ****     // Nothing Left To Do
 818              		.loc 1 714 0
 819 0012 0AD1     		bne	.L80
 734:arch/stm32/mcu_periph/i2c_arch.c **** 
 820              		.loc 1 734 0
 821 0014 FFF7FEFF 		bl	i2c_error
 822              	.LVL78:
 737:arch/stm32/mcu_periph/i2c_arch.c **** 
 823              		.loc 1 737 0
 824 0018 2046     		mov	r0, r4
 825 001a FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 826              	.LVL79:
 740:arch/stm32/mcu_periph/i2c_arch.c **** 
 827              		.loc 1 740 0
 828 001e EA6A     		ldr	r2, [r5, #44]
 829 0020 5369     		ldr	r3, [r2, #20]
 830 0022 0133     		adds	r3, r3, #1
 831 0024 5361     		str	r3, [r2, #20]
 743:arch/stm32/mcu_periph/i2c_arch.c **** 
 832              		.loc 1 743 0
 833 0026 0023     		movs	r3, #0
 834 0028 47E1     		b	.L144
 835              	.LVL80:
 836              	.L80:
 753:arch/stm32/mcu_periph/i2c_arch.c **** 
 837              		.loc 1 753 0
 838 002a 50F82360 		ldr	r6, [r0, r3, lsl #2]
 839              	.LVL81:
 757:arch/stm32/mcu_periph/i2c_arch.c **** 
 840              		.loc 1 757 0
 841 002e 6369     		ldr	r3, [r4, #20]
 842 0030 13F45F4F 		tst	r3, #57088
 843 0034 0ED0     		beq	.L82
 771:arch/stm32/mcu_periph/i2c_arch.c **** 
 844              		.loc 1 771 0
 845 0036 0323     		movs	r3, #3
 846 0038 86F82530 		strb	r3, [r6, #37]
 774:arch/stm32/mcu_periph/i2c_arch.c **** 
 847              		.loc 1 774 0
 848 003c 0A23     		movs	r3, #10
 849 003e 80F82230 		strb	r3, [r0, #34]
 777:arch/stm32/mcu_periph/i2c_arch.c **** 
 850              		.loc 1 777 0
 851 0042 0123     		movs	r3, #1
 852 0044 3370     		strb	r3, [r6]
 780:arch/stm32/mcu_periph/i2c_arch.c **** 
 853              		.loc 1 780 0
 854 0046 FFF7FEFF 		bl	i2c_error
 855              	.LVL82:
 783:arch/stm32/mcu_periph/i2c_arch.c **** 
 856              		.loc 1 783 0
 857 004a 2046     		mov	r0, r4
 858 004c FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 859              	.LVL83:
 786:arch/stm32/mcu_periph/i2c_arch.c **** 
 860              		.loc 1 786 0
 861 0050 0223     		movs	r3, #2
 862 0052 5CE1     		b	.L112
 863              	.LVL84:
 864              	.L82:
 799:arch/stm32/mcu_periph/i2c_arch.c ****       switch (trans->len_r) {
 865              		.loc 1 799 0
 866 0054 96F80080 		ldrb	r8, [r6]	@ zero_extendqisi2
 867 0058 B8F1010F 		cmp	r8, #1
 868 005c 40F00081 		bne	.L84
 800:arch/stm32/mcu_periph/i2c_arch.c ****         case 1:
 869              		.loc 1 800 0
 870 0060 7788     		ldrh	r7, [r6, #2]
 871 0062 012F     		cmp	r7, #1
 872 0064 02D0     		beq	.L86
 873 0066 022F     		cmp	r7, #2
 874 0068 31D0     		beq	.L87
 875 006a 60E0     		b	.L147
 876              	.L86:
 877              	.LVL85:
 878              	.LBB115:
 879              	.LBB116:
 300:arch/stm32/mcu_periph/i2c_arch.c **** 
 880              		.loc 1 300 0
 881 006c 6369     		ldr	r3, [r4, #20]
 882              	.LVL86:
 883 006e 9BB2     		uxth	r3, r3
 303:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 884              		.loc 1 303 0
 885 0070 D907     		lsls	r1, r3, #31
 886 0072 05D5     		bpl	.L88
 304:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 887              		.loc 1 304 0
 888 0074 2046     		mov	r0, r4
 889              	.LVL87:
 890 0076 4FF48061 		mov	r1, #1024
 891 007a FFF7FEFF 		bl	i2c_disable_interrupt
 892              	.LVL88:
 893 007e 66E0     		b	.L146
 894              	.LVL89:
 895              	.L88:
 311:arch/stm32/mcu_periph/i2c_arch.c ****     // First Clear the ACK bit: after the next byte we do not want new bytes
 896              		.loc 1 311 0
 897 0080 9A07     		lsls	r2, r3, #30
 898 0082 12D5     		bpl	.L90
 899              	.LBB117:
 313:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_ack(i2c);
 900              		.loc 1 313 0
 901 0084 2046     		mov	r0, r4
 902              	.LVL90:
 903 0086 FFF7FEFF 		bl	i2c_nack_current
 904              	.LVL91:
 314:arch/stm32/mcu_periph/i2c_arch.c **** 
 905              		.loc 1 314 0
 906 008a 2046     		mov	r0, r4
 907 008c FFF7FEFF 		bl	i2c_disable_ack
 908              	.LVL92:
 909              	.LBB118:
 910              	.LBB119:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 911              		.loc 1 65 0
 912              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 913 0090 72B6     		cpsid i
 914              	@ 0 "" 2
 915              		.thumb
 916              	.LBE119:
 917              	.LBE118:
 918              	.LBB120:
 919              	.LBB121:
 161:arch/stm32/mcu_periph/i2c_arch.c **** 
 920              		.loc 1 161 0
 921 0092 2046     		mov	r0, r4
 922              	.LBE121:
 923              	.LBE120:
 320:arch/stm32/mcu_periph/i2c_arch.c **** 
 924              		.loc 1 320 0
 925 0094 A369     		ldr	r3, [r4, #24]
 926              	.LVL93:
 927              	.LBB123:
 928              	.LBB122:
 161:arch/stm32/mcu_periph/i2c_arch.c **** 
 929              		.loc 1 161 0
 930 0096 FFF7FEFF 		bl	i2c_send_stop
 931              	.LVL94:
 932              	.LBE122:
 933              	.LBE123:
 934              	.LBB124:
 935              	.LBB125:
  66:arch/stm32/mcu_periph/i2c_arch.c **** 
 936              		.loc 1 66 0
 937              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 938 009a 62B6     		cpsie i
 939              	@ 0 "" 2
 940              		.thumb
 941              	.LBE125:
 942              	.LBE124:
 329:arch/stm32/mcu_periph/i2c_arch.c **** 
 943              		.loc 1 329 0
 944 009c 4FF48061 		mov	r1, #1024
 945 00a0 2046     		mov	r0, r4
 946 00a2 FFF7FEFF 		bl	i2c_enable_interrupt
 947              	.LVL95:
 332:arch/stm32/mcu_periph/i2c_arch.c ****   }
 948              		.loc 1 332 0
 949 00a6 0623     		movs	r3, #6
 950 00a8 07E1     		b	.L144
 951              	.LVL96:
 952              	.L90:
 953              	.LBE117:
 335:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 954              		.loc 1 335 0
 955 00aa 5806     		lsls	r0, r3, #25
 956              	.LVL97:
 957 00ac 40F16681 		bpl	.L91
 336:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[0] = I2C_DR(i2c);
 958              		.loc 1 336 0
 959 00b0 2046     		mov	r0, r4
 960 00b2 4FF48061 		mov	r1, #1024
 961 00b6 FFF7FEFF 		bl	i2c_disable_interrupt
 962              	.LVL98:
 337:arch/stm32/mcu_periph/i2c_arch.c **** 
 963              		.loc 1 337 0
 964 00ba 2369     		ldr	r3, [r4, #16]
 965 00bc DBB2     		uxtb	r3, r3
 966 00be 7371     		strb	r3, [r6, #5]
 340:arch/stm32/mcu_periph/i2c_arch.c **** 
 967              		.loc 1 340 0
 968 00c0 0223     		movs	r3, #2
 969 00c2 86F82530 		strb	r3, [r6, #37]
 344:arch/stm32/mcu_periph/i2c_arch.c **** 
 970              		.loc 1 344 0
 971 00c6 0723     		movs	r3, #7
 972 00c8 85F82230 		strb	r3, [r5, #34]
 973 00cc 66E1     		b	.L140
 974              	.LVL99:
 975              	.L87:
 976              	.LBE116:
 977              	.LBE115:
 978              	.LBB126:
 979              	.LBB127:
 359:arch/stm32/mcu_periph/i2c_arch.c **** 
 980              		.loc 1 359 0
 981 00ce 6269     		ldr	r2, [r4, #20]
 982              	.LVL100:
 983 00d0 92B2     		uxth	r2, r2
 362:arch/stm32/mcu_periph/i2c_arch.c ****     // according to the datasheet: instantly shedule a NAK on the second received byte:
 984              		.loc 1 362 0
 985 00d2 D107     		lsls	r1, r2, #31
 986 00d4 0BD5     		bpl	.L92
 364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 987              		.loc 1 364 0
 988 00d6 2046     		mov	r0, r4
 989              	.LVL101:
 990 00d8 4FF48061 		mov	r1, #1024
 991 00dc FFF7FEFF 		bl	i2c_disable_interrupt
 992              	.LVL102:
 365:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_nack_next(i2c);
 993              		.loc 1 365 0
 994 00e0 2046     		mov	r0, r4
 995 00e2 FFF7FEFF 		bl	i2c_enable_ack
 996              	.LVL103:
 366:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_send_data(i2c, trans->slave_addr | 0x01);
 997              		.loc 1 366 0
 998 00e6 2046     		mov	r0, r4
 999 00e8 FFF7FEFF 		bl	i2c_nack_next
 1000              	.LVL104:
 1001 00ec 2FE0     		b	.L146
 1002              	.LVL105:
 1003              	.L92:
 373:arch/stm32/mcu_periph/i2c_arch.c ****     // --- make absolutely sure this command is not delayed too much after the previous:
 1004              		.loc 1 373 0
 1005 00ee 9307     		lsls	r3, r2, #30
 1006 00f0 0BD5     		bpl	.L93
 1007              	.LBB128:
 1008              	.LBB129:
 1009              	.LBB130:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 1010              		.loc 1 65 0
 1011              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1012 00f2 72B6     		cpsid i
 1013              	@ 0 "" 2
 1014              		.thumb
 1015              	.LBE130:
 1016              	.LBE129:
 384:arch/stm32/mcu_periph/i2c_arch.c **** 
 1017              		.loc 1 384 0
 1018 00f4 2046     		mov	r0, r4
 1019              	.LVL106:
 381:arch/stm32/mcu_periph/i2c_arch.c **** 
 1020              		.loc 1 381 0
 1021 00f6 A369     		ldr	r3, [r4, #24]
 384:arch/stm32/mcu_periph/i2c_arch.c **** 
 1022              		.loc 1 384 0
 1023 00f8 FFF7FEFF 		bl	i2c_disable_ack
 1024              	.LVL107:
 387:arch/stm32/mcu_periph/i2c_arch.c **** 
 1025              		.loc 1 387 0
 1026 00fc 2046     		mov	r0, r4
 1027 00fe 4FF48061 		mov	r1, #1024
 1028 0102 FFF7FEFF 		bl	i2c_disable_interrupt
 1029              	.LVL108:
 1030              	.LBB131:
 1031              	.LBB132:
  66:arch/stm32/mcu_periph/i2c_arch.c **** 
 1032              		.loc 1 66 0
 1033              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1034 0106 62B6     		cpsie i
 1035              	@ 0 "" 2
 1036              		.thumb
 1037 0108 39E0     		b	.L145
 1038              	.LVL109:
 1039              	.L93:
 1040              	.LBE132:
 1041              	.LBE131:
 1042              	.LBE128:
 398:arch/stm32/mcu_periph/i2c_arch.c ****     // Stop condition MUST be set BEFORE reading the DR
 1043              		.loc 1 398 0
 1044 010a 5007     		lsls	r0, r2, #29
 1045              	.LVL110:
 1046 010c 40F13681 		bpl	.L91
 1047              	.LVL111:
 1048              	.LBB133:
 1049              	.LBB134:
 161:arch/stm32/mcu_periph/i2c_arch.c **** 
 1050              		.loc 1 161 0
 1051 0110 2046     		mov	r0, r4
 1052 0112 FFF7FEFF 		bl	i2c_send_stop
 1053              	.LVL112:
 1054              	.LBE134:
 1055              	.LBE133:
 404:arch/stm32/mcu_periph/i2c_arch.c **** 
 1056              		.loc 1 404 0
 1057 0116 0723     		movs	r3, #7
 1058 0118 85F82230 		strb	r3, [r5, #34]
 406:arch/stm32/mcu_periph/i2c_arch.c ****     trans->buf[1] = I2C_DR(i2c);
 1059              		.loc 1 406 0
 1060 011c 2369     		ldr	r3, [r4, #16]
 1061 011e DBB2     		uxtb	r3, r3
 1062 0120 7371     		strb	r3, [r6, #5]
 407:arch/stm32/mcu_periph/i2c_arch.c **** 
 1063              		.loc 1 407 0
 1064 0122 2369     		ldr	r3, [r4, #16]
 1065 0124 DBB2     		uxtb	r3, r3
 1066 0126 B371     		strb	r3, [r6, #6]
 410:arch/stm32/mcu_periph/i2c_arch.c **** 
 1067              		.loc 1 410 0
 1068 0128 86F82570 		strb	r7, [r6, #37]
 1069 012c 5BE0     		b	.L141
 1070              	.LVL113:
 1071              	.L147:
 1072              	.LBE127:
 1073              	.LBE126:
 1074              	.LBB135:
 1075              	.LBB136:
 425:arch/stm32/mcu_periph/i2c_arch.c **** 
 1076              		.loc 1 425 0
 1077 012e 6369     		ldr	r3, [r4, #20]
 1078              	.LVL114:
 1079 0130 9BB2     		uxth	r3, r3
 428:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1080              		.loc 1 428 0
 1081 0132 13F00102 		ands	r2, r3, #1
 1082 0136 12D0     		beq	.L94
 429:arch/stm32/mcu_periph/i2c_arch.c ****     // The first data byte will be acked in read many so the slave knows it should send more
 1083              		.loc 1 429 0
 1084 0138 2046     		mov	r0, r4
 1085              	.LVL115:
 1086 013a 4FF48061 		mov	r1, #1024
 1087 013e FFF7FEFF 		bl	i2c_disable_interrupt
 1088              	.LVL116:
 431:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_enable_ack(i2c);
 1089              		.loc 1 431 0
 1090 0142 2046     		mov	r0, r4
 1091 0144 FFF7FEFF 		bl	i2c_nack_current
 1092              	.LVL117:
 432:arch/stm32/mcu_periph/i2c_arch.c ****     // Clear the SB flag
 1093              		.loc 1 432 0
 1094 0148 2046     		mov	r0, r4
 1095 014a FFF7FEFF 		bl	i2c_enable_ack
 1096              	.LVL118:
 1097              	.L146:
 434:arch/stm32/mcu_periph/i2c_arch.c **** 
 1098              		.loc 1 434 0
 1099 014e 7178     		ldrb	r1, [r6, #1]	@ zero_extendqisi2
 1100 0150 2046     		mov	r0, r4
 1101 0152 41F00101 		orr	r1, r1, #1
 1102 0156 FFF7FEFF 		bl	i2c_send_data
 1103              	.LVL119:
 437:arch/stm32/mcu_periph/i2c_arch.c ****   }
 1104              		.loc 1 437 0
 1105 015a 0323     		movs	r3, #3
 1106 015c ADE0     		b	.L144
 1107              	.LVL120:
 1108              	.L94:
 440:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf = 0;
 1109              		.loc 1 440 0
 1110 015e 9907     		lsls	r1, r3, #30
 1111 0160 0FD5     		bpl	.L95
 1112              	.LBB137:
 441:arch/stm32/mcu_periph/i2c_arch.c **** 
 1113              		.loc 1 441 0
 1114 0162 80F82320 		strb	r2, [r0, #35]
 445:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1115              		.loc 1 445 0
 1116 0166 7388     		ldrh	r3, [r6, #2]
 1117              	.LVL121:
 1118 0168 90F82320 		ldrb	r2, [r0, #35]	@ zero_extendqisi2
 1119 016c 033B     		subs	r3, r3, #3
 1120 016e 9A42     		cmp	r2, r3
 1121 0170 04DA     		bge	.L96
 446:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1122              		.loc 1 446 0
 1123 0172 2046     		mov	r0, r4
 1124              	.LVL122:
 1125 0174 4FF48061 		mov	r1, #1024
 1126 0178 FFF7FEFF 		bl	i2c_enable_interrupt
 1127              	.LVL123:
 1128              	.L96:
 451:arch/stm32/mcu_periph/i2c_arch.c **** 
 1129              		.loc 1 451 0
 1130 017c A369     		ldr	r3, [r4, #24]
 1131              	.LVL124:
 1132              	.L145:
 454:arch/stm32/mcu_periph/i2c_arch.c ****   }
 1133              		.loc 1 454 0
 1134 017e 0523     		movs	r3, #5
 1135 0180 9BE0     		b	.L144
 1136              	.LVL125:
 1137              	.L95:
 1138              	.LBE137:
 457:arch/stm32/mcu_periph/i2c_arch.c ****     // read byte until 3 bytes remain to be read (e.g. len_r = 6, -> idx=3 means idx 3,4,5 = 3 rema
 1139              		.loc 1 457 0
 1140 0182 5806     		lsls	r0, r3, #25
 1141              	.LVL126:
 1142 0184 3BD5     		bpl	.L97
 1143 0186 6268     		ldr	r2, [r4, #4]
 1144 0188 5105     		lsls	r1, r2, #21
 1145 018a 38D5     		bpl	.L97
 459:arch/stm32/mcu_periph/i2c_arch.c ****       trans->buf[periph->idx_buf] = I2C_DR(i2c);
 1146              		.loc 1 459 0
 1147 018c 95F82320 		ldrb	r2, [r5, #35]	@ zero_extendqisi2
 1148 0190 FB1E     		subs	r3, r7, #3
 1149              	.LVL127:
 1150 0192 9A42     		cmp	r2, r3
 1151 0194 0CDA     		bge	.L98
 460:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 1152              		.loc 1 460 0
 1153 0196 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1154 019a 2269     		ldr	r2, [r4, #16]
 1155 019c 3344     		add	r3, r3, r6
 1156 019e D2B2     		uxtb	r2, r2
 1157 01a0 5A71     		strb	r2, [r3, #5]
 461:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1158              		.loc 1 461 0
 1159 01a2 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1160 01a6 0133     		adds	r3, r3, #1
 1161 01a8 DBB2     		uxtb	r3, r3
 1162 01aa 85F82330 		strb	r3, [r5, #35]
 1163 01ae 1CE0     		b	.L99
 1164              	.L98:
 466:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_disable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1165              		.loc 1 466 0
 1166 01b0 95F82320 		ldrb	r2, [r5, #35]	@ zero_extendqisi2
 1167 01b4 7B1E     		subs	r3, r7, #1
 1168 01b6 9A42     		cmp	r2, r3
 1169 01b8 17DB     		blt	.L99
 467:arch/stm32/mcu_periph/i2c_arch.c **** 
 1170              		.loc 1 467 0
 1171 01ba 2046     		mov	r0, r4
 1172 01bc 4FF48061 		mov	r1, #1024
 1173 01c0 FFF7FEFF 		bl	i2c_disable_interrupt
 1174              	.LVL128:
 470:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf ++;
 1175              		.loc 1 470 0
 1176 01c4 95F82370 		ldrb	r7, [r5, #35]	@ zero_extendqisi2
 1177 01c8 2046     		mov	r0, r4
 1178 01ca FFF7FEFF 		bl	i2c_get_data
 1179              	.LVL129:
 1180 01ce FFB2     		uxtb	r7, r7
 1181 01d0 3744     		add	r7, r7, r6
 1182 01d2 7871     		strb	r0, [r7, #5]
 471:arch/stm32/mcu_periph/i2c_arch.c **** 
 1183              		.loc 1 471 0
 1184 01d4 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1185 01d8 0133     		adds	r3, r3, #1
 1186 01da DBB2     		uxtb	r3, r3
 1187 01dc 85F82330 		strb	r3, [r5, #35]
 474:arch/stm32/mcu_periph/i2c_arch.c **** 
 1188              		.loc 1 474 0
 1189 01e0 0223     		movs	r3, #2
 1190 01e2 86F82530 		strb	r3, [r6, #37]
 1191              	.LVL130:
 1192              	.L141:
 476:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1193              		.loc 1 476 0
 1194 01e6 0123     		movs	r3, #1
 1195 01e8 91E0     		b	.L112
 1196              	.LVL131:
 1197              	.L99:
 480:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1198              		.loc 1 480 0
 1199 01ea 7388     		ldrh	r3, [r6, #2]
 1200 01ec 95F82320 		ldrb	r2, [r5, #35]	@ zero_extendqisi2
 1201 01f0 033B     		subs	r3, r3, #3
 1202 01f2 9A42     		cmp	r2, r3
 481:arch/stm32/mcu_periph/i2c_arch.c ****     } else { // idx >= len-3: there are 3 bytes to be read
 1203              		.loc 1 481 0
 1204 01f4 2046     		mov	r0, r4
 1205 01f6 4FF48061 		mov	r1, #1024
 480:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1206              		.loc 1 480 0
 1207 01fa 7CDA     		bge	.L143
 1208              	.LVL132:
 1209 01fc 2CE0     		b	.L142
 1210              	.LVL133:
 1211              	.L97:
 490:arch/stm32/mcu_periph/i2c_arch.c ****     // Now the shift register and data register contain data(n-2) and data(n-1)
 1212              		.loc 1 490 0
 1213 01fe 5A07     		lsls	r2, r3, #29
 1214 0200 40F1BC80 		bpl	.L91
 1215              	.LBB138:
 1216              	.LBB139:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 1217              		.loc 1 65 0
 1218              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1219 0204 72B6     		cpsid i
 1220              	@ 0 "" 2
 1221              		.thumb
 1222              	.LBE139:
 1223              	.LBE138:
 498:arch/stm32/mcu_periph/i2c_arch.c **** 
 1224              		.loc 1 498 0
 1225 0206 2046     		mov	r0, r4
 1226 0208 FFF7FEFF 		bl	i2c_disable_ack
 1227              	.LVL134:
 501:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 1228              		.loc 1 501 0
 1229 020c 95F82370 		ldrb	r7, [r5, #35]	@ zero_extendqisi2
 1230 0210 2046     		mov	r0, r4
 1231 0212 FFF7FEFF 		bl	i2c_get_data
 1232              	.LVL135:
 1233 0216 FFB2     		uxtb	r7, r7
 1234 0218 3744     		add	r7, r7, r6
 1235 021a 7871     		strb	r0, [r7, #5]
 502:arch/stm32/mcu_periph/i2c_arch.c **** 
 1236              		.loc 1 502 0
 1237 021c 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1238 0220 0133     		adds	r3, r3, #1
 1239 0222 DBB2     		uxtb	r3, r3
 1240 0224 85F82330 		strb	r3, [r5, #35]
 1241              	.LVL136:
 1242              	.LBB140:
 1243              	.LBB141:
 161:arch/stm32/mcu_periph/i2c_arch.c **** 
 1244              		.loc 1 161 0
 1245 0228 2046     		mov	r0, r4
 1246 022a FFF7FEFF 		bl	i2c_send_stop
 1247              	.LVL137:
 1248              	.LBE141:
 1249              	.LBE140:
 1250              	.LBB142:
 1251              	.LBB143:
  66:arch/stm32/mcu_periph/i2c_arch.c **** 
 1252              		.loc 1 66 0
 1253              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1254 022e 62B6     		cpsie i
 1255              	@ 0 "" 2
 1256              		.thumb
 1257              	.LBE143:
 1258              	.LBE142:
 513:arch/stm32/mcu_periph/i2c_arch.c **** 
 1259              		.loc 1 513 0
 1260 0230 0723     		movs	r3, #7
 1261 0232 85F82230 		strb	r3, [r5, #34]
 516:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 1262              		.loc 1 516 0
 1263 0236 95F82370 		ldrb	r7, [r5, #35]	@ zero_extendqisi2
 1264 023a 2046     		mov	r0, r4
 1265 023c FFF7FEFF 		bl	i2c_get_data
 1266              	.LVL138:
 1267 0240 FFB2     		uxtb	r7, r7
 1268 0242 3E44     		add	r6, r6, r7
 1269              	.LVL139:
 521:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 1270              		.loc 1 521 0
 1271 0244 4FF48061 		mov	r1, #1024
 516:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf ++;
 1272              		.loc 1 516 0
 1273 0248 7071     		strb	r0, [r6, #5]
 517:arch/stm32/mcu_periph/i2c_arch.c **** 
 1274              		.loc 1 517 0
 1275 024a 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1276 024e 0133     		adds	r3, r3, #1
 1277 0250 DBB2     		uxtb	r3, r3
 1278 0252 85F82330 		strb	r3, [r5, #35]
 521:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 1279              		.loc 1 521 0
 1280 0256 2046     		mov	r0, r4
 1281              	.LVL140:
 1282              	.L142:
 1283              	.LBE136:
 1284              	.LBE135:
 900:arch/stm32/mcu_periph/i2c_arch.c **** 
 1285              		.loc 1 900 0
 1286 0258 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1287              		.cfi_remember_state
 1288              		.cfi_restore 14
 1289              		.cfi_restore 8
 1290              		.cfi_restore 7
 1291              		.cfi_restore 6
 1292              		.cfi_restore 5
 1293              		.cfi_restore 4
 1294              		.cfi_def_cfa_offset 0
 1295              	.LVL141:
 1296              	.LBB145:
 1297              	.LBB144:
 521:arch/stm32/mcu_periph/i2c_arch.c ****   } else { // Event Logic Error
 1298              		.loc 1 521 0
 1299 025c FFF7FEBF 		b	i2c_enable_interrupt
 1300              	.LVL142:
 1301              	.L84:
 1302              		.cfi_restore_state
 1303              	.LBE144:
 1304              	.LBE145:
 1305              	.LBB146:
 1306              	.LBB147:
 228:arch/stm32/mcu_periph/i2c_arch.c **** 
 1307              		.loc 1 228 0
 1308 0260 6269     		ldr	r2, [r4, #20]
 1309              	.LVL143:
 1310 0262 92B2     		uxth	r2, r2
 231:arch/stm32/mcu_periph/i2c_arch.c ****     // Disable buffer interrupt
 1311              		.loc 1 231 0
 1312 0264 D307     		lsls	r3, r2, #31
 1313 0266 0AD5     		bpl	.L101
 233:arch/stm32/mcu_periph/i2c_arch.c ****     // Send Slave address and wait for ADDR interrupt
 1314              		.loc 1 233 0
 1315 0268 2046     		mov	r0, r4
 1316              	.LVL144:
 1317 026a 4FF48061 		mov	r1, #1024
 1318 026e FFF7FEFF 		bl	i2c_disable_interrupt
 1319              	.LVL145:
 235:arch/stm32/mcu_periph/i2c_arch.c ****     // Document the current Status
 1320              		.loc 1 235 0
 1321 0272 2046     		mov	r0, r4
 1322 0274 7178     		ldrb	r1, [r6, #1]	@ zero_extendqisi2
 1323 0276 FFF7FEFF 		bl	i2c_send_data
 1324              	.LVL146:
 237:arch/stm32/mcu_periph/i2c_arch.c ****   }
 1325              		.loc 1 237 0
 1326 027a 0223     		movs	r3, #2
 1327 027c 1DE0     		b	.L144
 1328              	.LVL147:
 1329              	.L101:
 240:arch/stm32/mcu_periph/i2c_arch.c ****     // Now read SR2 to clear the ADDR status Bit
 1330              		.loc 1 240 0
 1331 027e 9707     		lsls	r7, r2, #30
 1332 0280 1FD5     		bpl	.L102
 1333              	.LBB148:
 242:arch/stm32/mcu_periph/i2c_arch.c **** 
 1334              		.loc 1 242 0
 1335 0282 A369     		ldr	r3, [r4, #24]
 249:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->len_w > 1) {
 1336              		.loc 1 249 0
 1337 0284 7179     		ldrb	r1, [r6, #5]	@ zero_extendqisi2
 1338 0286 2046     		mov	r0, r4
 1339              	.LVL148:
 1340 0288 FFF7FEFF 		bl	i2c_send_data
 1341              	.LVL149:
 250:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_data(i2c, trans->buf[1]);
 1342              		.loc 1 250 0
 1343 028c 3379     		ldrb	r3, [r6, #4]	@ zero_extendqisi2
 1344 028e 012B     		cmp	r3, #1
 1345 0290 05D9     		bls	.L103
 251:arch/stm32/mcu_periph/i2c_arch.c ****       periph->idx_buf = 2;
 1346              		.loc 1 251 0
 1347 0292 B179     		ldrb	r1, [r6, #6]	@ zero_extendqisi2
 1348 0294 2046     		mov	r0, r4
 1349 0296 FFF7FEFF 		bl	i2c_send_data
 1350              	.LVL150:
 252:arch/stm32/mcu_periph/i2c_arch.c ****     } else {
 1351              		.loc 1 252 0
 1352 029a 0223     		movs	r3, #2
 1353 029c 00E0     		b	.L139
 1354              	.L103:
 254:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1355              		.loc 1 254 0
 1356 029e 0123     		movs	r3, #1
 1357              	.L139:
 1358 02a0 85F82330 		strb	r3, [r5, #35]
 259:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_enable_interrupt(i2c, I2C_CR2_ITBUFEN);
 1359              		.loc 1 259 0
 1360 02a4 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1361 02a8 3279     		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 1362 02aa 9A42     		cmp	r2, r3
 1363 02ac 04D9     		bls	.L105
 260:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1364              		.loc 1 260 0
 1365 02ae 2046     		mov	r0, r4
 1366 02b0 4FF48061 		mov	r1, #1024
 1367 02b4 FFF7FEFF 		bl	i2c_enable_interrupt
 1368              	.LVL151:
 1369              	.L105:
 264:arch/stm32/mcu_periph/i2c_arch.c ****   }
 1370              		.loc 1 264 0
 1371 02b8 0423     		movs	r3, #4
 1372              	.LVL152:
 1373              	.L144:
 1374 02ba 85F82230 		strb	r3, [r5, #34]
 1375 02be BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1376              	.LVL153:
 1377              	.L102:
 1378              	.LBE148:
 267:arch/stm32/mcu_periph/i2c_arch.c ****     // Send the next byte
 1379              		.loc 1 267 0
 1380 02c2 1006     		lsls	r0, r2, #24
 1381              	.LVL154:
 1382 02c4 1BD5     		bpl	.L106
 1383 02c6 6368     		ldr	r3, [r4, #4]
 1384 02c8 5905     		lsls	r1, r3, #21
 1385 02ca 18D5     		bpl	.L106
 269:arch/stm32/mcu_periph/i2c_arch.c ****     periph->idx_buf++;
 1386              		.loc 1 269 0
 1387 02cc 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1388 02d0 3344     		add	r3, r3, r6
 1389 02d2 2046     		mov	r0, r4
 1390 02d4 5979     		ldrb	r1, [r3, #5]	@ zero_extendqisi2
 1391 02d6 FFF7FEFF 		bl	i2c_send_data
 1392              	.LVL155:
 270:arch/stm32/mcu_periph/i2c_arch.c **** 
 1393              		.loc 1 270 0
 1394 02da 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1395 02de 0133     		adds	r3, r3, #1
 1396 02e0 DBB2     		uxtb	r3, r3
 1397 02e2 85F82330 		strb	r3, [r5, #35]
 273:arch/stm32/mcu_periph/i2c_arch.c ****       // Not interested anymore to know the buffer has space left
 1398              		.loc 1 273 0
 1399 02e6 95F82330 		ldrb	r3, [r5, #35]	@ zero_extendqisi2
 1400 02ea 3279     		ldrb	r2, [r6, #4]	@ zero_extendqisi2
 1401 02ec 9A42     		cmp	r2, r3
 1402 02ee 57D8     		bhi	.L79
 275:arch/stm32/mcu_periph/i2c_arch.c ****       // Next interrupt will be BTF (or error)
 1403              		.loc 1 275 0
 1404 02f0 2046     		mov	r0, r4
 1405 02f2 4FF48061 		mov	r1, #1024
 1406              	.LVL156:
 1407              	.L143:
 1408              	.LBE147:
 1409              	.LBE146:
 900:arch/stm32/mcu_periph/i2c_arch.c **** 
 1410              		.loc 1 900 0
 1411 02f6 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1412              		.cfi_remember_state
 1413              		.cfi_restore 14
 1414              		.cfi_restore 8
 1415              		.cfi_restore 7
 1416              		.cfi_restore 6
 1417              		.cfi_restore 5
 1418              		.cfi_restore 4
 1419              		.cfi_def_cfa_offset 0
 1420              	.LVL157:
 1421              	.LBB150:
 1422              	.LBB149:
 275:arch/stm32/mcu_periph/i2c_arch.c ****       // Next interrupt will be BTF (or error)
 1423              		.loc 1 275 0
 1424 02fa FFF7FEBF 		b	i2c_disable_interrupt
 1425              	.LVL158:
 1426              	.L106:
 1427              		.cfi_restore_state
 280:arch/stm32/mcu_periph/i2c_arch.c ****     if (trans->type == I2CTransTx) {
 1428              		.loc 1 280 0
 1429 02fe 5307     		lsls	r3, r2, #29
 1430 0300 3CD5     		bpl	.L91
 1431 0302 0223     		movs	r3, #2
 281:arch/stm32/mcu_periph/i2c_arch.c ****       // Tell the driver we are ready
 1432              		.loc 1 281 0
 1433 0304 B8F1000F 		cmp	r8, #0
 1434 0308 01D1     		bne	.L112
 283:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1435              		.loc 1 283 0
 1436 030a 86F82530 		strb	r3, [r6, #37]
 1437              	.LVL159:
 1438              	.L112:
 1439              	.LBE149:
 1440              	.LBE150:
 846:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;
 1441              		.loc 1 846 0
 1442 030e 3278     		ldrb	r2, [r6]	@ zero_extendqisi2
 1443 0310 022A     		cmp	r2, #2
 1444 0312 0CD1     		bne	.L107
 847:arch/stm32/mcu_periph/i2c_arch.c ****       periph->status = I2CStartRequested;
 1445              		.loc 1 847 0
 1446 0314 0123     		movs	r3, #1
 1447 0316 3370     		strb	r3, [r6]
 849:arch/stm32/mcu_periph/i2c_arch.c **** 
 1448              		.loc 1 849 0
 1449 0318 2046     		mov	r0, r4
 848:arch/stm32/mcu_periph/i2c_arch.c ****       i2c_send_start(i2c);
 1450              		.loc 1 848 0
 1451 031a 85F82230 		strb	r3, [r5, #34]
 849:arch/stm32/mcu_periph/i2c_arch.c **** 
 1452              		.loc 1 849 0
 1453 031e FFF7FEFF 		bl	i2c_send_start
 1454              	.LVL160:
 852:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1455              		.loc 1 852 0
 1456 0322 2046     		mov	r0, r4
 1457 0324 0021     		movs	r1, #0
 900:arch/stm32/mcu_periph/i2c_arch.c **** 
 1458              		.loc 1 900 0
 1459 0326 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1460              		.cfi_remember_state
 1461              		.cfi_restore 14
 1462              		.cfi_restore 8
 1463              		.cfi_restore 7
 1464              		.cfi_restore 6
 1465              		.cfi_restore 5
 1466              		.cfi_restore 4
 1467              		.cfi_def_cfa_offset 0
 1468              	.LVL161:
 852:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1469              		.loc 1 852 0
 1470 032a FFF7FEBF 		b	i2c_send_data
 1471              	.LVL162:
 1472              	.L107:
 1473              		.cfi_restore_state
 857:arch/stm32/mcu_periph/i2c_arch.c **** 
 1474              		.loc 1 857 0
 1475 032e 022B     		cmp	r3, #2
 1476 0330 06D1     		bne	.L108
 1477              	.LVL163:
 1478              	.LBB151:
 1479              	.LBB152:
 161:arch/stm32/mcu_periph/i2c_arch.c **** 
 1480              		.loc 1 161 0
 1481 0332 2046     		mov	r0, r4
 1482 0334 FFF7FEFF 		bl	i2c_send_stop
 1483              	.LVL164:
 1484              	.LBE152:
 1485              	.LBE151:
 863:arch/stm32/mcu_periph/i2c_arch.c ****       }
 1486              		.loc 1 863 0
 1487 0338 2046     		mov	r0, r4
 1488 033a 0021     		movs	r1, #0
 1489 033c FFF7FEFF 		bl	i2c_send_data
 1490              	.LVL165:
 1491              	.L108:
 1492              	.LBB153:
 1493              	.LBB154:
 867:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx >= I2C_TRANSACTION_QUEUE_LEN) {
 1494              		.loc 1 867 0
 1495 0340 95F82130 		ldrb	r3, [r5, #33]	@ zero_extendqisi2
 1496 0344 0133     		adds	r3, r3, #1
 1497 0346 DBB2     		uxtb	r3, r3
 868:arch/stm32/mcu_periph/i2c_arch.c ****         periph->trans_extract_idx = 0;
 1498              		.loc 1 868 0
 1499 0348 072B     		cmp	r3, #7
 1500 034a 4FF00002 		mov	r2, #0
 867:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph->trans_extract_idx >= I2C_TRANSACTION_QUEUE_LEN) {
 1501              		.loc 1 867 0
 1502 034e 94BF     		ite	ls
 1503 0350 85F82130 		strbls	r3, [r5, #33]
 869:arch/stm32/mcu_periph/i2c_arch.c ****       }
 1504              		.loc 1 869 0
 1505 0354 85F82120 		strbhi	r2, [r5, #33]
 873:arch/stm32/mcu_periph/i2c_arch.c **** 
 1506              		.loc 1 873 0
 1507 0358 85F82220 		strb	r2, [r5, #34]
 877:arch/stm32/mcu_periph/i2c_arch.c **** 
 1508              		.loc 1 877 0
 1509 035c 95F82030 		ldrb	r3, [r5, #32]	@ zero_extendqisi2
 1510 0360 95F82120 		ldrb	r2, [r5, #33]	@ zero_extendqisi2
 1511 0364 9A42     		cmp	r2, r3
 1512 0366 04D1     		bne	.L111
 879:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
 1513              		.loc 1 879 0
 1514 0368 4FF6FF73 		movw	r3, #65535
 1515 036c 2B86     		strh	r3, [r5, #48]	@ movhi
 1516 036e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1517              	.LVL166:
 1518              	.L111:
 893:arch/stm32/mcu_periph/i2c_arch.c ****         // ------
 1519              		.loc 1 893 0
 1520 0372 2846     		mov	r0, r5
 1521              	.LBE154:
 1522              	.LBE153:
 900:arch/stm32/mcu_periph/i2c_arch.c **** 
 1523              		.loc 1 900 0
 1524 0374 BDE8F041 		pop	{r4, r5, r6, r7, r8, lr}
 1525              		.cfi_remember_state
 1526              		.cfi_restore 14
 1527              		.cfi_restore 8
 1528              		.cfi_restore 7
 1529              		.cfi_restore 6
 1530              		.cfi_restore 5
 1531              		.cfi_restore 4
 1532              		.cfi_def_cfa_offset 0
 1533              	.LVL167:
 1534              	.LBB156:
 1535              	.LBB155:
 893:arch/stm32/mcu_periph/i2c_arch.c ****         // ------
 1536              		.loc 1 893 0
 1537 0378 FFF7FEBF 		b	PPRZ_I2C_SEND_START
 1538              	.LVL168:
 1539              	.L91:
 1540              		.cfi_restore_state
 1541              	.LBE155:
 1542              	.LBE156:
 826:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;   // Avoid possible restart
 1543              		.loc 1 826 0
 1544 037c 0A23     		movs	r3, #10
 829:arch/stm32/mcu_periph/i2c_arch.c **** 
 1545              		.loc 1 829 0
 1546 037e EA6A     		ldr	r2, [r5, #44]
 826:arch/stm32/mcu_periph/i2c_arch.c ****       trans->type = I2CTransRx;   // Avoid possible restart
 1547              		.loc 1 826 0
 1548 0380 85F82230 		strb	r3, [r5, #34]
 828:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->unexpected_event_cnt++;
 1549              		.loc 1 828 0
 1550 0384 0327     		movs	r7, #3
 827:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransFailed; // Notify Ready
 1551              		.loc 1 827 0
 1552 0386 0123     		movs	r3, #1
 828:arch/stm32/mcu_periph/i2c_arch.c ****       periph->errors->unexpected_event_cnt++;
 1553              		.loc 1 828 0
 1554 0388 86F82570 		strb	r7, [r6, #37]
 827:arch/stm32/mcu_periph/i2c_arch.c ****       trans->status = I2CTransFailed; // Notify Ready
 1555              		.loc 1 827 0
 1556 038c 3370     		strb	r3, [r6]
 829:arch/stm32/mcu_periph/i2c_arch.c **** 
 1557              		.loc 1 829 0
 1558 038e 138A     		ldrh	r3, [r2, #16]
 1559 0390 0133     		adds	r3, r3, #1
 1560 0392 9BB2     		uxth	r3, r3
 1561 0394 1382     		strh	r3, [r2, #16]	@ movhi
 842:arch/stm32/mcu_periph/i2c_arch.c ****     }
 1562              		.loc 1 842 0
 1563 0396 2046     		mov	r0, r4
 1564 0398 FFF7FEFF 		bl	stmi2c_clear_pending_interrupts
 1565              	.LVL169:
 1566              	.L140:
 1567 039c 3B46     		mov	r3, r7
 1568 039e B6E7     		b	.L112
 1569              	.LVL170:
 1570              	.L79:
 1571 03a0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1572              		.cfi_endproc
 1573              	.LFE54:
 1575              		.section	.text.i2c1_ev_isr,"ax",%progbits
 1576              		.align	1
 1577              		.weak	i2c1_ev_isr
 1578              		.thumb
 1579              		.thumb_func
 1581              	i2c1_ev_isr:
 1582              	.LFB18:
 975:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 1583              		.loc 1 975 0
 1584              		.cfi_startproc
 1585              		@ args = 0, pretend = 0, frame = 0
 1586              		@ frame_needed = 0, uses_anonymous_args = 0
 1587 0000 38B5     		push	{r3, r4, r5, lr}
 1588              		.cfi_def_cfa_offset 16
 1589              		.cfi_offset 3, -16
 1590              		.cfi_offset 4, -12
 1591              		.cfi_offset 5, -8
 1592              		.cfi_offset 14, -4
 976:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 1593              		.loc 1 976 0
 1594 0002 094C     		ldr	r4, .L149
 1595 0004 656A     		ldr	r5, [r4, #36]
 1596              	.LVL171:
 977:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 1597              		.loc 1 977 0
 1598 0006 4FF48071 		mov	r1, #256
 1599 000a 2846     		mov	r0, r5
 1600 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1601              	.LVL172:
 978:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);;
 1602              		.loc 1 978 0
 1603 0010 0023     		movs	r3, #0
 979:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1604              		.loc 1 979 0
 1605 0012 2046     		mov	r0, r4
 978:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);;
 1606              		.loc 1 978 0
 1607 0014 2386     		strh	r3, [r4, #48]	@ movhi
 979:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1608              		.loc 1 979 0
 1609 0016 FFF7FEFF 		bl	i2c_irq.constprop.6
 1610              	.LVL173:
 980:arch/stm32/mcu_periph/i2c_arch.c **** }
 1611              		.loc 1 980 0
 1612 001a 2846     		mov	r0, r5
 1613 001c 4FF48071 		mov	r1, #256
 981:arch/stm32/mcu_periph/i2c_arch.c **** 
 1614              		.loc 1 981 0
 1615 0020 BDE83840 		pop	{r3, r4, r5, lr}
 1616              		.cfi_restore 14
 1617              		.cfi_restore 5
 1618              		.cfi_restore 4
 1619              		.cfi_restore 3
 1620              		.cfi_def_cfa_offset 0
 1621              	.LVL174:
 980:arch/stm32/mcu_periph/i2c_arch.c **** }
 1622              		.loc 1 980 0
 1623 0024 FFF7FEBF 		b	i2c_enable_interrupt
 1624              	.LVL175:
 1625              	.L150:
 1626              		.align	2
 1627              	.L149:
 1628 0028 00000000 		.word	i2c1
 1629              		.cfi_endproc
 1630              	.LFE18:
 1632              		.section	.text.i2c1_er_isr,"ax",%progbits
 1633              		.align	1
 1634              		.weak	i2c1_er_isr
 1635              		.thumb
 1636              		.thumb_func
 1638              	i2c1_er_isr:
 1639              	.LFB19:
 984:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c1.reg_addr;
 1640              		.loc 1 984 0
 1641              		.cfi_startproc
 1642              		@ args = 0, pretend = 0, frame = 0
 1643              		@ frame_needed = 0, uses_anonymous_args = 0
 1644 0000 38B5     		push	{r3, r4, r5, lr}
 1645              		.cfi_def_cfa_offset 16
 1646              		.cfi_offset 3, -16
 1647              		.cfi_offset 4, -12
 1648              		.cfi_offset 5, -8
 1649              		.cfi_offset 14, -4
 985:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1650              		.loc 1 985 0
 1651 0002 094C     		ldr	r4, .L152
 1652 0004 656A     		ldr	r5, [r4, #36]
 1653              	.LVL176:
 986:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = 0; // restart watchdog
 1654              		.loc 1 986 0
 1655 0006 4FF40071 		mov	r1, #512
 1656 000a 2846     		mov	r0, r5
 1657 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1658              	.LVL177:
 987:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);
 1659              		.loc 1 987 0
 1660 0010 0023     		movs	r3, #0
 988:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1661              		.loc 1 988 0
 1662 0012 2046     		mov	r0, r4
 987:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c1);
 1663              		.loc 1 987 0
 1664 0014 2386     		strh	r3, [r4, #48]	@ movhi
 988:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1665              		.loc 1 988 0
 1666 0016 FFF7FEFF 		bl	i2c_irq.constprop.6
 1667              	.LVL178:
 989:arch/stm32/mcu_periph/i2c_arch.c **** }
 1668              		.loc 1 989 0
 1669 001a 2846     		mov	r0, r5
 1670 001c 4FF40071 		mov	r1, #512
 990:arch/stm32/mcu_periph/i2c_arch.c **** 
 1671              		.loc 1 990 0
 1672 0020 BDE83840 		pop	{r3, r4, r5, lr}
 1673              		.cfi_restore 14
 1674              		.cfi_restore 5
 1675              		.cfi_restore 4
 1676              		.cfi_restore 3
 1677              		.cfi_def_cfa_offset 0
 1678              	.LVL179:
 989:arch/stm32/mcu_periph/i2c_arch.c **** }
 1679              		.loc 1 989 0
 1680 0024 FFF7FEBF 		b	i2c_enable_interrupt
 1681              	.LVL180:
 1682              	.L153:
 1683              		.align	2
 1684              	.L152:
 1685 0028 00000000 		.word	i2c1
 1686              		.cfi_endproc
 1687              	.LFE19:
 1689              		.section	.text.i2c2_ev_isr,"ax",%progbits
 1690              		.align	1
 1691              		.weak	i2c2_ev_isr
 1692              		.thumb
 1693              		.thumb_func
 1695              	i2c2_ev_isr:
 1696              	.LFB21:
1047:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
 1697              		.loc 1 1047 0
 1698              		.cfi_startproc
 1699              		@ args = 0, pretend = 0, frame = 0
 1700              		@ frame_needed = 0, uses_anonymous_args = 0
 1701 0000 38B5     		push	{r3, r4, r5, lr}
 1702              		.cfi_def_cfa_offset 16
 1703              		.cfi_offset 3, -16
 1704              		.cfi_offset 4, -12
 1705              		.cfi_offset 5, -8
 1706              		.cfi_offset 14, -4
1048:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITERREN);
 1707              		.loc 1 1048 0
 1708 0002 094C     		ldr	r4, .L155
 1709 0004 656A     		ldr	r5, [r4, #36]
 1710              	.LVL181:
1049:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
 1711              		.loc 1 1049 0
 1712 0006 4FF48071 		mov	r1, #256
 1713 000a 2846     		mov	r0, r5
 1714 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1715              	.LVL182:
1050:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1716              		.loc 1 1050 0
 1717 0010 0023     		movs	r3, #0
1051:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1718              		.loc 1 1051 0
 1719 0012 2046     		mov	r0, r4
1050:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1720              		.loc 1 1050 0
 1721 0014 2386     		strh	r3, [r4, #48]	@ movhi
1051:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITERREN);
 1722              		.loc 1 1051 0
 1723 0016 FFF7FEFF 		bl	i2c_irq.constprop.6
 1724              	.LVL183:
1052:arch/stm32/mcu_periph/i2c_arch.c **** }
 1725              		.loc 1 1052 0
 1726 001a 2846     		mov	r0, r5
 1727 001c 4FF48071 		mov	r1, #256
1053:arch/stm32/mcu_periph/i2c_arch.c **** 
 1728              		.loc 1 1053 0
 1729 0020 BDE83840 		pop	{r3, r4, r5, lr}
 1730              		.cfi_restore 14
 1731              		.cfi_restore 5
 1732              		.cfi_restore 4
 1733              		.cfi_restore 3
 1734              		.cfi_def_cfa_offset 0
 1735              	.LVL184:
1052:arch/stm32/mcu_periph/i2c_arch.c **** }
 1736              		.loc 1 1052 0
 1737 0024 FFF7FEBF 		b	i2c_enable_interrupt
 1738              	.LVL185:
 1739              	.L156:
 1740              		.align	2
 1741              	.L155:
 1742 0028 00000000 		.word	i2c2
 1743              		.cfi_endproc
 1744              	.LFE21:
 1746              		.section	.text.i2c2_er_isr,"ax",%progbits
 1747              		.align	1
 1748              		.weak	i2c2_er_isr
 1749              		.thumb
 1750              		.thumb_func
 1752              	i2c2_er_isr:
 1753              	.LFB22:
1056:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) i2c2.reg_addr;
 1754              		.loc 1 1056 0
 1755              		.cfi_startproc
 1756              		@ args = 0, pretend = 0, frame = 0
 1757              		@ frame_needed = 0, uses_anonymous_args = 0
 1758 0000 38B5     		push	{r3, r4, r5, lr}
 1759              		.cfi_def_cfa_offset 16
 1760              		.cfi_offset 3, -16
 1761              		.cfi_offset 4, -12
 1762              		.cfi_offset 5, -8
 1763              		.cfi_offset 14, -4
1057:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_disable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1764              		.loc 1 1057 0
 1765 0002 094C     		ldr	r4, .L158
 1766 0004 656A     		ldr	r5, [r4, #36]
 1767              	.LVL186:
1058:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = 0; // restart watchdog
 1768              		.loc 1 1058 0
 1769 0006 4FF40071 		mov	r1, #512
 1770 000a 2846     		mov	r0, r5
 1771 000c FFF7FEFF 		bl	i2c_disable_interrupt
 1772              	.LVL187:
1059:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1773              		.loc 1 1059 0
 1774 0010 0023     		movs	r3, #0
1060:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1775              		.loc 1 1060 0
 1776 0012 2046     		mov	r0, r4
1059:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_irq(&i2c2);
 1777              		.loc 1 1059 0
 1778 0014 2386     		strh	r3, [r4, #48]	@ movhi
1060:arch/stm32/mcu_periph/i2c_arch.c ****   i2c_enable_interrupt(i2c, I2C_CR2_ITEVTEN);
 1779              		.loc 1 1060 0
 1780 0016 FFF7FEFF 		bl	i2c_irq.constprop.6
 1781              	.LVL188:
1061:arch/stm32/mcu_periph/i2c_arch.c **** }
 1782              		.loc 1 1061 0
 1783 001a 2846     		mov	r0, r5
 1784 001c 4FF40071 		mov	r1, #512
1062:arch/stm32/mcu_periph/i2c_arch.c **** 
 1785              		.loc 1 1062 0
 1786 0020 BDE83840 		pop	{r3, r4, r5, lr}
 1787              		.cfi_restore 14
 1788              		.cfi_restore 5
 1789              		.cfi_restore 4
 1790              		.cfi_restore 3
 1791              		.cfi_def_cfa_offset 0
 1792              	.LVL189:
1061:arch/stm32/mcu_periph/i2c_arch.c **** }
 1793              		.loc 1 1061 0
 1794 0024 FFF7FEBF 		b	i2c_enable_interrupt
 1795              	.LVL190:
 1796              	.L159:
 1797              		.align	2
 1798              	.L158:
 1799 0028 00000000 		.word	i2c2
 1800              		.cfi_endproc
 1801              	.LFE22:
 1803              		.section	.text.i2c_event,"ax",%progbits
 1804              		.align	1
 1805              		.global	i2c_event
 1806              		.thumb
 1807              		.thumb_func
 1809              	i2c_event:
 1810              	.LFB45:
1347:arch/stm32/mcu_periph/i2c_arch.c ****   }
1348:arch/stm32/mcu_periph/i2c_arch.c **** }
1349:arch/stm32/mcu_periph/i2c_arch.c **** #endif // USE_I2Cx
1350:arch/stm32/mcu_periph/i2c_arch.c **** 
1351:arch/stm32/mcu_periph/i2c_arch.c **** #include "mcu_periph/sys_time.h"
1352:arch/stm32/mcu_periph/i2c_arch.c **** 
1353:arch/stm32/mcu_periph/i2c_arch.c **** void i2c_event(void)
1354:arch/stm32/mcu_periph/i2c_arch.c **** {
 1811              		.loc 1 1354 0
 1812              		.cfi_startproc
 1813              		@ args = 0, pretend = 0, frame = 0
 1814              		@ frame_needed = 0, uses_anonymous_args = 0
 1815 0000 10B5     		push	{r4, lr}
 1816              		.cfi_def_cfa_offset 8
 1817              		.cfi_offset 4, -8
 1818              		.cfi_offset 14, -4
1355:arch/stm32/mcu_periph/i2c_arch.c ****   static uint32_t i2c_wd_timer;
1356:arch/stm32/mcu_periph/i2c_arch.c **** 
1357:arch/stm32/mcu_periph/i2c_arch.c ****   if (SysTimeTimer(i2c_wd_timer) > 2000) { // 2ms (500Hz) periodic watchdog check
 1819              		.loc 1 1357 0
 1820 0002 0A4C     		ldr	r4, .L162
 1821 0004 FFF7FEFF 		bl	get_sys_time_usec
 1822              	.LVL191:
 1823 0008 2368     		ldr	r3, [r4]
 1824 000a C01A     		subs	r0, r0, r3
 1825 000c B0F5FA6F 		cmp	r0, #2000
 1826 0010 0AD9     		bls	.L160
1358:arch/stm32/mcu_periph/i2c_arch.c ****     SysTimeTimerStart(i2c_wd_timer);
 1827              		.loc 1 1358 0
 1828 0012 FFF7FEFF 		bl	get_sys_time_usec
 1829              	.LVL192:
 1830 0016 2060     		str	r0, [r4]
1359:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1360:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c1);
 1831              		.loc 1 1360 0
 1832 0018 0548     		ldr	r0, .L162+4
 1833 001a FFF7FEFF 		bl	i2c_wd_check
 1834              	.LVL193:
1361:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1362:arch/stm32/mcu_periph/i2c_arch.c **** 
1363:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C2
1364:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c2);
 1835              		.loc 1 1364 0
 1836 001e 0548     		ldr	r0, .L162+8
1365:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1366:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C3
1367:arch/stm32/mcu_periph/i2c_arch.c ****     i2c_wd_check(&i2c3);
1368:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1369:arch/stm32/mcu_periph/i2c_arch.c ****   }
1370:arch/stm32/mcu_periph/i2c_arch.c **** }
 1837              		.loc 1 1370 0
 1838 0020 BDE81040 		pop	{r4, lr}
 1839              		.cfi_remember_state
 1840              		.cfi_restore 14
 1841              		.cfi_restore 4
 1842              		.cfi_def_cfa_offset 0
1364:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 1843              		.loc 1 1364 0
 1844 0024 FFF7FEBF 		b	i2c_wd_check
 1845              	.LVL194:
 1846              	.L160:
 1847              		.cfi_restore_state
 1848 0028 10BD     		pop	{r4, pc}
 1849              	.L163:
 1850 002a 00BF     		.align	2
 1851              	.L162:
 1852 002c 00000000 		.word	.LANCHOR0
 1853 0030 00000000 		.word	i2c1
 1854 0034 00000000 		.word	i2c2
 1855              		.cfi_endproc
 1856              	.LFE45:
 1858              		.section	.text.i2c_submit,"ax",%progbits
 1859              		.align	1
 1860              		.global	i2c_submit
 1861              		.thumb
 1862              		.thumb_func
 1864              	i2c_submit:
 1865              	.LFB46:
1371:arch/stm32/mcu_periph/i2c_arch.c **** 
1372:arch/stm32/mcu_periph/i2c_arch.c **** /////////////////////////////////////////////////////////
1373:arch/stm32/mcu_periph/i2c_arch.c **** // Implement Interface Functions
1374:arch/stm32/mcu_periph/i2c_arch.c **** 
1375:arch/stm32/mcu_periph/i2c_arch.c **** bool_t i2c_submit(struct i2c_periph *periph, struct i2c_transaction *t)
1376:arch/stm32/mcu_periph/i2c_arch.c **** {
 1866              		.loc 1 1376 0
 1867              		.cfi_startproc
 1868              		@ args = 0, pretend = 0, frame = 0
 1869              		@ frame_needed = 0, uses_anonymous_args = 0
 1870              	.LVL195:
 1871 0000 10B5     		push	{r4, lr}
 1872              		.cfi_def_cfa_offset 8
 1873              		.cfi_offset 4, -8
 1874              		.cfi_offset 14, -4
1377:arch/stm32/mcu_periph/i2c_arch.c **** 
1378:arch/stm32/mcu_periph/i2c_arch.c ****   uint8_t temp;
1379:arch/stm32/mcu_periph/i2c_arch.c ****   temp = periph->trans_insert_idx + 1;
 1875              		.loc 1 1379 0
 1876 0002 90F82030 		ldrb	r3, [r0, #32]	@ zero_extendqisi2
1380:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp >= I2C_TRANSACTION_QUEUE_LEN) { temp = 0; }
1381:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp == periph->trans_extract_idx) {
 1877              		.loc 1 1381 0
 1878 0006 90F82140 		ldrb	r4, [r0, #33]	@ zero_extendqisi2
1379:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp >= I2C_TRANSACTION_QUEUE_LEN) { temp = 0; }
 1879              		.loc 1 1379 0
 1880 000a 0133     		adds	r3, r3, #1
 1881 000c DBB2     		uxtb	r3, r3
 1882              	.LVL196:
1380:arch/stm32/mcu_periph/i2c_arch.c ****   if (temp >= I2C_TRANSACTION_QUEUE_LEN) { temp = 0; }
 1883              		.loc 1 1380 0
 1884 000e 082B     		cmp	r3, #8
 1885 0010 28BF     		it	cs
 1886 0012 0023     		movcs	r3, #0
 1887              	.LVL197:
 1888              		.loc 1 1381 0
 1889 0014 9C42     		cmp	r4, r3
 1890 0016 09D1     		bne	.L166
1382:arch/stm32/mcu_periph/i2c_arch.c ****     // queue full
1383:arch/stm32/mcu_periph/i2c_arch.c ****     periph->errors->queue_full_cnt++;
 1891              		.loc 1 1383 0
 1892 0018 C26A     		ldr	r2, [r0, #44]
 1893 001a 1388     		ldrh	r3, [r2]
 1894              	.LVL198:
 1895 001c 0133     		adds	r3, r3, #1
 1896 001e 9BB2     		uxth	r3, r3
 1897 0020 1380     		strh	r3, [r2]	@ movhi
 1898              	.LVL199:
1384:arch/stm32/mcu_periph/i2c_arch.c ****     t->status = I2CTransFailed;
 1899              		.loc 1 1384 0
 1900 0022 0323     		movs	r3, #3
 1901 0024 81F82530 		strb	r3, [r1, #37]
1385:arch/stm32/mcu_periph/i2c_arch.c ****     return FALSE;
 1902              		.loc 1 1385 0
 1903 0028 0020     		movs	r0, #0
 1904              	.LVL200:
 1905 002a 10BD     		pop	{r4, pc}
 1906              	.LVL201:
 1907              	.L166:
1386:arch/stm32/mcu_periph/i2c_arch.c ****   }
1387:arch/stm32/mcu_periph/i2c_arch.c **** 
1388:arch/stm32/mcu_periph/i2c_arch.c ****   t->status = I2CTransPending;
 1908              		.loc 1 1388 0
 1909 002c 0024     		movs	r4, #0
 1910 002e 81F82540 		strb	r4, [r1, #37]
 1911              	.LBB157:
 1912              	.LBB158:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 1913              		.loc 1 65 0
 1914              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1915 0032 72B6     		cpsid i
 1916              	@ 0 "" 2
 1917              		.thumb
 1918              	.LBE158:
 1919              	.LBE157:
1389:arch/stm32/mcu_periph/i2c_arch.c **** 
1390:arch/stm32/mcu_periph/i2c_arch.c ****   __disable_irq();
1391:arch/stm32/mcu_periph/i2c_arch.c ****   /* put transacation in queue */
1392:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans[periph->trans_insert_idx] = t;
 1920              		.loc 1 1392 0
 1921 0034 90F82040 		ldrb	r4, [r0, #32]	@ zero_extendqisi2
 1922 0038 40F82410 		str	r1, [r0, r4, lsl #2]
1393:arch/stm32/mcu_periph/i2c_arch.c ****   periph->trans_insert_idx = temp;
 1923              		.loc 1 1393 0
 1924 003c 80F82030 		strb	r3, [r0, #32]
1394:arch/stm32/mcu_periph/i2c_arch.c **** 
1395:arch/stm32/mcu_periph/i2c_arch.c ****   /* if peripheral is idle, start the transaction */
1396:arch/stm32/mcu_periph/i2c_arch.c ****   // if (PPRZ_I2C_IS_IDLE(p))
1397:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->status == I2CIdle) {
 1925              		.loc 1 1397 0
 1926 0040 90F82230 		ldrb	r3, [r0, #34]	@ zero_extendqisi2
 1927              	.LVL202:
 1928 0044 0BB9     		cbnz	r3, .L168
1398:arch/stm32/mcu_periph/i2c_arch.c ****     //if (i2c_idle(periph))
1399:arch/stm32/mcu_periph/i2c_arch.c ****     {
1400:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1401:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1402:arch/stm32/mcu_periph/i2c_arch.c ****       if (periph == &i2c1) {
1403:arch/stm32/mcu_periph/i2c_arch.c **** 
1404:arch/stm32/mcu_periph/i2c_arch.c ****       } else
1405:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1406:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1407:arch/stm32/mcu_periph/i2c_arch.c ****       {
1408:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1409:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_ON();
1410:arch/stm32/mcu_periph/i2c_arch.c ****         LED2_OFF();
1411:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1412:arch/stm32/mcu_periph/i2c_arch.c ****         PPRZ_I2C_SEND_START(periph);
 1929              		.loc 1 1412 0
 1930 0046 FFF7FEFF 		bl	PPRZ_I2C_SEND_START
 1931              	.LVL203:
 1932              	.L168:
 1933              	.LBB159:
 1934              	.LBB160:
  66:arch/stm32/mcu_periph/i2c_arch.c **** 
 1935              		.loc 1 66 0
 1936              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 1937 004a 62B6     		cpsie i
 1938              	@ 0 "" 2
 1939              		.thumb
 1940              	.LBE160:
 1941              	.LBE159:
1413:arch/stm32/mcu_periph/i2c_arch.c ****       }
1414:arch/stm32/mcu_periph/i2c_arch.c ****     }
1415:arch/stm32/mcu_periph/i2c_arch.c ****   }
1416:arch/stm32/mcu_periph/i2c_arch.c ****   /* else it will be started by the interrupt handler when the previous transactions completes */
1417:arch/stm32/mcu_periph/i2c_arch.c ****   __enable_irq();
1418:arch/stm32/mcu_periph/i2c_arch.c **** 
1419:arch/stm32/mcu_periph/i2c_arch.c ****   return TRUE;
 1942              		.loc 1 1419 0
 1943 004c 0120     		movs	r0, #1
1420:arch/stm32/mcu_periph/i2c_arch.c **** }
 1944              		.loc 1 1420 0
 1945 004e 10BD     		pop	{r4, pc}
 1946              		.cfi_endproc
 1947              	.LFE46:
 1949              		.section	.text.i2c_idle,"ax",%progbits
 1950              		.align	1
 1951              		.global	i2c_idle
 1952              		.thumb
 1953              		.thumb_func
 1955              	i2c_idle:
 1956              	.LFB47:
1421:arch/stm32/mcu_periph/i2c_arch.c **** 
1422:arch/stm32/mcu_periph/i2c_arch.c **** bool_t i2c_idle(struct i2c_periph *periph)
1423:arch/stm32/mcu_periph/i2c_arch.c **** {
 1957              		.loc 1 1423 0
 1958              		.cfi_startproc
 1959              		@ args = 0, pretend = 0, frame = 0
 1960              		@ frame_needed = 0, uses_anonymous_args = 0
 1961              		@ link register save eliminated.
 1962              	.LVL204:
1424:arch/stm32/mcu_periph/i2c_arch.c ****   // This is actually a difficult function:
1425:arch/stm32/mcu_periph/i2c_arch.c ****   // -simply reading the status flags can clear bits and corrupt the transaction
1426:arch/stm32/mcu_periph/i2c_arch.c **** 
1427:arch/stm32/mcu_periph/i2c_arch.c ****   uint32_t i2c = (uint32_t) periph->reg_addr;
1428:arch/stm32/mcu_periph/i2c_arch.c **** 
1429:arch/stm32/mcu_periph/i2c_arch.c **** #ifdef I2C_DEBUG_LED
1430:arch/stm32/mcu_periph/i2c_arch.c **** #if USE_I2C1
1431:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph == &i2c1) {
1432:arch/stm32/mcu_periph/i2c_arch.c ****     return TRUE;
1433:arch/stm32/mcu_periph/i2c_arch.c ****   }
1434:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1435:arch/stm32/mcu_periph/i2c_arch.c **** #endif
1436:arch/stm32/mcu_periph/i2c_arch.c **** 
1437:arch/stm32/mcu_periph/i2c_arch.c ****   // First we check if the software thinks it is ready
1438:arch/stm32/mcu_periph/i2c_arch.c ****   if (periph->status == I2CIdle) {
 1963              		.loc 1 1438 0
 1964 0000 90F82220 		ldrb	r2, [r0, #34]	@ zero_extendqisi2
1427:arch/stm32/mcu_periph/i2c_arch.c **** 
 1965              		.loc 1 1427 0
 1966 0004 436A     		ldr	r3, [r0, #36]
 1967              	.LVL205:
 1968              		.loc 1 1438 0
 1969 0006 2AB9     		cbnz	r2, .L171
1439:arch/stm32/mcu_periph/i2c_arch.c ****     return !(BIT_X_IS_SET_IN_REG(I2C_SR2_BUSY, I2C_SR2(i2c)));
 1970              		.loc 1 1439 0
 1971 0008 9869     		ldr	r0, [r3, #24]
 1972              	.LVL206:
 1973 000a 80F00200 		eor	r0, r0, #2
 1974 000e C0F34000 		ubfx	r0, r0, #1, #1
 1975 0012 7047     		bx	lr
 1976              	.LVL207:
 1977              	.L171:
1440:arch/stm32/mcu_periph/i2c_arch.c ****   } else {
1441:arch/stm32/mcu_periph/i2c_arch.c ****     return FALSE;
 1978              		.loc 1 1441 0
 1979 0014 0020     		movs	r0, #0
 1980              	.LVL208:
1442:arch/stm32/mcu_periph/i2c_arch.c ****   }
1443:arch/stm32/mcu_periph/i2c_arch.c **** }
 1981              		.loc 1 1443 0
 1982 0016 7047     		bx	lr
 1983              		.cfi_endproc
 1984              	.LFE47:
 1986              		.section	.text.i2c_setbitrate,"ax",%progbits
 1987              		.align	1
 1988              		.global	i2c_setbitrate
 1989              		.thumb
 1990              		.thumb_func
 1992              	i2c_setbitrate:
 1993              	.LFB23:
1146:arch/stm32/mcu_periph/i2c_arch.c ****   // If NOT Busy
 1994              		.loc 1 1146 0
 1995              		.cfi_startproc
 1996              		@ args = 0, pretend = 0, frame = 8
 1997              		@ frame_needed = 0, uses_anonymous_args = 0
 1998              	.LVL209:
 1999 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 2000              		.cfi_def_cfa_offset 24
 2001              		.cfi_offset 4, -12
 2002              		.cfi_offset 5, -8
 2003              		.cfi_offset 14, -4
1146:arch/stm32/mcu_periph/i2c_arch.c ****   // If NOT Busy
 2004              		.loc 1 1146 0
 2005 0002 0546     		mov	r5, r0
 2006 0004 0C46     		mov	r4, r1
1148:arch/stm32/mcu_periph/i2c_arch.c ****     volatile int devider;
 2007              		.loc 1 1148 0
 2008 0006 FFF7FEFF 		bl	i2c_idle
 2009              	.LVL210:
 2010 000a 0028     		cmp	r0, #0
 2011 000c 46D0     		beq	.L172
 2012              	.LVL211:
 2013              	.LBB168:
 2014              	.LBB169:
1172:arch/stm32/mcu_periph/i2c_arch.c ****     }
 2015              		.loc 1 1172 0
 2016 000e 40F6B833 		movw	r3, #3000
 2017 0012 9C42     		cmp	r4, r3
 2018 0014 B8BF     		it	lt
 2019 0016 1C46     		movlt	r4, r3
 2020              	.LVL212:
1178:arch/stm32/mcu_periph/i2c_arch.c **** 
 2021              		.loc 1 1178 0
 2022 0018 214B     		ldr	r3, .L182
1152:arch/stm32/mcu_periph/i2c_arch.c **** 
 2023              		.loc 1 1152 0
 2024 001a 6D6A     		ldr	r5, [r5, #36]
 2025              	.LVL213:
1178:arch/stm32/mcu_periph/i2c_arch.c **** 
 2026              		.loc 1 1178 0
 2027 001c 1B68     		ldr	r3, [r3]
 2028 001e 4FF47A71 		mov	r1, #1000
 2029 0022 4FF4FA62 		mov	r2, #2000
 2030 0026 94FBF1F4 		sdiv	r4, r4, r1
 2031              	.LVL214:
 2032 002a B3FBF2F3 		udiv	r3, r3, r2
 2033 002e B3FBF4F3 		udiv	r3, r3, r4
 2034 0032 0093     		str	r3, [sp]
1181:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 20;
 2035              		.loc 1 1181 0
 2036 0034 009B     		ldr	r3, [sp]
1191:arch/stm32/mcu_periph/i2c_arch.c **** 
 2037              		.loc 1 1191 0
 2038 0036 1B49     		ldr	r1, .L182+4
 2039 0038 91FBF4F4 		sdiv	r4, r1, r4
1181:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 20;
 2040              		.loc 1 1181 0
 2041 003c 132B     		cmp	r3, #19
 2042              	.LVL215:
1182:arch/stm32/mcu_periph/i2c_arch.c ****     }
 2043              		.loc 1 1182 0
 2044 003e DCBF     		itt	le
 2045 0040 1423     		movle	r3, #20
 2046 0042 0093     		strle	r3, [sp]
1186:arch/stm32/mcu_periph/i2c_arch.c ****       devider = 4095;
 2047              		.loc 1 1186 0
 2048 0044 009A     		ldr	r2, [sp]
 2049 0046 40F6FE73 		movw	r3, #4094
 2050 004a 9A42     		cmp	r2, r3
1187:arch/stm32/mcu_periph/i2c_arch.c ****     }
 2051              		.loc 1 1187 0
 2052 004c C4BF     		itt	gt
 2053 004e 40F6FF73 		movwgt	r3, #4095
 2054 0052 0093     		strgt	r3, [sp]
1191:arch/stm32/mcu_periph/i2c_arch.c **** 
 2055              		.loc 1 1191 0
 2056 0054 A821     		movs	r1, #168
 2057 0056 94FBF1F4 		sdiv	r4, r4, r1
 2058 005a 0194     		str	r4, [sp, #4]
1193:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 10;
 2059              		.loc 1 1193 0
 2060 005c 019B     		ldr	r3, [sp, #4]
 2061 005e 092B     		cmp	r3, #9
1194:arch/stm32/mcu_periph/i2c_arch.c ****     }
 2062              		.loc 1 1194 0
 2063 0060 DCBF     		itt	le
 2064 0062 0A23     		movle	r3, #10
 2065 0064 0193     		strle	r3, [sp, #4]
1198:arch/stm32/mcu_periph/i2c_arch.c ****       risetime = 31;
 2066              		.loc 1 1198 0
 2067 0066 019B     		ldr	r3, [sp, #4]
 2068 0068 1E2B     		cmp	r3, #30
1199:arch/stm32/mcu_periph/i2c_arch.c ****     }
 2069              		.loc 1 1199 0
 2070 006a C4BF     		itt	gt
 2071 006c 1F23     		movgt	r3, #31
 2072 006e 0193     		strgt	r3, [sp, #4]
 2073              	.LBB170:
 2074              	.LBB171:
  65:arch/stm32/mcu_periph/i2c_arch.c **** static inline void __enable_irq(void)   { asm volatile("cpsie i"); }
 2075              		.loc 1 65 0
 2076              	@ 65 "arch/stm32/mcu_periph/i2c_arch.c" 1
 2077 0070 72B6     		cpsid i
 2078              	@ 0 "" 2
 2079              		.thumb
 2080              	.LBE171:
 2081              	.LBE170:
1207:arch/stm32/mcu_periph/i2c_arch.c **** 
 2082              		.loc 1 1207 0
 2083 0072 2846     		mov	r0, r5
 2084 0074 FFF7FEFF 		bl	i2c_peripheral_disable
 2085              	.LVL216:
1213:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 2086              		.loc 1 1213 0
 2087 0078 2846     		mov	r0, r5
 2088 007a 2A21     		movs	r1, #42
 2089 007c FFF7FEFF 		bl	i2c_set_clock_frequency
 2090              	.LVL217:
1217:arch/stm32/mcu_periph/i2c_arch.c ****     // 3)
 2091              		.loc 1 1217 0
 2092 0080 0099     		ldr	r1, [sp]
 2093 0082 2846     		mov	r0, r5
 2094 0084 89B2     		uxth	r1, r1
 2095 0086 FFF7FEFF 		bl	i2c_set_ccr
 2096              	.LVL218:
1219:arch/stm32/mcu_periph/i2c_arch.c **** 
 2097              		.loc 1 1219 0
 2098 008a 0199     		ldr	r1, [sp, #4]
 2099 008c 2846     		mov	r0, r5
 2100 008e 89B2     		uxth	r1, r1
 2101 0090 FFF7FEFF 		bl	i2c_set_trise
 2102              	.LVL219:
1222:arch/stm32/mcu_periph/i2c_arch.c **** 
 2103              		.loc 1 1222 0
 2104 0094 2846     		mov	r0, r5
 2105 0096 FFF7FEFF 		bl	i2c_peripheral_enable
 2106              	.LVL220:
 2107              	.LBB172:
 2108              	.LBB173:
  66:arch/stm32/mcu_periph/i2c_arch.c **** 
 2109              		.loc 1 66 0
 2110              	@ 66 "arch/stm32/mcu_periph/i2c_arch.c" 1
 2111 009a 62B6     		cpsie i
 2112              	@ 0 "" 2
 2113              	.LVL221:
 2114              		.thumb
 2115              	.L172:
 2116              	.LBE173:
 2117              	.LBE172:
 2118              	.LBE169:
 2119              	.LBE168:
1242:arch/stm32/mcu_periph/i2c_arch.c **** 
 2120              		.loc 1 1242 0
 2121 009c 03B0     		add	sp, sp, #12
 2122              		.cfi_def_cfa_offset 12
 2123              		@ sp needed
 2124 009e 30BD     		pop	{r4, r5, pc}
 2125              	.L183:
 2126              		.align	2
 2127              	.L182:
 2128 00a0 00000000 		.word	rcc_apb1_frequency
 2129 00a4 40420F00 		.word	1000000
 2130              		.cfi_endproc
 2131              	.LFE23:
 2133              		.section	.text.i2c1_hw_init,"ax",%progbits
 2134              		.align	1
 2135              		.global	i2c1_hw_init
 2136              		.thumb
 2137              		.thumb_func
 2139              	i2c1_hw_init:
 2140              	.LFB17:
 928:arch/stm32/mcu_periph/i2c_arch.c **** 
 2141              		.loc 1 928 0
 2142              		.cfi_startproc
 2143              		@ args = 0, pretend = 0, frame = 0
 2144              		@ frame_needed = 0, uses_anonymous_args = 0
 2145 0000 70B5     		push	{r4, r5, r6, lr}
 2146              		.cfi_def_cfa_offset 16
 2147              		.cfi_offset 4, -16
 2148              		.cfi_offset 5, -12
 2149              		.cfi_offset 6, -8
 2150              		.cfi_offset 14, -4
 932:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = -1;
 2151              		.loc 1 932 0
 2152 0002 1F4B     		ldr	r3, .L185
 930:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.init_struct = NULL;
 2153              		.loc 1 930 0
 2154 0004 1F4D     		ldr	r5, .L185+4
 2155 0006 204E     		ldr	r6, .L185+8
 932:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.watchdog = -1;
 2156              		.loc 1 932 0
 2157 0008 EB62     		str	r3, [r5, #44]
 931:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.errors = &i2c1_errors;
 2158              		.loc 1 931 0
 2159 000a 0024     		movs	r4, #0
 933:arch/stm32/mcu_periph/i2c_arch.c **** 
 2160              		.loc 1 933 0
 2161 000c 4FF6FF72 		movw	r2, #65535
 947:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_EV_IRQ);
 2162              		.loc 1 947 0
 2163 0010 0421     		movs	r1, #4
 2164 0012 1F20     		movs	r0, #31
 933:arch/stm32/mcu_periph/i2c_arch.c **** 
 2165              		.loc 1 933 0
 2166 0014 2A86     		strh	r2, [r5, #48]	@ movhi
 930:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.init_struct = NULL;
 2167              		.loc 1 930 0
 2168 0016 6E62     		str	r6, [r5, #36]
 936:arch/stm32/mcu_periph/i2c_arch.c **** 
 2169              		.loc 1 936 0
 2170 0018 1C80     		strh	r4, [r3]	@ movhi
 931:arch/stm32/mcu_periph/i2c_arch.c ****   i2c1.errors = &i2c1_errors;
 2171              		.loc 1 931 0
 2172 001a AC62     		str	r4, [r5, #40]
 936:arch/stm32/mcu_periph/i2c_arch.c **** 
 2173              		.loc 1 936 0
 2174 001c 5C80     		strh	r4, [r3, #2]	@ movhi
 2175 001e 9C80     		strh	r4, [r3, #4]	@ movhi
 2176 0020 DC80     		strh	r4, [r3, #6]	@ movhi
 2177 0022 1C81     		strh	r4, [r3, #8]	@ movhi
 2178 0024 5C81     		strh	r4, [r3, #10]	@ movhi
 2179 0026 9C81     		strh	r4, [r3, #12]	@ movhi
 2180 0028 DC81     		strh	r4, [r3, #14]	@ movhi
 2181 002a 1C82     		strh	r4, [r3, #16]	@ movhi
 2182 002c 5C61     		str	r4, [r3, #20]
 2183 002e 9C61     		str	r4, [r3, #24]
 947:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_EV_IRQ);
 2184              		.loc 1 947 0
 2185 0030 FFF7FEFF 		bl	nvic_set_priority
 2186              	.LVL222:
 948:arch/stm32/mcu_periph/i2c_arch.c **** 
 2187              		.loc 1 948 0
 2188 0034 1F20     		movs	r0, #31
 2189 0036 FFF7FEFF 		bl	nvic_enable_irq
 2190              	.LVL223:
 951:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C1_ER_IRQ);
 2191              		.loc 1 951 0
 2192 003a 0521     		movs	r1, #5
 2193 003c 2020     		movs	r0, #32
 2194 003e FFF7FEFF 		bl	nvic_set_priority
 2195              	.LVL224:
 952:arch/stm32/mcu_periph/i2c_arch.c **** 
 2196              		.loc 1 952 0
 2197 0042 2020     		movs	r0, #32
 2198 0044 FFF7FEFF 		bl	nvic_enable_irq
 2199              	.LVL225:
 956:arch/stm32/mcu_periph/i2c_arch.c ****   /* setup gpio clock and pins */
 2200              		.loc 1 956 0
 2201 0048 40F61500 		movw	r0, #2069
 2202 004c FFF7FEFF 		bl	rcc_periph_clock_enable
 2203              	.LVL226:
 2204              	.LBB176:
 2205              	.LBB177:
 2206 0050 FFF7FEFF 		bl	i2c_setup_gpio.part.0
 2207              	.LVL227:
 2208              	.LBE177:
 2209              	.LBE176:
 960:arch/stm32/mcu_periph/i2c_arch.c **** 
 2210              		.loc 1 960 0
 2211 0054 40F21540 		movw	r0, #1045
 2212 0058 FFF7FEFF 		bl	rcc_periph_reset_pulse
 2213              	.LVL228:
 963:arch/stm32/mcu_periph/i2c_arch.c **** 
 2214              		.loc 1 963 0
 2215 005c 3046     		mov	r0, r6
 2216 005e FFF7FEFF 		bl	i2c_peripheral_enable
 2217              	.LVL229:
 965:arch/stm32/mcu_periph/i2c_arch.c **** 
 2218              		.loc 1 965 0
 2219 0062 3046     		mov	r0, r6
 2220 0064 2146     		mov	r1, r4
 2221 0066 FFF7FEFF 		bl	i2c_set_own_7bit_slave_address
 2222              	.LVL230:
 968:arch/stm32/mcu_periph/i2c_arch.c **** 
 2223              		.loc 1 968 0
 2224 006a 3046     		mov	r0, r6
 2225 006c 4FF48071 		mov	r1, #256
 2226 0070 FFF7FEFF 		bl	i2c_enable_interrupt
 2227              	.LVL231:
 970:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 2228              		.loc 1 970 0
 2229 0074 2846     		mov	r0, r5
 2230 0076 0549     		ldr	r1, .L185+12
 972:arch/stm32/mcu_periph/i2c_arch.c **** 
 2231              		.loc 1 972 0
 2232 0078 BDE87040 		pop	{r4, r5, r6, lr}
 2233              		.cfi_restore 14
 2234              		.cfi_restore 6
 2235              		.cfi_restore 5
 2236              		.cfi_restore 4
 2237              		.cfi_def_cfa_offset 0
 970:arch/stm32/mcu_periph/i2c_arch.c **** #endif
 2238              		.loc 1 970 0
 2239 007c FFF7FEBF 		b	i2c_setbitrate
 2240              	.LVL232:
 2241              	.L186:
 2242              		.align	2
 2243              	.L185:
 2244 0080 00000000 		.word	.LANCHOR1
 2245 0084 00000000 		.word	i2c1
 2246 0088 00540040 		.word	1073763328
 2247 008c 400D0300 		.word	200000
 2248              		.cfi_endproc
 2249              	.LFE17:
 2251              		.section	.text.i2c2_hw_init,"ax",%progbits
 2252              		.align	1
 2253              		.global	i2c2_hw_init
 2254              		.thumb
 2255              		.thumb_func
 2257              	i2c2_hw_init:
 2258              	.LFB20:
1005:arch/stm32/mcu_periph/i2c_arch.c **** 
 2259              		.loc 1 1005 0
 2260              		.cfi_startproc
 2261              		@ args = 0, pretend = 0, frame = 0
 2262              		@ frame_needed = 0, uses_anonymous_args = 0
 2263 0000 70B5     		push	{r4, r5, r6, lr}
 2264              		.cfi_def_cfa_offset 16
 2265              		.cfi_offset 4, -16
 2266              		.cfi_offset 5, -12
 2267              		.cfi_offset 6, -8
 2268              		.cfi_offset 14, -4
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
 2269              		.loc 1 1009 0
 2270 0002 204B     		ldr	r3, .L188
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
 2271              		.loc 1 1007 0
 2272 0004 204D     		ldr	r5, .L188+4
 2273 0006 214E     		ldr	r6, .L188+8
1009:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.watchdog = -1;
 2274              		.loc 1 1009 0
 2275 0008 EB62     		str	r3, [r5, #44]
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
 2276              		.loc 1 1008 0
 2277 000a 0024     		movs	r4, #0
1010:arch/stm32/mcu_periph/i2c_arch.c **** 
 2278              		.loc 1 1010 0
 2279 000c 4FF6FF72 		movw	r2, #65535
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_EV_IRQ);
 2280              		.loc 1 1019 0
 2281 0010 0421     		movs	r1, #4
 2282 0012 2120     		movs	r0, #33
1010:arch/stm32/mcu_periph/i2c_arch.c **** 
 2283              		.loc 1 1010 0
 2284 0014 2A86     		strh	r2, [r5, #48]	@ movhi
1007:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.init_struct = NULL;
 2285              		.loc 1 1007 0
 2286 0016 6E62     		str	r6, [r5, #36]
1013:arch/stm32/mcu_periph/i2c_arch.c **** 
 2287              		.loc 1 1013 0
 2288 0018 1C80     		strh	r4, [r3]	@ movhi
1008:arch/stm32/mcu_periph/i2c_arch.c ****   i2c2.errors = &i2c2_errors;
 2289              		.loc 1 1008 0
 2290 001a AC62     		str	r4, [r5, #40]
1013:arch/stm32/mcu_periph/i2c_arch.c **** 
 2291              		.loc 1 1013 0
 2292 001c 5C80     		strh	r4, [r3, #2]	@ movhi
 2293 001e 9C80     		strh	r4, [r3, #4]	@ movhi
 2294 0020 DC80     		strh	r4, [r3, #6]	@ movhi
 2295 0022 1C81     		strh	r4, [r3, #8]	@ movhi
 2296 0024 5C81     		strh	r4, [r3, #10]	@ movhi
 2297 0026 9C81     		strh	r4, [r3, #12]	@ movhi
 2298 0028 DC81     		strh	r4, [r3, #14]	@ movhi
 2299 002a 1C82     		strh	r4, [r3, #16]	@ movhi
 2300 002c 5C61     		str	r4, [r3, #20]
 2301 002e 9C61     		str	r4, [r3, #24]
1019:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_EV_IRQ);
 2302              		.loc 1 1019 0
 2303 0030 FFF7FEFF 		bl	nvic_set_priority
 2304              	.LVL233:
1020:arch/stm32/mcu_periph/i2c_arch.c **** 
 2305              		.loc 1 1020 0
 2306 0034 2120     		movs	r0, #33
 2307 0036 FFF7FEFF 		bl	nvic_enable_irq
 2308              	.LVL234:
1023:arch/stm32/mcu_periph/i2c_arch.c ****   nvic_enable_irq(NVIC_I2C2_ER_IRQ);
 2309              		.loc 1 1023 0
 2310 003a 0521     		movs	r1, #5
 2311 003c 2220     		movs	r0, #34
 2312 003e FFF7FEFF 		bl	nvic_set_priority
 2313              	.LVL235:
1024:arch/stm32/mcu_periph/i2c_arch.c **** 
 2314              		.loc 1 1024 0
 2315 0042 2220     		movs	r0, #34
 2316 0044 FFF7FEFF 		bl	nvic_enable_irq
 2317              	.LVL236:
1028:arch/stm32/mcu_periph/i2c_arch.c **** 
 2318              		.loc 1 1028 0
 2319 0048 40F61600 		movw	r0, #2070
 2320 004c FFF7FEFF 		bl	rcc_periph_clock_enable
 2321              	.LVL237:
1031:arch/stm32/mcu_periph/i2c_arch.c **** 
 2322              		.loc 1 1031 0
 2323 0050 3046     		mov	r0, r6
 2324 0052 FFF7FEFF 		bl	i2c_setup_gpio
 2325              	.LVL238:
1033:arch/stm32/mcu_periph/i2c_arch.c **** 
 2326              		.loc 1 1033 0
 2327 0056 40F21640 		movw	r0, #1046
 2328 005a FFF7FEFF 		bl	rcc_periph_reset_pulse
 2329              	.LVL239:
1036:arch/stm32/mcu_periph/i2c_arch.c **** 
 2330              		.loc 1 1036 0
 2331 005e 3046     		mov	r0, r6
 2332 0060 FFF7FEFF 		bl	i2c_peripheral_enable
 2333              	.LVL240:
1038:arch/stm32/mcu_periph/i2c_arch.c **** 
 2334              		.loc 1 1038 0
 2335 0064 3046     		mov	r0, r6
 2336 0066 2146     		mov	r1, r4
 2337 0068 FFF7FEFF 		bl	i2c_set_own_7bit_slave_address
 2338              	.LVL241:
1041:arch/stm32/mcu_periph/i2c_arch.c **** 
 2339              		.loc 1 1041 0
 2340 006c 3046     		mov	r0, r6
 2341 006e 4FF48071 		mov	r1, #256
 2342 0072 FFF7FEFF 		bl	i2c_enable_interrupt
 2343              	.LVL242:
1043:arch/stm32/mcu_periph/i2c_arch.c **** }
 2344              		.loc 1 1043 0
 2345 0076 2846     		mov	r0, r5
 2346 0078 0549     		ldr	r1, .L188+12
1044:arch/stm32/mcu_periph/i2c_arch.c **** 
 2347              		.loc 1 1044 0
 2348 007a BDE87040 		pop	{r4, r5, r6, lr}
 2349              		.cfi_restore 14
 2350              		.cfi_restore 6
 2351              		.cfi_restore 5
 2352              		.cfi_restore 4
 2353              		.cfi_def_cfa_offset 0
1043:arch/stm32/mcu_periph/i2c_arch.c **** }
 2354              		.loc 1 1043 0
 2355 007e FFF7FEBF 		b	i2c_setbitrate
 2356              	.LVL243:
 2357              	.L189:
 2358 0082 00BF     		.align	2
 2359              	.L188:
 2360 0084 00000000 		.word	.LANCHOR2
 2361 0088 00000000 		.word	i2c2
 2362 008c 00580040 		.word	1073764352
 2363 0090 E0930400 		.word	300000
 2364              		.cfi_endproc
 2365              	.LFE20:
 2367              		.global	i2c2_errors
 2368              		.global	i2c1_errors
 2369              		.section	.bss.i2c1_errors,"aw",%nobits
 2370              		.align	2
 2371              		.set	.LANCHOR1,. + 0
 2374              	i2c1_errors:
 2375 0000 00000000 		.space	112
 2375      00000000 
 2375      00000000 
 2375      00000000 
 2375      00000000 
 2376              		.section	.bss.i2c2_errors,"aw",%nobits
 2377              		.align	2
 2378              		.set	.LANCHOR2,. + 0
 2381              	i2c2_errors:
 2382 0000 00000000 		.space	112
 2382      00000000 
 2382      00000000 
 2382      00000000 
 2382      00000000 
 2383              		.section	.bss.i2c_wd_timer.6446,"aw",%nobits
 2384              		.align	2
 2385              		.set	.LANCHOR0,. + 0
 2388              	i2c_wd_timer.6446:
 2389 0000 00000000 		.space	4
 2390              		.text
 2391              	.Letext0:
 2392              		.file 4 "/usr/arm-none-eabi/include/machine/_default_types.h"
 2393              		.file 5 "/usr/arm-none-eabi/include/sys/_stdint.h"
 2394              		.file 6 "/home/dino/paparazzi/sw/include/std.h"
 2395              		.file 7 "./mcu_periph/i2c.h"
 2396              		.file 8 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
 2397              		.file 9 "../ext/libopencm3/include/libopencm3/stm32/common/i2c_common_all.h"
 2398              		.file 10 "../ext/libopencm3/include/libopencm3/cm3/systick.h"
 2399              		.file 11 "/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/gpio_arch.h"
 2400              		.file 12 "../ext/libopencm3/include/libopencm3/stm32/common/gpio_common_f234.h"
 2401              		.file 13 "../ext/libopencm3/include/libopencm3/stm32/common/gpio_common_all.h"
 2402              		.file 14 "../ext/libopencm3/include/libopencm3/cm3/nvic.h"
 2403              		.file 15 "../ext/libopencm3/include/libopencm3/stm32/common/rcc_common_all.h"
DEFINED SYMBOLS
                            *ABS*:00000000 i2c_arch.c
     /tmp/ccgxsc4z.s:20     .text.i2c_error:00000000 $t
     /tmp/ccgxsc4z.s:24     .text.i2c_error:00000000 i2c_error
     /tmp/ccgxsc4z.s:141    .text.PPRZ_I2C_SEND_START:00000000 $t
     /tmp/ccgxsc4z.s:145    .text.PPRZ_I2C_SEND_START:00000000 PPRZ_I2C_SEND_START
     /tmp/ccgxsc4z.s:210    .text.get_sys_time_usec:00000000 $t
     /tmp/ccgxsc4z.s:214    .text.get_sys_time_usec:00000000 get_sys_time_usec
     /tmp/ccgxsc4z.s:287    .text.get_sys_time_usec:00000038 $d
     /tmp/ccgxsc4z.s:293    .text.i2c_setup_gpio.part.0:00000000 $t
     /tmp/ccgxsc4z.s:297    .text.i2c_setup_gpio.part.0:00000000 i2c_setup_gpio.part.0
     /tmp/ccgxsc4z.s:342    .text.i2c_setup_gpio.part.0:00000038 $d
     /tmp/ccgxsc4z.s:347    .text.i2c_setup_gpio:00000000 $t
     /tmp/ccgxsc4z.s:351    .text.i2c_setup_gpio:00000000 i2c_setup_gpio
     /tmp/ccgxsc4z.s:415    .text.i2c_setup_gpio:0000004c $d
     /tmp/ccgxsc4z.s:421    .text.stmi2c_clear_pending_interrupts:00000000 $t
     /tmp/ccgxsc4z.s:425    .text.stmi2c_clear_pending_interrupts:00000000 stmi2c_clear_pending_interrupts
     /tmp/ccgxsc4z.s:507    .text.i2c_scl_clear:00000000 $t
     /tmp/ccgxsc4z.s:511    .text.i2c_scl_clear:00000000 i2c_scl_clear
     /tmp/ccgxsc4z.s:550    .text.i2c_scl_clear:00000020 $d
     /tmp/ccgxsc4z.s:559    .text.i2c_scl_set:00000000 $t
     /tmp/ccgxsc4z.s:563    .text.i2c_scl_set:00000000 i2c_scl_set
     /tmp/ccgxsc4z.s:602    .text.i2c_scl_set:00000020 $d
     /tmp/ccgxsc4z.s:611    .text.i2c_wd_check:00000000 $t
     /tmp/ccgxsc4z.s:615    .text.i2c_wd_check:00000000 i2c_wd_check
     /tmp/ccgxsc4z.s:782    .text.i2c_wd_check:000000d4 $d
     /tmp/ccgxsc4z.s:789    .text.i2c_irq.constprop.6:00000000 $t
     /tmp/ccgxsc4z.s:793    .text.i2c_irq.constprop.6:00000000 i2c_irq.constprop.6
     /tmp/ccgxsc4z.s:1576   .text.i2c1_ev_isr:00000000 $t
     /tmp/ccgxsc4z.s:1581   .text.i2c1_ev_isr:00000000 i2c1_ev_isr
     /tmp/ccgxsc4z.s:1628   .text.i2c1_ev_isr:00000028 $d
     /tmp/ccgxsc4z.s:1633   .text.i2c1_er_isr:00000000 $t
     /tmp/ccgxsc4z.s:1638   .text.i2c1_er_isr:00000000 i2c1_er_isr
     /tmp/ccgxsc4z.s:1685   .text.i2c1_er_isr:00000028 $d
     /tmp/ccgxsc4z.s:1690   .text.i2c2_ev_isr:00000000 $t
     /tmp/ccgxsc4z.s:1695   .text.i2c2_ev_isr:00000000 i2c2_ev_isr
     /tmp/ccgxsc4z.s:1742   .text.i2c2_ev_isr:00000028 $d
     /tmp/ccgxsc4z.s:1747   .text.i2c2_er_isr:00000000 $t
     /tmp/ccgxsc4z.s:1752   .text.i2c2_er_isr:00000000 i2c2_er_isr
     /tmp/ccgxsc4z.s:1799   .text.i2c2_er_isr:00000028 $d
     /tmp/ccgxsc4z.s:1804   .text.i2c_event:00000000 $t
     /tmp/ccgxsc4z.s:1809   .text.i2c_event:00000000 i2c_event
     /tmp/ccgxsc4z.s:1852   .text.i2c_event:0000002c $d
     /tmp/ccgxsc4z.s:1859   .text.i2c_submit:00000000 $t
     /tmp/ccgxsc4z.s:1864   .text.i2c_submit:00000000 i2c_submit
     /tmp/ccgxsc4z.s:1950   .text.i2c_idle:00000000 $t
     /tmp/ccgxsc4z.s:1955   .text.i2c_idle:00000000 i2c_idle
     /tmp/ccgxsc4z.s:1987   .text.i2c_setbitrate:00000000 $t
     /tmp/ccgxsc4z.s:1992   .text.i2c_setbitrate:00000000 i2c_setbitrate
     /tmp/ccgxsc4z.s:2128   .text.i2c_setbitrate:000000a0 $d
     /tmp/ccgxsc4z.s:2134   .text.i2c1_hw_init:00000000 $t
     /tmp/ccgxsc4z.s:2139   .text.i2c1_hw_init:00000000 i2c1_hw_init
     /tmp/ccgxsc4z.s:2244   .text.i2c1_hw_init:00000080 $d
     /tmp/ccgxsc4z.s:2252   .text.i2c2_hw_init:00000000 $t
     /tmp/ccgxsc4z.s:2257   .text.i2c2_hw_init:00000000 i2c2_hw_init
     /tmp/ccgxsc4z.s:2360   .text.i2c2_hw_init:00000084 $d
     /tmp/ccgxsc4z.s:2381   .bss.i2c2_errors:00000000 i2c2_errors
     /tmp/ccgxsc4z.s:2374   .bss.i2c1_errors:00000000 i2c1_errors
     /tmp/ccgxsc4z.s:2370   .bss.i2c1_errors:00000000 $d
     /tmp/ccgxsc4z.s:2377   .bss.i2c2_errors:00000000 $d
     /tmp/ccgxsc4z.s:2384   .bss.i2c_wd_timer.6446:00000000 $d
     /tmp/ccgxsc4z.s:2388   .bss.i2c_wd_timer.6446:00000000 i2c_wd_timer.6446
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.7f506cdee5614e5fae524d20989ad8c8
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._intsup.h.10.b2832a532eae49c14d45880be6d4ca65
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.23.a096771aacee9aba4b33c2d04aacc9b1
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4._ansi.h.13.1b5575dc7921a4c0cff7dbaa2f33e670
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.ad242c9287d2217c7d2035216e5d04ca
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.common.h.21.22efaac882611267214d0a36f6f15e74
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.i2c_common_all.h.33.0891c362b103dbf9b3c797a7eb8c45dd
                           .group:00000000 wm4.i2c.h.84.34a7bcc5d6061ae04ce49649a64c2253
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.i2c.h.173.edf41ec62e7796285c1333ff32983d5f
                           .group:00000000 wm4.apogee_1.0.h.2.34ab7bb688056eecb54e2e3ffff48ca6
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.nvic.h.38.b26077e701ba065ebce4922ce89b9357
                           .group:00000000 wm4.nvic.h.16.68b2cd144a8737a35a31e344912a6e4f
                           .group:00000000 wm4.scb.h.22.290c4c25c761b65def084c067920a0d2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.54.cd3744e0b066087ec8fbb1bdc22d1043
                           .group:00000000 wm4.sys_time.h.40.92f532b5cea824e0ec5ea845e7275d34
                           .group:00000000 wm4.systick.h.44.34e759e1f218a187b07e9a617cb1d556
                           .group:00000000 wm4.sys_time.h.213.4ee43452c5934214134db56488f53299

UNDEFINED SYMBOLS
i2c_enable_interrupt
i2c_disable_interrupt
i2c_nack_current
i2c_disable_ack
i2c_clear_stop
i2c_peripheral_enable
i2c_send_start
systick_get_reload
systick_get_value
sys_time
gpio_enable_clock
gpio_mode_setup
gpio_set_output_options
gpio_set_af
i2c_send_data
i2c_get_data
gpio_clear
gpio_set
i2c_peripheral_disable
gpio_setup_output
gpio_setup_input
i2c_send_stop
i2c_enable_ack
i2c_nack_next
i2c1
i2c2
i2c_set_clock_frequency
i2c_set_ccr
i2c_set_trise
rcc_apb1_frequency
nvic_set_priority
nvic_enable_irq
rcc_periph_clock_enable
rcc_periph_reset_pulse
i2c_set_own_7bit_slave_address
