   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"adc_arch.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.adc_init,"ax",%progbits
  20              		.align	1
  21              		.global	adc_init
  22              		.thumb
  23              		.thumb_func
  25              	adc_init:
  26              	.LFB5:
  27              		.file 1 "arch/stm32/mcu_periph/adc_arch.c"
   1:arch/stm32/mcu_periph/adc_arch.c **** /*
   2:arch/stm32/mcu_periph/adc_arch.c ****  * Copyright (C) 2010-2013 The Paparazzi Team
   3:arch/stm32/mcu_periph/adc_arch.c ****  *
   4:arch/stm32/mcu_periph/adc_arch.c ****  * This file is part of paparazzi.
   5:arch/stm32/mcu_periph/adc_arch.c ****  *
   6:arch/stm32/mcu_periph/adc_arch.c ****  * paparazzi is free software; you can redistribute it and/or modify
   7:arch/stm32/mcu_periph/adc_arch.c ****  * it under the terms of the GNU General Public License as published by
   8:arch/stm32/mcu_periph/adc_arch.c ****  * the Free Software Foundation; either version 2, or (at your option)
   9:arch/stm32/mcu_periph/adc_arch.c ****  * any later version.
  10:arch/stm32/mcu_periph/adc_arch.c ****  *
  11:arch/stm32/mcu_periph/adc_arch.c ****  * paparazzi is distributed in the hope that it will be useful,
  12:arch/stm32/mcu_periph/adc_arch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:arch/stm32/mcu_periph/adc_arch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:arch/stm32/mcu_periph/adc_arch.c ****  * GNU General Public License for more details.
  15:arch/stm32/mcu_periph/adc_arch.c ****  *
  16:arch/stm32/mcu_periph/adc_arch.c ****  * You should have received a copy of the GNU General Public License
  17:arch/stm32/mcu_periph/adc_arch.c ****  * along with paparazzi; see the file COPYING.  If not, write to
  18:arch/stm32/mcu_periph/adc_arch.c ****  * the Free Software Foundation, 59 Temple Place - Suite 330,
  19:arch/stm32/mcu_periph/adc_arch.c ****  * Boston, MA 02111-1307, USA.
  20:arch/stm32/mcu_periph/adc_arch.c ****  */
  21:arch/stm32/mcu_periph/adc_arch.c **** /**
  22:arch/stm32/mcu_periph/adc_arch.c ****  * @file arch/stm32/mcu_periph/adc_arch.c
  23:arch/stm32/mcu_periph/adc_arch.c ****  * @ingroup stm32_arch
  24:arch/stm32/mcu_periph/adc_arch.c ****  *
  25:arch/stm32/mcu_periph/adc_arch.c ****  * Driver for the analog to digital converters on STM32.
  26:arch/stm32/mcu_periph/adc_arch.c ****  *
  27:arch/stm32/mcu_periph/adc_arch.c ****  * Usage:
  28:arch/stm32/mcu_periph/adc_arch.c ****  * Define flags for ADCs to use (can be explicitly disabled by setting to 0):
  29:arch/stm32/mcu_periph/adc_arch.c ****  *
  30:arch/stm32/mcu_periph/adc_arch.c ****  *   -DUSE_ADC_1 -DUSE_ADC_3=1 -DUSE_ADC_4=0
  31:arch/stm32/mcu_periph/adc_arch.c ****  *
  32:arch/stm32/mcu_periph/adc_arch.c ****  * would explicitly enable the ADC_1 and ADC_3 and disable ADC_4.
  33:arch/stm32/mcu_periph/adc_arch.c ****  *
  34:arch/stm32/mcu_periph/adc_arch.c ****  * The mapping of these virtual "board" ADC_x numbers to a concrete AD converter
  35:arch/stm32/mcu_periph/adc_arch.c ****  * and channel is done in the sw/airborne/boards/<boardname>.h header files.
  36:arch/stm32/mcu_periph/adc_arch.c ****  * Some ADCs are normally already enabled in the board files per default
  37:arch/stm32/mcu_periph/adc_arch.c ****  * (e.g. for battery voltage measurement).
  38:arch/stm32/mcu_periph/adc_arch.c ****  *
  39:arch/stm32/mcu_periph/adc_arch.c ****  */
  40:arch/stm32/mcu_periph/adc_arch.c **** 
  41:arch/stm32/mcu_periph/adc_arch.c **** /*
  42:arch/stm32/mcu_periph/adc_arch.c ****   For better understanding of timer and GPIO settings:
  43:arch/stm32/mcu_periph/adc_arch.c **** 
  44:arch/stm32/mcu_periph/adc_arch.c ****   Table of GPIO pins available per ADC:
  45:arch/stm32/mcu_periph/adc_arch.c **** 
  46:arch/stm32/mcu_periph/adc_arch.c ****   ADC1/2:                   ADC3:
  47:arch/stm32/mcu_periph/adc_arch.c ****   C0  -> PA0                C0  -> PA0
  48:arch/stm32/mcu_periph/adc_arch.c ****   C1  -> PA1                C1  -> PA1
  49:arch/stm32/mcu_periph/adc_arch.c ****   C2  -> PA2                C2  -> PA2
  50:arch/stm32/mcu_periph/adc_arch.c ****   C3  -> PA3                C3  -> PA3
  51:arch/stm32/mcu_periph/adc_arch.c ****   C4  -> PA4                C4  -> PF6
  52:arch/stm32/mcu_periph/adc_arch.c ****   C5  -> PA5                C5  -> PF7
  53:arch/stm32/mcu_periph/adc_arch.c ****   C6  -> PA6                C6  -> PF8
  54:arch/stm32/mcu_periph/adc_arch.c ****   C7  -> PA7                C7  -> PF9
  55:arch/stm32/mcu_periph/adc_arch.c ****   C8  -> PB0                C8  -> PF10
  56:arch/stm32/mcu_periph/adc_arch.c ****   C9  -> PB1
  57:arch/stm32/mcu_periph/adc_arch.c ****   C10 -> PC0                C10 -> PC0
  58:arch/stm32/mcu_periph/adc_arch.c ****   C11 -> PC1                C11 -> PC1
  59:arch/stm32/mcu_periph/adc_arch.c ****   C12 -> PC2                C12 -> PC2
  60:arch/stm32/mcu_periph/adc_arch.c ****   C13 -> PC3                C13 -> PC3
  61:arch/stm32/mcu_periph/adc_arch.c ****   C14 -> PC4
  62:arch/stm32/mcu_periph/adc_arch.c ****   C15 -> PC5
  63:arch/stm32/mcu_periph/adc_arch.c **** 
  64:arch/stm32/mcu_periph/adc_arch.c ****   Table of timers available per ADC (from libstm/src/stm32_adc.c):
  65:arch/stm32/mcu_periph/adc_arch.c **** 
  66:arch/stm32/mcu_periph/adc_arch.c ****   T1_TRGO:    Timer1 TRGO event (ADC1, ADC2 and ADC3)
  67:arch/stm32/mcu_periph/adc_arch.c ****   T1_CC4:     Timer1 capture compare4 (ADC1, ADC2 and ADC3)
  68:arch/stm32/mcu_periph/adc_arch.c ****   T2_TRGO:    Timer2 TRGO event (ADC1 and ADC2)
  69:arch/stm32/mcu_periph/adc_arch.c ****   T2_CC1:     Timer2 capture compare1 (ADC1 and ADC2)
  70:arch/stm32/mcu_periph/adc_arch.c ****   T3_CC4:     Timer3 capture compare4 (ADC1 and ADC2)
  71:arch/stm32/mcu_periph/adc_arch.c ****   T4_TRGO:    Timer4 TRGO event (ADC1 and ADC2)
  72:arch/stm32/mcu_periph/adc_arch.c ****   TIM8_CC4: External interrupt line 15 or Timer8 capture compare4 event (ADC1 and ADC2)
  73:arch/stm32/mcu_periph/adc_arch.c ****   T4_CC3:     Timer4 capture compare3 (ADC3 only)
  74:arch/stm32/mcu_periph/adc_arch.c ****   T8_CC2:     Timer8 capture compare2 (ADC3 only)
  75:arch/stm32/mcu_periph/adc_arch.c ****   T8_CC4:     Timer8 capture compare4 (ADC3 only)
  76:arch/stm32/mcu_periph/adc_arch.c ****   T5_TRGO:    Timer5 TRGO event (ADC3 only)
  77:arch/stm32/mcu_periph/adc_arch.c ****   T5_CC4:     Timer5 capture compare4 (ADC3 only)
  78:arch/stm32/mcu_periph/adc_arch.c **** 
  79:arch/stm32/mcu_periph/adc_arch.c ****   By setting ADC_ExternalTrigInjecConv_None, injected conversion
  80:arch/stm32/mcu_periph/adc_arch.c ****   is started by software instead of external trigger for any ADC.
  81:arch/stm32/mcu_periph/adc_arch.c **** 
  82:arch/stm32/mcu_periph/adc_arch.c ****   Table of APB per Timer (from libstm/src/stm32_tim.c):
  83:arch/stm32/mcu_periph/adc_arch.c **** 
  84:arch/stm32/mcu_periph/adc_arch.c ****   RCC_APB1: TIM2, TIM3, TIM4, TIM5, TIM7 (non-advanced timers)
  85:arch/stm32/mcu_periph/adc_arch.c ****   RCC_APB2: TIM1, TIM8 (advanced timers)
  86:arch/stm32/mcu_periph/adc_arch.c **** 
  87:arch/stm32/mcu_periph/adc_arch.c **** */
  88:arch/stm32/mcu_periph/adc_arch.c **** 
  89:arch/stm32/mcu_periph/adc_arch.c **** #include "mcu_periph/adc.h"
  90:arch/stm32/mcu_periph/adc_arch.c **** 
  91:arch/stm32/mcu_periph/adc_arch.c **** #include <libopencm3/stm32/rcc.h>
  92:arch/stm32/mcu_periph/adc_arch.c **** #include <libopencm3/stm32/gpio.h>
  93:arch/stm32/mcu_periph/adc_arch.c **** #include <libopencm3/stm32/adc.h>
  94:arch/stm32/mcu_periph/adc_arch.c **** #include <libopencm3/cm3/nvic.h>
  95:arch/stm32/mcu_periph/adc_arch.c **** #include <libopencm3/stm32/timer.h>
  96:arch/stm32/mcu_periph/adc_arch.c **** #include <string.h>
  97:arch/stm32/mcu_periph/adc_arch.c **** #include "mcu_periph/gpio.h"
  98:arch/stm32/mcu_periph/adc_arch.c **** #include "mcu_arch.h"
  99:arch/stm32/mcu_periph/adc_arch.c **** #include "std.h"
 100:arch/stm32/mcu_periph/adc_arch.c **** #include BOARD_CONFIG
 101:arch/stm32/mcu_periph/adc_arch.c **** 
 102:arch/stm32/mcu_periph/adc_arch.c **** 
 103:arch/stm32/mcu_periph/adc_arch.c **** #ifndef NVIC_ADC_IRQ_PRIO
 104:arch/stm32/mcu_periph/adc_arch.c **** #define NVIC_ADC_IRQ_PRIO 0
 105:arch/stm32/mcu_periph/adc_arch.c **** #endif
 106:arch/stm32/mcu_periph/adc_arch.c **** 
 107:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 108:arch/stm32/mcu_periph/adc_arch.c **** #define ADC_SAMPLE_TIME ADC_SMPR_SMP_41DOT5CYC
 109:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 110:arch/stm32/mcu_periph/adc_arch.c **** #define ADC_SAMPLE_TIME ADC_SMPR_SMP_56CYC
 111:arch/stm32/mcu_periph/adc_arch.c **** #endif
 112:arch/stm32/mcu_periph/adc_arch.c **** 
 113:arch/stm32/mcu_periph/adc_arch.c **** // Macros to automatically enable the correct ADC
 114:arch/stm32/mcu_periph/adc_arch.c **** 
 115:arch/stm32/mcu_periph/adc_arch.c **** #if defined(AD1_1_CHANNEL) || defined(AD1_2_CHANNEL) || defined(AD1_3_CHANNEL) || defined(AD1_4_CHA
 116:arch/stm32/mcu_periph/adc_arch.c **** #ifndef USE_AD1
 117:arch/stm32/mcu_periph/adc_arch.c **** #define USE_AD1 1
 118:arch/stm32/mcu_periph/adc_arch.c **** #endif
 119:arch/stm32/mcu_periph/adc_arch.c **** #endif
 120:arch/stm32/mcu_periph/adc_arch.c **** 
 121:arch/stm32/mcu_periph/adc_arch.c **** #if defined(AD2_1_CHANNEL) || defined(AD2_2_CHANNEL) || defined(AD2_3_CHANNEL) || defined(AD2_4_CHA
 122:arch/stm32/mcu_periph/adc_arch.c **** #ifndef USE_AD2
 123:arch/stm32/mcu_periph/adc_arch.c **** #define USE_AD2 1
 124:arch/stm32/mcu_periph/adc_arch.c **** #endif
 125:arch/stm32/mcu_periph/adc_arch.c **** #endif
 126:arch/stm32/mcu_periph/adc_arch.c **** 
 127:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F4)
 128:arch/stm32/mcu_periph/adc_arch.c **** 
 129:arch/stm32/mcu_periph/adc_arch.c **** #if defined(AD3_1_CHANNEL) || defined(AD3_2_CHANNEL) || defined(AD3_3_CHANNEL) || defined(AD3_4_CHA
 130:arch/stm32/mcu_periph/adc_arch.c **** #ifndef USE_AD3
 131:arch/stm32/mcu_periph/adc_arch.c **** #define USE_AD3 1
 132:arch/stm32/mcu_periph/adc_arch.c **** #endif
 133:arch/stm32/mcu_periph/adc_arch.c **** #endif
 134:arch/stm32/mcu_periph/adc_arch.c **** 
 135:arch/stm32/mcu_periph/adc_arch.c **** #else // !STM32F4
 136:arch/stm32/mcu_periph/adc_arch.c **** // ADC 3 not supported on STM32F1
 137:arch/stm32/mcu_periph/adc_arch.c **** #undef USE_AD3
 138:arch/stm32/mcu_periph/adc_arch.c **** #define USE_AD3 0
 139:arch/stm32/mcu_periph/adc_arch.c **** #endif
 140:arch/stm32/mcu_periph/adc_arch.c **** 
 141:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 142:arch/stm32/mcu_periph/adc_arch.c **** PRINT_CONFIG_MSG("Analog to Digital Coverter 1 active")
 143:arch/stm32/mcu_periph/adc_arch.c **** #endif
 144:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 145:arch/stm32/mcu_periph/adc_arch.c **** PRINT_CONFIG_MSG("Analog to Digital Coverter 2 active")
 146:arch/stm32/mcu_periph/adc_arch.c **** #endif
 147:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 148:arch/stm32/mcu_periph/adc_arch.c **** PRINT_CONFIG_MSG("Analog to Digital Coverter 3 active")
 149:arch/stm32/mcu_periph/adc_arch.c **** #endif
 150:arch/stm32/mcu_periph/adc_arch.c **** #if !USE_AD1 && !USE_AD2 && !USE_AD3
 151:arch/stm32/mcu_periph/adc_arch.c **** #warning ALL ADC CONVERTERS INACTIVE
 152:arch/stm32/mcu_periph/adc_arch.c **** #endif
 153:arch/stm32/mcu_periph/adc_arch.c **** 
 154:arch/stm32/mcu_periph/adc_arch.c **** #ifndef ADC_TIMER_PERIOD
 155:arch/stm32/mcu_periph/adc_arch.c **** #define ADC_TIMER_PERIOD 10000
 156:arch/stm32/mcu_periph/adc_arch.c **** #endif
 157:arch/stm32/mcu_periph/adc_arch.c **** 
 158:arch/stm32/mcu_periph/adc_arch.c **** /** Timer frequency for ADC
 159:arch/stm32/mcu_periph/adc_arch.c ****  * Timer will trigger an update event after reaching the period reload value.
 160:arch/stm32/mcu_periph/adc_arch.c ****  * New conversion is triggered on update event.
 161:arch/stm32/mcu_periph/adc_arch.c ****  * ADC measuerement frequency is hence ADC_TIMER_FREQUENCY / ADC_TIMER_PERIOD.
 162:arch/stm32/mcu_periph/adc_arch.c ****  */
 163:arch/stm32/mcu_periph/adc_arch.c **** #ifndef ADC_TIMER_FREQUENCY
 164:arch/stm32/mcu_periph/adc_arch.c **** #define ADC_TIMER_FREQUENCY 2000000
 165:arch/stm32/mcu_periph/adc_arch.c **** #endif
 166:arch/stm32/mcu_periph/adc_arch.c **** 
 167:arch/stm32/mcu_periph/adc_arch.c **** /***************************************/
 168:arch/stm32/mcu_periph/adc_arch.c **** /***   STATIC FUNCTION PROTOTYPES    ***/
 169:arch/stm32/mcu_periph/adc_arch.c **** /***************************************/
 170:arch/stm32/mcu_periph/adc_arch.c **** 
 171:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_single(uint32_t adc, uint8_t nb_channels, uint8_t *channel_map);
 172:arch/stm32/mcu_periph/adc_arch.c **** 
 173:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_push_sample(struct adc_buf *buf,
 174:arch/stm32/mcu_periph/adc_arch.c ****                                    uint16_t sample);
 175:arch/stm32/mcu_periph/adc_arch.c **** 
 176:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_rcc(void);
 177:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_irq(void);
 178:arch/stm32/mcu_periph/adc_arch.c **** 
 179:arch/stm32/mcu_periph/adc_arch.c **** 
 180:arch/stm32/mcu_periph/adc_arch.c **** /********************************/
 181:arch/stm32/mcu_periph/adc_arch.c **** /***     GLOBAL VARIABLES     ***/
 182:arch/stm32/mcu_periph/adc_arch.c **** /********************************/
 183:arch/stm32/mcu_periph/adc_arch.c **** 
 184:arch/stm32/mcu_periph/adc_arch.c **** /* Only 4 ADC channels may be enabled at the same time
 185:arch/stm32/mcu_periph/adc_arch.c ****  * on each ADC, as there are only 4 injection registers.
 186:arch/stm32/mcu_periph/adc_arch.c ****  * Currently, the enums adc1_channels and adc2_channels only
 187:arch/stm32/mcu_periph/adc_arch.c ****  * serve to resolve the number of channels on each ADC.
 188:arch/stm32/mcu_periph/adc_arch.c ****  * There are 3 separate buffer lists, each holds the addresses of the actual adc buffers
 189:arch/stm32/mcu_periph/adc_arch.c ****  * for the particular adc converter.
 190:arch/stm32/mcu_periph/adc_arch.c ****  */
 191:arch/stm32/mcu_periph/adc_arch.c **** 
 192:arch/stm32/mcu_periph/adc_arch.c **** static uint8_t nb_adc1_channels = 0;
 193:arch/stm32/mcu_periph/adc_arch.c **** static uint8_t nb_adc2_channels = 0;
 194:arch/stm32/mcu_periph/adc_arch.c **** static uint8_t nb_adc3_channels = 0;
 195:arch/stm32/mcu_periph/adc_arch.c **** 
 196:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 197:arch/stm32/mcu_periph/adc_arch.c **** /// List of buffers, one for each active channel.
 198:arch/stm32/mcu_periph/adc_arch.c **** static struct adc_buf *adc1_buffers[4];
 199:arch/stm32/mcu_periph/adc_arch.c **** #endif
 200:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 201:arch/stm32/mcu_periph/adc_arch.c **** /// List of buffers, one for each active channel.
 202:arch/stm32/mcu_periph/adc_arch.c **** static struct adc_buf *adc2_buffers[4];
 203:arch/stm32/mcu_periph/adc_arch.c **** #endif
 204:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 205:arch/stm32/mcu_periph/adc_arch.c **** /// List of buffers, one for each active channel.
 206:arch/stm32/mcu_periph/adc_arch.c **** static struct adc_buf *adc3_buffers[4];
 207:arch/stm32/mcu_periph/adc_arch.c **** #endif
 208:arch/stm32/mcu_periph/adc_arch.c **** 
 209:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_WATCHDOG
 210:arch/stm32/mcu_periph/adc_arch.c **** #include "mcu_periph/sys_time.h"
 211:arch/stm32/mcu_periph/adc_arch.c **** // watchdog structure with adc bank and callback
 212:arch/stm32/mcu_periph/adc_arch.c **** static struct {
 213:arch/stm32/mcu_periph/adc_arch.c ****   uint32_t timeStamp;
 214:arch/stm32/mcu_periph/adc_arch.c ****   uint32_t adc;
 215:arch/stm32/mcu_periph/adc_arch.c ****   adc_watchdog_callback cb;
 216:arch/stm32/mcu_periph/adc_arch.c **** } adc_watchdog;
 217:arch/stm32/mcu_periph/adc_arch.c **** #endif
 218:arch/stm32/mcu_periph/adc_arch.c **** 
 219:arch/stm32/mcu_periph/adc_arch.c **** /***************************************/
 220:arch/stm32/mcu_periph/adc_arch.c **** /***   PUBLIC FUNCTION DEFINITIONS   ***/
 221:arch/stm32/mcu_periph/adc_arch.c **** /***************************************/
 222:arch/stm32/mcu_periph/adc_arch.c **** 
 223:arch/stm32/mcu_periph/adc_arch.c **** void adc_init(void)
 224:arch/stm32/mcu_periph/adc_arch.c **** {
  28              		.loc 1 224 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
  34              		.cfi_def_cfa_offset 32
  35              		.cfi_offset 4, -20
  36              		.cfi_offset 5, -16
  37              		.cfi_offset 6, -12
  38              		.cfi_offset 7, -8
  39              		.cfi_offset 14, -4
 225:arch/stm32/mcu_periph/adc_arch.c **** 
 226:arch/stm32/mcu_periph/adc_arch.c ****   uint8_t x = 0;
 227:arch/stm32/mcu_periph/adc_arch.c **** 
 228:arch/stm32/mcu_periph/adc_arch.c ****   // ADC channel mapping
 229:arch/stm32/mcu_periph/adc_arch.c ****   uint8_t adc_channel_map[4];
 230:arch/stm32/mcu_periph/adc_arch.c **** 
 231:arch/stm32/mcu_periph/adc_arch.c ****   /* Init GPIO ports for ADC operation
 232:arch/stm32/mcu_periph/adc_arch.c ****    */
 233:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_1
 234:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_1")
 235:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_1_GPIO_PORT, ADC_1_GPIO_PIN);
 236:arch/stm32/mcu_periph/adc_arch.c **** #endif
 237:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_2
 238:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_2")
 239:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_2_GPIO_PORT, ADC_2_GPIO_PIN);
 240:arch/stm32/mcu_periph/adc_arch.c **** #endif
 241:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_3
 242:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_3")
 243:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_3_GPIO_PORT, ADC_3_GPIO_PIN);
 244:arch/stm32/mcu_periph/adc_arch.c **** #endif
 245:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_4
 246:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_4")
 247:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_4_GPIO_PORT, ADC_4_GPIO_PIN);
  40              		.loc 1 247 0
  41 0002 1021     		movs	r1, #16
  42 0004 4448     		ldr	r0, .L2
  43              	.LBB8:
  44              	.LBB9:
 248:arch/stm32/mcu_periph/adc_arch.c **** #endif
 249:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_5
 250:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_5")
 251:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_5_GPIO_PORT, ADC_5_GPIO_PIN);
 252:arch/stm32/mcu_periph/adc_arch.c **** #endif
 253:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_6
 254:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_6")
 255:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_6_GPIO_PORT, ADC_6_GPIO_PIN);
 256:arch/stm32/mcu_periph/adc_arch.c **** #endif
 257:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_7
 258:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_7")
 259:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_7_GPIO_PORT, ADC_7_GPIO_PIN);
 260:arch/stm32/mcu_periph/adc_arch.c **** #endif
 261:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_8
 262:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_8")
 263:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_8_GPIO_PORT, ADC_8_GPIO_PIN);
 264:arch/stm32/mcu_periph/adc_arch.c **** #endif
 265:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_9
 266:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using ADC_9")
 267:arch/stm32/mcu_periph/adc_arch.c ****   gpio_setup_pin_analog(ADC_9_GPIO_PORT, ADC_9_GPIO_PIN);
 268:arch/stm32/mcu_periph/adc_arch.c **** #endif
 269:arch/stm32/mcu_periph/adc_arch.c **** 
 270:arch/stm32/mcu_periph/adc_arch.c ****   // Init clock and irq
 271:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_rcc();
 272:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_irq();
 273:arch/stm32/mcu_periph/adc_arch.c **** 
 274:arch/stm32/mcu_periph/adc_arch.c ****   /* If fewer than 4 channels are active, say 3, then they are placed in to
 275:arch/stm32/mcu_periph/adc_arch.c ****    * injection slots 2,3 and 4 because the stm32 architecture converts injected
 276:arch/stm32/mcu_periph/adc_arch.c ****    * slots 2,3 and 4 and skips slot 1 instead of logicaly converting slots 1,2
 277:arch/stm32/mcu_periph/adc_arch.c ****    * and 3 and leave slot 4.
 278:arch/stm32/mcu_periph/adc_arch.c ****    * EXAMPLE OF ADC EXECUTION ORDER WHEN WE HAVE SAY 2 ADC INPUTS USED on ADC1
 279:arch/stm32/mcu_periph/adc_arch.c ****    * The first board adc channel ADC1_1 is mapped to injected channel 3 and ADC1_2
 280:arch/stm32/mcu_periph/adc_arch.c ****    * to injected channel 4 and because the conversions start from the lowest
 281:arch/stm32/mcu_periph/adc_arch.c ****    * injection channel used, 3 in our case, injected channel 3 data will be
 282:arch/stm32/mcu_periph/adc_arch.c ****    * located at JDR1 and 4 to JDR2 so JDR1 = ADC1_1 and JDR2 = ADC1_2.
 283:arch/stm32/mcu_periph/adc_arch.c ****    * That's why "adc_channel_map" has this descending order.
 284:arch/stm32/mcu_periph/adc_arch.c ****    */
 285:arch/stm32/mcu_periph/adc_arch.c **** 
 286:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels = 0;
 287:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 288:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD1_1_CHANNEL
 289:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD1_1] = AD1_1_CHANNEL;
 290:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 291:arch/stm32/mcu_periph/adc_arch.c **** #endif
 292:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD1_2_CHANNEL
 293:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD1_2] = AD1_2_CHANNEL;
 294:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 295:arch/stm32/mcu_periph/adc_arch.c **** #endif
 296:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD1_3_CHANNEL
 297:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD1_3] = AD1_3_CHANNEL;
 298:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 299:arch/stm32/mcu_periph/adc_arch.c **** #endif
 300:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD1_4_CHANNEL
 301:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD1_4] = AD1_4_CHANNEL;
 302:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 303:arch/stm32/mcu_periph/adc_arch.c **** #endif
 304:arch/stm32/mcu_periph/adc_arch.c ****   // initialize buffer pointers with 0 (not set). Buffer null pointers will be ignored in interrupt
 305:arch/stm32/mcu_periph/adc_arch.c ****   // handler, which is important as there are no buffers registered at the time the ADC trigger
 306:arch/stm32/mcu_periph/adc_arch.c ****   // interrupt is enabled.
 307:arch/stm32/mcu_periph/adc_arch.c ****   for (x = 0; x < 4; x++) { adc1_buffers[x] = NULL; }
 308:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_single(ADC1, nb_adc1_channels, adc_channel_map);
 309:arch/stm32/mcu_periph/adc_arch.c **** #endif // USE_AD1
 310:arch/stm32/mcu_periph/adc_arch.c **** 
 311:arch/stm32/mcu_periph/adc_arch.c **** 
 312:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc2_channels = 0;
 313:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 314:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD2_1_CHANNEL
 315:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD2_1 - nb_adc1_channels] = AD2_1_CHANNEL;
 316:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc2_channels++;
 317:arch/stm32/mcu_periph/adc_arch.c **** #endif
 318:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD2_2_CHANNEL
 319:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD2_2 - nb_adc1_channels] = AD2_2_CHANNEL;
 320:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc2_channels++;
 321:arch/stm32/mcu_periph/adc_arch.c **** #endif
 322:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD2_3_CHANNEL
 323:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD2_3 - nb_adc1_channels] = AD2_3_CHANNEL;
 324:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc2_channels++;
 325:arch/stm32/mcu_periph/adc_arch.c **** #endif
 326:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD2_4_CHANNEL
 327:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD2_4 - nb_adc1_channels] = AD2_4_CHANNEL;
 328:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc2_channels++;
 329:arch/stm32/mcu_periph/adc_arch.c **** #endif
 330:arch/stm32/mcu_periph/adc_arch.c ****   // initialize buffer pointers with 0 (not set). Buffer null pointers will be ignored in interrupt
 331:arch/stm32/mcu_periph/adc_arch.c ****   // handler, which is important as there are no buffers registered at the time the ADC trigger
 332:arch/stm32/mcu_periph/adc_arch.c ****   // interrupt is enabled.
 333:arch/stm32/mcu_periph/adc_arch.c ****   for (x = 0; x < 4; x++) { adc2_buffers[x] = NULL; }
 334:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_single(ADC2, nb_adc2_channels, adc_channel_map);
 335:arch/stm32/mcu_periph/adc_arch.c **** #endif // USE_AD2
 336:arch/stm32/mcu_periph/adc_arch.c **** 
 337:arch/stm32/mcu_periph/adc_arch.c **** 
 338:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc3_channels = 0;
 339:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 340:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD3_1_CHANNEL
 341:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD3_1 - nb_adc1_channels - nb_adc2_channels] = AD3_1_CHANNEL;
 342:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc3_channels++;
 343:arch/stm32/mcu_periph/adc_arch.c **** #endif
 344:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD3_2_CHANNEL
 345:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD3_2 - nb_adc1_channels - nb_adc2_channels] = AD3_2_CHANNEL;
 346:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc3_channels++;
 347:arch/stm32/mcu_periph/adc_arch.c **** #endif
 348:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD3_3_CHANNEL
 349:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD3_3 - nb_adc1_channels - nb_adc2_channels] = AD3_3_CHANNEL;
 350:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc3_channels++;
 351:arch/stm32/mcu_periph/adc_arch.c **** #endif
 352:arch/stm32/mcu_periph/adc_arch.c **** #ifdef AD3_4_CHANNEL
 353:arch/stm32/mcu_periph/adc_arch.c ****   adc_channel_map[AD3_4 - nb_adc1_channels - nb_adc2_channels] = AD3_4_CHANNEL;
 354:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc3_channels++;
 355:arch/stm32/mcu_periph/adc_arch.c **** #endif
 356:arch/stm32/mcu_periph/adc_arch.c ****   // initialize buffer pointers with 0 (not set). Buffer null pointers will be ignored in interrupt
 357:arch/stm32/mcu_periph/adc_arch.c ****   // handler, which is important as there are no buffers registered at the time the ADC trigger
 358:arch/stm32/mcu_periph/adc_arch.c ****   // interrupt is enabled.
 359:arch/stm32/mcu_periph/adc_arch.c ****   for (x = 0; x < 4; x++) { adc3_buffers[x] = NULL; }
 360:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_single(ADC3, nb_adc3_channels, adc_channel_map);
 361:arch/stm32/mcu_periph/adc_arch.c **** #endif // USE_AD3
 362:arch/stm32/mcu_periph/adc_arch.c **** 
 363:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_WATCHDOG
 364:arch/stm32/mcu_periph/adc_arch.c ****   adc_watchdog.cb = NULL;
 365:arch/stm32/mcu_periph/adc_arch.c ****   adc_watchdog.timeStamp = 0;
 366:arch/stm32/mcu_periph/adc_arch.c **** #endif
 367:arch/stm32/mcu_periph/adc_arch.c **** 
 368:arch/stm32/mcu_periph/adc_arch.c **** }
 369:arch/stm32/mcu_periph/adc_arch.c **** 
 370:arch/stm32/mcu_periph/adc_arch.c **** void adc_buf_channel(uint8_t adc_channel, struct adc_buf *s, uint8_t av_nb_sample)
 371:arch/stm32/mcu_periph/adc_arch.c **** {
 372:arch/stm32/mcu_periph/adc_arch.c **** 
 373:arch/stm32/mcu_periph/adc_arch.c ****   if (adc_channel < nb_adc1_channels) {
 374:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 375:arch/stm32/mcu_periph/adc_arch.c ****     adc1_buffers[adc_channel] = s;
 376:arch/stm32/mcu_periph/adc_arch.c **** #endif
 377:arch/stm32/mcu_periph/adc_arch.c ****   } else if (adc_channel < (nb_adc1_channels + nb_adc2_channels)) {
 378:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 379:arch/stm32/mcu_periph/adc_arch.c ****     adc2_buffers[adc_channel - nb_adc1_channels] = s;
 380:arch/stm32/mcu_periph/adc_arch.c **** #endif
 381:arch/stm32/mcu_periph/adc_arch.c ****   } else if (adc_channel < (nb_adc1_channels + nb_adc2_channels + nb_adc3_channels)) {
 382:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 383:arch/stm32/mcu_periph/adc_arch.c ****     adc3_buffers[adc_channel - (nb_adc1_channels + nb_adc2_channels)] = s;
 384:arch/stm32/mcu_periph/adc_arch.c **** #endif
 385:arch/stm32/mcu_periph/adc_arch.c ****   }
 386:arch/stm32/mcu_periph/adc_arch.c **** 
 387:arch/stm32/mcu_periph/adc_arch.c ****   s->av_nb_sample = av_nb_sample;
 388:arch/stm32/mcu_periph/adc_arch.c **** 
 389:arch/stm32/mcu_periph/adc_arch.c **** }
 390:arch/stm32/mcu_periph/adc_arch.c **** 
 391:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_WATCHDOG
 392:arch/stm32/mcu_periph/adc_arch.c **** void register_adc_watchdog(uint32_t adc, uint8_t chan, uint16_t low, uint16_t high, adc_watchdog_ca
 393:arch/stm32/mcu_periph/adc_arch.c **** {
 394:arch/stm32/mcu_periph/adc_arch.c ****   adc_watchdog.adc = adc;
 395:arch/stm32/mcu_periph/adc_arch.c ****   adc_watchdog.cb = cb;
 396:arch/stm32/mcu_periph/adc_arch.c **** 
 397:arch/stm32/mcu_periph/adc_arch.c ****   // activated adc watchdog of a single injected channel with interrupt
 398:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_watchdog_low_threshold(adc, low);
 399:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_watchdog_high_threshold(adc, high);
 400:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_analog_watchdog_injected(adc);
 401:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_analog_watchdog_on_selected_channel(adc, chan);
 402:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_awd_interrupt(adc);
 403:arch/stm32/mcu_periph/adc_arch.c **** }
 404:arch/stm32/mcu_periph/adc_arch.c **** #endif
 405:arch/stm32/mcu_periph/adc_arch.c **** 
 406:arch/stm32/mcu_periph/adc_arch.c **** /**************************************/
 407:arch/stm32/mcu_periph/adc_arch.c **** /***  PRIVATE FUNCTION DEFINITIONS  ***/
 408:arch/stm32/mcu_periph/adc_arch.c **** /**************************************/
 409:arch/stm32/mcu_periph/adc_arch.c **** 
 410:arch/stm32/mcu_periph/adc_arch.c **** #if defined(USE_AD_TIM4)
 411:arch/stm32/mcu_periph/adc_arch.c **** #define TIM_ADC      TIM4
 412:arch/stm32/mcu_periph/adc_arch.c **** #define RCC_TIM_ADC  RCC_TIM4
 413:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(USE_AD_TIM1)
 414:arch/stm32/mcu_periph/adc_arch.c **** #define TIM_ADC      TIM1
 415:arch/stm32/mcu_periph/adc_arch.c **** #define RCC_TIM_ADC  RCC_TIM1
 416:arch/stm32/mcu_periph/adc_arch.c **** #else
 417:arch/stm32/mcu_periph/adc_arch.c **** #define TIM_ADC      TIM2
 418:arch/stm32/mcu_periph/adc_arch.c **** #define RCC_TIM_ADC  RCC_TIM2
 419:arch/stm32/mcu_periph/adc_arch.c **** #endif
 420:arch/stm32/mcu_periph/adc_arch.c **** 
 421:arch/stm32/mcu_periph/adc_arch.c **** /** Configure and enable RCC for peripherals (ADC1, ADC2, Timer) */
 422:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_rcc(void)
 423:arch/stm32/mcu_periph/adc_arch.c **** {
 424:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1 || USE_AD2 || USE_AD3
 425:arch/stm32/mcu_periph/adc_arch.c ****   /* Timer peripheral clock enable. */
 426:arch/stm32/mcu_periph/adc_arch.c ****   rcc_periph_clock_enable(RCC_TIM_ADC);
 427:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F4)
 428:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_clk_prescale(ADC_CCR_ADCPRE_BY2);
 429:arch/stm32/mcu_periph/adc_arch.c **** #endif
 430:arch/stm32/mcu_periph/adc_arch.c **** 
 431:arch/stm32/mcu_periph/adc_arch.c ****   /* Enable ADC peripheral clocks. */
 432:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 433:arch/stm32/mcu_periph/adc_arch.c ****   rcc_periph_clock_enable(RCC_ADC1);
 434:arch/stm32/mcu_periph/adc_arch.c **** #endif
 435:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 436:arch/stm32/mcu_periph/adc_arch.c ****   rcc_periph_clock_enable(RCC_ADC2);
 437:arch/stm32/mcu_periph/adc_arch.c **** #endif
 438:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 439:arch/stm32/mcu_periph/adc_arch.c ****   rcc_periph_clock_enable(RCC_ADC3);
 440:arch/stm32/mcu_periph/adc_arch.c **** #endif
 441:arch/stm32/mcu_periph/adc_arch.c **** 
 442:arch/stm32/mcu_periph/adc_arch.c ****   /* Time Base configuration */
 443:arch/stm32/mcu_periph/adc_arch.c ****   timer_reset(TIM_ADC);
  45              		.loc 1 443 0
  46 0006 454C     		ldr	r4, .L2+4
  47              	.LBE9:
  48              	.LBE8:
 247:arch/stm32/mcu_periph/adc_arch.c **** #endif
  49              		.loc 1 247 0
  50 0008 FFF7FEFF 		bl	gpio_setup_pin_analog
  51              	.LVL1:
  52              	.LBB11:
  53              	.LBB10:
 426:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F4)
  54              		.loc 1 426 0
  55 000c 40F60200 		movw	r0, #2050
  56 0010 FFF7FEFF 		bl	rcc_periph_clock_enable
  57              	.LVL2:
 428:arch/stm32/mcu_periph/adc_arch.c **** #endif
  58              		.loc 1 428 0
  59 0014 0020     		movs	r0, #0
  60 0016 FFF7FEFF 		bl	adc_set_clk_prescale
  61              	.LVL3:
 433:arch/stm32/mcu_periph/adc_arch.c **** #endif
  62              		.loc 1 433 0
  63 001a 40F68800 		movw	r0, #2184
  64 001e FFF7FEFF 		bl	rcc_periph_clock_enable
  65              	.LVL4:
  66              		.loc 1 443 0
  67 0022 2046     		mov	r0, r4
  68 0024 FFF7FEFF 		bl	timer_reset
  69              	.LVL5:
 444:arch/stm32/mcu_periph/adc_arch.c ****   timer_set_mode(TIM_ADC, TIM_CR1_CKD_CK_INT,
  70              		.loc 1 444 0
  71 0028 0021     		movs	r1, #0
  72 002a 0A46     		mov	r2, r1
  73 002c 0B46     		mov	r3, r1
  74 002e 2046     		mov	r0, r4
  75 0030 FFF7FEFF 		bl	timer_set_mode
  76              	.LVL6:
 445:arch/stm32/mcu_periph/adc_arch.c ****                  TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);
 446:arch/stm32/mcu_periph/adc_arch.c ****   /* timer counts with ADC_TIMER_FREQUENCY */
 447:arch/stm32/mcu_periph/adc_arch.c ****   uint32_t timer_clk = timer_get_frequency(TIM_ADC);
  77              		.loc 1 447 0
  78 0034 2046     		mov	r0, r4
  79 0036 FFF7FEFF 		bl	timer_get_frequency
  80              	.LVL7:
 448:arch/stm32/mcu_periph/adc_arch.c ****   timer_set_prescaler(TIM_ADC, (timer_clk / ADC_TIMER_FREQUENCY) - 1);
  81              		.loc 1 448 0
  82 003a 3949     		ldr	r1, .L2+8
  83 003c B0FBF1F1 		udiv	r1, r0, r1
  84 0040 2046     		mov	r0, r4
  85              	.LVL8:
  86 0042 0139     		subs	r1, r1, #1
  87 0044 FFF7FEFF 		bl	timer_set_prescaler
  88              	.LVL9:
 449:arch/stm32/mcu_periph/adc_arch.c **** 
 450:arch/stm32/mcu_periph/adc_arch.c ****   timer_set_period(TIM_ADC, ADC_TIMER_PERIOD);
  89              		.loc 1 450 0
  90 0048 2046     		mov	r0, r4
  91 004a 42F21071 		movw	r1, #10000
  92 004e FFF7FEFF 		bl	timer_set_period
  93              	.LVL10:
 451:arch/stm32/mcu_periph/adc_arch.c ****   /* Generate TRGO on every update (when counter reaches period reload value) */
 452:arch/stm32/mcu_periph/adc_arch.c ****   timer_set_master_mode(TIM_ADC, TIM_CR2_MMS_UPDATE);
  94              		.loc 1 452 0
  95 0052 2046     		mov	r0, r4
  96 0054 2021     		movs	r1, #32
  97 0056 FFF7FEFF 		bl	timer_set_master_mode
  98              	.LVL11:
 453:arch/stm32/mcu_periph/adc_arch.c ****   timer_enable_counter(TIM_ADC);
  99              		.loc 1 453 0
 100 005a 2046     		mov	r0, r4
 101 005c FFF7FEFF 		bl	timer_enable_counter
 102              	.LVL12:
 103              	.LBE10:
 104              	.LBE11:
 105              	.LBB12:
 106              	.LBB13:
 454:arch/stm32/mcu_periph/adc_arch.c **** 
 455:arch/stm32/mcu_periph/adc_arch.c **** #endif // USE_AD1 || USE_AD2 || USE_AD3
 456:arch/stm32/mcu_periph/adc_arch.c **** }
 457:arch/stm32/mcu_periph/adc_arch.c **** 
 458:arch/stm32/mcu_periph/adc_arch.c **** /** Configure and enable ADC interrupt */
 459:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_irq(void)
 460:arch/stm32/mcu_periph/adc_arch.c **** {
 461:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 462:arch/stm32/mcu_periph/adc_arch.c ****   nvic_set_priority(NVIC_ADC1_2_IRQ, NVIC_ADC_IRQ_PRIO);
 463:arch/stm32/mcu_periph/adc_arch.c ****   nvic_enable_irq(NVIC_ADC1_2_IRQ);
 464:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 465:arch/stm32/mcu_periph/adc_arch.c ****   nvic_set_priority(NVIC_ADC_IRQ, NVIC_ADC_IRQ_PRIO);
 107              		.loc 1 465 0
 108 0060 0721     		movs	r1, #7
 109 0062 1220     		movs	r0, #18
 110 0064 FFF7FEFF 		bl	nvic_set_priority
 111              	.LVL13:
 112              	.LBE13:
 113              	.LBE12:
 301:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 114              		.loc 1 301 0
 115 0068 02AE     		add	r6, sp, #8
 116              	.LBB15:
 117              	.LBB14:
 466:arch/stm32/mcu_periph/adc_arch.c ****   nvic_enable_irq(NVIC_ADC_IRQ);
 118              		.loc 1 466 0
 119 006a 1220     		movs	r0, #18
 120 006c FFF7FEFF 		bl	nvic_enable_irq
 121              	.LVL14:
 122              	.LBE14:
 123              	.LBE15:
 301:arch/stm32/mcu_periph/adc_arch.c ****   nb_adc1_channels++;
 124              		.loc 1 301 0
 125 0070 0423     		movs	r3, #4
 126 0072 06F8043D 		strb	r3, [r6, #-4]!
 302:arch/stm32/mcu_periph/adc_arch.c **** #endif
 127              		.loc 1 302 0
 128 0076 2B4B     		ldr	r3, .L2+12
 129 0078 0127     		movs	r7, #1
 130              	.LBB16:
 131              	.LBB17:
 467:arch/stm32/mcu_periph/adc_arch.c **** #endif
 468:arch/stm32/mcu_periph/adc_arch.c **** }
 469:arch/stm32/mcu_periph/adc_arch.c **** 
 470:arch/stm32/mcu_periph/adc_arch.c **** 
 471:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_init_single(uint32_t adc, uint8_t nb_channels, uint8_t *channel_map)
 472:arch/stm32/mcu_periph/adc_arch.c **** {
 473:arch/stm32/mcu_periph/adc_arch.c ****   // Paranoia, must be down for 2+ ADC clock cycles before calibration
 474:arch/stm32/mcu_periph/adc_arch.c ****   adc_off(adc);
 132              		.loc 1 474 0
 133 007a 04F58C34 		add	r4, r4, #71680
 134              	.LBE17:
 135              	.LBE16:
 302:arch/stm32/mcu_periph/adc_arch.c **** #endif
 136              		.loc 1 302 0
 137 007e 1F70     		strb	r7, [r3]
 307:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_single(ADC1, nb_adc1_channels, adc_channel_map);
 138              		.loc 1 307 0
 139 0080 294B     		ldr	r3, .L2+16
 140 0082 0025     		movs	r5, #0
 141              	.LBB20:
 142              	.LBB18:
 143              		.loc 1 474 0
 144 0084 2046     		mov	r0, r4
 145              	.LBE18:
 146              	.LBE20:
 307:arch/stm32/mcu_periph/adc_arch.c ****   adc_init_single(ADC1, nb_adc1_channels, adc_channel_map);
 147              		.loc 1 307 0
 148 0086 1D60     		str	r5, [r3]
 149              	.LVL15:
 150 0088 5D60     		str	r5, [r3, #4]
 151              	.LVL16:
 152 008a 9D60     		str	r5, [r3, #8]
 153              	.LVL17:
 154 008c DD60     		str	r5, [r3, #12]
 155              	.LVL18:
 156              	.LBB21:
 157              	.LBB19:
 158              		.loc 1 474 0
 159 008e FFF7FEFF 		bl	adc_off
 160              	.LVL19:
 475:arch/stm32/mcu_periph/adc_arch.c **** 
 476:arch/stm32/mcu_periph/adc_arch.c ****   /* Configure ADC */
 477:arch/stm32/mcu_periph/adc_arch.c ****   /* Explicitly setting most registers, reset/default values are correct for most */
 478:arch/stm32/mcu_periph/adc_arch.c ****   /* Set CR1 register. */
 479:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear AWDEN */
 480:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_analog_watchdog_regular(adc);
 161              		.loc 1 480 0
 162 0092 2046     		mov	r0, r4
 163 0094 FFF7FEFF 		bl	adc_disable_analog_watchdog_regular
 164              	.LVL20:
 481:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear JAWDEN */
 482:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_analog_watchdog_injected(adc);
 165              		.loc 1 482 0
 166 0098 2046     		mov	r0, r4
 167 009a FFF7FEFF 		bl	adc_disable_analog_watchdog_injected
 168              	.LVL21:
 483:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear DISCEN */
 484:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_discontinuous_mode_regular(adc);
 169              		.loc 1 484 0
 170 009e 2046     		mov	r0, r4
 171 00a0 FFF7FEFF 		bl	adc_disable_discontinuous_mode_regular
 172              	.LVL22:
 485:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear JDISCEN */
 486:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_discontinuous_mode_injected(adc);
 173              		.loc 1 486 0
 174 00a4 2046     		mov	r0, r4
 175 00a6 FFF7FEFF 		bl	adc_disable_discontinuous_mode_injected
 176              	.LVL23:
 487:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear JAUTO */
 488:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_automatic_injected_group_conversion(adc);
 177              		.loc 1 488 0
 178 00aa 2046     		mov	r0, r4
 179 00ac FFF7FEFF 		bl	adc_disable_automatic_injected_group_conversion
 180              	.LVL24:
 489:arch/stm32/mcu_periph/adc_arch.c ****   /* Set SCAN */
 490:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_scan_mode(adc);
 181              		.loc 1 490 0
 182 00b0 2046     		mov	r0, r4
 183 00b2 FFF7FEFF 		bl	adc_enable_scan_mode
 184              	.LVL25:
 491:arch/stm32/mcu_periph/adc_arch.c ****   /* Enable ADC<X> JEOC interrupt (Set JEOCIE) */
 492:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_eoc_interrupt_injected(adc);
 185              		.loc 1 492 0
 186 00b6 2046     		mov	r0, r4
 187 00b8 FFF7FEFF 		bl	adc_enable_eoc_interrupt_injected
 188              	.LVL26:
 493:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear AWDIE */
 494:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_awd_interrupt(adc);
 189              		.loc 1 494 0
 190 00bc 2046     		mov	r0, r4
 191 00be FFF7FEFF 		bl	adc_disable_awd_interrupt
 192              	.LVL27:
 495:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear EOCIE */
 496:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_eoc_interrupt(adc);
 193              		.loc 1 496 0
 194 00c2 2046     		mov	r0, r4
 195 00c4 FFF7FEFF 		bl	adc_disable_eoc_interrupt
 196              	.LVL28:
 497:arch/stm32/mcu_periph/adc_arch.c **** 
 498:arch/stm32/mcu_periph/adc_arch.c ****   /* Set CR2 register. */
 499:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear TSVREFE */
 500:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 501:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_temperature_sensor(adc);
 502:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 503:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_temperature_sensor();
 197              		.loc 1 503 0
 198 00c8 FFF7FEFF 		bl	adc_disable_temperature_sensor
 199              	.LVL29:
 504:arch/stm32/mcu_periph/adc_arch.c **** #endif
 505:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear EXTTRIG */
 506:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_external_trigger_regular(adc);
 200              		.loc 1 506 0
 201 00cc 2046     		mov	r0, r4
 202 00ce FFF7FEFF 		bl	adc_disable_external_trigger_regular
 203              	.LVL30:
 507:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear ALIGN */
 508:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_right_aligned(adc);
 204              		.loc 1 508 0
 205 00d2 2046     		mov	r0, r4
 206 00d4 FFF7FEFF 		bl	adc_set_right_aligned
 207              	.LVL31:
 509:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear DMA */
 510:arch/stm32/mcu_periph/adc_arch.c ****   adc_disable_dma(adc);
 208              		.loc 1 510 0
 209 00d8 2046     		mov	r0, r4
 210 00da FFF7FEFF 		bl	adc_disable_dma
 211              	.LVL32:
 511:arch/stm32/mcu_periph/adc_arch.c ****   /* Clear CONT */
 512:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_single_conversion_mode(adc);
 212              		.loc 1 512 0
 213 00de 2046     		mov	r0, r4
 214 00e0 FFF7FEFF 		bl	adc_set_single_conversion_mode
 215              	.LVL33:
 513:arch/stm32/mcu_periph/adc_arch.c **** 
 514:arch/stm32/mcu_periph/adc_arch.c ****   //uint8_t x = 0;
 515:arch/stm32/mcu_periph/adc_arch.c ****   //for (x = 0; x < nb_channels; x++) {
 516:arch/stm32/mcu_periph/adc_arch.c ****   //  adc_set_sample_time(adc, channel_map[x], ADC_SAMPLE_TIME);
 517:arch/stm32/mcu_periph/adc_arch.c ****   //}
 518:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_sample_time_on_all_channels(adc, ADC_SAMPLE_TIME);
 216              		.loc 1 518 0
 217 00e4 2046     		mov	r0, r4
 218 00e6 0321     		movs	r1, #3
 219 00e8 FFF7FEFF 		bl	adc_set_sample_time_on_all_channels
 220              	.LVL34:
 519:arch/stm32/mcu_periph/adc_arch.c **** 
 520:arch/stm32/mcu_periph/adc_arch.c ****   adc_set_injected_sequence(adc, nb_channels, channel_map);
 221              		.loc 1 520 0
 222 00ec 2046     		mov	r0, r4
 223 00ee 3946     		mov	r1, r7
 224 00f0 3246     		mov	r2, r6
 225 00f2 FFF7FEFF 		bl	adc_set_injected_sequence
 226              	.LVL35:
 521:arch/stm32/mcu_periph/adc_arch.c **** 
 522:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD_TIM4
 523:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using TIM4 for ADC")
 524:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 525:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM4_TRGO);
 526:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 527:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM4_TRGO, ADC_CR2_JEXTEN_BOTH_EDGES);
 227              		.loc 1 527 0
 228 00f6 2046     		mov	r0, r4
 229 00f8 4FF41021 		mov	r1, #589824
 230 00fc 4FF44012 		mov	r2, #3145728
 231 0100 FFF7FEFF 		bl	adc_enable_external_trigger_injected
 232              	.LVL36:
 528:arch/stm32/mcu_periph/adc_arch.c **** #endif
 529:arch/stm32/mcu_periph/adc_arch.c **** #elif USE_AD_TIM1
 530:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using TIM1 for ADC")
 531:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 532:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM1_TRGO);
 533:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 534:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM1_TRGO, ADC_CR2_JEXTEN_BOTH_EDGES);
 535:arch/stm32/mcu_periph/adc_arch.c **** #endif
 536:arch/stm32/mcu_periph/adc_arch.c **** #else
 537:arch/stm32/mcu_periph/adc_arch.c ****   PRINT_CONFIG_MSG("Info: Using default TIM2 for ADC")
 538:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 539:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM2_TRGO);
 540:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 541:arch/stm32/mcu_periph/adc_arch.c ****   adc_enable_external_trigger_injected(adc, ADC_CR2_JEXTSEL_TIM2_TRGO, ADC_CR2_JEXTEN_BOTH_EDGES);
 542:arch/stm32/mcu_periph/adc_arch.c **** #endif
 543:arch/stm32/mcu_periph/adc_arch.c **** #endif
 544:arch/stm32/mcu_periph/adc_arch.c **** 
 545:arch/stm32/mcu_periph/adc_arch.c ****   /* Enable ADC<X> */
 546:arch/stm32/mcu_periph/adc_arch.c ****   adc_power_on(adc);
 233              		.loc 1 546 0
 234 0104 2046     		mov	r0, r4
 235 0106 FFF7FEFF 		bl	adc_power_on
 236              	.LVL37:
 237              	.LBE19:
 238              	.LBE21:
 312:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD2
 239              		.loc 1 312 0
 240 010a 084B     		ldr	r3, .L2+20
 241 010c 1D70     		strb	r5, [r3]
 338:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD3
 242              		.loc 1 338 0
 243 010e 084B     		ldr	r3, .L2+24
 244 0110 1D70     		strb	r5, [r3]
 368:arch/stm32/mcu_periph/adc_arch.c **** 
 245              		.loc 1 368 0
 246 0112 03B0     		add	sp, sp, #12
 247              		.cfi_def_cfa_offset 20
 248              		@ sp needed
 249 0114 F0BD     		pop	{r4, r5, r6, r7, pc}
 250              	.LVL38:
 251              	.L3:
 252 0116 00BF     		.align	2
 253              	.L2:
 254 0118 00000240 		.word	1073872896
 255 011c 00080040 		.word	1073743872
 256 0120 80841E00 		.word	2000000
 257 0124 00000000 		.word	.LANCHOR0
 258 0128 00000000 		.word	.LANCHOR1
 259 012c 00000000 		.word	.LANCHOR2
 260 0130 00000000 		.word	.LANCHOR3
 261              		.cfi_endproc
 262              	.LFE5:
 264              		.section	.text.adc_buf_channel,"ax",%progbits
 265              		.align	1
 266              		.global	adc_buf_channel
 267              		.thumb
 268              		.thumb_func
 270              	adc_buf_channel:
 271              	.LFB6:
 371:arch/stm32/mcu_periph/adc_arch.c **** 
 272              		.loc 1 371 0
 273              		.cfi_startproc
 274              		@ args = 0, pretend = 0, frame = 0
 275              		@ frame_needed = 0, uses_anonymous_args = 0
 276              		@ link register save eliminated.
 277              	.LVL39:
 373:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 278              		.loc 1 373 0
 279 0000 044B     		ldr	r3, .L6
 387:arch/stm32/mcu_periph/adc_arch.c **** 
 280              		.loc 1 387 0
 281 0002 81F84520 		strb	r2, [r1, #69]
 373:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 282              		.loc 1 373 0
 283 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 284 0008 8342     		cmp	r3, r0
 375:arch/stm32/mcu_periph/adc_arch.c **** #endif
 285              		.loc 1 375 0
 286 000a 84BF     		itt	hi
 287 000c 024B     		ldrhi	r3, .L6+4
 288 000e 43F82010 		strhi	r1, [r3, r0, lsl #2]
 387:arch/stm32/mcu_periph/adc_arch.c **** 
 289              		.loc 1 387 0
 290 0012 7047     		bx	lr
 291              	.L7:
 292              		.align	2
 293              	.L6:
 294 0014 00000000 		.word	.LANCHOR0
 295 0018 00000000 		.word	.LANCHOR1
 296              		.cfi_endproc
 297              	.LFE6:
 299              		.section	.text.adc_isr,"ax",%progbits
 300              		.align	1
 301              		.weak	adc_isr
 302              		.thumb
 303              		.thumb_func
 305              	adc_isr:
 306              	.LFB11:
 547:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 548:arch/stm32/mcu_periph/adc_arch.c ****   /* Enable ADC<X> reset calibaration register */
 549:arch/stm32/mcu_periph/adc_arch.c ****   adc_reset_calibration(adc);
 550:arch/stm32/mcu_periph/adc_arch.c ****   /* Check the end of ADC<X> reset calibration */
 551:arch/stm32/mcu_periph/adc_arch.c ****   while ((ADC_CR2(adc) & ADC_CR2_RSTCAL) != 0);
 552:arch/stm32/mcu_periph/adc_arch.c ****   /* Start ADC<X> calibaration */
 553:arch/stm32/mcu_periph/adc_arch.c ****   adc_calibration(adc);
 554:arch/stm32/mcu_periph/adc_arch.c ****   /* Check the end of ADC<X> calibration */
 555:arch/stm32/mcu_periph/adc_arch.c ****   while ((ADC_CR2(adc) & ADC_CR2_CAL) != 0);
 556:arch/stm32/mcu_periph/adc_arch.c **** #endif
 557:arch/stm32/mcu_periph/adc_arch.c **** 
 558:arch/stm32/mcu_periph/adc_arch.c ****   return;
 559:arch/stm32/mcu_periph/adc_arch.c **** } // adc_init_single
 560:arch/stm32/mcu_periph/adc_arch.c **** 
 561:arch/stm32/mcu_periph/adc_arch.c **** 
 562:arch/stm32/mcu_periph/adc_arch.c **** static inline void adc_push_sample(struct adc_buf *buf, uint16_t value)
 563:arch/stm32/mcu_periph/adc_arch.c **** {
 564:arch/stm32/mcu_periph/adc_arch.c ****   uint8_t new_head = buf->head + 1;
 565:arch/stm32/mcu_periph/adc_arch.c **** 
 566:arch/stm32/mcu_periph/adc_arch.c ****   if (new_head >= buf->av_nb_sample) {
 567:arch/stm32/mcu_periph/adc_arch.c ****     new_head = 0;
 568:arch/stm32/mcu_periph/adc_arch.c ****   }
 569:arch/stm32/mcu_periph/adc_arch.c ****   buf->sum -= buf->values[new_head];
 570:arch/stm32/mcu_periph/adc_arch.c ****   buf->values[new_head] = value;
 571:arch/stm32/mcu_periph/adc_arch.c ****   buf->sum += value;
 572:arch/stm32/mcu_periph/adc_arch.c ****   buf->head = new_head;
 573:arch/stm32/mcu_periph/adc_arch.c **** }
 574:arch/stm32/mcu_periph/adc_arch.c **** 
 575:arch/stm32/mcu_periph/adc_arch.c **** /*********************************/
 576:arch/stm32/mcu_periph/adc_arch.c **** /***   ADC INTERRUPT HANDLER   ***/
 577:arch/stm32/mcu_periph/adc_arch.c **** /*********************************/
 578:arch/stm32/mcu_periph/adc_arch.c **** 
 579:arch/stm32/mcu_periph/adc_arch.c **** #if defined(STM32F1)
 580:arch/stm32/mcu_periph/adc_arch.c **** void adc1_2_isr(void)
 581:arch/stm32/mcu_periph/adc_arch.c **** #elif defined(STM32F4)
 582:arch/stm32/mcu_periph/adc_arch.c **** void adc_isr(void)
 583:arch/stm32/mcu_periph/adc_arch.c **** #endif
 584:arch/stm32/mcu_periph/adc_arch.c **** {
 307              		.loc 1 584 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              	.LVL40:
 312 0000 70B5     		push	{r4, r5, r6, lr}
 313              		.cfi_def_cfa_offset 16
 314              		.cfi_offset 4, -16
 315              		.cfi_offset 5, -12
 316              		.cfi_offset 6, -8
 317              		.cfi_offset 14, -4
 585:arch/stm32/mcu_periph/adc_arch.c ****   uint8_t channel = 0;
 586:arch/stm32/mcu_periph/adc_arch.c ****   uint16_t value  = 0;
 587:arch/stm32/mcu_periph/adc_arch.c ****   struct adc_buf *buf;
 588:arch/stm32/mcu_periph/adc_arch.c **** 
 589:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_WATCHDOG
 590:arch/stm32/mcu_periph/adc_arch.c ****   /*
 591:arch/stm32/mcu_periph/adc_arch.c ****     We need adc sampling fast enough to detect battery plug out, but we did not
 592:arch/stm32/mcu_periph/adc_arch.c ****     need to get actual actual value so fast. So timer fire adc conversion fast,
 593:arch/stm32/mcu_periph/adc_arch.c ****     at least 500 hz, but we inject adc value in sampling buffer only at 50hz
 594:arch/stm32/mcu_periph/adc_arch.c ****    */
 595:arch/stm32/mcu_periph/adc_arch.c ****   const uint32_t timeStampDiff = get_sys_time_msec() - adc_watchdog.timeStamp;
 596:arch/stm32/mcu_periph/adc_arch.c ****   const bool_t shouldAccumulateValue = timeStampDiff > 20;
 597:arch/stm32/mcu_periph/adc_arch.c ****   if (shouldAccumulateValue) {
 598:arch/stm32/mcu_periph/adc_arch.c ****     adc_watchdog.timeStamp = get_sys_time_msec();
 599:arch/stm32/mcu_periph/adc_arch.c ****   }
 600:arch/stm32/mcu_periph/adc_arch.c **** 
 601:arch/stm32/mcu_periph/adc_arch.c ****   if (adc_watchdog.cb != NULL) {
 602:arch/stm32/mcu_periph/adc_arch.c ****     if (adc_awd(adc_watchdog.adc)) {
 603:arch/stm32/mcu_periph/adc_arch.c ****       ADC_SR(adc_watchdog.adc) &= ~ADC_SR_AWD; // clear int flag
 604:arch/stm32/mcu_periph/adc_arch.c ****       adc_watchdog.cb();
 605:arch/stm32/mcu_periph/adc_arch.c ****     }
 606:arch/stm32/mcu_periph/adc_arch.c ****   }
 607:arch/stm32/mcu_periph/adc_arch.c **** #endif
 608:arch/stm32/mcu_periph/adc_arch.c **** 
 609:arch/stm32/mcu_periph/adc_arch.c **** #if USE_AD1
 610:arch/stm32/mcu_periph/adc_arch.c ****   // Clear Injected End Of Conversion
 611:arch/stm32/mcu_periph/adc_arch.c ****   if (adc_eoc_injected(ADC1)) {
 318              		.loc 1 611 0
 319 0002 174C     		ldr	r4, .L19
 320 0004 2046     		mov	r0, r4
 321 0006 FFF7FEFF 		bl	adc_eoc_injected
 322              	.LVL41:
 323 000a 40B3     		cbz	r0, .L8
 612:arch/stm32/mcu_periph/adc_arch.c ****     ADC_SR(ADC1) &= ~ADC_SR_JEOC;
 324              		.loc 1 612 0
 325 000c 2368     		ldr	r3, [r4]
 326 000e 23F00403 		bic	r3, r3, #4
 327 0012 2360     		str	r3, [r4]
 613:arch/stm32/mcu_periph/adc_arch.c **** #if USE_ADC_WATCHDOG
 614:arch/stm32/mcu_periph/adc_arch.c ****     if (shouldAccumulateValue) {
 615:arch/stm32/mcu_periph/adc_arch.c **** #endif
 616:arch/stm32/mcu_periph/adc_arch.c ****       for (channel = 0; channel < nb_adc1_channels; channel++) {
 328              		.loc 1 616 0
 329 0014 0025     		movs	r5, #0
 330              	.LVL42:
 331              	.L10:
 332              		.loc 1 616 0 is_stmt 0 discriminator 1
 333 0016 134B     		ldr	r3, .L19+4
 334 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 335 001a E9B2     		uxtb	r1, r5
 336              	.LVL43:
 337 001c 8B42     		cmp	r3, r1
 338 001e 1ED9     		bls	.L8
 617:arch/stm32/mcu_periph/adc_arch.c ****         buf = adc1_buffers[channel];
 339              		.loc 1 617 0 is_stmt 1
 340 0020 114B     		ldr	r3, .L19+8
 341 0022 53F82140 		ldr	r4, [r3, r1, lsl #2]
 342              	.LVL44:
 618:arch/stm32/mcu_periph/adc_arch.c ****         if (buf) {
 343              		.loc 1 618 0
 344 0026 C4B1     		cbz	r4, .L11
 345 0028 0131     		adds	r1, r1, #1
 346              	.LVL45:
 619:arch/stm32/mcu_periph/adc_arch.c ****           value = adc_read_injected(ADC1, channel + 1);
 347              		.loc 1 619 0
 348 002a C9B2     		uxtb	r1, r1
 349              	.LVL46:
 350 002c 0C48     		ldr	r0, .L19
 351 002e FFF7FEFF 		bl	adc_read_injected
 352              	.LVL47:
 353              	.LBB24:
 354              	.LBB25:
 564:arch/stm32/mcu_periph/adc_arch.c **** 
 355              		.loc 1 564 0
 356 0032 94F84430 		ldrb	r3, [r4, #68]	@ zero_extendqisi2
 566:arch/stm32/mcu_periph/adc_arch.c ****     new_head = 0;
 357              		.loc 1 566 0
 358 0036 94F84520 		ldrb	r2, [r4, #69]	@ zero_extendqisi2
 564:arch/stm32/mcu_periph/adc_arch.c **** 
 359              		.loc 1 564 0
 360 003a 0133     		adds	r3, r3, #1
 361 003c DBB2     		uxtb	r3, r3
 567:arch/stm32/mcu_periph/adc_arch.c ****   }
 362              		.loc 1 567 0
 363 003e 9A42     		cmp	r2, r3
 364 0040 98BF     		it	ls
 365 0042 0023     		movls	r3, #0
 366 0044 04EB4301 		add	r1, r4, r3, lsl #1
 569:arch/stm32/mcu_periph/adc_arch.c ****   buf->values[new_head] = value;
 367              		.loc 1 569 0
 368 0048 2268     		ldr	r2, [r4]
 369 004a 8E88     		ldrh	r6, [r1, #4]
 370              	.LBE25:
 371              	.LBE24:
 372              		.loc 1 619 0
 373 004c 80B2     		uxth	r0, r0
 374              	.LVL48:
 375              	.LBB27:
 376              	.LBB26:
 570:arch/stm32/mcu_periph/adc_arch.c ****   buf->sum += value;
 377              		.loc 1 570 0
 378 004e 8880     		strh	r0, [r1, #4]	@ movhi
 379 0050 1044     		add	r0, r0, r2
 380              	.LVL49:
 571:arch/stm32/mcu_periph/adc_arch.c ****   buf->head = new_head;
 381              		.loc 1 571 0
 382 0052 801B     		subs	r0, r0, r6
 383 0054 2060     		str	r0, [r4]
 384              	.LVL50:
 572:arch/stm32/mcu_periph/adc_arch.c **** }
 385              		.loc 1 572 0
 386 0056 84F84430 		strb	r3, [r4, #68]
 387              	.LVL51:
 388              	.L11:
 389 005a 0135     		adds	r5, r5, #1
 390              	.LVL52:
 391 005c DBE7     		b	.L10
 392              	.LVL53:
 393              	.L8:
 394 005e 70BD     		pop	{r4, r5, r6, pc}
 395              	.L20:
 396              		.align	2
 397              	.L19:
 398 0060 00200140 		.word	1073815552
 399 0064 00000000 		.word	.LANCHOR0
 400 0068 00000000 		.word	.LANCHOR1
 401              	.LBE26:
 402              	.LBE27:
 403              		.cfi_endproc
 404              	.LFE11:
 406              		.section	.bss.adc1_buffers,"aw",%nobits
 407              		.align	2
 408              		.set	.LANCHOR1,. + 0
 411              	adc1_buffers:
 412 0000 00000000 		.space	16
 412      00000000 
 412      00000000 
 412      00000000 
 413              		.section	.bss.nb_adc1_channels,"aw",%nobits
 414              		.set	.LANCHOR0,. + 0
 417              	nb_adc1_channels:
 418 0000 00       		.space	1
 419              		.section	.bss.nb_adc2_channels,"aw",%nobits
 420              		.set	.LANCHOR2,. + 0
 423              	nb_adc2_channels:
 424 0000 00       		.space	1
 425              		.section	.bss.nb_adc3_channels,"aw",%nobits
 426              		.set	.LANCHOR3,. + 0
 429              	nb_adc3_channels:
 430 0000 00       		.space	1
 431              		.text
 432              	.Letext0:
 433              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 434              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 435              		.file 4 "./mcu_periph/adc.h"
 436              		.file 5 "/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/adc_arch.h"
 437              		.file 6 "../ext/libopencm3/include/libopencm3/stm32/f4/rcc.h"
 438              		.file 7 "../ext/libopencm3/include/libopencm3/stm32/common/rcc_common_all.h"
 439              		.file 8 "../ext/libopencm3/include/libopencm3/stm32/f4/adc.h"
 440              		.file 9 "../ext/libopencm3/include/libopencm3/stm32/common/timer_common_all.h"
 441              		.file 10 "../ext/libopencm3/include/libopencm3/cm3/nvic.h"
 442              		.file 11 "../ext/libopencm3/include/libopencm3/stm32/common/adc_common_v1.h"
 443              		.file 12 "/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_periph/gpio_arch.h"
 444              		.file 13 "/home/dino/paparazzi/sw/airborne/arch/stm32/mcu_arch.h"
DEFINED SYMBOLS
                            *ABS*:00000000 adc_arch.c
     /tmp/ccB6w3Nx.s:20     .text.adc_init:00000000 $t
     /tmp/ccB6w3Nx.s:25     .text.adc_init:00000000 adc_init
     /tmp/ccB6w3Nx.s:254    .text.adc_init:00000118 $d
     /tmp/ccB6w3Nx.s:265    .text.adc_buf_channel:00000000 $t
     /tmp/ccB6w3Nx.s:270    .text.adc_buf_channel:00000000 adc_buf_channel
     /tmp/ccB6w3Nx.s:294    .text.adc_buf_channel:00000014 $d
     /tmp/ccB6w3Nx.s:300    .text.adc_isr:00000000 $t
     /tmp/ccB6w3Nx.s:305    .text.adc_isr:00000000 adc_isr
     /tmp/ccB6w3Nx.s:398    .text.adc_isr:00000060 $d
     /tmp/ccB6w3Nx.s:407    .bss.adc1_buffers:00000000 $d
     /tmp/ccB6w3Nx.s:411    .bss.adc1_buffers:00000000 adc1_buffers
     /tmp/ccB6w3Nx.s:417    .bss.nb_adc1_channels:00000000 nb_adc1_channels
     /tmp/ccB6w3Nx.s:418    .bss.nb_adc1_channels:00000000 $d
     /tmp/ccB6w3Nx.s:423    .bss.nb_adc2_channels:00000000 nb_adc2_channels
     /tmp/ccB6w3Nx.s:424    .bss.nb_adc2_channels:00000000 $d
     /tmp/ccB6w3Nx.s:429    .bss.nb_adc3_channels:00000000 nb_adc3_channels
     /tmp/ccB6w3Nx.s:430    .bss.nb_adc3_channels:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.7f506cdee5614e5fae524d20989ad8c8
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._intsup.h.10.b2832a532eae49c14d45880be6d4ca65
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.23.a096771aacee9aba4b33c2d04aacc9b1
                           .group:00000000 wm4.apogee_1.0.h.2.34ab7bb688056eecb54e2e3ffff48ca6
                           .group:00000000 wm4.adc.h.40.1a39266ea7e49764800ee7652a642a83
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4.common.h.32.d86387944c62748791af32fae2b4e12c
                           .group:00000000 wm4.memorymap.h.21.0c01d18fc5814f65c6ceb1822d4030fa
                           .group:00000000 wm4.memorymap.h.28.85f6f5de65b1d4294c70f79052a0b8c0
                           .group:00000000 wm4.rcc.h.46.c4bbaa886b7ca1bd1829424ae12e70af
                           .group:00000000 wm4.gpio_common_all.h.37.fedbbcb9179f773c905aa3c3e4b7dbdd
                           .group:00000000 wm4.gpio_common_f234.h.48.ee30692f386eaf6801df27cae93943b1
                           .group:00000000 wm4.gpio_common_f24.h.48.4e4be5e3ebe26aee10d604e2d0fecde8
                           .group:00000000 wm4.adc_common_v1.h.36.4bbf1c8b73393a221308006046221089
                           .group:00000000 wm4.adc.h.47.c9fd10d42370db7efcbb39b337bc5c9b
                           .group:00000000 wm4.nvic.h.38.b26077e701ba065ebce4922ce89b9357
                           .group:00000000 wm4.nvic.h.16.68b2cd144a8737a35a31e344912a6e4f
                           .group:00000000 wm4.timer_common_all.h.35.b42b09af17c21cc72e25b3b2ba1809d2
                           .group:00000000 wm4.timer_common_f24.h.44.de6aabe29f6c3596e141b760d97b2482
                           .group:00000000 wm4._ansi.h.13.1b5575dc7921a4c0cff7dbaa2f33e670
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.math.h.35.ad242c9287d2217c7d2035216e5d04ca
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.mcu_arch.h.30.9e61c0408281ef19f3143a9b685c0b7d

UNDEFINED SYMBOLS
gpio_setup_pin_analog
rcc_periph_clock_enable
adc_set_clk_prescale
timer_reset
timer_set_mode
timer_get_frequency
timer_set_prescaler
timer_set_period
timer_set_master_mode
timer_enable_counter
nvic_set_priority
nvic_enable_irq
adc_off
adc_disable_analog_watchdog_regular
adc_disable_analog_watchdog_injected
adc_disable_discontinuous_mode_regular
adc_disable_discontinuous_mode_injected
adc_disable_automatic_injected_group_conversion
adc_enable_scan_mode
adc_enable_eoc_interrupt_injected
adc_disable_awd_interrupt
adc_disable_eoc_interrupt
adc_disable_temperature_sensor
adc_disable_external_trigger_regular
adc_set_right_aligned
adc_disable_dma
adc_set_single_conversion_mode
adc_set_sample_time_on_all_channels
adc_set_injected_sequence
adc_enable_external_trigger_injected
adc_power_on
adc_eoc_injected
adc_read_injected
