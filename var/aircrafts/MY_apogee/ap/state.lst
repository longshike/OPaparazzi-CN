   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 1
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 4
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"state.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.stateInit,"ax",%progbits
  20              		.align	1
  21              		.global	stateInit
  22              		.thumb
  23              		.thumb_func
  25              	stateInit:
  26              	.LFB139:
  27              		.file 1 "state.c"
   1:state.c       **** /*
   2:state.c       ****  * Copyright (C) 2011-2012 Felix Ruess <felix.ruess@gmail.com>
   3:state.c       ****  *
   4:state.c       ****  * This file is part of paparazzi.
   5:state.c       ****  *
   6:state.c       ****  * paparazzi is free software; you can redistribute it and/or modify
   7:state.c       ****  * it under the terms of the GNU General Public License as published by
   8:state.c       ****  * the Free Software Foundation; either version 2, or (at your option)
   9:state.c       ****  * any later version.
  10:state.c       ****  *
  11:state.c       ****  * paparazzi is distributed in the hope that it will be useful,
  12:state.c       ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:state.c       ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:state.c       ****  * GNU General Public License for more details.
  15:state.c       ****  *
  16:state.c       ****  * You should have received a copy of the GNU General Public License
  17:state.c       ****  * along with paparazzi; see the file COPYING.  If not, see
  18:state.c       ****  * <http://www.gnu.org/licenses/>.
  19:state.c       ****  */
  20:state.c       **** 
  21:state.c       **** /**
  22:state.c       ****  * @file state.c
  23:state.c       ****  *
  24:state.c       ****  * General interface for the main vehicle states.
  25:state.c       ****  *
  26:state.c       ****  * This file contains the functions to automatically convert between
  27:state.c       ****  * the different representations. They should normally not be used
  28:state.c       ****  * directly and instead the stateGet/Set interfaces used.
  29:state.c       ****  * Also see the @ref state_interface "State Interface" page.
  30:state.c       ****  *
  31:state.c       ****  * @author Felix Ruess <felix.ruess@gmail.com>
  32:state.c       ****  */
  33:state.c       **** 
  34:state.c       **** #include "state.h"
  35:state.c       **** 
  36:state.c       **** struct State state;
  37:state.c       **** 
  38:state.c       **** /**
  39:state.c       ****  * @addtogroup state_interface
  40:state.c       ****  * @{
  41:state.c       ****  */
  42:state.c       **** 
  43:state.c       **** void stateInit(void)
  44:state.c       **** {
  28              		.loc 1 44 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  45:state.c       ****   state.pos_status = 0;
  33              		.loc 1 45 0
  34 0000 094B     		ldr	r3, .L2
  35 0002 0022     		movs	r2, #0
  36 0004 1A80     		strh	r2, [r3]	@ movhi
  46:state.c       ****   state.speed_status = 0;
  37              		.loc 1 46 0
  38 0006 A3F81421 		strh	r2, [r3, #276]	@ movhi
  47:state.c       ****   state.accel_status = 0;
  39              		.loc 1 47 0
  40 000a 83F87021 		strb	r2, [r3, #368]
  48:state.c       ****   state.ned_to_body_orientation.status = 0;
  41              		.loc 1 48 0
  42 000e 83F8A421 		strb	r2, [r3, #420]
  49:state.c       ****   state.rate_status = 0;
  43              		.loc 1 49 0
  44 0012 83F82822 		strb	r2, [r3, #552]
  50:state.c       ****   state.wind_air_status = 0;
  45              		.loc 1 50 0
  46 0016 83F84422 		strb	r2, [r3, #580]
  51:state.c       ****   state.ned_initialized_i = FALSE;
  47              		.loc 1 51 0
  48 001a 83F85C20 		strb	r2, [r3, #92]
  52:state.c       ****   state.ned_initialized_f = FALSE;
  49              		.loc 1 52 0
  50 001e 83F8E420 		strb	r2, [r3, #228]
  53:state.c       ****   state.utm_initialized_f = FALSE;
  51              		.loc 1 53 0
  52 0022 83F8F820 		strb	r2, [r3, #248]
  53 0026 7047     		bx	lr
  54              	.L3:
  55              		.align	2
  56              	.L2:
  57 0028 00000000 		.word	.LANCHOR0
  58              		.cfi_endproc
  59              	.LFE139:
  61              		.global	__aeabi_f2d
  62              		.global	__aeabi_dmul
  63              		.global	__aeabi_d2iz
  64              		.section	.text.stateCalcPositionEcef_i,"ax",%progbits
  65              		.align	1
  66              		.global	stateCalcPositionEcef_i
  67              		.thumb
  68              		.thumb_func
  70              	stateCalcPositionEcef_i:
  71              	.LFB140:
  54:state.c       **** }
  55:state.c       **** 
  56:state.c       **** 
  57:state.c       **** /*******************************************************************************
  58:state.c       ****  *                                                                             *
  59:state.c       ****  * transformation functions for the POSITION representations                   *
  60:state.c       ****  *                                                                             *
  61:state.c       ****  ******************************************************************************/
  62:state.c       **** /** @addtogroup state_position
  63:state.c       ****  *  @{ */
  64:state.c       **** 
  65:state.c       **** void stateCalcPositionEcef_i(void)
  66:state.c       **** {
  72              		.loc 1 66 0
  73              		.cfi_startproc
  74              		@ args = 0, pretend = 0, frame = 0
  75              		@ frame_needed = 0, uses_anonymous_args = 0
  76 0000 38B5     		push	{r3, r4, r5, lr}
  77              		.cfi_def_cfa_offset 16
  78              		.cfi_offset 3, -16
  79              		.cfi_offset 4, -12
  80              		.cfi_offset 5, -8
  81              		.cfi_offset 14, -4
  67:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
  82              		.loc 1 67 0
  83 0002 404C     		ldr	r4, .L28
  84 0004 2388     		ldrh	r3, [r4]
  85 0006 DA07     		lsls	r2, r3, #31
  86 0008 7AD4     		bmi	.L4
  68:state.c       ****     return;
  69:state.c       ****   }
  70:state.c       **** 
  71:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
  87              		.loc 1 71 0
  88 000a 9D06     		lsls	r5, r3, #26
  89 000c 53D4     		bmi	.L26
  72:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
  73:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_i) {
  90              		.loc 1 73 0
  91 000e 9807     		lsls	r0, r3, #30
  92 0010 0AD5     		bpl	.L8
  93              		.loc 1 73 0 is_stmt 0 discriminator 1
  94 0012 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
  95 0016 3AB1     		cbz	r2, .L8
  74:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
  96              		.loc 1 74 0 is_stmt 1
  97 0018 201D     		adds	r0, r4, #4
  98 001a 04F11C01 		add	r1, r4, #28
  99 001e 04F16002 		add	r2, r4, #96
 100 0022 FFF7FEFF 		bl	ecef_of_ned_pos_i
 101              	.LVL0:
 102 0026 67E0     		b	.L7
 103              	.L8:
  75:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_f) {
 104              		.loc 1 75 0
 105 0028 5906     		lsls	r1, r3, #25
 106 002a 31D5     		bpl	.L9
 107              		.loc 1 75 0 is_stmt 0 discriminator 1
 108 002c 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 109 0030 344D     		ldr	r5, .L28
 110 0032 6AB3     		cbz	r2, .L9
  76:state.c       ****     /* transform ned_f to ecef_f, set status bit, then convert to int */
  77:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 111              		.loc 1 77 0 is_stmt 1
 112 0034 05F1FC02 		add	r2, r5, #252
 113 0038 05F19800 		add	r0, r5, #152
 114 003c 05F1A401 		add	r1, r5, #164
 115 0040 FFF7FEFF 		bl	ecef_of_ned_point_f
 116              	.LVL1:
  78:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 117              		.loc 1 78 0
 118 0044 2B88     		ldrh	r3, [r5]
  79:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 119              		.loc 1 79 0
 120 0046 D5F89800 		ldr	r0, [r5, #152]	@ float
  78:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 121              		.loc 1 78 0
 122 004a 43F02003 		orr	r3, r3, #32
 123 004e 2B80     		strh	r3, [r5]	@ movhi
 124              		.loc 1 79 0
 125 0050 FFF7FEFF 		bl	__aeabi_f2d
 126              	.LVL2:
 127 0054 0022     		movs	r2, #0
 128 0056 2C4B     		ldr	r3, .L28+4
 129 0058 FFF7FEFF 		bl	__aeabi_dmul
 130              	.LVL3:
 131 005c FFF7FEFF 		bl	__aeabi_d2iz
 132              	.LVL4:
 133 0060 6860     		str	r0, [r5, #4]
 134 0062 D5F89C00 		ldr	r0, [r5, #156]	@ float
 135 0066 FFF7FEFF 		bl	__aeabi_f2d
 136              	.LVL5:
 137 006a 0022     		movs	r2, #0
 138 006c 264B     		ldr	r3, .L28+4
 139 006e FFF7FEFF 		bl	__aeabi_dmul
 140              	.LVL6:
 141 0072 FFF7FEFF 		bl	__aeabi_d2iz
 142              	.LVL7:
 143 0076 A860     		str	r0, [r5, #8]
 144 0078 D5F8A000 		ldr	r0, [r5, #160]	@ float
 145 007c FFF7FEFF 		bl	__aeabi_f2d
 146              	.LVL8:
 147 0080 0022     		movs	r2, #0
 148 0082 214B     		ldr	r3, .L28+4
 149 0084 FFF7FEFF 		bl	__aeabi_dmul
 150              	.LVL9:
 151 0088 FFF7FEFF 		bl	__aeabi_d2iz
 152              	.LVL10:
 153 008c E860     		str	r0, [r5, #12]
 154 008e 33E0     		b	.L7
 155              	.L9:
  80:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 156              		.loc 1 80 0
 157 0090 1A07     		lsls	r2, r3, #28
 158 0092 05D5     		bpl	.L10
  81:state.c       ****     ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i);
 159              		.loc 1 81 0
 160 0094 1D48     		ldr	r0, .L28+8
 161 0096 00F10C01 		add	r1, r0, #12
 162 009a FFF7FEFF 		bl	ecef_of_lla_i
 163              	.LVL11:
 164 009e 2BE0     		b	.L7
 165              	.L10:
  82:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 166              		.loc 1 82 0
 167 00a0 DB05     		lsls	r3, r3, #23
 168 00a2 29D5     		bpl	.L7
  83:state.c       ****     /* transform lla_f to ecef_f, set status bit, then convert to int */
  84:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 169              		.loc 1 84 0
 170 00a4 1A48     		ldr	r0, .L28+12
 171 00a6 A0F10C01 		sub	r1, r0, #12
 172 00aa FFF7FEFF 		bl	ecef_of_lla_f
 173              	.LVL12:
  85:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 174              		.loc 1 85 0
 175 00ae 2388     		ldrh	r3, [r4]
 176 00b0 43F02003 		orr	r3, r3, #32
 177 00b4 2380     		strh	r3, [r4]	@ movhi
 178              	.L26:
  86:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 179              		.loc 1 86 0
 180 00b6 D4F89800 		ldr	r0, [r4, #152]	@ float
 181 00ba FFF7FEFF 		bl	__aeabi_f2d
 182              	.LVL13:
 183 00be 0022     		movs	r2, #0
 184 00c0 114B     		ldr	r3, .L28+4
 185 00c2 FFF7FEFF 		bl	__aeabi_dmul
 186              	.LVL14:
 187 00c6 FFF7FEFF 		bl	__aeabi_d2iz
 188              	.LVL15:
 189 00ca 6060     		str	r0, [r4, #4]
 190 00cc D4F89C00 		ldr	r0, [r4, #156]	@ float
 191 00d0 FFF7FEFF 		bl	__aeabi_f2d
 192              	.LVL16:
 193 00d4 0022     		movs	r2, #0
 194 00d6 0C4B     		ldr	r3, .L28+4
 195 00d8 FFF7FEFF 		bl	__aeabi_dmul
 196              	.LVL17:
 197 00dc FFF7FEFF 		bl	__aeabi_d2iz
 198              	.LVL18:
 199 00e0 A060     		str	r0, [r4, #8]
 200 00e2 D4F8A000 		ldr	r0, [r4, #160]	@ float
 201 00e6 FFF7FEFF 		bl	__aeabi_f2d
 202              	.LVL19:
 203 00ea 0022     		movs	r2, #0
 204 00ec 064B     		ldr	r3, .L28+4
 205 00ee FFF7FEFF 		bl	__aeabi_dmul
 206              	.LVL20:
 207 00f2 FFF7FEFF 		bl	__aeabi_d2iz
 208              	.LVL21:
 209 00f6 E060     		str	r0, [r4, #12]
 210              	.L7:
  87:state.c       ****   } else {
  88:state.c       ****     /* could not get this representation,  set errno */
  89:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
  90:state.c       ****     //return _ecef_zero;
  91:state.c       ****   }
  92:state.c       ****   /* set bit to indicate this representation is computed */
  93:state.c       ****   SetBit(state.pos_status, POS_ECEF_I);
 211              		.loc 1 93 0
 212 00f8 2388     		ldrh	r3, [r4]
 213 00fa 43F00103 		orr	r3, r3, #1
 214 00fe 2380     		strh	r3, [r4]	@ movhi
 215              	.L4:
 216 0100 38BD     		pop	{r3, r4, r5, pc}
 217              	.L29:
 218 0102 00BF     		.align	2
 219              	.L28:
 220 0104 00000000 		.word	.LANCHOR0
 221 0108 00005940 		.word	1079574528
 222 010c 04000000 		.word	.LANCHOR0+4
 223 0110 98000000 		.word	.LANCHOR0+152
 224              		.cfi_endproc
 225              	.LFE140:
 227              		.global	__aeabi_ddiv
 228              		.global	__aeabi_d2f
 229              		.section	.text.stateCalcPositionNed_i,"ax",%progbits
 230              		.align	1
 231              		.global	stateCalcPositionNed_i
 232              		.thumb
 233              		.thumb_func
 235              	stateCalcPositionNed_i:
 236              	.LFB141:
  94:state.c       **** }
  95:state.c       **** 
  96:state.c       **** void stateCalcPositionNed_i(void)
  97:state.c       **** {
 237              		.loc 1 97 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241 0000 38B5     		push	{r3, r4, r5, lr}
 242              		.cfi_def_cfa_offset 16
 243              		.cfi_offset 3, -16
 244              		.cfi_offset 4, -12
 245              		.cfi_offset 5, -8
 246              		.cfi_offset 14, -4
  98:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_I)) {
 247              		.loc 1 98 0
 248 0002 9B4C     		ldr	r4, .L61+16
 249 0004 2588     		ldrh	r5, [r4]
 250 0006 AA07     		lsls	r2, r5, #30
 251 0008 00F12681 		bmi	.L30
 252              	.LVL22:
  99:state.c       ****     return;
 100:state.c       ****   }
 101:state.c       **** 
 102:state.c       ****   int errno = 0;
 103:state.c       ****   if (state.ned_initialized_i) {
 253              		.loc 1 103 0
 254 000c 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 255 0010 002B     		cmp	r3, #0
 256 0012 3FD0     		beq	.L32
 104:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 257              		.loc 1 104 0
 258 0014 6B06     		lsls	r3, r5, #25
 259 0016 44D4     		bmi	.L59
 105:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 106:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 260              		.loc 1 106 0
 261 0018 6807     		lsls	r0, r5, #29
 262 001a 05D5     		bpl	.L35
 263              	.L41:
 107:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 264              		.loc 1 107 0
 265 001c 236F     		ldr	r3, [r4, #112]
 266 001e 2366     		str	r3, [r4, #96]
 267 0020 E36E     		ldr	r3, [r4, #108]
 268 0022 6366     		str	r3, [r4, #100]
 269 0024 636F     		ldr	r3, [r4, #116]
 270 0026 7CE0     		b	.L58
 271              	.L35:
 108:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 272              		.loc 1 108 0
 273 0028 2906     		lsls	r1, r5, #24
 274 002a 55D4     		bmi	.L57
 109:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 110:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 111:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 112:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 275              		.loc 1 112 0
 276 002c EA07     		lsls	r2, r5, #31
 277 002e 07D5     		bpl	.L37
 113:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 278              		.loc 1 113 0
 279 0030 04F16000 		add	r0, r4, #96
 280 0034 04F11C01 		add	r1, r4, #28
 281 0038 221D     		adds	r2, r4, #4
 282 003a FFF7FEFF 		bl	ned_of_ecef_pos_i
 283              	.LVL23:
 284 003e 07E1     		b	.L34
 285              	.L37:
 114:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 286              		.loc 1 114 0
 287 0040 AB06     		lsls	r3, r5, #26
 288 0042 02D5     		bpl	.L38
 115:state.c       ****       /* transform ecef_f -> ned_f, set status bit, then convert to int */
 116:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 289              		.loc 1 116 0
 290 0044 04F1FC00 		add	r0, r4, #252
 291 0048 0DE0     		b	.L60
 292              	.L38:
 117:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 118:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 119:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 293              		.loc 1 119 0
 294 004a E805     		lsls	r0, r5, #23
 295 004c 16D5     		bpl	.L39
 120:state.c       ****       /* transform lla_f -> ecef_f -> ned_f, set status bits, then convert to int */
 121:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 296              		.loc 1 121 0
 297 004e 04F19800 		add	r0, r4, #152
 298 0052 04F18C01 		add	r1, r4, #140
 299 0056 FFF7FEFF 		bl	ecef_of_lla_f
 300              	.LVL24:
 122:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 301              		.loc 1 122 0
 302 005a 2388     		ldrh	r3, [r4]
 303 005c 2046     		mov	r0, r4
 304 005e 43F02003 		orr	r3, r3, #32
 305 0062 20F8FC3B 		strh	r3, [r0], #252	@ movhi
 306              	.L60:
 123:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 307              		.loc 1 123 0
 308 0066 04F1A401 		add	r1, r4, #164
 309 006a 04F19802 		add	r2, r4, #152
 310 006e FFF7FEFF 		bl	ned_of_ecef_point_f
 311              	.LVL25:
 124:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 312              		.loc 1 124 0
 313 0072 2388     		ldrh	r3, [r4]
 314 0074 43F04003 		orr	r3, r3, #64
 315 0078 2380     		strh	r3, [r4]	@ movhi
 316 007a 12E0     		b	.L59
 317              	.L39:
 125:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 126:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 318              		.loc 1 126 0
 319 007c 2907     		lsls	r1, r5, #28
 320 007e 40F1E780 		bpl	.L34
 127:state.c       ****       ned_of_lla_point_i(&state.ned_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 321              		.loc 1 127 0
 322 0082 04F16000 		add	r0, r4, #96
 323 0086 04F11C01 		add	r1, r4, #28
 324 008a 04F11002 		add	r2, r4, #16
 325 008e FFF7FEFF 		bl	ned_of_lla_point_i
 326              	.LVL26:
 327 0092 DDE0     		b	.L34
 328              	.L32:
 128:state.c       ****     } else { /* could not get this representation,  set errno */
 129:state.c       ****       errno = 1;
 130:state.c       ****     }
 131:state.c       ****   } else if (state.utm_initialized_f) {
 329              		.loc 1 131 0
 330 0094 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 331 0098 002B     		cmp	r3, #0
 332 009a 00F0D980 		beq	.L34
 132:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 333              		.loc 1 132 0
 334 009e 6A06     		lsls	r2, r5, #25
 335 00a0 16D5     		bpl	.L40
 336              	.L59:
 133:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 337              		.loc 1 133 0
 338 00a2 DFED746A 		flds	s13, .L61+20
 339 00a6 94ED3F7A 		flds	s14, [r4, #252]
 340 00aa D4ED417A 		flds	s15, [r4, #260]
 341 00ae 27EE267A 		fmuls	s14, s14, s13
 342 00b2 67EEA67A 		fmuls	s15, s15, s13
 343 00b6 BDEEC77A 		ftosizs	s14, s14
 344 00ba 84ED187A 		fsts	s14, [r4, #96]	@ int
 345 00be 94ED407A 		flds	s14, [r4, #256]
 346 00c2 27EE267A 		fmuls	s14, s14, s13
 347 00c6 BDEEC77A 		ftosizs	s14, s14
 348 00ca 84ED197A 		fsts	s14, [r4, #100]	@ int
 349 00ce BBE0     		b	.L54
 350              	.L40:
 134:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 351              		.loc 1 134 0
 352 00d0 6B07     		lsls	r3, r5, #29
 353 00d2 A3D4     		bmi	.L41
 135:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 136:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 354              		.loc 1 136 0
 355 00d4 2806     		lsls	r0, r5, #24
 356 00d6 27D5     		bpl	.L42
 357              	.L57:
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 358              		.loc 1 137 0
 359 00d8 DFED666A 		flds	s13, .L61+20
 360 00dc 94ED427A 		flds	s14, [r4, #264]
 361 00e0 27EE267A 		fmuls	s14, s14, s13
 138:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 362              		.loc 1 138 0
 363 00e4 45F00405 		orr	r5, r5, #4
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 364              		.loc 1 137 0
 365 00e8 FDEEC77A 		ftosizs	s15, s14
 366 00ec 94ED437A 		flds	s14, [r4, #268]
 367 00f0 C4ED1B7A 		fsts	s15, [r4, #108]	@ int
 368 00f4 27EE267A 		fmuls	s14, s14, s13
 369 00f8 17EE902A 		fmrs	r2, s15	@ int
 370 00fc FDEEC77A 		ftosizs	s15, s14
 371              		.loc 1 138 0
 372 0100 2580     		strh	r5, [r4]	@ movhi
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 373              		.loc 1 137 0
 374 0102 17EE901A 		fmrs	r1, s15	@ int
 375 0106 C4ED1C7A 		fsts	s15, [r4, #112]	@ int
 376 010a D4ED447A 		flds	s15, [r4, #272]
 139:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_pos_i, state.enu_pos_i);
 377              		.loc 1 139 0
 378 010e 2166     		str	r1, [r4, #96]
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 379              		.loc 1 137 0
 380 0110 67EEA67A 		fmuls	s15, s15, s13
 381              		.loc 1 139 0
 382 0114 6266     		str	r2, [r4, #100]
 137:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 383              		.loc 1 137 0
 384 0116 FDEEE77A 		ftosizs	s15, s15
 385 011a 17EE903A 		fmrs	r3, s15	@ int
 386 011e C4ED1D7A 		fsts	s15, [r4, #116]	@ int
 387              	.L58:
 388              		.loc 1 139 0
 389 0122 5B42     		negs	r3, r3
 390 0124 A366     		str	r3, [r4, #104]
 391 0126 93E0     		b	.L34
 392              	.L42:
 140:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 393              		.loc 1 140 0
 394 0128 A905     		lsls	r1, r5, #22
 395 012a 1BD5     		bpl	.L43
 141:state.c       ****       /* transform utm_f -> ned_f -> ned_i, set status bits */
 142:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 396              		.loc 1 142 0
 397 012c D4ED1E7A 		flds	s15, [r4, #120]
 398 0130 D4ED3A6A 		flds	s13, [r4, #232]
 399 0134 94ED3B7A 		flds	s14, [r4, #236]
 400 0138 94ED206A 		flds	s12, [r4, #128]
 401 013c 77EEE66A 		fsubs	s13, s15, s13
 402 0140 D4ED1F7A 		flds	s15, [r4, #124]
 403 0144 C4ED3F6A 		fsts	s13, [r4, #252]
 404 0148 37EEC77A 		fsubs	s14, s15, s14
 405 014c D4ED3C7A 		flds	s15, [r4, #240]
 406 0150 84ED407A 		fsts	s14, [r4, #256]
 407 0154 77EEC67A 		fsubs	s15, s15, s12
 143:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 408              		.loc 1 143 0
 409 0158 45F04005 		orr	r5, r5, #64
 142:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 410              		.loc 1 142 0
 411 015c C4ED417A 		fsts	s15, [r4, #260]
 412              		.loc 1 143 0
 413 0160 2580     		strh	r5, [r4]	@ movhi
 414 0162 61E0     		b	.L56
 415              	.L43:
 144:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 145:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 416              		.loc 1 145 0
 417 0164 EA05     		lsls	r2, r5, #23
 418 0166 02D5     		bpl	.L44
 146:state.c       ****       /* transform lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 147:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 419              		.loc 1 147 0
 420 0168 04F17800 		add	r0, r4, #120
 421 016c 3CE0     		b	.L55
 422              	.L44:
 148:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 149:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 150:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 151:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 152:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 423              		.loc 1 152 0
 424 016e 2B07     		lsls	r3, r5, #28
 425 0170 6ED5     		bpl	.L34
 153:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned_f -> ned_i, set status bits */
 154:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 426              		.loc 1 154 0
 427 0172 D4ED047A 		flds	s15, [r4, #16]	@ int
 428 0176 F8EEE77A 		fsitos	s15, s15
 155:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 429              		.loc 1 155 0
 430 017a 45F48075 		orr	r5, r5, #256
 154:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 431              		.loc 1 154 0
 432 017e 17EE900A 		fmrs	r0, s15
 433 0182 FFF7FEFF 		bl	__aeabi_f2d
 434              	.LVL27:
 435 0186 36A3     		adr	r3, .L61
 436 0188 D3E90023 		ldrd	r2, [r3]
 437 018c FFF7FEFF 		bl	__aeabi_dmul
 438              	.LVL28:
 439 0190 35A3     		adr	r3, .L61+8
 440 0192 D3E90023 		ldrd	r2, [r3]
 441 0196 FFF7FEFF 		bl	__aeabi_ddiv
 442              	.LVL29:
 443 019a FFF7FEFF 		bl	__aeabi_d2f
 444              	.LVL30:
 445 019e D4ED057A 		flds	s15, [r4, #20]	@ int
 446 01a2 C4F88C00 		str	r0, [r4, #140]	@ float
 447 01a6 F8EEE77A 		fsitos	s15, s15
 448 01aa 17EE900A 		fmrs	r0, s15
 449 01ae FFF7FEFF 		bl	__aeabi_f2d
 450              	.LVL31:
 451 01b2 2BA3     		adr	r3, .L61
 452 01b4 D3E90023 		ldrd	r2, [r3]
 453 01b8 FFF7FEFF 		bl	__aeabi_dmul
 454              	.LVL32:
 455 01bc 2AA3     		adr	r3, .L61+8
 456 01be D3E90023 		ldrd	r2, [r3]
 457 01c2 FFF7FEFF 		bl	__aeabi_ddiv
 458              	.LVL33:
 459 01c6 FFF7FEFF 		bl	__aeabi_d2f
 460              	.LVL34:
 461 01ca D4ED067A 		flds	s15, [r4, #24]	@ int
 462 01ce 9FED2A7A 		flds	s14, .L61+24
 463 01d2 C4F89000 		str	r0, [r4, #144]	@ float
 464 01d6 F8EEE77A 		fsitos	s15, s15
 465              		.loc 1 155 0
 466 01da 2046     		mov	r0, r4
 154:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 467              		.loc 1 154 0
 468 01dc C7EE877A 		fdivs	s15, s15, s14
 469              		.loc 1 155 0
 470 01e0 20F8785B 		strh	r5, [r0], #120	@ movhi
 154:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 471              		.loc 1 154 0
 472 01e4 C4ED257A 		fsts	s15, [r4, #148]
 473              	.L55:
 156:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 474              		.loc 1 156 0
 475 01e8 04F18C01 		add	r1, r4, #140
 476 01ec FFF7FEFF 		bl	utm_of_lla_f
 477              	.LVL35:
 157:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 158:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 478              		.loc 1 158 0
 479 01f0 D4ED1E7A 		flds	s15, [r4, #120]
 480 01f4 D4ED3A6A 		flds	s13, [r4, #232]
 481 01f8 94ED3B7A 		flds	s14, [r4, #236]
 482 01fc 94ED206A 		flds	s12, [r4, #128]
 157:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 483              		.loc 1 157 0
 484 0200 2388     		ldrh	r3, [r4]
 485              		.loc 1 158 0
 486 0202 77EEE66A 		fsubs	s13, s15, s13
 487 0206 D4ED1F7A 		flds	s15, [r4, #124]
 488 020a C4ED3F6A 		fsts	s13, [r4, #252]
 489 020e 37EEC77A 		fsubs	s14, s15, s14
 490 0212 D4ED3C7A 		flds	s15, [r4, #240]
 491 0216 84ED407A 		fsts	s14, [r4, #256]
 492 021a 77EEC67A 		fsubs	s15, s15, s12
 159:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 493              		.loc 1 159 0
 494 021e 43F41073 		orr	r3, r3, #576
 158:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 495              		.loc 1 158 0
 496 0222 C4ED417A 		fsts	s15, [r4, #260]
 497              		.loc 1 159 0
 498 0226 2380     		strh	r3, [r4]	@ movhi
 499              	.L56:
 160:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 500              		.loc 1 160 0
 501 0228 9FED126A 		flds	s12, .L61+20
 502 022c 66EE866A 		fmuls	s13, s13, s12
 503 0230 27EE067A 		fmuls	s14, s14, s12
 504 0234 FDEEE66A 		ftosizs	s13, s13
 505 0238 BDEEC77A 		ftosizs	s14, s14
 506 023c 67EE867A 		fmuls	s15, s15, s12
 507 0240 C4ED186A 		fsts	s13, [r4, #96]	@ int
 508 0244 84ED197A 		fsts	s14, [r4, #100]	@ int
 509              	.L54:
 510 0248 FDEEE77A 		ftosizs	s15, s15
 511 024c C4ED1A7A 		fsts	s15, [r4, #104]	@ int
 512              	.L34:
 161:state.c       ****     } else { /* could not get this representation,  set errno */
 162:state.c       ****       errno = 2;
 163:state.c       ****     }
 164:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 165:state.c       ****     errno = 3;
 166:state.c       ****   }
 167:state.c       ****   if (errno) {
 168:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 169:state.c       ****     //return _ned_zero;
 170:state.c       ****   }
 171:state.c       ****   /* set bit to indicate this representation is computed */
 172:state.c       ****   SetBit(state.pos_status, POS_NED_I);
 513              		.loc 1 172 0
 514 0250 2388     		ldrh	r3, [r4]
 515 0252 43F00203 		orr	r3, r3, #2
 516 0256 2380     		strh	r3, [r4]	@ movhi
 517              	.LVL36:
 518              	.L30:
 519 0258 38BD     		pop	{r3, r4, r5, pc}
 520              	.L62:
 521 025a 00BFAFF3 		.align	3
 521      0080
 522              	.L61:
 523 0260 399D52A2 		.word	-1571644103
 524 0264 46DF913F 		.word	1066524486
 525 0268 00000000 		.word	0
 526 026c D0126341 		.word	1097011920
 527 0270 00000000 		.word	.LANCHOR0
 528 0274 00008043 		.word	1132462080
 529 0278 00007A44 		.word	1148846080
 530              		.cfi_endproc
 531              	.LFE141:
 533              		.section	.text.stateCalcPositionEnu_i,"ax",%progbits
 534              		.align	1
 535              		.global	stateCalcPositionEnu_i
 536              		.thumb
 537              		.thumb_func
 539              	stateCalcPositionEnu_i:
 540              	.LFB142:
 173:state.c       **** }
 174:state.c       **** 
 175:state.c       **** void stateCalcPositionEnu_i(void)
 176:state.c       **** {
 541              		.loc 1 176 0
 542              		.cfi_startproc
 543              		@ args = 0, pretend = 0, frame = 0
 544              		@ frame_needed = 0, uses_anonymous_args = 0
 545 0000 38B5     		push	{r3, r4, r5, lr}
 546              		.cfi_def_cfa_offset 16
 547              		.cfi_offset 3, -16
 548              		.cfi_offset 4, -12
 549              		.cfi_offset 5, -8
 550              		.cfi_offset 14, -4
 177:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_I)) {
 551              		.loc 1 177 0
 552 0002 994C     		ldr	r4, .L94+16
 553 0004 2588     		ldrh	r5, [r4]
 554 0006 6A07     		lsls	r2, r5, #29
 555 0008 00F12381 		bmi	.L63
 556              	.LVL37:
 178:state.c       ****     return;
 179:state.c       ****   }
 180:state.c       **** 
 181:state.c       ****   int errno = 0;
 182:state.c       ****   if (state.ned_initialized_i) {
 557              		.loc 1 182 0
 558 000c 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 559 0010 002B     		cmp	r3, #0
 560 0012 3CD0     		beq	.L65
 183:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 561              		.loc 1 183 0
 562 0014 AB07     		lsls	r3, r5, #30
 563 0016 05D5     		bpl	.L66
 564              	.L74:
 184:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 565              		.loc 1 184 0
 566 0018 636E     		ldr	r3, [r4, #100]
 567 001a E366     		str	r3, [r4, #108]
 568 001c 236E     		ldr	r3, [r4, #96]
 569 001e 2367     		str	r3, [r4, #112]
 570 0020 A36E     		ldr	r3, [r4, #104]
 571 0022 7BE0     		b	.L87
 572              	.L66:
 185:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 573              		.loc 1 185 0
 574 0024 2806     		lsls	r0, r5, #24
 575 0026 39D4     		bmi	.L92
 186:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 187:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 576              		.loc 1 187 0
 577 0028 6906     		lsls	r1, r5, #25
 578 002a 52D4     		bmi	.L91
 188:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 189:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 190:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 191:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 579              		.loc 1 191 0
 580 002c EA07     		lsls	r2, r5, #31
 581 002e 07D5     		bpl	.L70
 192:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 582              		.loc 1 192 0
 583 0030 04F16C00 		add	r0, r4, #108
 584 0034 04F11C01 		add	r1, r4, #28
 585 0038 221D     		adds	r2, r4, #4
 586 003a FFF7FEFF 		bl	enu_of_ecef_pos_i
 587              	.LVL38:
 588 003e 04E1     		b	.L67
 589              	.L70:
 193:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 590              		.loc 1 193 0
 591 0040 AB06     		lsls	r3, r5, #26
 592 0042 0BD4     		bmi	.L93
 194:state.c       ****       /* transform ecef_f -> enu_f, set status bit, then convert to int */
 195:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 196:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 197:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 198:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 593              		.loc 1 198 0
 594 0044 E805     		lsls	r0, r5, #23
 595 0046 16D5     		bpl	.L72
 199:state.c       ****       /* transform lla_f -> ecef_f -> enu_f, set status bits, then convert to int */
 200:state.c       ****       ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 596              		.loc 1 200 0
 597 0048 04F19800 		add	r0, r4, #152
 598 004c 04F18C01 		add	r1, r4, #140
 599 0050 FFF7FEFF 		bl	ecef_of_lla_f
 600              	.LVL39:
 201:state.c       ****       SetBit(state.pos_status, POS_ECEF_F);
 601              		.loc 1 201 0
 602 0054 2388     		ldrh	r3, [r4]
 603 0056 43F02003 		orr	r3, r3, #32
 604 005a 2380     		strh	r3, [r4]	@ movhi
 605              	.L93:
 202:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 606              		.loc 1 202 0
 607 005c 04F58470 		add	r0, r4, #264
 608 0060 04F1A401 		add	r1, r4, #164
 609 0064 04F19802 		add	r2, r4, #152
 610 0068 FFF7FEFF 		bl	enu_of_ecef_point_f
 611              	.LVL40:
 203:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 612              		.loc 1 203 0
 613 006c 2388     		ldrh	r3, [r4]
 614 006e 43F08003 		orr	r3, r3, #128
 615 0072 2380     		strh	r3, [r4]	@ movhi
 616 0074 12E0     		b	.L92
 617              	.L72:
 204:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 205:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 618              		.loc 1 205 0
 619 0076 2907     		lsls	r1, r5, #28
 620 0078 40F1E780 		bpl	.L67
 206:state.c       ****       enu_of_lla_point_i(&state.enu_pos_i, &state.ned_origin_i, &state.lla_pos_i);
 621              		.loc 1 206 0
 622 007c 04F16C00 		add	r0, r4, #108
 623 0080 04F11C01 		add	r1, r4, #28
 624 0084 04F11002 		add	r2, r4, #16
 625 0088 FFF7FEFF 		bl	enu_of_lla_point_i
 626              	.LVL41:
 627 008c DDE0     		b	.L67
 628              	.L65:
 207:state.c       ****     } else { /* could not get this representation,  set errno */
 208:state.c       ****       errno = 1;
 209:state.c       ****     }
 210:state.c       ****   } else if (state.utm_initialized_f) {
 629              		.loc 1 210 0
 630 008e 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 631 0092 002B     		cmp	r3, #0
 632 0094 00F0D980 		beq	.L67
 211:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_F)) {
 633              		.loc 1 211 0
 634 0098 2A06     		lsls	r2, r5, #24
 635 009a 16D5     		bpl	.L73
 636              	.L92:
 212:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 637              		.loc 1 212 0
 638 009c DFED736A 		flds	s13, .L94+20
 639 00a0 94ED427A 		flds	s14, [r4, #264]
 640 00a4 D4ED447A 		flds	s15, [r4, #272]
 641 00a8 27EE267A 		fmuls	s14, s14, s13
 642 00ac 67EEA67A 		fmuls	s15, s15, s13
 643 00b0 BDEEC77A 		ftosizs	s14, s14
 644 00b4 84ED1B7A 		fsts	s14, [r4, #108]	@ int
 645 00b8 94ED437A 		flds	s14, [r4, #268]
 646 00bc 27EE267A 		fmuls	s14, s14, s13
 647 00c0 BDEEC77A 		ftosizs	s14, s14
 648 00c4 84ED1C7A 		fsts	s14, [r4, #112]	@ int
 649 00c8 BBE0     		b	.L89
 650              	.L73:
 213:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 651              		.loc 1 213 0
 652 00ca AB07     		lsls	r3, r5, #30
 653 00cc A4D4     		bmi	.L74
 214:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 215:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 654              		.loc 1 215 0
 655 00ce 6806     		lsls	r0, r5, #25
 656 00d0 27D5     		bpl	.L75
 657              	.L91:
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 658              		.loc 1 216 0
 659 00d2 DFED666A 		flds	s13, .L94+20
 660 00d6 94ED3F7A 		flds	s14, [r4, #252]
 661 00da 27EE267A 		fmuls	s14, s14, s13
 217:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 662              		.loc 1 217 0
 663 00de 45F00205 		orr	r5, r5, #2
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 664              		.loc 1 216 0
 665 00e2 FDEEC77A 		ftosizs	s15, s14
 666 00e6 94ED407A 		flds	s14, [r4, #256]
 667 00ea C4ED187A 		fsts	s15, [r4, #96]	@ int
 668 00ee 27EE267A 		fmuls	s14, s14, s13
 669 00f2 17EE902A 		fmrs	r2, s15	@ int
 670 00f6 FDEEC77A 		ftosizs	s15, s14
 671              		.loc 1 217 0
 672 00fa 2580     		strh	r5, [r4]	@ movhi
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 673              		.loc 1 216 0
 674 00fc 17EE901A 		fmrs	r1, s15	@ int
 675 0100 C4ED197A 		fsts	s15, [r4, #100]	@ int
 676 0104 D4ED417A 		flds	s15, [r4, #260]
 218:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_pos_i, state.ned_pos_i);
 677              		.loc 1 218 0
 678 0108 E166     		str	r1, [r4, #108]
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 679              		.loc 1 216 0
 680 010a 67EEA67A 		fmuls	s15, s15, s13
 681              		.loc 1 218 0
 682 010e 2267     		str	r2, [r4, #112]
 216:state.c       ****       NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 683              		.loc 1 216 0
 684 0110 FDEEE77A 		ftosizs	s15, s15
 685 0114 17EE903A 		fmrs	r3, s15	@ int
 686 0118 C4ED1A7A 		fsts	s15, [r4, #104]	@ int
 687              	.L87:
 688              		.loc 1 218 0
 689 011c 5B42     		negs	r3, r3
 690 011e 6367     		str	r3, [r4, #116]
 691 0120 93E0     		b	.L67
 692              	.L75:
 219:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 693              		.loc 1 219 0
 694 0122 A905     		lsls	r1, r5, #22
 695 0124 1BD5     		bpl	.L76
 220:state.c       ****       /* transform utm_f -> enu_f -> enu_i , set status bits */
 221:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 696              		.loc 1 221 0
 697 0126 D4ED1F7A 		flds	s15, [r4, #124]
 698 012a D4ED3B6A 		flds	s13, [r4, #236]
 699 012e 94ED3A7A 		flds	s14, [r4, #232]
 700 0132 94ED3C6A 		flds	s12, [r4, #240]
 701 0136 77EEE66A 		fsubs	s13, s15, s13
 702 013a D4ED1E7A 		flds	s15, [r4, #120]
 703 013e C4ED426A 		fsts	s13, [r4, #264]
 704 0142 37EEC77A 		fsubs	s14, s15, s14
 705 0146 D4ED207A 		flds	s15, [r4, #128]
 706 014a 84ED437A 		fsts	s14, [r4, #268]
 707 014e 77EEC67A 		fsubs	s15, s15, s12
 222:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 708              		.loc 1 222 0
 709 0152 45F08005 		orr	r5, r5, #128
 221:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 710              		.loc 1 221 0
 711 0156 C4ED447A 		fsts	s15, [r4, #272]
 712              		.loc 1 222 0
 713 015a 2580     		strh	r5, [r4]	@ movhi
 714 015c 61E0     		b	.L90
 715              	.L76:
 223:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 224:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 716              		.loc 1 224 0
 717 015e EA05     		lsls	r2, r5, #23
 718 0160 02D5     		bpl	.L77
 225:state.c       ****       /* transform lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 226:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 719              		.loc 1 226 0
 720 0162 04F17800 		add	r0, r4, #120
 721 0166 3CE0     		b	.L88
 722              	.L77:
 227:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 228:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 229:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 230:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 231:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 723              		.loc 1 231 0
 724 0168 2B07     		lsls	r3, r5, #28
 725 016a 6ED5     		bpl	.L67
 232:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu_f -> enu_i , set status bits */
 233:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 726              		.loc 1 233 0
 727 016c D4ED047A 		flds	s15, [r4, #16]	@ int
 728 0170 F8EEE77A 		fsitos	s15, s15
 234:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 729              		.loc 1 234 0
 730 0174 45F48075 		orr	r5, r5, #256
 233:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 731              		.loc 1 233 0
 732 0178 17EE900A 		fmrs	r0, s15
 733 017c FFF7FEFF 		bl	__aeabi_f2d
 734              	.LVL42:
 735 0180 35A3     		adr	r3, .L94
 736 0182 D3E90023 		ldrd	r2, [r3]
 737 0186 FFF7FEFF 		bl	__aeabi_dmul
 738              	.LVL43:
 739 018a 35A3     		adr	r3, .L94+8
 740 018c D3E90023 		ldrd	r2, [r3]
 741 0190 FFF7FEFF 		bl	__aeabi_ddiv
 742              	.LVL44:
 743 0194 FFF7FEFF 		bl	__aeabi_d2f
 744              	.LVL45:
 745 0198 D4ED057A 		flds	s15, [r4, #20]	@ int
 746 019c C4F88C00 		str	r0, [r4, #140]	@ float
 747 01a0 F8EEE77A 		fsitos	s15, s15
 748 01a4 17EE900A 		fmrs	r0, s15
 749 01a8 FFF7FEFF 		bl	__aeabi_f2d
 750              	.LVL46:
 751 01ac 2AA3     		adr	r3, .L94
 752 01ae D3E90023 		ldrd	r2, [r3]
 753 01b2 FFF7FEFF 		bl	__aeabi_dmul
 754              	.LVL47:
 755 01b6 2AA3     		adr	r3, .L94+8
 756 01b8 D3E90023 		ldrd	r2, [r3]
 757 01bc FFF7FEFF 		bl	__aeabi_ddiv
 758              	.LVL48:
 759 01c0 FFF7FEFF 		bl	__aeabi_d2f
 760              	.LVL49:
 761 01c4 D4ED067A 		flds	s15, [r4, #24]	@ int
 762 01c8 9FED297A 		flds	s14, .L94+24
 763 01cc C4F89000 		str	r0, [r4, #144]	@ float
 764 01d0 F8EEE77A 		fsitos	s15, s15
 765              		.loc 1 234 0
 766 01d4 2046     		mov	r0, r4
 233:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 767              		.loc 1 233 0
 768 01d6 C7EE877A 		fdivs	s15, s15, s14
 769              		.loc 1 234 0
 770 01da 20F8785B 		strh	r5, [r0], #120	@ movhi
 233:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 771              		.loc 1 233 0
 772 01de C4ED257A 		fsts	s15, [r4, #148]
 773              	.L88:
 235:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 774              		.loc 1 235 0
 775 01e2 04F18C01 		add	r1, r4, #140
 776 01e6 FFF7FEFF 		bl	utm_of_lla_f
 777              	.LVL50:
 236:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 237:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 778              		.loc 1 237 0
 779 01ea D4ED1F7A 		flds	s15, [r4, #124]
 780 01ee D4ED3B6A 		flds	s13, [r4, #236]
 781 01f2 94ED3A7A 		flds	s14, [r4, #232]
 782 01f6 94ED3C6A 		flds	s12, [r4, #240]
 236:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 783              		.loc 1 236 0
 784 01fa 2388     		ldrh	r3, [r4]
 785              		.loc 1 237 0
 786 01fc 77EEE66A 		fsubs	s13, s15, s13
 787 0200 D4ED1E7A 		flds	s15, [r4, #120]
 788 0204 C4ED426A 		fsts	s13, [r4, #264]
 789 0208 37EEC77A 		fsubs	s14, s15, s14
 790 020c D4ED207A 		flds	s15, [r4, #128]
 791 0210 84ED437A 		fsts	s14, [r4, #268]
 792 0214 77EEC67A 		fsubs	s15, s15, s12
 238:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 793              		.loc 1 238 0
 794 0218 43F42073 		orr	r3, r3, #640
 237:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 795              		.loc 1 237 0
 796 021c C4ED447A 		fsts	s15, [r4, #272]
 797              		.loc 1 238 0
 798 0220 2380     		strh	r3, [r4]	@ movhi
 799              	.L90:
 239:state.c       ****       ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 800              		.loc 1 239 0
 801 0222 9FED126A 		flds	s12, .L94+20
 802 0226 66EE866A 		fmuls	s13, s13, s12
 803 022a 27EE067A 		fmuls	s14, s14, s12
 804 022e FDEEE66A 		ftosizs	s13, s13
 805 0232 BDEEC77A 		ftosizs	s14, s14
 806 0236 67EE867A 		fmuls	s15, s15, s12
 807 023a C4ED1B6A 		fsts	s13, [r4, #108]	@ int
 808 023e 84ED1C7A 		fsts	s14, [r4, #112]	@ int
 809              	.L89:
 810 0242 FDEEE77A 		ftosizs	s15, s15
 811 0246 C4ED1D7A 		fsts	s15, [r4, #116]	@ int
 812              	.L67:
 240:state.c       ****     } else { /* could not get this representation,  set errno */
 241:state.c       ****       errno = 2;
 242:state.c       ****     }
 243:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 244:state.c       ****     errno = 3;
 245:state.c       ****   }
 246:state.c       ****   if (errno) {
 247:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 248:state.c       ****     //return _enu_zero;
 249:state.c       ****   }
 250:state.c       ****   /* set bit to indicate this representation is computed */
 251:state.c       ****   SetBit(state.pos_status, POS_ENU_I);
 813              		.loc 1 251 0
 814 024a 2388     		ldrh	r3, [r4]
 815 024c 43F00403 		orr	r3, r3, #4
 816 0250 2380     		strh	r3, [r4]	@ movhi
 817              	.LVL51:
 818              	.L63:
 819 0252 38BD     		pop	{r3, r4, r5, pc}
 820              	.L95:
 821 0254 AFF30080 		.align	3
 822              	.L94:
 823 0258 399D52A2 		.word	-1571644103
 824 025c 46DF913F 		.word	1066524486
 825 0260 00000000 		.word	0
 826 0264 D0126341 		.word	1097011920
 827 0268 00000000 		.word	.LANCHOR0
 828 026c 00008043 		.word	1132462080
 829 0270 00007A44 		.word	1148846080
 830              		.cfi_endproc
 831              	.LFE142:
 833              		.section	.text.stateCalcPositionLla_i,"ax",%progbits
 834              		.align	1
 835              		.global	stateCalcPositionLla_i
 836              		.thumb
 837              		.thumb_func
 839              	stateCalcPositionLla_i:
 840              	.LFB143:
 252:state.c       **** }
 253:state.c       **** 
 254:state.c       **** /**
 255:state.c       ****  * Calculate LLA (int) from any other available representation.
 256:state.c       ****  * Note that since LLA in float has bad precision this is the last choice.
 257:state.c       ****  * So we mostly first convert to ECEF and then use lla_of_ecef_i
 258:state.c       ****  * which provides higher precision but is currently using the double function internally.
 259:state.c       ****  */
 260:state.c       **** void stateCalcPositionLla_i(void)
 261:state.c       **** {
 841              		.loc 1 261 0
 842              		.cfi_startproc
 843              		@ args = 0, pretend = 0, frame = 0
 844              		@ frame_needed = 0, uses_anonymous_args = 0
 845 0000 70B5     		push	{r4, r5, r6, lr}
 846              		.cfi_def_cfa_offset 16
 847              		.cfi_offset 4, -16
 848              		.cfi_offset 5, -12
 849              		.cfi_offset 6, -8
 850              		.cfi_offset 14, -4
 262:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I)) {
 851              		.loc 1 262 0
 852 0002 7B4C     		ldr	r4, .L138+16
 853 0004 2588     		ldrh	r5, [r4]
 854 0006 2807     		lsls	r0, r5, #28
 855 0008 00F1E980 		bmi	.L96
 263:state.c       ****     return;
 264:state.c       ****   }
 265:state.c       **** 
 266:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 856              		.loc 1 266 0
 857 000c E907     		lsls	r1, r5, #31
 858 000e 02D5     		bpl	.L98
 267:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 859              		.loc 1 267 0
 860 0010 04F11000 		add	r0, r4, #16
 861 0014 27E0     		b	.L133
 862              	.L98:
 268:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 863              		.loc 1 268 0
 864 0016 AA06     		lsls	r2, r5, #26
 865 0018 29D5     		bpl	.L100
 269:state.c       ****     /* transform ecef_f -> ecef_i -> lla_i, set status bits */
 270:state.c       ****     ECEF_BFP_OF_REAL(state.ecef_pos_i, state.ecef_pos_f);
 866              		.loc 1 270 0
 867 001a D4F89800 		ldr	r0, [r4, #152]	@ float
 868 001e FFF7FEFF 		bl	__aeabi_f2d
 869              	.LVL52:
 870 0022 0022     		movs	r2, #0
 871 0024 734B     		ldr	r3, .L138+20
 872 0026 FFF7FEFF 		bl	__aeabi_dmul
 873              	.LVL53:
 874 002a FFF7FEFF 		bl	__aeabi_d2iz
 875              	.LVL54:
 876 002e 6060     		str	r0, [r4, #4]
 877 0030 D4F89C00 		ldr	r0, [r4, #156]	@ float
 878 0034 FFF7FEFF 		bl	__aeabi_f2d
 879              	.LVL55:
 880 0038 0022     		movs	r2, #0
 881 003a 6E4B     		ldr	r3, .L138+20
 882 003c FFF7FEFF 		bl	__aeabi_dmul
 883              	.LVL56:
 884 0040 FFF7FEFF 		bl	__aeabi_d2iz
 885              	.LVL57:
 886 0044 A060     		str	r0, [r4, #8]
 887 0046 D4F8A000 		ldr	r0, [r4, #160]	@ float
 888 004a FFF7FEFF 		bl	__aeabi_f2d
 889              	.LVL58:
 890 004e 0022     		movs	r2, #0
 891 0050 684B     		ldr	r3, .L138+20
 892 0052 FFF7FEFF 		bl	__aeabi_dmul
 893              	.LVL59:
 894 0056 FFF7FEFF 		bl	__aeabi_d2iz
 895              	.LVL60:
 896 005a E060     		str	r0, [r4, #12]
 271:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 897              		.loc 1 271 0
 898 005c 2046     		mov	r0, r4
 899 005e 45F00105 		orr	r5, r5, #1
 900 0062 20F8105B 		strh	r5, [r0], #16	@ movhi
 901              	.L133:
 272:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 902              		.loc 1 272 0
 903 0066 211D     		adds	r1, r4, #4
 904              	.L135:
 905 0068 FFF7FEFF 		bl	lla_of_ecef_i
 906              	.LVL61:
 907 006c B3E0     		b	.L99
 908              	.L100:
 273:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_i) {
 909              		.loc 1 273 0
 910 006e AB07     		lsls	r3, r5, #30
 911 0070 10D5     		bpl	.L101
 912              		.loc 1 273 0 is_stmt 0 discriminator 1
 913 0072 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 914 0076 6BB1     		cbz	r3, .L101
 274:state.c       ****     /* transform ned_i -> ecef_i -> lla_i, set status bits */
 275:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 915              		.loc 1 275 0 is_stmt 1
 916 0078 201D     		adds	r0, r4, #4
 917 007a 04F11C01 		add	r1, r4, #28
 918 007e 04F16002 		add	r2, r4, #96
 919 0082 FFF7FEFF 		bl	ecef_of_ned_pos_i
 920              	.LVL62:
 276:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 921              		.loc 1 276 0
 922 0086 2388     		ldrh	r3, [r4]
 923 0088 2046     		mov	r0, r4
 924 008a 43F00103 		orr	r3, r3, #1
 925 008e 20F8103B 		strh	r3, [r0], #16	@ movhi
 926 0092 E8E7     		b	.L133
 927              	.L101:
 277:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 278:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ENU_I) && state.ned_initialized_i) {
 928              		.loc 1 278 0
 929 0094 6E07     		lsls	r6, r5, #29
 930 0096 05D5     		bpl	.L102
 931              		.loc 1 278 0 is_stmt 0 discriminator 1
 932 0098 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 933 009c 544E     		ldr	r6, .L138+16
 934 009e 0BB1     		cbz	r3, .L102
 279:state.c       ****     /* transform enu_i -> ecef_i -> lla_i, set status bits */
 280:state.c       ****     ecef_of_enu_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.enu_pos_i);
 935              		.loc 1 280 0 is_stmt 1
 936 00a0 301D     		adds	r0, r6, #4
 937 00a2 50E0     		b	.L137
 938              	.L102:
 281:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 282:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 283:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_i) {
 939              		.loc 1 283 0
 940 00a4 6806     		lsls	r0, r5, #25
 941 00a6 29D5     		bpl	.L103
 942              		.loc 1 283 0 is_stmt 0 discriminator 1
 943 00a8 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 944 00ac 504E     		ldr	r6, .L138+16
 945 00ae 2BB3     		cbz	r3, .L103
 284:state.c       ****     /* transform ned_f -> ned_i -> ecef_i -> lla_i, set status bits */
 285:state.c       ****     NED_BFP_OF_REAL(state.ned_pos_i, state.ned_pos_f);
 946              		.loc 1 285 0 is_stmt 1
 947 00b0 DFED516A 		flds	s13, .L138+24
 948 00b4 96ED3F7A 		flds	s14, [r6, #252]
 949 00b8 D6ED417A 		flds	s15, [r6, #260]
 950 00bc 27EE267A 		fmuls	s14, s14, s13
 951 00c0 67EEA67A 		fmuls	s15, s15, s13
 952 00c4 BDEEC77A 		ftosizs	s14, s14
 286:state.c       ****     SetBit(state.pos_status, POS_NED_I);
 953              		.loc 1 286 0
 954 00c8 3046     		mov	r0, r6
 285:state.c       ****     SetBit(state.pos_status, POS_NED_I);
 955              		.loc 1 285 0
 956 00ca 86ED187A 		fsts	s14, [r6, #96]	@ int
 957 00ce 96ED407A 		flds	s14, [r6, #256]
 958 00d2 27EE267A 		fmuls	s14, s14, s13
 959 00d6 FDEEE77A 		ftosizs	s15, s15
 960 00da BDEEC77A 		ftosizs	s14, s14
 961              		.loc 1 286 0
 962 00de 45F00205 		orr	r5, r5, #2
 963 00e2 20F8045B 		strh	r5, [r0], #4	@ movhi
 287:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 964              		.loc 1 287 0
 965 00e6 06F11C01 		add	r1, r6, #28
 966 00ea 06F16002 		add	r2, r6, #96
 285:state.c       ****     SetBit(state.pos_status, POS_NED_I);
 967              		.loc 1 285 0
 968 00ee 86ED197A 		fsts	s14, [r6, #100]	@ int
 969 00f2 C6ED1A7A 		fsts	s15, [r6, #104]	@ int
 970              		.loc 1 287 0
 971 00f6 FFF7FEFF 		bl	ecef_of_ned_pos_i
 972              	.LVL63:
 973 00fa 2AE0     		b	.L136
 974              	.L103:
 288:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 289:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 290:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ENU_F) && state.ned_initialized_i) {
 975              		.loc 1 290 0
 976 00fc 2906     		lsls	r1, r5, #24
 977 00fe 30D5     		bpl	.L104
 978              		.loc 1 290 0 is_stmt 0 discriminator 1
 979 0100 94F85C30 		ldrb	r3, [r4, #92]	@ zero_extendqisi2
 980 0104 3A4E     		ldr	r6, .L138+16
 981 0106 63B3     		cbz	r3, .L104
 291:state.c       ****     /* transform enu_f -> enu_i -> ecef_i -> lla_i, set status bits */
 292:state.c       ****     ENU_BFP_OF_REAL(state.enu_pos_i, state.enu_pos_f);
 982              		.loc 1 292 0 is_stmt 1
 983 0108 DFED3B6A 		flds	s13, .L138+24
 984 010c 96ED427A 		flds	s14, [r6, #264]
 985 0110 D6ED447A 		flds	s15, [r6, #272]
 986 0114 27EE267A 		fmuls	s14, s14, s13
 987 0118 67EEA67A 		fmuls	s15, s15, s13
 988 011c BDEEC77A 		ftosizs	s14, s14
 293:state.c       ****     SetBit(state.pos_status, POS_ENU_I);
 989              		.loc 1 293 0
 990 0120 3046     		mov	r0, r6
 292:state.c       ****     SetBit(state.pos_status, POS_ENU_I);
 991              		.loc 1 292 0
 992 0122 86ED1B7A 		fsts	s14, [r6, #108]	@ int
 993 0126 96ED437A 		flds	s14, [r6, #268]
 994 012a 27EE267A 		fmuls	s14, s14, s13
 995 012e FDEEE77A 		ftosizs	s15, s15
 996 0132 BDEEC77A 		ftosizs	s14, s14
 997              		.loc 1 293 0
 998 0136 45F00405 		orr	r5, r5, #4
 999 013a 20F8045B 		strh	r5, [r0], #4	@ movhi
 292:state.c       ****     SetBit(state.pos_status, POS_ENU_I);
 1000              		.loc 1 292 0
 1001 013e 86ED1C7A 		fsts	s14, [r6, #112]	@ int
 1002 0142 C6ED1D7A 		fsts	s15, [r6, #116]	@ int
 1003              	.L137:
 294:state.c       ****     ecef_of_enu_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.enu_pos_i);
 1004              		.loc 1 294 0
 1005 0146 06F11C01 		add	r1, r6, #28
 1006 014a 06F16C02 		add	r2, r6, #108
 1007 014e FFF7FEFF 		bl	ecef_of_enu_pos_i
 1008              	.LVL64:
 1009              	.L136:
 295:state.c       ****     SetBit(state.pos_status, POS_ECEF_I);
 1010              		.loc 1 295 0
 1011 0152 3388     		ldrh	r3, [r6]
 1012 0154 3046     		mov	r0, r6
 1013 0156 43F00103 		orr	r3, r3, #1
 1014 015a 20F8103B 		strh	r3, [r0], #16	@ movhi
 296:state.c       ****     lla_of_ecef_i(&state.lla_pos_i, &state.ecef_pos_i);
 1015              		.loc 1 296 0
 1016 015e 311D     		adds	r1, r6, #4
 1017 0160 82E7     		b	.L135
 1018              	.L104:
 297:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1019              		.loc 1 297 0
 1020 0162 EA05     		lsls	r2, r5, #23
 1021 0164 0AD4     		bmi	.L134
 298:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 299:state.c       ****   } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1022              		.loc 1 299 0
 1023 0166 AB05     		lsls	r3, r5, #22
 1024 0168 35D5     		bpl	.L99
 300:state.c       ****     /* transform utm_f -> lla_f -> lla_i, set status bits */
 301:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 1025              		.loc 1 301 0
 1026 016a 2448     		ldr	r0, .L138+28
 1027 016c A0F11401 		sub	r1, r0, #20
 1028 0170 FFF7FEFF 		bl	lla_of_utm_f
 1029              	.LVL65:
 302:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1030              		.loc 1 302 0
 1031 0174 2388     		ldrh	r3, [r4]
 1032 0176 43F48073 		orr	r3, r3, #256
 1033 017a 2380     		strh	r3, [r4]	@ movhi
 1034              	.L134:
 303:state.c       ****     LLA_BFP_OF_REAL(state.lla_pos_i, state.lla_pos_f);
 1035              		.loc 1 303 0
 1036 017c D4F88C00 		ldr	r0, [r4, #140]	@ float
 1037 0180 FFF7FEFF 		bl	__aeabi_f2d
 1038              	.LVL66:
 1039 0184 16A3     		adr	r3, .L138
 1040 0186 D3E90023 		ldrd	r2, [r3]
 1041 018a FFF7FEFF 		bl	__aeabi_dmul
 1042              	.LVL67:
 1043 018e 16A3     		adr	r3, .L138+8
 1044 0190 D3E90023 		ldrd	r2, [r3]
 1045 0194 FFF7FEFF 		bl	__aeabi_dmul
 1046              	.LVL68:
 1047 0198 FFF7FEFF 		bl	__aeabi_d2iz
 1048              	.LVL69:
 1049 019c 2061     		str	r0, [r4, #16]
 1050 019e D4F89000 		ldr	r0, [r4, #144]	@ float
 1051 01a2 FFF7FEFF 		bl	__aeabi_f2d
 1052              	.LVL70:
 1053 01a6 0EA3     		adr	r3, .L138
 1054 01a8 D3E90023 		ldrd	r2, [r3]
 1055 01ac FFF7FEFF 		bl	__aeabi_dmul
 1056              	.LVL71:
 1057 01b0 0DA3     		adr	r3, .L138+8
 1058 01b2 D3E90023 		ldrd	r2, [r3]
 1059 01b6 FFF7FEFF 		bl	__aeabi_dmul
 1060              	.LVL72:
 1061 01ba FFF7FEFF 		bl	__aeabi_d2iz
 1062              	.LVL73:
 1063 01be 6061     		str	r0, [r4, #20]
 1064 01c0 D4F89400 		ldr	r0, [r4, #148]	@ float
 1065 01c4 FFF7FEFF 		bl	__aeabi_f2d
 1066              	.LVL74:
 1067 01c8 0022     		movs	r2, #0
 1068 01ca 0D4B     		ldr	r3, .L138+32
 1069 01cc FFF7FEFF 		bl	__aeabi_dmul
 1070              	.LVL75:
 1071 01d0 FFF7FEFF 		bl	__aeabi_d2iz
 1072              	.LVL76:
 1073 01d4 A061     		str	r0, [r4, #24]
 1074              	.L99:
 304:state.c       ****   } else {
 305:state.c       ****     /* could not get this representation,  set errno */
 306:state.c       ****     //struct LlaCoor_i _lla_zero = {0};
 307:state.c       ****     //return _lla_zero;
 308:state.c       ****   }
 309:state.c       ****   /* set bit to indicate this representation is computed */
 310:state.c       ****   SetBit(state.pos_status, POS_LLA_I);
 1075              		.loc 1 310 0
 1076 01d6 2388     		ldrh	r3, [r4]
 1077 01d8 43F00803 		orr	r3, r3, #8
 1078 01dc 2380     		strh	r3, [r4]	@ movhi
 1079              	.L96:
 1080 01de 70BD     		pop	{r4, r5, r6, pc}
 1081              	.L139:
 1082              		.align	3
 1083              	.L138:
 1084 01e0 F8C1631A 		.word	442745336
 1085 01e4 DCA54C40 		.word	1078765020
 1086 01e8 00000000 		.word	0
 1087 01ec D0126341 		.word	1097011920
 1088 01f0 00000000 		.word	.LANCHOR0
 1089 01f4 00005940 		.word	1079574528
 1090 01f8 00008043 		.word	1132462080
 1091 01fc 8C000000 		.word	.LANCHOR0+140
 1092 0200 00408F40 		.word	1083129856
 1093              		.cfi_endproc
 1094              	.LFE143:
 1096              		.section	.text.stateCalcPositionUtm_f,"ax",%progbits
 1097              		.align	1
 1098              		.global	stateCalcPositionUtm_f
 1099              		.thumb
 1100              		.thumb_func
 1102              	stateCalcPositionUtm_f:
 1103              	.LFB144:
 311:state.c       **** }
 312:state.c       **** 
 313:state.c       **** void stateCalcPositionUtm_f(void)
 314:state.c       **** {
 1104              		.loc 1 314 0
 1105              		.cfi_startproc
 1106              		@ args = 0, pretend = 0, frame = 0
 1107              		@ frame_needed = 0, uses_anonymous_args = 0
 1108 0000 38B5     		push	{r3, r4, r5, lr}
 1109              		.cfi_def_cfa_offset 16
 1110              		.cfi_offset 3, -16
 1111              		.cfi_offset 4, -12
 1112              		.cfi_offset 5, -8
 1113              		.cfi_offset 14, -4
 315:state.c       ****   if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1114              		.loc 1 315 0
 1115 0002 774C     		ldr	r4, .L157+16
 1116 0004 2588     		ldrh	r5, [r4]
 1117 0006 A905     		lsls	r1, r5, #22
 1118 0008 00F1E180 		bmi	.L140
 316:state.c       ****     return;
 317:state.c       ****   }
 318:state.c       **** 
 319:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1119              		.loc 1 319 0
 1120 000c EA05     		lsls	r2, r5, #23
 1121 000e 02D5     		bpl	.L142
 320:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1122              		.loc 1 320 0
 1123 0010 04F17800 		add	r0, r4, #120
 1124 0014 3CE0     		b	.L154
 1125              	.L142:
 321:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1126              		.loc 1 321 0
 1127 0016 2B07     		lsls	r3, r5, #28
 1128 0018 3FD5     		bpl	.L144
 322:state.c       ****     /* transform lla_i -> lla_f -> utm_f, set status bits */
 323:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1129              		.loc 1 323 0
 1130 001a D4ED047A 		flds	s15, [r4, #16]	@ int
 1131 001e F8EEE77A 		fsitos	s15, s15
 324:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1132              		.loc 1 324 0
 1133 0022 45F48075 		orr	r5, r5, #256
 323:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1134              		.loc 1 323 0
 1135 0026 17EE900A 		fmrs	r0, s15
 1136 002a FFF7FEFF 		bl	__aeabi_f2d
 1137              	.LVL77:
 1138 002e 68A3     		adr	r3, .L157
 1139 0030 D3E90023 		ldrd	r2, [r3]
 1140 0034 FFF7FEFF 		bl	__aeabi_dmul
 1141              	.LVL78:
 1142 0038 67A3     		adr	r3, .L157+8
 1143 003a D3E90023 		ldrd	r2, [r3]
 1144 003e FFF7FEFF 		bl	__aeabi_ddiv
 1145              	.LVL79:
 1146 0042 FFF7FEFF 		bl	__aeabi_d2f
 1147              	.LVL80:
 1148 0046 D4ED057A 		flds	s15, [r4, #20]	@ int
 1149 004a C4F88C00 		str	r0, [r4, #140]	@ float
 1150 004e F8EEE77A 		fsitos	s15, s15
 1151 0052 17EE900A 		fmrs	r0, s15
 1152 0056 FFF7FEFF 		bl	__aeabi_f2d
 1153              	.LVL81:
 1154 005a 5DA3     		adr	r3, .L157
 1155 005c D3E90023 		ldrd	r2, [r3]
 1156 0060 FFF7FEFF 		bl	__aeabi_dmul
 1157              	.LVL82:
 1158 0064 5CA3     		adr	r3, .L157+8
 1159 0066 D3E90023 		ldrd	r2, [r3]
 1160 006a FFF7FEFF 		bl	__aeabi_ddiv
 1161              	.LVL83:
 1162 006e FFF7FEFF 		bl	__aeabi_d2f
 1163              	.LVL84:
 1164 0072 D4ED067A 		flds	s15, [r4, #24]	@ int
 1165 0076 9FED5B7A 		flds	s14, .L157+20
 1166 007a C4F89000 		str	r0, [r4, #144]	@ float
 1167 007e F8EEE77A 		fsitos	s15, s15
 1168              		.loc 1 324 0
 1169 0082 2046     		mov	r0, r4
 323:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1170              		.loc 1 323 0
 1171 0084 C7EE877A 		fdivs	s15, s15, s14
 1172              		.loc 1 324 0
 1173 0088 20F8785B 		strh	r5, [r0], #120	@ movhi
 323:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1174              		.loc 1 323 0
 1175 008c C4ED257A 		fsts	s15, [r4, #148]
 1176              	.L154:
 325:state.c       ****     utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1177              		.loc 1 325 0
 1178 0090 04F18C01 		add	r1, r4, #140
 1179 0094 FFF7FEFF 		bl	utm_of_lla_f
 1180              	.LVL85:
 1181 0098 95E0     		b	.L143
 1182              	.L144:
 326:state.c       ****   } else if (state.utm_initialized_f) {
 1183              		.loc 1 326 0
 1184 009a 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1185 009e 002B     		cmp	r3, #0
 1186 00a0 00F09180 		beq	.L143
 327:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1187              		.loc 1 327 0
 1188 00a4 2806     		lsls	r0, r5, #24
 1189 00a6 14D5     		bpl	.L145
 328:state.c       ****       UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
 1190              		.loc 1 328 0
 1191 00a8 94ED427A 		flds	s14, [r4, #264]
 1192 00ac D4ED3B7A 		flds	s15, [r4, #236]
 1193 00b0 77EE877A 		fadds	s15, s15, s14
 1194 00b4 94ED437A 		flds	s14, [r4, #268]
 1195 00b8 C4ED1F7A 		fsts	s15, [r4, #124]
 1196 00bc D4ED3A7A 		flds	s15, [r4, #232]
 1197 00c0 77EE877A 		fadds	s15, s15, s14
 1198 00c4 94ED447A 		flds	s14, [r4, #272]
 1199 00c8 C4ED1E7A 		fsts	s15, [r4, #120]
 1200 00cc D4ED3C7A 		flds	s15, [r4, #240]
 1201 00d0 2CE0     		b	.L156
 1202              	.L145:
 329:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1203              		.loc 1 329 0
 1204 00d2 6907     		lsls	r1, r5, #29
 1205 00d4 2DD5     		bpl	.L146
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1206              		.loc 1 330 0
 1207 00d6 D4ED1B7A 		flds	s15, [r4, #108]	@ int
 1208 00da 9FED436A 		flds	s12, .L157+24
 1209 00de F8EEE76A 		fsitos	s13, s15
 1210 00e2 D4ED1C7A 		flds	s15, [r4, #112]	@ int
 1211 00e6 B8EEE77A 		fsitos	s14, s15
 1212 00ea D4ED1D7A 		flds	s15, [r4, #116]	@ int
 1213 00ee F8EEE77A 		fsitos	s15, s15
 1214 00f2 66EE866A 		fmuls	s13, s13, s12
 1215 00f6 27EE067A 		fmuls	s14, s14, s12
 1216 00fa 67EE867A 		fmuls	s15, s15, s12
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 332:state.c       ****       UTM_OF_ENU_ADD(state.utm_pos_f, state.enu_pos_f, state.utm_origin_f);
 1217              		.loc 1 332 0
 1218 00fe 94ED3B6A 		flds	s12, [r4, #236]
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1219              		.loc 1 330 0
 1220 0102 C4ED426A 		fsts	s13, [r4, #264]
 1221              		.loc 1 332 0
 1222 0106 76EE266A 		fadds	s13, s12, s13
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1223              		.loc 1 330 0
 1224 010a 84ED437A 		fsts	s14, [r4, #268]
 1225              		.loc 1 332 0
 1226 010e C4ED1F6A 		fsts	s13, [r4, #124]
 1227 0112 D4ED3A6A 		flds	s13, [r4, #232]
 330:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1228              		.loc 1 330 0
 1229 0116 C4ED447A 		fsts	s15, [r4, #272]
 1230              		.loc 1 332 0
 1231 011a 36EE877A 		fadds	s14, s13, s14
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1232              		.loc 1 331 0
 1233 011e 45F08005 		orr	r5, r5, #128
 1234              		.loc 1 332 0
 1235 0122 84ED1E7A 		fsts	s14, [r4, #120]
 1236 0126 94ED3C7A 		flds	s14, [r4, #240]
 331:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1237              		.loc 1 331 0
 1238 012a 2580     		strh	r5, [r4]	@ movhi
 1239              	.L156:
 1240              		.loc 1 332 0
 1241 012c 77EE277A 		fadds	s15, s14, s15
 1242 0130 47E0     		b	.L155
 1243              	.L146:
 333:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1244              		.loc 1 333 0
 1245 0132 6A06     		lsls	r2, r5, #25
 1246 0134 16D5     		bpl	.L147
 334:state.c       ****       UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
 1247              		.loc 1 334 0
 1248 0136 94ED407A 		flds	s14, [r4, #256]
 1249 013a D4ED3B7A 		flds	s15, [r4, #236]
 1250 013e 77EE877A 		fadds	s15, s15, s14
 1251 0142 94ED3F7A 		flds	s14, [r4, #252]
 1252 0146 C4ED1F7A 		fsts	s15, [r4, #124]
 1253 014a D4ED3A7A 		flds	s15, [r4, #232]
 1254 014e 77EE877A 		fadds	s15, s15, s14
 1255 0152 94ED417A 		flds	s14, [r4, #260]
 1256 0156 C4ED1E7A 		fsts	s15, [r4, #120]
 1257 015a D4ED3C7A 		flds	s15, [r4, #240]
 1258 015e 77EEC77A 		fsubs	s15, s15, s14
 1259 0162 2EE0     		b	.L155
 1260              	.L147:
 335:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1261              		.loc 1 335 0
 1262 0164 AB07     		lsls	r3, r5, #30
 1263 0166 2ED5     		bpl	.L143
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1264              		.loc 1 336 0
 1265 0168 D4ED187A 		flds	s15, [r4, #96]	@ int
 1266 016c 9FED1E6A 		flds	s12, .L157+24
 1267 0170 B8EEE77A 		fsitos	s14, s15
 1268 0174 D4ED197A 		flds	s15, [r4, #100]	@ int
 1269 0178 F8EEE76A 		fsitos	s13, s15
 1270 017c D4ED1A7A 		flds	s15, [r4, #104]	@ int
 1271 0180 F8EEE77A 		fsitos	s15, s15
 1272 0184 27EE067A 		fmuls	s14, s14, s12
 1273 0188 66EE866A 		fmuls	s13, s13, s12
 1274 018c 67EE867A 		fmuls	s15, s15, s12
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 338:state.c       ****       UTM_OF_NED_ADD(state.utm_pos_f, state.ned_pos_f, state.utm_origin_f);
 1275              		.loc 1 338 0
 1276 0190 94ED3B6A 		flds	s12, [r4, #236]
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1277              		.loc 1 336 0
 1278 0194 C4ED406A 		fsts	s13, [r4, #256]
 1279              		.loc 1 338 0
 1280 0198 76EE266A 		fadds	s13, s12, s13
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1281              		.loc 1 336 0
 1282 019c 84ED3F7A 		fsts	s14, [r4, #252]
 1283              		.loc 1 338 0
 1284 01a0 C4ED1F6A 		fsts	s13, [r4, #124]
 1285 01a4 D4ED3A6A 		flds	s13, [r4, #232]
 336:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1286              		.loc 1 336 0
 1287 01a8 C4ED417A 		fsts	s15, [r4, #260]
 1288              		.loc 1 338 0
 1289 01ac 36EE877A 		fadds	s14, s13, s14
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1290              		.loc 1 337 0
 1291 01b0 45F04005 		orr	r5, r5, #64
 1292              		.loc 1 338 0
 1293 01b4 84ED1E7A 		fsts	s14, [r4, #120]
 1294 01b8 94ED3C7A 		flds	s14, [r4, #240]
 337:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1295              		.loc 1 337 0
 1296 01bc 2580     		strh	r5, [r4]	@ movhi
 1297              		.loc 1 338 0
 1298 01be 77EE677A 		fsubs	s15, s14, s15
 1299              	.L155:
 1300 01c2 C4ED207A 		fsts	s15, [r4, #128]
 1301              	.L143:
 339:state.c       ****     }
 340:state.c       ****   } else {
 341:state.c       ****     /* could not get this representation,  set errno */
 342:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 343:state.c       ****     //return _ecef_zero;
 344:state.c       ****   }
 345:state.c       ****   /* set bit to indicate this representation is computed */
 346:state.c       ****   SetBit(state.pos_status, POS_UTM_F);
 1302              		.loc 1 346 0
 1303 01c6 2388     		ldrh	r3, [r4]
 1304 01c8 43F40073 		orr	r3, r3, #512
 1305 01cc 2380     		strh	r3, [r4]	@ movhi
 1306              	.L140:
 1307 01ce 38BD     		pop	{r3, r4, r5, pc}
 1308              	.L158:
 1309              		.align	3
 1310              	.L157:
 1311 01d0 399D52A2 		.word	-1571644103
 1312 01d4 46DF913F 		.word	1066524486
 1313 01d8 00000000 		.word	0
 1314 01dc D0126341 		.word	1097011920
 1315 01e0 00000000 		.word	.LANCHOR0
 1316 01e4 00007A44 		.word	1148846080
 1317 01e8 0000803B 		.word	998244352
 1318              		.cfi_endproc
 1319              	.LFE144:
 1321              		.global	__aeabi_i2d
 1322              		.section	.text.stateCalcPositionEcef_f,"ax",%progbits
 1323              		.align	1
 1324              		.global	stateCalcPositionEcef_f
 1325              		.thumb
 1326              		.thumb_func
 1328              	stateCalcPositionEcef_f:
 1329              	.LFB145:
 347:state.c       **** }
 348:state.c       **** 
 349:state.c       **** void stateCalcPositionEcef_f(void)
 350:state.c       **** {
 1330              		.loc 1 350 0
 1331              		.cfi_startproc
 1332              		@ args = 0, pretend = 0, frame = 0
 1333              		@ frame_needed = 0, uses_anonymous_args = 0
 1334 0000 38B5     		push	{r3, r4, r5, lr}
 1335              		.cfi_def_cfa_offset 16
 1336              		.cfi_offset 3, -16
 1337              		.cfi_offset 4, -12
 1338              		.cfi_offset 5, -8
 1339              		.cfi_offset 14, -4
 351:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1340              		.loc 1 351 0
 1341 0002 4B4C     		ldr	r4, .L171+16
 1342 0004 2588     		ldrh	r5, [r4]
 1343 0006 AA06     		lsls	r2, r5, #26
 1344 0008 00F18680 		bmi	.L159
 352:state.c       ****     return;
 353:state.c       ****   }
 354:state.c       **** 
 355:state.c       ****   if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1345              		.loc 1 355 0
 1346 000c EB07     		lsls	r3, r5, #31
 1347 000e 17D4     		bmi	.L169
 356:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 357:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && &state.ned_initialized_f) {
 1348              		.loc 1 357 0
 1349 0010 6806     		lsls	r0, r5, #25
 1350 0012 08D5     		bpl	.L163
 358:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 1351              		.loc 1 358 0
 1352 0014 04F19800 		add	r0, r4, #152
 1353 0018 04F1A401 		add	r1, r4, #164
 1354 001c 04F1FC02 		add	r2, r4, #252
 1355 0020 FFF7FEFF 		bl	ecef_of_ned_point_f
 1356              	.LVL86:
 1357 0024 74E0     		b	.L162
 1358              	.L163:
 359:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && &state.ned_initialized_i) {
 1359              		.loc 1 359 0
 1360 0026 A907     		lsls	r1, r5, #30
 1361 0028 2CD5     		bpl	.L164
 360:state.c       ****     /* transform ned_i -> ecef_i -> ecef_f, set status bits */
 361:state.c       ****     ecef_of_ned_pos_i(&state.ecef_pos_i, &state.ned_origin_i, &state.ned_pos_i);
 1362              		.loc 1 361 0
 1363 002a 201D     		adds	r0, r4, #4
 1364 002c 04F11C01 		add	r1, r4, #28
 1365 0030 04F16002 		add	r2, r4, #96
 1366 0034 FFF7FEFF 		bl	ecef_of_ned_pos_i
 1367              	.LVL87:
 362:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 1368              		.loc 1 362 0
 1369 0038 2388     		ldrh	r3, [r4]
 1370 003a 43F02003 		orr	r3, r3, #32
 1371 003e 2380     		strh	r3, [r4]	@ movhi
 1372              	.L169:
 363:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 1373              		.loc 1 363 0
 1374 0040 6068     		ldr	r0, [r4, #4]
 1375 0042 FFF7FEFF 		bl	__aeabi_i2d
 1376              	.LVL88:
 1377 0046 0022     		movs	r2, #0
 1378 0048 3A4B     		ldr	r3, .L171+20
 1379 004a FFF7FEFF 		bl	__aeabi_ddiv
 1380              	.LVL89:
 1381 004e FFF7FEFF 		bl	__aeabi_d2f
 1382              	.LVL90:
 1383 0052 C4F89800 		str	r0, [r4, #152]	@ float
 1384 0056 A068     		ldr	r0, [r4, #8]
 1385 0058 FFF7FEFF 		bl	__aeabi_i2d
 1386              	.LVL91:
 1387 005c 0022     		movs	r2, #0
 1388 005e 354B     		ldr	r3, .L171+20
 1389 0060 FFF7FEFF 		bl	__aeabi_ddiv
 1390              	.LVL92:
 1391 0064 FFF7FEFF 		bl	__aeabi_d2f
 1392              	.LVL93:
 1393 0068 C4F89C00 		str	r0, [r4, #156]	@ float
 1394 006c E068     		ldr	r0, [r4, #12]
 1395 006e FFF7FEFF 		bl	__aeabi_i2d
 1396              	.LVL94:
 1397 0072 0022     		movs	r2, #0
 1398 0074 2F4B     		ldr	r3, .L171+20
 1399 0076 FFF7FEFF 		bl	__aeabi_ddiv
 1400              	.LVL95:
 1401 007a FFF7FEFF 		bl	__aeabi_d2f
 1402              	.LVL96:
 1403 007e C4F8A000 		str	r0, [r4, #160]	@ float
 1404 0082 45E0     		b	.L162
 1405              	.L164:
 364:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1406              		.loc 1 364 0
 1407 0084 EA05     		lsls	r2, r5, #23
 1408 0086 02D5     		bpl	.L165
 365:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1409              		.loc 1 365 0
 1410 0088 04F19800 		add	r0, r4, #152
 1411 008c 3CE0     		b	.L170
 1412              	.L165:
 366:state.c       ****   } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1413              		.loc 1 366 0
 1414 008e 2B07     		lsls	r3, r5, #28
 1415 0090 3ED5     		bpl	.L162
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1416              		.loc 1 367 0
 1417 0092 D4ED047A 		flds	s15, [r4, #16]	@ int
 1418 0096 F8EEE77A 		fsitos	s15, s15
 368:state.c       ****     SetBit(state.pos_status, POS_LLA_F);
 1419              		.loc 1 368 0
 1420 009a 45F48075 		orr	r5, r5, #256
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1421              		.loc 1 367 0
 1422 009e 17EE900A 		fmrs	r0, s15
 1423 00a2 FFF7FEFF 		bl	__aeabi_f2d
 1424              	.LVL97:
 1425 00a6 1EA3     		adr	r3, .L171
 1426 00a8 D3E90023 		ldrd	r2, [r3]
 1427 00ac FFF7FEFF 		bl	__aeabi_dmul
 1428              	.LVL98:
 1429 00b0 1DA3     		adr	r3, .L171+8
 1430 00b2 D3E90023 		ldrd	r2, [r3]
 1431 00b6 FFF7FEFF 		bl	__aeabi_ddiv
 1432              	.LVL99:
 1433 00ba FFF7FEFF 		bl	__aeabi_d2f
 1434              	.LVL100:
 1435 00be D4ED057A 		flds	s15, [r4, #20]	@ int
 1436 00c2 C4F88C00 		str	r0, [r4, #140]	@ float
 1437 00c6 F8EEE77A 		fsitos	s15, s15
 1438 00ca 17EE900A 		fmrs	r0, s15
 1439 00ce FFF7FEFF 		bl	__aeabi_f2d
 1440              	.LVL101:
 1441 00d2 13A3     		adr	r3, .L171
 1442 00d4 D3E90023 		ldrd	r2, [r3]
 1443 00d8 FFF7FEFF 		bl	__aeabi_dmul
 1444              	.LVL102:
 1445 00dc 12A3     		adr	r3, .L171+8
 1446 00de D3E90023 		ldrd	r2, [r3]
 1447 00e2 FFF7FEFF 		bl	__aeabi_ddiv
 1448              	.LVL103:
 1449 00e6 FFF7FEFF 		bl	__aeabi_d2f
 1450              	.LVL104:
 1451 00ea D4ED067A 		flds	s15, [r4, #24]	@ int
 1452 00ee 9FED127A 		flds	s14, .L171+24
 1453 00f2 C4F89000 		str	r0, [r4, #144]	@ float
 1454 00f6 F8EEE77A 		fsitos	s15, s15
 1455              		.loc 1 368 0
 1456 00fa 2046     		mov	r0, r4
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1457              		.loc 1 367 0
 1458 00fc C7EE877A 		fdivs	s15, s15, s14
 1459              		.loc 1 368 0
 1460 0100 20F8985B 		strh	r5, [r0], #152	@ movhi
 367:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1461              		.loc 1 367 0
 1462 0104 C4ED257A 		fsts	s15, [r4, #148]
 1463              	.L170:
 369:state.c       ****     ecef_of_lla_f(&state.ecef_pos_f, &state.lla_pos_f);
 1464              		.loc 1 369 0
 1465 0108 04F18C01 		add	r1, r4, #140
 1466 010c FFF7FEFF 		bl	ecef_of_lla_f
 1467              	.LVL105:
 1468              	.L162:
 370:state.c       ****   } else {
 371:state.c       ****     /* could not get this representation,  set errno */
 372:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 373:state.c       ****     //return _ecef_zero;
 374:state.c       ****   }
 375:state.c       ****   /* set bit to indicate this representation is computed */
 376:state.c       ****   SetBit(state.pos_status, POS_ECEF_F);
 1469              		.loc 1 376 0
 1470 0110 2388     		ldrh	r3, [r4]
 1471 0112 43F02003 		orr	r3, r3, #32
 1472 0116 2380     		strh	r3, [r4]	@ movhi
 1473              	.L159:
 1474 0118 38BD     		pop	{r3, r4, r5, pc}
 1475              	.L172:
 1476 011a 00BFAFF3 		.align	3
 1476      0080
 1477              	.L171:
 1478 0120 399D52A2 		.word	-1571644103
 1479 0124 46DF913F 		.word	1066524486
 1480 0128 00000000 		.word	0
 1481 012c D0126341 		.word	1097011920
 1482 0130 00000000 		.word	.LANCHOR0
 1483 0134 00005940 		.word	1079574528
 1484 0138 00007A44 		.word	1148846080
 1485              		.cfi_endproc
 1486              	.LFE145:
 1488              		.section	.text.stateCalcPositionNed_f,"ax",%progbits
 1489              		.align	1
 1490              		.global	stateCalcPositionNed_f
 1491              		.thumb
 1492              		.thumb_func
 1494              	stateCalcPositionNed_f:
 1495              	.LFB146:
 377:state.c       **** }
 378:state.c       **** 
 379:state.c       **** void stateCalcPositionNed_f(void)
 380:state.c       **** {
 1496              		.loc 1 380 0
 1497              		.cfi_startproc
 1498              		@ args = 0, pretend = 0, frame = 0
 1499              		@ frame_needed = 0, uses_anonymous_args = 0
 1500 0000 38B5     		push	{r3, r4, r5, lr}
 1501              		.cfi_def_cfa_offset 16
 1502              		.cfi_offset 3, -16
 1503              		.cfi_offset 4, -12
 1504              		.cfi_offset 5, -8
 1505              		.cfi_offset 14, -4
 381:state.c       ****   if (bit_is_set(state.pos_status, POS_NED_F)) {
 1506              		.loc 1 381 0
 1507 0002 814C     		ldr	r4, .L201+16
 1508 0004 2588     		ldrh	r5, [r4]
 1509 0006 6806     		lsls	r0, r5, #25
 1510 0008 00F1F380 		bmi	.L173
 1511              	.LVL106:
 382:state.c       ****     return;
 383:state.c       ****   }
 384:state.c       **** 
 385:state.c       ****   int errno = 0;
 386:state.c       ****   if (state.ned_initialized_f) {
 1512              		.loc 1 386 0
 1513 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1514 0010 A3B3     		cbz	r3, .L175
 387:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1515              		.loc 1 387 0
 1516 0012 A907     		lsls	r1, r5, #30
 1517 0014 39D4     		bmi	.L198
 388:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 389:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1518              		.loc 1 389 0
 1519 0016 AA06     		lsls	r2, r5, #26
 1520 0018 08D5     		bpl	.L178
 390:state.c       ****       ned_of_ecef_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1521              		.loc 1 390 0
 1522 001a 04F1FC00 		add	r0, r4, #252
 1523 001e 04F1A401 		add	r1, r4, #164
 1524 0022 04F19802 		add	r2, r4, #152
 1525 0026 FFF7FEFF 		bl	ned_of_ecef_point_f
 1526              	.LVL107:
 1527 002a DEE0     		b	.L177
 1528              	.L178:
 391:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1529              		.loc 1 391 0
 1530 002c EB07     		lsls	r3, r5, #31
 1531 002e 02D5     		bpl	.L179
 392:state.c       ****       /* transform ecef_i -> ned_i -> ned_f, set status bits */
 393:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1532              		.loc 1 393 0
 1533 0030 04F16000 		add	r0, r4, #96
 1534 0034 18E0     		b	.L200
 1535              	.L179:
 394:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 395:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 396:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1536              		.loc 1 396 0
 1537 0036 E805     		lsls	r0, r5, #23
 1538 0038 08D5     		bpl	.L180
 397:state.c       ****       ned_of_lla_point_f(&state.ned_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1539              		.loc 1 397 0
 1540 003a 04F1FC00 		add	r0, r4, #252
 1541 003e 04F1A401 		add	r1, r4, #164
 1542 0042 04F18C02 		add	r2, r4, #140
 1543 0046 FFF7FEFF 		bl	ned_of_lla_point_f
 1544              	.LVL108:
 1545 004a CEE0     		b	.L177
 1546              	.L180:
 398:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1547              		.loc 1 398 0
 1548 004c 2907     		lsls	r1, r5, #28
 1549 004e 40F1CC80 		bpl	.L177
 399:state.c       ****       /* transform lla_i -> ecef_i -> ned_i -> ned_f, set status bits */
 400:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1550              		.loc 1 400 0
 1551 0052 201D     		adds	r0, r4, #4
 1552 0054 04F11001 		add	r1, r4, #16
 1553 0058 FFF7FEFF 		bl	ecef_of_lla_i
 1554              	.LVL109:
 401:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1555              		.loc 1 401 0
 1556 005c 2388     		ldrh	r3, [r4]
 1557 005e 2046     		mov	r0, r4
 1558 0060 43F00103 		orr	r3, r3, #1
 1559 0064 20F8603B 		strh	r3, [r0], #96	@ movhi
 1560              	.L200:
 402:state.c       ****       ned_of_ecef_pos_i(&state.ned_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1561              		.loc 1 402 0
 1562 0068 04F11C01 		add	r1, r4, #28
 1563 006c 221D     		adds	r2, r4, #4
 1564 006e FFF7FEFF 		bl	ned_of_ecef_pos_i
 1565              	.LVL110:
 403:state.c       ****       SetBit(state.pos_status, POS_NED_I);
 1566              		.loc 1 403 0
 1567 0072 2388     		ldrh	r3, [r4]
 1568 0074 43F00203 		orr	r3, r3, #2
 1569 0078 2380     		strh	r3, [r4]	@ movhi
 1570 007a 06E0     		b	.L198
 1571              	.L175:
 404:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 405:state.c       ****     } else { /* could not get this representation,  set errno */
 406:state.c       ****       errno = 1;
 407:state.c       ****     }
 408:state.c       ****   } else if (state.utm_initialized_f) {
 1572              		.loc 1 408 0
 1573 007c 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1574 0080 002B     		cmp	r3, #0
 1575 0082 00F0B280 		beq	.L177
 409:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_I)) {
 1576              		.loc 1 409 0
 1577 0086 AA07     		lsls	r2, r5, #30
 1578 0088 18D5     		bpl	.L181
 1579              	.L198:
 410:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1580              		.loc 1 410 0
 1581 008a D4ED187A 		flds	s15, [r4, #96]	@ int
 1582 008e DFED5F6A 		flds	s13, .L201+20
 1583 0092 B8EEE77A 		fsitos	s14, s15
 1584 0096 D4ED197A 		flds	s15, [r4, #100]	@ int
 1585 009a 27EE267A 		fmuls	s14, s14, s13
 1586 009e 84ED3F7A 		fsts	s14, [r4, #252]
 1587 00a2 B8EEE77A 		fsitos	s14, s15
 1588 00a6 D4ED1A7A 		flds	s15, [r4, #104]	@ int
 1589 00aa 27EE267A 		fmuls	s14, s14, s13
 1590 00ae F8EEE77A 		fsitos	s15, s15
 1591 00b2 84ED407A 		fsts	s14, [r4, #256]
 1592 00b6 67EEA67A 		fmuls	s15, s15, s13
 1593 00ba 94E0     		b	.L195
 1594              	.L181:
 411:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1595              		.loc 1 411 0
 1596 00bc 6B07     		lsls	r3, r5, #29
 1597 00be 21D5     		bpl	.L182
 412:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1598              		.loc 1 412 0
 1599 00c0 D4ED1B7A 		flds	s15, [r4, #108]	@ int
 1600 00c4 9FED516A 		flds	s12, .L201+20
 1601 00c8 B8EEE77A 		fsitos	s14, s15
 1602 00cc D4ED1C7A 		flds	s15, [r4, #112]	@ int
 1603 00d0 F8EEE76A 		fsitos	s13, s15
 1604 00d4 D4ED1D7A 		flds	s15, [r4, #116]	@ int
 1605 00d8 F8EEE77A 		fsitos	s15, s15
 1606 00dc 27EE067A 		fmuls	s14, s14, s12
 1607 00e0 66EE866A 		fmuls	s13, s13, s12
 1608 00e4 67EE867A 		fmuls	s15, s15, s12
 413:state.c       ****       SetBit(state.pos_status, POS_ENU_F);
 1609              		.loc 1 413 0
 1610 00e8 45F08005 		orr	r5, r5, #128
 412:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1611              		.loc 1 412 0
 1612 00ec 84ED427A 		fsts	s14, [r4, #264]
 1613 00f0 C4ED436A 		fsts	s13, [r4, #268]
 1614 00f4 C4ED447A 		fsts	s15, [r4, #272]
 1615              		.loc 1 413 0
 1616 00f8 2580     		strh	r5, [r4]	@ movhi
 414:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1617              		.loc 1 414 0
 1618 00fa C4ED3F6A 		fsts	s13, [r4, #252]
 1619 00fe 84ED407A 		fsts	s14, [r4, #256]
 1620 0102 0BE0     		b	.L199
 1621              	.L182:
 415:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1622              		.loc 1 415 0
 1623 0104 2806     		lsls	r0, r5, #24
 1624 0106 0CD5     		bpl	.L183
 416:state.c       ****       VECT3_NED_OF_ENU(state.ned_pos_f, state.enu_pos_f);
 1625              		.loc 1 416 0
 1626 0108 D4F80C31 		ldr	r3, [r4, #268]	@ float
 1627 010c C4F8FC30 		str	r3, [r4, #252]	@ float
 1628 0110 D4ED447A 		flds	s15, [r4, #272]
 1629 0114 D4F80831 		ldr	r3, [r4, #264]	@ float
 1630 0118 C4F80031 		str	r3, [r4, #256]	@ float
 1631              	.L199:
 1632 011c F1EE677A 		fnegs	s15, s15
 1633 0120 61E0     		b	.L195
 1634              	.L183:
 417:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1635              		.loc 1 417 0
 1636 0122 A905     		lsls	r1, r5, #22
 1637 0124 49D4     		bmi	.L197
 418:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 419:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1638              		.loc 1 419 0
 1639 0126 EA05     		lsls	r2, r5, #23
 1640 0128 02D5     		bpl	.L185
 420:state.c       ****       /* transform lla_f -> utm_f -> ned, set status bits */
 421:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1641              		.loc 1 421 0
 1642 012a 04F17800 		add	r0, r4, #120
 1643 012e 3CE0     		b	.L196
 1644              	.L185:
 422:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 423:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 424:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1645              		.loc 1 424 0
 1646 0130 2B07     		lsls	r3, r5, #28
 1647 0132 5AD5     		bpl	.L177
 425:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> ned, set status bits */
 426:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1648              		.loc 1 426 0
 1649 0134 D4ED047A 		flds	s15, [r4, #16]	@ int
 1650 0138 F8EEE77A 		fsitos	s15, s15
 427:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1651              		.loc 1 427 0
 1652 013c 45F48075 		orr	r5, r5, #256
 426:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1653              		.loc 1 426 0
 1654 0140 17EE900A 		fmrs	r0, s15
 1655 0144 FFF7FEFF 		bl	__aeabi_f2d
 1656              	.LVL111:
 1657 0148 2BA3     		adr	r3, .L201
 1658 014a D3E90023 		ldrd	r2, [r3]
 1659 014e FFF7FEFF 		bl	__aeabi_dmul
 1660              	.LVL112:
 1661 0152 2BA3     		adr	r3, .L201+8
 1662 0154 D3E90023 		ldrd	r2, [r3]
 1663 0158 FFF7FEFF 		bl	__aeabi_ddiv
 1664              	.LVL113:
 1665 015c FFF7FEFF 		bl	__aeabi_d2f
 1666              	.LVL114:
 1667 0160 D4ED057A 		flds	s15, [r4, #20]	@ int
 1668 0164 C4F88C00 		str	r0, [r4, #140]	@ float
 1669 0168 F8EEE77A 		fsitos	s15, s15
 1670 016c 17EE900A 		fmrs	r0, s15
 1671 0170 FFF7FEFF 		bl	__aeabi_f2d
 1672              	.LVL115:
 1673 0174 20A3     		adr	r3, .L201
 1674 0176 D3E90023 		ldrd	r2, [r3]
 1675 017a FFF7FEFF 		bl	__aeabi_dmul
 1676              	.LVL116:
 1677 017e 20A3     		adr	r3, .L201+8
 1678 0180 D3E90023 		ldrd	r2, [r3]
 1679 0184 FFF7FEFF 		bl	__aeabi_ddiv
 1680              	.LVL117:
 1681 0188 FFF7FEFF 		bl	__aeabi_d2f
 1682              	.LVL118:
 1683 018c D4ED067A 		flds	s15, [r4, #24]	@ int
 1684 0190 9FED1F7A 		flds	s14, .L201+24
 1685 0194 C4F89000 		str	r0, [r4, #144]	@ float
 1686 0198 F8EEE77A 		fsitos	s15, s15
 1687              		.loc 1 427 0
 1688 019c 2046     		mov	r0, r4
 426:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1689              		.loc 1 426 0
 1690 019e C7EE877A 		fdivs	s15, s15, s14
 1691              		.loc 1 427 0
 1692 01a2 20F8785B 		strh	r5, [r0], #120	@ movhi
 426:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1693              		.loc 1 426 0
 1694 01a6 C4ED257A 		fsts	s15, [r4, #148]
 1695              	.L196:
 428:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1696              		.loc 1 428 0
 1697 01aa 04F18C01 		add	r1, r4, #140
 1698 01ae FFF7FEFF 		bl	utm_of_lla_f
 1699              	.LVL119:
 429:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 1700              		.loc 1 429 0
 1701 01b2 2388     		ldrh	r3, [r4]
 1702 01b4 43F40073 		orr	r3, r3, #512
 1703 01b8 2380     		strh	r3, [r4]	@ movhi
 1704              	.L197:
 430:state.c       ****       NED_OF_UTM_DIFF(state.ned_pos_f, state.utm_pos_f, state.utm_origin_f);
 1705              		.loc 1 430 0
 1706 01ba 94ED3A7A 		flds	s14, [r4, #232]
 1707 01be D4ED1E7A 		flds	s15, [r4, #120]
 1708 01c2 77EEC77A 		fsubs	s15, s15, s14
 1709 01c6 94ED3B7A 		flds	s14, [r4, #236]
 1710 01ca C4ED3F7A 		fsts	s15, [r4, #252]
 1711 01ce D4ED1F7A 		flds	s15, [r4, #124]
 1712 01d2 77EEC77A 		fsubs	s15, s15, s14
 1713 01d6 94ED207A 		flds	s14, [r4, #128]
 1714 01da C4ED407A 		fsts	s15, [r4, #256]
 1715 01de D4ED3C7A 		flds	s15, [r4, #240]
 1716 01e2 77EEC77A 		fsubs	s15, s15, s14
 1717              	.L195:
 1718 01e6 C4ED417A 		fsts	s15, [r4, #260]
 1719              	.L177:
 431:state.c       ****     } else { /* could not get this representation,  set errno */
 432:state.c       ****       errno = 2;
 433:state.c       ****     }
 434:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 435:state.c       ****     errno = 3;
 436:state.c       ****   }
 437:state.c       ****   if (errno) {
 438:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 439:state.c       ****     //return _ned_zero;
 440:state.c       ****   }
 441:state.c       ****   /* set bit to indicate this representation is computed */
 442:state.c       ****   SetBit(state.pos_status, POS_NED_F);
 1720              		.loc 1 442 0
 1721 01ea 2388     		ldrh	r3, [r4]
 1722 01ec 43F04003 		orr	r3, r3, #64
 1723 01f0 2380     		strh	r3, [r4]	@ movhi
 1724              	.LVL120:
 1725              	.L173:
 1726 01f2 38BD     		pop	{r3, r4, r5, pc}
 1727              	.L202:
 1728 01f4 AFF30080 		.align	3
 1729              	.L201:
 1730 01f8 399D52A2 		.word	-1571644103
 1731 01fc 46DF913F 		.word	1066524486
 1732 0200 00000000 		.word	0
 1733 0204 D0126341 		.word	1097011920
 1734 0208 00000000 		.word	.LANCHOR0
 1735 020c 0000803B 		.word	998244352
 1736 0210 00007A44 		.word	1148846080
 1737              		.cfi_endproc
 1738              	.LFE146:
 1740              		.section	.text.stateCalcPositionEnu_f,"ax",%progbits
 1741              		.align	1
 1742              		.global	stateCalcPositionEnu_f
 1743              		.thumb
 1744              		.thumb_func
 1746              	stateCalcPositionEnu_f:
 1747              	.LFB147:
 443:state.c       **** }
 444:state.c       **** 
 445:state.c       **** void stateCalcPositionEnu_f(void)
 446:state.c       **** {
 1748              		.loc 1 446 0
 1749              		.cfi_startproc
 1750              		@ args = 0, pretend = 0, frame = 0
 1751              		@ frame_needed = 0, uses_anonymous_args = 0
 1752 0000 38B5     		push	{r3, r4, r5, lr}
 1753              		.cfi_def_cfa_offset 16
 1754              		.cfi_offset 3, -16
 1755              		.cfi_offset 4, -12
 1756              		.cfi_offset 5, -8
 1757              		.cfi_offset 14, -4
 447:state.c       ****   if (bit_is_set(state.pos_status, POS_ENU_F)) {
 1758              		.loc 1 447 0
 1759 0002 834C     		ldr	r4, .L234+16
 1760 0004 2588     		ldrh	r5, [r4]
 1761 0006 2A06     		lsls	r2, r5, #24
 1762 0008 00F1F880 		bmi	.L203
 1763              	.LVL121:
 448:state.c       ****     return;
 449:state.c       ****   }
 450:state.c       **** 
 451:state.c       ****   int errno = 0;
 452:state.c       ****   if (state.ned_initialized_f) {
 1764              		.loc 1 452 0
 1765 000c 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 1766 0010 002B     		cmp	r3, #0
 1767 0012 43D0     		beq	.L205
 453:state.c       ****     if (bit_is_set(state.pos_status, POS_NED_F)) {
 1768              		.loc 1 453 0
 1769 0014 6B06     		lsls	r3, r5, #25
 1770 0016 0AD5     		bpl	.L206
 1771              	.L214:
 454:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1772              		.loc 1 454 0
 1773 0018 D4F80031 		ldr	r3, [r4, #256]	@ float
 1774 001c C4F80831 		str	r3, [r4, #264]	@ float
 1775 0020 D4F8FC30 		ldr	r3, [r4, #252]	@ float
 1776 0024 C4F80C31 		str	r3, [r4, #268]	@ float
 1777 0028 D4ED417A 		flds	s15, [r4, #260]
 1778 002c 7BE0     		b	.L230
 1779              	.L206:
 455:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1780              		.loc 1 455 0
 1781 002e 6807     		lsls	r0, r5, #29
 1782 0030 3BD4     		bmi	.L231
 456:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 457:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1783              		.loc 1 457 0
 1784 0032 A907     		lsls	r1, r5, #30
 1785 0034 56D4     		bmi	.L232
 458:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 459:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 460:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 461:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 1786              		.loc 1 461 0
 1787 0036 AA06     		lsls	r2, r5, #26
 1788 0038 08D5     		bpl	.L210
 462:state.c       ****       enu_of_ecef_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.ecef_pos_f);
 1789              		.loc 1 462 0
 1790 003a 04F58470 		add	r0, r4, #264
 1791 003e 04F1A401 		add	r1, r4, #164
 1792 0042 04F19802 		add	r2, r4, #152
 1793 0046 FFF7FEFF 		bl	enu_of_ecef_point_f
 1794              	.LVL122:
 1795 004a D3E0     		b	.L207
 1796              	.L210:
 463:state.c       ****     } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 1797              		.loc 1 463 0
 1798 004c EB07     		lsls	r3, r5, #31
 1799 004e 02D5     		bpl	.L211
 464:state.c       ****       /* transform ecef_i -> enu_i -> enu_f, set status bits */
 465:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1800              		.loc 1 465 0
 1801 0050 04F16C00 		add	r0, r4, #108
 1802 0054 18E0     		b	.L233
 1803              	.L211:
 466:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 467:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 468:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1804              		.loc 1 468 0
 1805 0056 E805     		lsls	r0, r5, #23
 1806 0058 08D5     		bpl	.L212
 469:state.c       ****       enu_of_lla_point_f(&state.enu_pos_f, &state.ned_origin_f, &state.lla_pos_f);
 1807              		.loc 1 469 0
 1808 005a 04F58470 		add	r0, r4, #264
 1809 005e 04F1A401 		add	r1, r4, #164
 1810 0062 04F18C02 		add	r2, r4, #140
 1811 0066 FFF7FEFF 		bl	enu_of_lla_point_f
 1812              	.LVL123:
 1813 006a C3E0     		b	.L207
 1814              	.L212:
 470:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1815              		.loc 1 470 0
 1816 006c 2907     		lsls	r1, r5, #28
 1817 006e 40F1C180 		bpl	.L207
 471:state.c       ****       /* transform lla_i -> ecef_i -> enu_i -> enu_f, set status bits */
 472:state.c       ****       ecef_of_lla_i(&state.ecef_pos_i, &state.lla_pos_i); /* converts to doubles internally */
 1818              		.loc 1 472 0
 1819 0072 201D     		adds	r0, r4, #4
 1820 0074 04F11001 		add	r1, r4, #16
 1821 0078 FFF7FEFF 		bl	ecef_of_lla_i
 1822              	.LVL124:
 473:state.c       ****       SetBit(state.pos_status, POS_ECEF_I);
 1823              		.loc 1 473 0
 1824 007c 2388     		ldrh	r3, [r4]
 1825 007e 2046     		mov	r0, r4
 1826 0080 43F00103 		orr	r3, r3, #1
 1827 0084 20F86C3B 		strh	r3, [r0], #108	@ movhi
 1828              	.L233:
 474:state.c       ****       enu_of_ecef_pos_i(&state.enu_pos_i, &state.ned_origin_i, &state.ecef_pos_i);
 1829              		.loc 1 474 0
 1830 0088 04F11C01 		add	r1, r4, #28
 1831 008c 221D     		adds	r2, r4, #4
 1832 008e FFF7FEFF 		bl	enu_of_ecef_pos_i
 1833              	.LVL125:
 475:state.c       ****       SetBit(state.pos_status, POS_ENU_I);
 1834              		.loc 1 475 0
 1835 0092 2388     		ldrh	r3, [r4]
 1836 0094 43F00403 		orr	r3, r3, #4
 1837 0098 2380     		strh	r3, [r4]	@ movhi
 1838 009a 06E0     		b	.L231
 1839              	.L205:
 476:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 477:state.c       ****     } else { /* could not get this representation,  set errno */
 478:state.c       ****       errno = 1;
 479:state.c       ****     }
 480:state.c       ****   } else if (state.utm_initialized_f) {
 1840              		.loc 1 480 0
 1841 009c 94F8F830 		ldrb	r3, [r4, #248]	@ zero_extendqisi2
 1842 00a0 002B     		cmp	r3, #0
 1843 00a2 00F0A780 		beq	.L207
 481:state.c       ****     if (bit_is_set(state.pos_status, POS_ENU_I)) {
 1844              		.loc 1 481 0
 1845 00a6 6A07     		lsls	r2, r5, #29
 1846 00a8 18D5     		bpl	.L213
 1847              	.L231:
 482:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_pos_f, state.enu_pos_i);
 1848              		.loc 1 482 0
 1849 00aa D4ED1B7A 		flds	s15, [r4, #108]	@ int
 1850 00ae DFED596A 		flds	s13, .L234+20
 1851 00b2 B8EEE77A 		fsitos	s14, s15
 1852 00b6 D4ED1C7A 		flds	s15, [r4, #112]	@ int
 1853 00ba 27EE267A 		fmuls	s14, s14, s13
 1854 00be 84ED427A 		fsts	s14, [r4, #264]
 1855 00c2 B8EEE77A 		fsitos	s14, s15
 1856 00c6 D4ED1D7A 		flds	s15, [r4, #116]	@ int
 1857 00ca 27EE267A 		fmuls	s14, s14, s13
 1858 00ce F8EEE77A 		fsitos	s15, s15
 1859 00d2 84ED437A 		fsts	s14, [r4, #268]
 1860 00d6 67EEA67A 		fmuls	s15, s15, s13
 1861 00da 89E0     		b	.L227
 1862              	.L213:
 483:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_F)) {
 1863              		.loc 1 483 0
 1864 00dc 6B06     		lsls	r3, r5, #25
 1865 00de 9BD4     		bmi	.L214
 484:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 485:state.c       ****     } else if (bit_is_set(state.pos_status, POS_NED_I)) {
 1866              		.loc 1 485 0
 1867 00e0 A807     		lsls	r0, r5, #30
 1868 00e2 23D5     		bpl	.L215
 1869              	.L232:
 486:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1870              		.loc 1 486 0
 1871 00e4 D4ED187A 		flds	s15, [r4, #96]	@ int
 1872 00e8 9FED4A6A 		flds	s12, .L234+20
 1873 00ec B8EEE77A 		fsitos	s14, s15
 1874 00f0 D4ED197A 		flds	s15, [r4, #100]	@ int
 1875 00f4 F8EEE76A 		fsitos	s13, s15
 1876 00f8 D4ED1A7A 		flds	s15, [r4, #104]	@ int
 1877 00fc F8EEE77A 		fsitos	s15, s15
 1878 0100 27EE067A 		fmuls	s14, s14, s12
 1879 0104 66EE866A 		fmuls	s13, s13, s12
 1880 0108 67EE867A 		fmuls	s15, s15, s12
 487:state.c       ****       SetBit(state.pos_status, POS_NED_F);
 1881              		.loc 1 487 0
 1882 010c 45F04005 		orr	r5, r5, #64
 486:state.c       ****       NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 1883              		.loc 1 486 0
 1884 0110 84ED3F7A 		fsts	s14, [r4, #252]
 1885 0114 C4ED406A 		fsts	s13, [r4, #256]
 1886 0118 C4ED417A 		fsts	s15, [r4, #260]
 1887              		.loc 1 487 0
 1888 011c 2580     		strh	r5, [r4]	@ movhi
 488:state.c       ****       VECT3_ENU_OF_NED(state.enu_pos_f, state.ned_pos_f);
 1889              		.loc 1 488 0
 1890 011e C4ED426A 		fsts	s13, [r4, #264]
 1891 0122 84ED437A 		fsts	s14, [r4, #268]
 1892              	.L230:
 1893 0126 F1EE677A 		fnegs	s15, s15
 1894 012a 61E0     		b	.L227
 1895              	.L215:
 489:state.c       ****     } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 1896              		.loc 1 489 0
 1897 012c A905     		lsls	r1, r5, #22
 1898 012e 49D4     		bmi	.L229
 490:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 491:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_F)) {
 1899              		.loc 1 491 0
 1900 0130 EA05     		lsls	r2, r5, #23
 1901 0132 02D5     		bpl	.L217
 492:state.c       ****       /* transform lla_f -> utm_f -> enu, set status bits */
 493:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1902              		.loc 1 493 0
 1903 0134 04F17800 		add	r0, r4, #120
 1904 0138 3CE0     		b	.L228
 1905              	.L217:
 494:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 495:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 496:state.c       ****     } else if (bit_is_set(state.pos_status, POS_LLA_I)) {
 1906              		.loc 1 496 0
 1907 013a 2B07     		lsls	r3, r5, #28
 1908 013c 5AD5     		bpl	.L207
 497:state.c       ****       /* transform lla_i -> lla_f -> utm_f -> enu, set status bits */
 498:state.c       ****       LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_i);
 1909              		.loc 1 498 0
 1910 013e D4ED047A 		flds	s15, [r4, #16]	@ int
 1911 0142 F8EEE77A 		fsitos	s15, s15
 499:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1912              		.loc 1 499 0
 1913 0146 45F48075 		orr	r5, r5, #256
 498:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1914              		.loc 1 498 0
 1915 014a 17EE900A 		fmrs	r0, s15
 1916 014e FFF7FEFF 		bl	__aeabi_f2d
 1917              	.LVL126:
 1918 0152 2BA3     		adr	r3, .L234
 1919 0154 D3E90023 		ldrd	r2, [r3]
 1920 0158 FFF7FEFF 		bl	__aeabi_dmul
 1921              	.LVL127:
 1922 015c 2AA3     		adr	r3, .L234+8
 1923 015e D3E90023 		ldrd	r2, [r3]
 1924 0162 FFF7FEFF 		bl	__aeabi_ddiv
 1925              	.LVL128:
 1926 0166 FFF7FEFF 		bl	__aeabi_d2f
 1927              	.LVL129:
 1928 016a D4ED057A 		flds	s15, [r4, #20]	@ int
 1929 016e C4F88C00 		str	r0, [r4, #140]	@ float
 1930 0172 F8EEE77A 		fsitos	s15, s15
 1931 0176 17EE900A 		fmrs	r0, s15
 1932 017a FFF7FEFF 		bl	__aeabi_f2d
 1933              	.LVL130:
 1934 017e 20A3     		adr	r3, .L234
 1935 0180 D3E90023 		ldrd	r2, [r3]
 1936 0184 FFF7FEFF 		bl	__aeabi_dmul
 1937              	.LVL131:
 1938 0188 1FA3     		adr	r3, .L234+8
 1939 018a D3E90023 		ldrd	r2, [r3]
 1940 018e FFF7FEFF 		bl	__aeabi_ddiv
 1941              	.LVL132:
 1942 0192 FFF7FEFF 		bl	__aeabi_d2f
 1943              	.LVL133:
 1944 0196 D4ED067A 		flds	s15, [r4, #24]	@ int
 1945 019a 9FED1F7A 		flds	s14, .L234+24
 1946 019e C4F89000 		str	r0, [r4, #144]	@ float
 1947 01a2 F8EEE77A 		fsitos	s15, s15
 1948              		.loc 1 499 0
 1949 01a6 2046     		mov	r0, r4
 498:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1950              		.loc 1 498 0
 1951 01a8 C7EE877A 		fdivs	s15, s15, s14
 1952              		.loc 1 499 0
 1953 01ac 20F8785B 		strh	r5, [r0], #120	@ movhi
 498:state.c       ****       SetBit(state.pos_status, POS_LLA_F);
 1954              		.loc 1 498 0
 1955 01b0 C4ED257A 		fsts	s15, [r4, #148]
 1956              	.L228:
 500:state.c       ****       utm_of_lla_f(&state.utm_pos_f, &state.lla_pos_f);
 1957              		.loc 1 500 0
 1958 01b4 04F18C01 		add	r1, r4, #140
 1959 01b8 FFF7FEFF 		bl	utm_of_lla_f
 1960              	.LVL134:
 501:state.c       ****       SetBit(state.pos_status, POS_UTM_F);
 1961              		.loc 1 501 0
 1962 01bc 2388     		ldrh	r3, [r4]
 1963 01be 43F40073 		orr	r3, r3, #512
 1964 01c2 2380     		strh	r3, [r4]	@ movhi
 1965              	.L229:
 502:state.c       ****       ENU_OF_UTM_DIFF(state.enu_pos_f, state.utm_pos_f, state.utm_origin_f);
 1966              		.loc 1 502 0
 1967 01c4 94ED3B7A 		flds	s14, [r4, #236]
 1968 01c8 D4ED1F7A 		flds	s15, [r4, #124]
 1969 01cc 77EEC77A 		fsubs	s15, s15, s14
 1970 01d0 94ED3A7A 		flds	s14, [r4, #232]
 1971 01d4 C4ED427A 		fsts	s15, [r4, #264]
 1972 01d8 D4ED1E7A 		flds	s15, [r4, #120]
 1973 01dc 77EEC77A 		fsubs	s15, s15, s14
 1974 01e0 94ED3C7A 		flds	s14, [r4, #240]
 1975 01e4 C4ED437A 		fsts	s15, [r4, #268]
 1976 01e8 D4ED207A 		flds	s15, [r4, #128]
 1977 01ec 77EEC77A 		fsubs	s15, s15, s14
 1978              	.L227:
 1979 01f0 C4ED447A 		fsts	s15, [r4, #272]
 1980              	.L207:
 503:state.c       ****     } else { /* could not get this representation,  set errno */
 504:state.c       ****       errno = 2;
 505:state.c       ****     }
 506:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 507:state.c       ****     errno = 3;
 508:state.c       ****   }
 509:state.c       ****   if (errno) {
 510:state.c       ****     //struct EnuCoor_f _enu_zero = {0.0f};
 511:state.c       ****     //return _enu_zero;
 512:state.c       ****   }
 513:state.c       ****   /* set bit to indicate this representation is computed */
 514:state.c       ****   SetBit(state.pos_status, POS_ENU_F);
 1981              		.loc 1 514 0
 1982 01f4 2388     		ldrh	r3, [r4]
 1983 01f6 43F08003 		orr	r3, r3, #128
 1984 01fa 2380     		strh	r3, [r4]	@ movhi
 1985              	.LVL135:
 1986              	.L203:
 1987 01fc 38BD     		pop	{r3, r4, r5, pc}
 1988              	.L235:
 1989 01fe 00BF     		.align	3
 1990              	.L234:
 1991 0200 399D52A2 		.word	-1571644103
 1992 0204 46DF913F 		.word	1066524486
 1993 0208 00000000 		.word	0
 1994 020c D0126341 		.word	1097011920
 1995 0210 00000000 		.word	.LANCHOR0
 1996 0214 0000803B 		.word	998244352
 1997 0218 00007A44 		.word	1148846080
 1998              		.cfi_endproc
 1999              	.LFE147:
 2001              		.section	.text.stateCalcPositionLla_f,"ax",%progbits
 2002              		.align	1
 2003              		.global	stateCalcPositionLla_f
 2004              		.thumb
 2005              		.thumb_func
 2007              	stateCalcPositionLla_f:
 2008              	.LFB148:
 515:state.c       **** }
 516:state.c       **** 
 517:state.c       **** void stateCalcPositionLla_f(void)
 518:state.c       **** {
 2009              		.loc 1 518 0
 2010              		.cfi_startproc
 2011              		@ args = 0, pretend = 0, frame = 0
 2012              		@ frame_needed = 0, uses_anonymous_args = 0
 2013 0000 70B5     		push	{r4, r5, r6, lr}
 2014              		.cfi_def_cfa_offset 16
 2015              		.cfi_offset 4, -16
 2016              		.cfi_offset 5, -12
 2017              		.cfi_offset 6, -8
 2018              		.cfi_offset 14, -4
 519:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_F)) {
 2019              		.loc 1 519 0
 2020 0002 614C     		ldr	r4, .L261+16
 2021 0004 2588     		ldrh	r5, [r4]
 2022 0006 EA05     		lsls	r2, r5, #23
 2023 0008 00F1B480 		bmi	.L236
 520:state.c       ****     return;
 521:state.c       ****   }
 522:state.c       **** 
 523:state.c       ****   if (bit_is_set(state.pos_status, POS_LLA_I)) {
 2024              		.loc 1 523 0
 2025 000c 2B07     		lsls	r3, r5, #28
 2026 000e 2CD5     		bpl	.L238
 524:state.c       ****     LLA_FLOAT_OF_BFP(state.lla_pos_f, state.lla_pos_f);
 2027              		.loc 1 524 0
 2028 0010 D4F88C00 		ldr	r0, [r4, #140]	@ float
 2029 0014 FFF7FEFF 		bl	__aeabi_f2d
 2030              	.LVL136:
 2031 0018 57A3     		adr	r3, .L261
 2032 001a D3E90023 		ldrd	r2, [r3]
 2033 001e FFF7FEFF 		bl	__aeabi_dmul
 2034              	.LVL137:
 2035 0022 57A3     		adr	r3, .L261+8
 2036 0024 D3E90023 		ldrd	r2, [r3]
 2037 0028 FFF7FEFF 		bl	__aeabi_ddiv
 2038              	.LVL138:
 2039 002c FFF7FEFF 		bl	__aeabi_d2f
 2040              	.LVL139:
 2041 0030 C4F88C00 		str	r0, [r4, #140]	@ float
 2042 0034 D4F89000 		ldr	r0, [r4, #144]	@ float
 2043 0038 FFF7FEFF 		bl	__aeabi_f2d
 2044              	.LVL140:
 2045 003c 4EA3     		adr	r3, .L261
 2046 003e D3E90023 		ldrd	r2, [r3]
 2047 0042 FFF7FEFF 		bl	__aeabi_dmul
 2048              	.LVL141:
 2049 0046 4EA3     		adr	r3, .L261+8
 2050 0048 D3E90023 		ldrd	r2, [r3]
 2051 004c FFF7FEFF 		bl	__aeabi_ddiv
 2052              	.LVL142:
 2053 0050 FFF7FEFF 		bl	__aeabi_d2f
 2054              	.LVL143:
 2055 0054 D4ED257A 		flds	s15, [r4, #148]
 2056 0058 9FED4C7A 		flds	s14, .L261+20
 2057 005c C4F89000 		str	r0, [r4, #144]	@ float
 2058 0060 C7EE877A 		fdivs	s15, s15, s14
 2059 0064 C4ED257A 		fsts	s15, [r4, #148]
 2060 0068 80E0     		b	.L239
 2061              	.L238:
 525:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_F)) {
 2062              		.loc 1 525 0
 2063 006a AE06     		lsls	r6, r5, #26
 2064 006c 02D5     		bpl	.L240
 526:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2065              		.loc 1 526 0
 2066 006e 04F18C00 		add	r0, r4, #140
 2067 0072 27E0     		b	.L259
 2068              	.L240:
 527:state.c       ****   } else if (bit_is_set(state.pos_status, POS_ECEF_I)) {
 2069              		.loc 1 527 0
 2070 0074 E807     		lsls	r0, r5, #31
 2071 0076 2AD5     		bpl	.L241
 528:state.c       ****     /* transform ecef_i -> ecef_f -> lla_f, set status bits */
 529:state.c       ****     ECEF_FLOAT_OF_BFP(state.ecef_pos_f, state.ecef_pos_i);
 2072              		.loc 1 529 0
 2073 0078 6068     		ldr	r0, [r4, #4]
 2074 007a FFF7FEFF 		bl	__aeabi_i2d
 2075              	.LVL144:
 2076 007e 0022     		movs	r2, #0
 2077 0080 434B     		ldr	r3, .L261+24
 2078 0082 FFF7FEFF 		bl	__aeabi_ddiv
 2079              	.LVL145:
 2080 0086 FFF7FEFF 		bl	__aeabi_d2f
 2081              	.LVL146:
 2082 008a C4F89800 		str	r0, [r4, #152]	@ float
 2083 008e A068     		ldr	r0, [r4, #8]
 2084 0090 FFF7FEFF 		bl	__aeabi_i2d
 2085              	.LVL147:
 2086 0094 0022     		movs	r2, #0
 2087 0096 3E4B     		ldr	r3, .L261+24
 2088 0098 FFF7FEFF 		bl	__aeabi_ddiv
 2089              	.LVL148:
 2090 009c FFF7FEFF 		bl	__aeabi_d2f
 2091              	.LVL149:
 2092 00a0 C4F89C00 		str	r0, [r4, #156]	@ float
 2093 00a4 E068     		ldr	r0, [r4, #12]
 2094 00a6 FFF7FEFF 		bl	__aeabi_i2d
 2095              	.LVL150:
 2096 00aa 0022     		movs	r2, #0
 2097 00ac 384B     		ldr	r3, .L261+24
 2098 00ae FFF7FEFF 		bl	__aeabi_ddiv
 2099              	.LVL151:
 2100 00b2 FFF7FEFF 		bl	__aeabi_d2f
 2101              	.LVL152:
 2102 00b6 C4F8A000 		str	r0, [r4, #160]	@ float
 530:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2103              		.loc 1 530 0
 2104 00ba 2046     		mov	r0, r4
 2105 00bc 45F02005 		orr	r5, r5, #32
 2106 00c0 20F88C5B 		strh	r5, [r0], #140	@ movhi
 2107              	.L259:
 531:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2108              		.loc 1 531 0
 2109 00c4 04F19801 		add	r1, r4, #152
 2110              	.L260:
 2111 00c8 FFF7FEFF 		bl	lla_of_ecef_f
 2112              	.LVL153:
 2113 00cc 4EE0     		b	.L239
 2114              	.L241:
 532:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_F) && state.ned_initialized_f) {
 2115              		.loc 1 532 0
 2116 00ce 6906     		lsls	r1, r5, #25
 2117 00d0 11D5     		bpl	.L242
 2118              		.loc 1 532 0 is_stmt 0 discriminator 1
 2119 00d2 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 2120 00d6 73B1     		cbz	r3, .L242
 533:state.c       ****     /* transform ned_f -> ecef_f -> lla_f, set status bits */
 534:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 2121              		.loc 1 534 0 is_stmt 1
 2122 00d8 04F19800 		add	r0, r4, #152
 2123 00dc 04F1A401 		add	r1, r4, #164
 2124 00e0 04F1FC02 		add	r2, r4, #252
 2125 00e4 FFF7FEFF 		bl	ecef_of_ned_point_f
 2126              	.LVL154:
 535:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2127              		.loc 1 535 0
 2128 00e8 2388     		ldrh	r3, [r4]
 2129 00ea 2046     		mov	r0, r4
 2130 00ec 43F02003 		orr	r3, r3, #32
 2131 00f0 20F88C3B 		strh	r3, [r0], #140	@ movhi
 2132 00f4 E6E7     		b	.L259
 2133              	.L242:
 536:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 537:state.c       ****   } else if (bit_is_set(state.pos_status, POS_NED_I) && state.ned_initialized_f) {
 2134              		.loc 1 537 0
 2135 00f6 AA07     		lsls	r2, r5, #30
 2136 00f8 31D5     		bpl	.L243
 2137              		.loc 1 537 0 is_stmt 0 discriminator 1
 2138 00fa 94F8E430 		ldrb	r3, [r4, #228]	@ zero_extendqisi2
 2139 00fe 224E     		ldr	r6, .L261+16
 2140 0100 6BB3     		cbz	r3, .L243
 538:state.c       ****     /* transform ned_i -> ned_f -> ecef_f -> lla_f, set status bits */
 539:state.c       ****     NED_FLOAT_OF_BFP(state.ned_pos_f, state.ned_pos_i);
 2141              		.loc 1 539 0 is_stmt 1
 2142 0102 D6ED187A 		flds	s15, [r6, #96]	@ int
 2143 0106 DFED236A 		flds	s13, .L261+28
 2144 010a B8EEE77A 		fsitos	s14, s15
 2145 010e D6ED197A 		flds	s15, [r6, #100]	@ int
 2146 0112 27EE267A 		fmuls	s14, s14, s13
 540:state.c       ****     SetBit(state.pos_status, POS_NED_F);
 2147              		.loc 1 540 0
 2148 0116 3046     		mov	r0, r6
 539:state.c       ****     SetBit(state.pos_status, POS_NED_F);
 2149              		.loc 1 539 0
 2150 0118 86ED3F7A 		fsts	s14, [r6, #252]
 2151 011c B8EEE77A 		fsitos	s14, s15
 2152 0120 D6ED1A7A 		flds	s15, [r6, #104]	@ int
 2153 0124 F8EEE77A 		fsitos	s15, s15
 2154 0128 27EE267A 		fmuls	s14, s14, s13
 2155 012c 67EEA67A 		fmuls	s15, s15, s13
 2156              		.loc 1 540 0
 2157 0130 45F04005 		orr	r5, r5, #64
 2158 0134 20F8985B 		strh	r5, [r0], #152	@ movhi
 541:state.c       ****     ecef_of_ned_point_f(&state.ecef_pos_f, &state.ned_origin_f, &state.ned_pos_f);
 2159              		.loc 1 541 0
 2160 0138 06F1A401 		add	r1, r6, #164
 2161 013c 06F1FC02 		add	r2, r6, #252
 539:state.c       ****     SetBit(state.pos_status, POS_NED_F);
 2162              		.loc 1 539 0
 2163 0140 86ED407A 		fsts	s14, [r6, #256]
 2164 0144 C6ED417A 		fsts	s15, [r6, #260]
 2165              		.loc 1 541 0
 2166 0148 FFF7FEFF 		bl	ecef_of_ned_point_f
 2167              	.LVL155:
 542:state.c       ****     SetBit(state.pos_status, POS_ECEF_F);
 2168              		.loc 1 542 0
 2169 014c 3388     		ldrh	r3, [r6]
 2170 014e 3046     		mov	r0, r6
 2171 0150 43F02003 		orr	r3, r3, #32
 2172 0154 20F88C3B 		strh	r3, [r0], #140	@ movhi
 543:state.c       ****     lla_of_ecef_f(&state.lla_pos_f, &state.ecef_pos_f);
 2173              		.loc 1 543 0
 2174 0158 06F19801 		add	r1, r6, #152
 2175 015c B4E7     		b	.L260
 2176              	.L243:
 544:state.c       ****   } else if (bit_is_set(state.pos_status, POS_UTM_F)) {
 2177              		.loc 1 544 0
 2178 015e AB05     		lsls	r3, r5, #22
 2179 0160 04D5     		bpl	.L239
 545:state.c       ****     lla_of_utm_f(&state.lla_pos_f, &state.utm_pos_f);
 2180              		.loc 1 545 0
 2181 0162 0D48     		ldr	r0, .L261+32
 2182 0164 A0F11401 		sub	r1, r0, #20
 2183 0168 FFF7FEFF 		bl	lla_of_utm_f
 2184              	.LVL156:
 2185              	.L239:
 546:state.c       ****   } else {
 547:state.c       ****     /* could not get this representation,  set errno */
 548:state.c       ****     //struct LlaCoor_f _lla_zero = {0.0};
 549:state.c       ****     //return _lla_zero;
 550:state.c       ****   }
 551:state.c       ****   /* set bit to indicate this representation is computed */
 552:state.c       ****   SetBit(state.pos_status, POS_LLA_F);
 2186              		.loc 1 552 0
 2187 016c 2388     		ldrh	r3, [r4]
 2188 016e 43F48073 		orr	r3, r3, #256
 2189 0172 2380     		strh	r3, [r4]	@ movhi
 2190              	.L236:
 2191 0174 70BD     		pop	{r4, r5, r6, pc}
 2192              	.L262:
 2193 0176 00BF     		.align	3
 2194              	.L261:
 2195 0178 399D52A2 		.word	-1571644103
 2196 017c 46DF913F 		.word	1066524486
 2197 0180 00000000 		.word	0
 2198 0184 D0126341 		.word	1097011920
 2199 0188 00000000 		.word	.LANCHOR0
 2200 018c 00007A44 		.word	1148846080
 2201 0190 00005940 		.word	1079574528
 2202 0194 0000803B 		.word	998244352
 2203 0198 8C000000 		.word	.LANCHOR0+140
 2204              		.cfi_endproc
 2205              	.LFE148:
 2207              		.section	.text.stateCalcSpeedNed_i,"ax",%progbits
 2208              		.align	1
 2209              		.global	stateCalcSpeedNed_i
 2210              		.thumb
 2211              		.thumb_func
 2213              	stateCalcSpeedNed_i:
 2214              	.LFB149:
 553:state.c       **** }
 554:state.c       **** /** @}*/
 555:state.c       **** 
 556:state.c       **** 
 557:state.c       **** 
 558:state.c       **** 
 559:state.c       **** 
 560:state.c       **** /******************************************************************************
 561:state.c       ****  *                                                                            *
 562:state.c       ****  * Transformation functions for the SPEED representations                     *
 563:state.c       ****  *                                                                            *
 564:state.c       ****  *****************************************************************************/
 565:state.c       **** /** @addtogroup state_velocity
 566:state.c       ****  *  @{ */
 567:state.c       **** /************************ Set functions ****************************/
 568:state.c       **** 
 569:state.c       **** void stateCalcSpeedNed_i(void)
 570:state.c       **** {
 2215              		.loc 1 570 0
 2216              		.cfi_startproc
 2217              		@ args = 0, pretend = 0, frame = 0
 2218              		@ frame_needed = 0, uses_anonymous_args = 0
 2219 0000 10B5     		push	{r4, lr}
 2220              		.cfi_def_cfa_offset 8
 2221              		.cfi_offset 4, -8
 2222              		.cfi_offset 14, -4
 571:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2223              		.loc 1 571 0
 2224 0002 504C     		ldr	r4, .L285
 2225 0004 B4F81431 		ldrh	r3, [r4, #276]
 2226 0008 9807     		lsls	r0, r3, #30
 2227 000a 00F19980 		bmi	.L263
 2228              	.LVL157:
 572:state.c       ****     return;
 573:state.c       ****   }
 574:state.c       **** 
 575:state.c       ****   int errno = 0;
 576:state.c       ****   if (state.ned_initialized_i) {
 2229              		.loc 1 576 0
 2230 000e 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 2231 0012 002A     		cmp	r2, #0
 2232 0014 3ED0     		beq	.L265
 577:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2233              		.loc 1 577 0
 2234 0016 5906     		lsls	r1, r3, #25
 2235 0018 42D4     		bmi	.L282
 578:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 579:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2236              		.loc 1 579 0
 2237 001a 5A07     		lsls	r2, r3, #29
 2238 001c 0DD5     		bpl	.L268
 2239              	.L272:
 580:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2240              		.loc 1 580 0
 2241 001e D4F83431 		ldr	r3, [r4, #308]
 2242 0022 C4F82431 		str	r3, [r4, #292]
 2243 0026 D4F83031 		ldr	r3, [r4, #304]
 2244 002a C4F82831 		str	r3, [r4, #296]
 2245 002e D4F83831 		ldr	r3, [r4, #312]
 2246 0032 5B42     		negs	r3, r3
 2247 0034 C4F82C31 		str	r3, [r4, #300]
 2248 0038 7CE0     		b	.L267
 2249              	.L268:
 581:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2250              		.loc 1 581 0
 2251 003a 1806     		lsls	r0, r3, #24
 2252 003c 4FD4     		bmi	.L283
 582:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 583:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 584:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 585:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2253              		.loc 1 585 0
 2254 003e D907     		lsls	r1, r3, #31
 2255 0040 1FD4     		bmi	.L284
 586:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 587:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2256              		.loc 1 587 0
 2257 0042 9A06     		lsls	r2, r3, #26
 2258 0044 76D5     		bpl	.L267
 588:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
 589:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2259              		.loc 1 589 0
 2260 0046 DFED406A 		flds	s13, .L285+4
 2261 004a 94ED517A 		flds	s14, [r4, #324]
 2262 004e D4ED537A 		flds	s15, [r4, #332]
 2263 0052 27EE267A 		fmuls	s14, s14, s13
 2264 0056 67EEA67A 		fmuls	s15, s15, s13
 2265 005a BDEEC77A 		ftosizs	s14, s14
 2266 005e FDEEE77A 		ftosizs	s15, s15
 2267 0062 84ED467A 		fsts	s14, [r4, #280]	@ int
 2268 0066 94ED527A 		flds	s14, [r4, #328]
 2269 006a C4ED487A 		fsts	s15, [r4, #288]	@ int
 2270 006e 27EE267A 		fmuls	s14, s14, s13
 590:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2271              		.loc 1 590 0
 2272 0072 43F00103 		orr	r3, r3, #1
 589:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2273              		.loc 1 589 0
 2274 0076 BDEEC77A 		ftosizs	s14, s14
 2275              		.loc 1 590 0
 2276 007a A4F81431 		strh	r3, [r4, #276]	@ movhi
 589:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2277              		.loc 1 589 0
 2278 007e 84ED477A 		fsts	s14, [r4, #284]	@ int
 2279              	.L284:
 591:state.c       ****       ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2280              		.loc 1 591 0
 2281 0082 04F59270 		add	r0, r4, #292
 2282 0086 04F11C01 		add	r1, r4, #28
 2283 008a 04F58C72 		add	r2, r4, #280
 2284 008e FFF7FEFF 		bl	ned_of_ecef_vect_i
 2285              	.LVL158:
 2286 0092 4FE0     		b	.L267
 2287              	.L265:
 592:state.c       ****     } else { /* could not get this representation,  set errno */
 593:state.c       ****       errno = 1;
 594:state.c       ****     }
 595:state.c       ****   } else if (state.utm_initialized_f) {
 2288              		.loc 1 595 0
 2289 0094 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 2290 0098 002A     		cmp	r2, #0
 2291 009a 4BD0     		beq	.L267
 596:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2292              		.loc 1 596 0
 2293 009c 5806     		lsls	r0, r3, #25
 2294 009e 1AD5     		bpl	.L271
 2295              	.L282:
 597:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2296              		.loc 1 597 0
 2297 00a0 DFED296A 		flds	s13, .L285+4
 2298 00a4 94ED547A 		flds	s14, [r4, #336]
 2299 00a8 D4ED567A 		flds	s15, [r4, #344]
 2300 00ac 27EE267A 		fmuls	s14, s14, s13
 2301 00b0 67EEA67A 		fmuls	s15, s15, s13
 2302 00b4 BDEEC77A 		ftosizs	s14, s14
 2303 00b8 FDEEE77A 		ftosizs	s15, s15
 2304 00bc 84ED497A 		fsts	s14, [r4, #292]	@ int
 2305 00c0 94ED557A 		flds	s14, [r4, #340]
 2306 00c4 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2307 00c8 27EE267A 		fmuls	s14, s14, s13
 2308 00cc BDEEC77A 		ftosizs	s14, s14
 2309 00d0 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2310 00d4 2EE0     		b	.L267
 2311              	.L271:
 598:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2312              		.loc 1 598 0
 2313 00d6 5907     		lsls	r1, r3, #29
 2314 00d8 A1D4     		bmi	.L272
 599:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 600:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2315              		.loc 1 600 0
 2316 00da 1A06     		lsls	r2, r3, #24
 2317 00dc 2AD5     		bpl	.L267
 2318              	.L283:
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2319              		.loc 1 601 0
 2320 00de DFED1A6A 		flds	s13, .L285+4
 2321 00e2 94ED577A 		flds	s14, [r4, #348]
 2322 00e6 27EE267A 		fmuls	s14, s14, s13
 602:state.c       ****       SetBit(state.speed_status, SPEED_ENU_I);
 2323              		.loc 1 602 0
 2324 00ea 43F00403 		orr	r3, r3, #4
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2325              		.loc 1 601 0
 2326 00ee FDEEC77A 		ftosizs	s15, s14
 2327 00f2 94ED587A 		flds	s14, [r4, #352]
 2328 00f6 C4ED4C7A 		fsts	s15, [r4, #304]	@ int
 2329 00fa 27EE267A 		fmuls	s14, s14, s13
 2330 00fe 17EE901A 		fmrs	r1, s15	@ int
 2331 0102 FDEEC77A 		ftosizs	s15, s14
 2332              		.loc 1 602 0
 2333 0106 A4F81431 		strh	r3, [r4, #276]	@ movhi
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2334              		.loc 1 601 0
 2335 010a 17EE900A 		fmrs	r0, s15	@ int
 2336 010e C4ED4D7A 		fsts	s15, [r4, #308]	@ int
 2337 0112 D4ED597A 		flds	s15, [r4, #356]
 603:state.c       ****       INT32_VECT3_NED_OF_ENU(state.ned_speed_i, state.enu_speed_i);
 2338              		.loc 1 603 0
 2339 0116 C4F82401 		str	r0, [r4, #292]
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2340              		.loc 1 601 0
 2341 011a 67EEA67A 		fmuls	s15, s15, s13
 2342              		.loc 1 603 0
 2343 011e C4F82811 		str	r1, [r4, #296]
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2344              		.loc 1 601 0
 2345 0122 FDEEE77A 		ftosizs	s15, s15
 2346 0126 17EE902A 		fmrs	r2, s15	@ int
 2347              		.loc 1 603 0
 2348 012a 5242     		negs	r2, r2
 601:state.c       ****       SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2349              		.loc 1 601 0
 2350 012c C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 2351              		.loc 1 603 0
 2352 0130 C4F82C21 		str	r2, [r4, #300]
 2353              	.L267:
 604:state.c       ****     } else { /* could not get this representation,  set errno */
 605:state.c       ****       errno = 2;
 606:state.c       ****     }
 607:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 608:state.c       ****     errno = 3;
 609:state.c       ****   }
 610:state.c       ****   if (errno) {
 611:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 612:state.c       ****     //return _ned_zero;
 613:state.c       ****   }
 614:state.c       ****   /* set bit to indicate this representation is computed */
 615:state.c       ****   SetBit(state.speed_status, SPEED_NED_I);
 2354              		.loc 1 615 0
 2355 0134 B4F81431 		ldrh	r3, [r4, #276]
 2356 0138 43F00203 		orr	r3, r3, #2
 2357 013c A4F81431 		strh	r3, [r4, #276]	@ movhi
 2358              	.LVL159:
 2359              	.L263:
 2360 0140 10BD     		pop	{r4, pc}
 2361              	.L286:
 2362 0142 00BF     		.align	2
 2363              	.L285:
 2364 0144 00000000 		.word	.LANCHOR0
 2365 0148 00000049 		.word	1224736768
 2366              		.cfi_endproc
 2367              	.LFE149:
 2369              		.section	.text.stateCalcSpeedEnu_i,"ax",%progbits
 2370              		.align	1
 2371              		.global	stateCalcSpeedEnu_i
 2372              		.thumb
 2373              		.thumb_func
 2375              	stateCalcSpeedEnu_i:
 2376              	.LFB150:
 616:state.c       **** }
 617:state.c       **** 
 618:state.c       **** void stateCalcSpeedEnu_i(void)
 619:state.c       **** {
 2377              		.loc 1 619 0
 2378              		.cfi_startproc
 2379              		@ args = 0, pretend = 0, frame = 0
 2380              		@ frame_needed = 0, uses_anonymous_args = 0
 2381 0000 10B5     		push	{r4, lr}
 2382              		.cfi_def_cfa_offset 8
 2383              		.cfi_offset 4, -8
 2384              		.cfi_offset 14, -4
 620:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2385              		.loc 1 620 0
 2386 0002 564C     		ldr	r4, .L314
 2387 0004 B4F81431 		ldrh	r3, [r4, #276]
 2388 0008 5907     		lsls	r1, r3, #29
 2389 000a 00F1A580 		bmi	.L287
 2390              	.LVL160:
 621:state.c       ****     return;
 622:state.c       ****   }
 623:state.c       **** 
 624:state.c       ****   int errno = 0;
 625:state.c       ****   if (state.ned_initialized_i) {
 2391              		.loc 1 625 0
 2392 000e 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 2393 0012 002A     		cmp	r2, #0
 2394 0014 3DD0     		beq	.L289
 626:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2395              		.loc 1 626 0
 2396 0016 9A07     		lsls	r2, r3, #30
 2397 0018 0CD5     		bpl	.L290
 627:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2398              		.loc 1 627 0
 2399 001a D4F82821 		ldr	r2, [r4, #296]
 2400 001e C4F83021 		str	r2, [r4, #304]
 2401 0022 D4F82421 		ldr	r2, [r4, #292]
 2402 0026 C4F83421 		str	r2, [r4, #308]
 2403 002a D4F82C21 		ldr	r2, [r4, #300]
 2404 002e 5242     		negs	r2, r2
 2405 0030 C4F83821 		str	r2, [r4, #312]
 2406              	.L290:
 628:state.c       ****     }
 629:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2407              		.loc 1 629 0
 2408 0034 1806     		lsls	r0, r3, #24
 2409 0036 41D4     		bmi	.L311
 630:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 631:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2410              		.loc 1 631 0
 2411 0038 5906     		lsls	r1, r3, #25
 2412 003a 5CD4     		bmi	.L312
 632:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 633:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 634:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 635:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2413              		.loc 1 635 0
 2414 003c DA07     		lsls	r2, r3, #31
 2415 003e 20D4     		bmi	.L313
 636:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 637:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2416              		.loc 1 637 0
 2417 0040 9806     		lsls	r0, r3, #26
 2418 0042 40F18380 		bpl	.L292
 638:state.c       ****       /* transform ecef_f -> ecef_i -> enu_i , set status bits */
 639:state.c       ****       SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2419              		.loc 1 639 0
 2420 0046 DFED466A 		flds	s13, .L314+4
 2421 004a 94ED517A 		flds	s14, [r4, #324]
 2422 004e D4ED537A 		flds	s15, [r4, #332]
 2423 0052 27EE267A 		fmuls	s14, s14, s13
 2424 0056 67EEA67A 		fmuls	s15, s15, s13
 2425 005a BDEEC77A 		ftosizs	s14, s14
 2426 005e FDEEE77A 		ftosizs	s15, s15
 2427 0062 84ED467A 		fsts	s14, [r4, #280]	@ int
 2428 0066 94ED527A 		flds	s14, [r4, #328]
 2429 006a C4ED487A 		fsts	s15, [r4, #288]	@ int
 2430 006e 27EE267A 		fmuls	s14, s14, s13
 640:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2431              		.loc 1 640 0
 2432 0072 43F00103 		orr	r3, r3, #1
 639:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2433              		.loc 1 639 0
 2434 0076 BDEEC77A 		ftosizs	s14, s14
 2435              		.loc 1 640 0
 2436 007a A4F81431 		strh	r3, [r4, #276]	@ movhi
 639:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_I);
 2437              		.loc 1 639 0
 2438 007e 84ED477A 		fsts	s14, [r4, #284]	@ int
 2439              	.L313:
 641:state.c       ****       enu_of_ecef_vect_i(&state.enu_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2440              		.loc 1 641 0
 2441 0082 3848     		ldr	r0, .L314+8
 2442 0084 A0F58A71 		sub	r1, r0, #276
 2443 0088 A0F11802 		sub	r2, r0, #24
 2444 008c FFF7FEFF 		bl	enu_of_ecef_vect_i
 2445              	.LVL161:
 2446 0090 5CE0     		b	.L292
 2447              	.L289:
 642:state.c       ****     } else { /* could not get this representation,  set errno */
 643:state.c       ****       errno = 1;
 644:state.c       ****     }
 645:state.c       ****   } else if (state.utm_initialized_f) {
 2448              		.loc 1 645 0
 2449 0092 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 2450 0096 002A     		cmp	r2, #0
 2451 0098 58D0     		beq	.L292
 646:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2452              		.loc 1 646 0
 2453 009a 9907     		lsls	r1, r3, #30
 2454 009c 0CD5     		bpl	.L297
 647:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2455              		.loc 1 647 0
 2456 009e D4F82821 		ldr	r2, [r4, #296]
 2457 00a2 C4F83021 		str	r2, [r4, #304]
 2458 00a6 D4F82421 		ldr	r2, [r4, #292]
 2459 00aa C4F83421 		str	r2, [r4, #308]
 2460 00ae D4F82C21 		ldr	r2, [r4, #300]
 2461 00b2 5242     		negs	r2, r2
 2462 00b4 C4F83821 		str	r2, [r4, #312]
 2463              	.L297:
 648:state.c       ****     }
 649:state.c       ****     if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2464              		.loc 1 649 0
 2465 00b8 1A06     		lsls	r2, r3, #24
 2466 00ba 1AD5     		bpl	.L298
 2467              	.L311:
 650:state.c       ****       ENU_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2468              		.loc 1 650 0
 2469 00bc DFED2A6A 		flds	s13, .L314+12
 2470 00c0 94ED577A 		flds	s14, [r4, #348]
 2471 00c4 D4ED597A 		flds	s15, [r4, #356]
 2472 00c8 27EE267A 		fmuls	s14, s14, s13
 2473 00cc 67EEA67A 		fmuls	s15, s15, s13
 2474 00d0 BDEEC77A 		ftosizs	s14, s14
 2475 00d4 FDEEE77A 		ftosizs	s15, s15
 2476 00d8 84ED4C7A 		fsts	s14, [r4, #304]	@ int
 2477 00dc 94ED587A 		flds	s14, [r4, #352]
 2478 00e0 C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 2479 00e4 27EE267A 		fmuls	s14, s14, s13
 2480 00e8 BDEEC77A 		ftosizs	s14, s14
 2481 00ec 84ED4D7A 		fsts	s14, [r4, #308]	@ int
 2482 00f0 2CE0     		b	.L292
 2483              	.L298:
 651:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2484              		.loc 1 651 0
 2485 00f2 5B06     		lsls	r3, r3, #25
 2486 00f4 2AD5     		bpl	.L292
 2487              	.L312:
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2488              		.loc 1 652 0
 2489 00f6 DFED1A6A 		flds	s13, .L314+4
 2490 00fa 94ED547A 		flds	s14, [r4, #336]
 653:state.c       ****       SetBit(state.pos_status, SPEED_NED_I);
 2491              		.loc 1 653 0
 2492 00fe 2088     		ldrh	r0, [r4]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2493              		.loc 1 652 0
 2494 0100 27EE267A 		fmuls	s14, s14, s13
 2495              		.loc 1 653 0
 2496 0104 40F00200 		orr	r0, r0, #2
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2497              		.loc 1 652 0
 2498 0108 FDEEC77A 		ftosizs	s15, s14
 2499 010c 94ED557A 		flds	s14, [r4, #340]
 2500 0110 C4ED497A 		fsts	s15, [r4, #292]	@ int
 2501 0114 27EE267A 		fmuls	s14, s14, s13
 2502 0118 17EE902A 		fmrs	r2, s15	@ int
 2503 011c FDEEC77A 		ftosizs	s15, s14
 2504              		.loc 1 653 0
 2505 0120 2080     		strh	r0, [r4]	@ movhi
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2506              		.loc 1 652 0
 2507 0122 17EE901A 		fmrs	r1, s15	@ int
 2508 0126 C4ED4A7A 		fsts	s15, [r4, #296]	@ int
 2509 012a D4ED567A 		flds	s15, [r4, #344]
 654:state.c       ****       INT32_VECT3_ENU_OF_NED(state.enu_speed_i, state.ned_speed_i);
 2510              		.loc 1 654 0
 2511 012e C4F83011 		str	r1, [r4, #304]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2512              		.loc 1 652 0
 2513 0132 67EEA67A 		fmuls	s15, s15, s13
 2514              		.loc 1 654 0
 2515 0136 C4F83421 		str	r2, [r4, #308]
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2516              		.loc 1 652 0
 2517 013a FDEEE77A 		ftosizs	s15, s15
 2518 013e 17EE903A 		fmrs	r3, s15	@ int
 2519              		.loc 1 654 0
 2520 0142 5B42     		negs	r3, r3
 652:state.c       ****       SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2521              		.loc 1 652 0
 2522 0144 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2523              		.loc 1 654 0
 2524 0148 C4F83831 		str	r3, [r4, #312]
 2525              	.L292:
 655:state.c       ****     } else { /* could not get this representation,  set errno */
 656:state.c       ****       errno = 2;
 657:state.c       ****     }
 658:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 659:state.c       ****     errno = 3;
 660:state.c       ****   }
 661:state.c       ****   if (errno) {
 662:state.c       ****     //struct EnuCoor_i _enu_zero = {0};
 663:state.c       ****     //return _enu_zero;
 664:state.c       ****   }
 665:state.c       ****   /* set bit to indicate this representation is computed */
 666:state.c       ****   SetBit(state.speed_status, SPEED_ENU_I);
 2526              		.loc 1 666 0
 2527 014c B4F81431 		ldrh	r3, [r4, #276]
 2528 0150 43F00403 		orr	r3, r3, #4
 2529 0154 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2530              	.LVL162:
 2531              	.L287:
 2532 0158 10BD     		pop	{r4, pc}
 2533              	.L315:
 2534 015a 00BF     		.align	2
 2535              	.L314:
 2536 015c 00000000 		.word	.LANCHOR0
 2537 0160 00000049 		.word	1224736768
 2538 0164 30010000 		.word	.LANCHOR0+304
 2539 0168 00008043 		.word	1132462080
 2540              		.cfi_endproc
 2541              	.LFE150:
 2543              		.section	.text.stateCalcSpeedEcef_i,"ax",%progbits
 2544              		.align	1
 2545              		.global	stateCalcSpeedEcef_i
 2546              		.thumb
 2547              		.thumb_func
 2549              	stateCalcSpeedEcef_i:
 2550              	.LFB151:
 667:state.c       **** }
 668:state.c       **** 
 669:state.c       **** void stateCalcSpeedEcef_i(void)
 670:state.c       **** {
 2551              		.loc 1 670 0
 2552              		.cfi_startproc
 2553              		@ args = 0, pretend = 0, frame = 0
 2554              		@ frame_needed = 0, uses_anonymous_args = 0
 2555 0000 10B5     		push	{r4, lr}
 2556              		.cfi_def_cfa_offset 8
 2557              		.cfi_offset 4, -8
 2558              		.cfi_offset 14, -4
 671:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2559              		.loc 1 671 0
 2560 0002 294C     		ldr	r4, .L325
 2561 0004 B4F81431 		ldrh	r3, [r4, #276]
 2562 0008 DA07     		lsls	r2, r3, #31
 2563 000a 4CD4     		bmi	.L316
 672:state.c       ****     return;
 673:state.c       ****   }
 674:state.c       **** 
 675:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2564              		.loc 1 675 0
 2565 000c 9806     		lsls	r0, r3, #26
 2566 000e 1AD5     		bpl	.L318
 676:state.c       ****     SPEEDS_BFP_OF_REAL(state.ecef_speed_i, state.ecef_speed_f);
 2567              		.loc 1 676 0
 2568 0010 DFED266A 		flds	s13, .L325+4
 2569 0014 94ED517A 		flds	s14, [r4, #324]
 2570 0018 D4ED537A 		flds	s15, [r4, #332]
 2571 001c 27EE267A 		fmuls	s14, s14, s13
 2572 0020 67EEA67A 		fmuls	s15, s15, s13
 2573 0024 BDEEC77A 		ftosizs	s14, s14
 2574 0028 FDEEE77A 		ftosizs	s15, s15
 2575 002c 84ED467A 		fsts	s14, [r4, #280]	@ int
 2576 0030 94ED527A 		flds	s14, [r4, #328]
 2577 0034 C4ED487A 		fsts	s15, [r4, #288]	@ int
 2578 0038 27EE267A 		fmuls	s14, s14, s13
 2579 003c BDEEC77A 		ftosizs	s14, s14
 2580 0040 84ED477A 		fsts	s14, [r4, #284]	@ int
 2581 0044 29E0     		b	.L319
 2582              	.L318:
 677:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2583              		.loc 1 677 0
 2584 0046 9907     		lsls	r1, r3, #30
 2585 0048 1FD4     		bmi	.L324
 678:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 679:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2586              		.loc 1 679 0
 2587 004a 5A06     		lsls	r2, r3, #25
 2588 004c 25D5     		bpl	.L319
 680:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 681:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2589              		.loc 1 681 0
 2590 004e DFED176A 		flds	s13, .L325+4
 2591 0052 94ED547A 		flds	s14, [r4, #336]
 2592 0056 D4ED567A 		flds	s15, [r4, #344]
 2593 005a 27EE267A 		fmuls	s14, s14, s13
 2594 005e 67EEA67A 		fmuls	s15, s15, s13
 2595 0062 BDEEC77A 		ftosizs	s14, s14
 2596 0066 FDEEE77A 		ftosizs	s15, s15
 2597 006a 84ED497A 		fsts	s14, [r4, #292]	@ int
 2598 006e 94ED557A 		flds	s14, [r4, #340]
 2599 0072 C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 2600 0076 27EE267A 		fmuls	s14, s14, s13
 682:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2601              		.loc 1 682 0
 2602 007a 43F00203 		orr	r3, r3, #2
 681:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2603              		.loc 1 681 0
 2604 007e BDEEC77A 		ftosizs	s14, s14
 2605              		.loc 1 682 0
 2606 0082 A4F81431 		strh	r3, [r4, #276]	@ movhi
 681:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2607              		.loc 1 681 0
 2608 0086 84ED4A7A 		fsts	s14, [r4, #296]	@ int
 2609              	.L324:
 683:state.c       ****     ecef_of_ned_vect_i(&state.ecef_speed_i, &state.ned_origin_i, &state.ned_speed_i);
 2610              		.loc 1 683 0
 2611 008a 04F58C70 		add	r0, r4, #280
 2612 008e 04F11C01 		add	r1, r4, #28
 2613 0092 04F59272 		add	r2, r4, #292
 2614 0096 FFF7FEFF 		bl	ecef_of_ned_vect_i
 2615              	.LVL163:
 2616              	.L319:
 684:state.c       ****   } else {
 685:state.c       ****     /* could not get this representation,  set errno */
 686:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
 687:state.c       ****     //return _ecef_zero;
 688:state.c       ****   }
 689:state.c       ****   /* set bit to indicate this representation is computed */
 690:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_I);
 2617              		.loc 1 690 0
 2618 009a B4F81431 		ldrh	r3, [r4, #276]
 2619 009e 43F00103 		orr	r3, r3, #1
 2620 00a2 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2621              	.L316:
 2622 00a6 10BD     		pop	{r4, pc}
 2623              	.L326:
 2624              		.align	2
 2625              	.L325:
 2626 00a8 00000000 		.word	.LANCHOR0
 2627 00ac 00000049 		.word	1224736768
 2628              		.cfi_endproc
 2629              	.LFE151:
 2631              		.section	.text.stateCalcHorizontalSpeedNorm_i,"ax",%progbits
 2632              		.align	1
 2633              		.global	stateCalcHorizontalSpeedNorm_i
 2634              		.thumb
 2635              		.thumb_func
 2637              	stateCalcHorizontalSpeedNorm_i:
 2638              	.LFB152:
 691:state.c       **** }
 692:state.c       **** 
 693:state.c       **** void stateCalcHorizontalSpeedNorm_i(void)
 694:state.c       **** {
 2639              		.loc 1 694 0
 2640              		.cfi_startproc
 2641              		@ args = 0, pretend = 0, frame = 0
 2642              		@ frame_needed = 0, uses_anonymous_args = 0
 2643 0000 10B5     		push	{r4, lr}
 2644              		.cfi_def_cfa_offset 8
 2645              		.cfi_offset 4, -8
 2646              		.cfi_offset 14, -4
 695:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I)) {
 2647              		.loc 1 695 0
 2648 0002 374C     		ldr	r4, .L344
 2649 0004 B4F81431 		ldrh	r3, [r4, #276]
 2650 0008 1A07     		lsls	r2, r3, #28
 2651 000a 67D4     		bmi	.L327
 696:state.c       ****     return;
 697:state.c       ****   }
 698:state.c       **** 
 699:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F)) {
 2652              		.loc 1 699 0
 2653 000c D805     		lsls	r0, r3, #23
 2654 000e 02D5     		bpl	.L329
 700:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2655              		.loc 1 700 0
 2656 0010 D4ED5A7A 		flds	s15, [r4, #360]
 2657 0014 54E0     		b	.L339
 2658              	.L329:
 701:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2659              		.loc 1 701 0
 2660 0016 9907     		lsls	r1, r3, #30
 2661 0018 1FD4     		bmi	.L340
 702:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 703:state.c       ****                    state.ned_speed_i.y * state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 704:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 705:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2662              		.loc 1 705 0
 2663 001a 5A06     		lsls	r2, r3, #25
 2664 001c 3AD4     		bmi	.L341
 706:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 707:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 708:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 709:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2665              		.loc 1 709 0
 2666 001e 5807     		lsls	r0, r3, #29
 2667 0020 04D5     		bpl	.L333
 2668              	.LBB2:
 710:state.c       ****     uint32_t n2 = (state.enu_speed_i.x * state.enu_speed_i.x +
 2669              		.loc 1 710 0
 2670 0022 D4F83001 		ldr	r0, [r4, #304]
 711:state.c       ****                    state.enu_speed_i.y * state.enu_speed_i.y) >> INT32_SPEED_FRAC;
 2671              		.loc 1 711 0
 2672 0026 D4F83431 		ldr	r3, [r4, #308]
 2673              	.LVL164:
 2674 002a 1AE0     		b	.L343
 2675              	.LVL165:
 2676              	.L333:
 2677              	.LBE2:
 712:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 713:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2678              		.loc 1 713 0
 2679 002c 1906     		lsls	r1, r3, #24
 2680 002e 04D5     		bpl	.L334
 714:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 2681              		.loc 1 714 0
 2682 0030 94ED577A 		flds	s14, [r4, #348]
 2683 0034 D4ED587A 		flds	s15, [r4, #352]
 2684 0038 30E0     		b	.L342
 2685              	.L334:
 715:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 716:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 717:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 2686              		.loc 1 717 0
 2687 003a DA07     		lsls	r2, r3, #31
 2688 003c 1AD5     		bpl	.L335
 2689              	.LBB3:
 718:state.c       ****     /* transform ecef speed to ned, set status bit, then compute norm */
 719:state.c       ****     ned_of_ecef_vect_i(&state.ned_speed_i, &state.ned_origin_i, &state.ecef_speed_i);
 2690              		.loc 1 719 0
 2691 003e 04F59270 		add	r0, r4, #292
 2692 0042 04F11C01 		add	r1, r4, #28
 2693 0046 04F58C72 		add	r2, r4, #280
 2694 004a FFF7FEFF 		bl	ned_of_ecef_vect_i
 2695              	.LVL166:
 720:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2696              		.loc 1 720 0
 2697 004e B4F81431 		ldrh	r3, [r4, #276]
 2698 0052 43F00203 		orr	r3, r3, #2
 2699 0056 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2700              	.L340:
 721:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 2701              		.loc 1 721 0
 2702 005a D4F82401 		ldr	r0, [r4, #292]
 722:state.c       ****                    state.ned_speed_i.y * state.ned_speed_i.y) >> INT32_SPEED_FRAC;
 2703              		.loc 1 722 0
 2704 005e D4F82831 		ldr	r3, [r4, #296]
 2705              	.L343:
 2706              	.LVL167:
 2707 0062 5B43     		muls	r3, r3, r3
 2708              	.LVL168:
 721:state.c       ****     uint32_t n2 = (state.ned_speed_i.x * state.ned_speed_i.x +
 2709              		.loc 1 721 0
 2710 0064 00FB0030 		mla	r0, r0, r0, r3
 723:state.c       ****     INT32_SQRT(state.h_speed_norm_i, n2);
 2711              		.loc 1 723 0
 2712 0068 C014     		asrs	r0, r0, #19
 2713              	.LVL169:
 2714 006a FFF7FEFF 		bl	int32_sqrt
 2715              	.LVL170:
 2716 006e C4F83C01 		str	r0, [r4, #316]
 2717              	.LBE3:
 2718 0072 2DE0     		b	.L330
 2719              	.L335:
 724:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 2720              		.loc 1 724 0
 2721 0074 9B06     		lsls	r3, r3, #26
 2722 0076 2BD5     		bpl	.L330
 725:state.c       ****     ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 2723              		.loc 1 725 0
 2724 0078 04F5A870 		add	r0, r4, #336
 2725 007c 04F1A401 		add	r1, r4, #164
 2726 0080 04F5A272 		add	r2, r4, #324
 2727 0084 FFF7FEFF 		bl	ned_of_ecef_vect_f
 2728              	.LVL171:
 726:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 2729              		.loc 1 726 0
 2730 0088 B4F81431 		ldrh	r3, [r4, #276]
 2731 008c 43F04003 		orr	r3, r3, #64
 2732 0090 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2733              	.L341:
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2734              		.loc 1 727 0
 2735 0094 94ED547A 		flds	s14, [r4, #336]
 2736 0098 D4ED557A 		flds	s15, [r4, #340]
 2737              	.L342:
 2738 009c 67EEA77A 		fmuls	s15, s15, s15
 2739 00a0 E7EE077A 		vfma.f32	s15, s14, s14
 2740 00a4 17EE900A 		fmrs	r0, s15
 2741 00a8 FFF7FEFF 		bl	sqrtf
 2742              	.LVL172:
 728:state.c       ****     SetBit(state.speed_status, SPEED_HNORM_F);
 2743              		.loc 1 728 0
 2744 00ac B4F81431 		ldrh	r3, [r4, #276]
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2745              		.loc 1 727 0
 2746 00b0 C4F86801 		str	r0, [r4, #360]	@ float
 2747              		.loc 1 728 0
 2748 00b4 43F48073 		orr	r3, r3, #256
 727:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 2749              		.loc 1 727 0
 2750 00b8 07EE900A 		fmsr	s15, r0
 2751              		.loc 1 728 0
 2752 00bc A4F81431 		strh	r3, [r4, #276]	@ movhi
 2753              	.L339:
 729:state.c       ****     state.h_speed_norm_i = SPEED_BFP_OF_REAL(state.h_speed_norm_f);
 2754              		.loc 1 729 0
 2755 00c0 9FED087A 		flds	s14, .L344+4
 2756 00c4 67EE877A 		fmuls	s15, s15, s14
 2757 00c8 FCEEE77A 		ftouizs	s15, s15
 2758 00cc C4ED4F7A 		fsts	s15, [r4, #316]	@ int
 2759              	.L330:
 730:state.c       ****   } else {
 731:state.c       ****     //int32_t _norm_zero = 0;
 732:state.c       ****     //return _norm_zero;
 733:state.c       ****   }
 734:state.c       ****   /* set bit to indicate this representation is computed */
 735:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_I);
 2760              		.loc 1 735 0
 2761 00d0 B4F81431 		ldrh	r3, [r4, #276]
 2762 00d4 43F00803 		orr	r3, r3, #8
 2763 00d8 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2764              	.L327:
 2765 00dc 10BD     		pop	{r4, pc}
 2766              	.L345:
 2767 00de 00BF     		.align	2
 2768              	.L344:
 2769 00e0 00000000 		.word	.LANCHOR0
 2770 00e4 00000049 		.word	1224736768
 2771              		.cfi_endproc
 2772              	.LFE152:
 2774              		.section	.text.stateCalcHorizontalSpeedDir_i,"ax",%progbits
 2775              		.align	1
 2776              		.global	stateCalcHorizontalSpeedDir_i
 2777              		.thumb
 2778              		.thumb_func
 2780              	stateCalcHorizontalSpeedDir_i:
 2781              	.LFB153:
 736:state.c       **** }
 737:state.c       **** 
 738:state.c       **** void stateCalcHorizontalSpeedDir_i(void)
 739:state.c       **** {
 2782              		.loc 1 739 0
 2783              		.cfi_startproc
 2784              		@ args = 0, pretend = 0, frame = 0
 2785              		@ frame_needed = 0, uses_anonymous_args = 0
 2786 0000 10B5     		push	{r4, lr}
 2787              		.cfi_def_cfa_offset 8
 2788              		.cfi_offset 4, -8
 2789              		.cfi_offset 14, -4
 740:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I)) {
 2790              		.loc 1 740 0
 2791 0002 564C     		ldr	r4, .L374
 2792 0004 B4F81431 		ldrh	r3, [r4, #276]
 2793 0008 D806     		lsls	r0, r3, #27
 2794 000a 00F1A680 		bmi	.L346
 741:state.c       ****     return;
 742:state.c       ****   }
 743:state.c       **** 
 744:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F)) {
 2795              		.loc 1 744 0
 2796 000e 9905     		lsls	r1, r3, #22
 2797 0010 06D5     		bpl	.L348
 745:state.c       ****     state.h_speed_dir_i = SPEED_BFP_OF_REAL(state.h_speed_dir_f);
 2798              		.loc 1 745 0
 2799 0012 D4ED5B7A 		flds	s15, [r4, #364]
 2800 0016 FEEEE67A 		vcvt.s32.f32	s15, s15, #19
 2801 001a C4ED507A 		fsts	s15, [r4, #320]	@ int
 2802 001e 96E0     		b	.L349
 2803              	.L348:
 746:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2804              		.loc 1 746 0
 2805 0020 9A07     		lsls	r2, r3, #30
 2806 0022 14D5     		bpl	.L350
 747:state.c       ****     state.h_speed_dir_i = int32_atan2(state.ned_speed_i.y, state.ned_speed_i.x);
 2807              		.loc 1 747 0
 2808 0024 D4F82801 		ldr	r0, [r4, #296]
 2809 0028 D4F82411 		ldr	r1, [r4, #292]
 2810 002c FFF7FEFF 		bl	int32_atan2
 2811              	.LVL173:
 2812              	.L351:
 748:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2813              		.loc 1 748 0 discriminator 1
 2814 0030 0028     		cmp	r0, #0
 2815 0032 03DA     		bge	.L353
 2816              		.loc 1 748 0 is_stmt 0 discriminator 2
 2817 0034 00F5C940 		add	r0, r0, #25728
 2818 0038 0730     		adds	r0, r0, #7
 2819 003a F9E7     		b	.L351
 2820              	.L353:
 2821              		.loc 1 748 0 discriminator 3
 2822 003c 46F28643 		movw	r3, #25734
 2823 0040 9842     		cmp	r0, r3
 2824 0042 40F38280 		ble	.L373
 2825              		.loc 1 748 0 discriminator 4
 2826 0046 A0F5C940 		sub	r0, r0, #25728
 2827 004a 0738     		subs	r0, r0, #7
 2828 004c F6E7     		b	.L353
 2829              	.L350:
 749:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 2830              		.loc 1 749 0 is_stmt 1
 2831 004e 5807     		lsls	r0, r3, #29
 2832 0050 13D5     		bpl	.L355
 750:state.c       ****     state.h_speed_dir_i = int32_atan2(state.enu_speed_i.x, state.enu_speed_i.y);
 2833              		.loc 1 750 0
 2834 0052 D4F83001 		ldr	r0, [r4, #304]
 2835 0056 D4F83411 		ldr	r1, [r4, #308]
 2836 005a FFF7FEFF 		bl	int32_atan2
 2837              	.LVL174:
 2838              	.L356:
 751:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2839              		.loc 1 751 0 discriminator 1
 2840 005e 0028     		cmp	r0, #0
 2841 0060 03DA     		bge	.L358
 2842              		.loc 1 751 0 is_stmt 0 discriminator 2
 2843 0062 00F5C940 		add	r0, r0, #25728
 2844 0066 0730     		adds	r0, r0, #7
 2845 0068 F9E7     		b	.L356
 2846              	.L358:
 2847              		.loc 1 751 0 discriminator 3
 2848 006a 46F28643 		movw	r3, #25734
 2849 006e 9842     		cmp	r0, r3
 2850 0070 6BDD     		ble	.L373
 2851              		.loc 1 751 0 discriminator 4
 2852 0072 A0F5C940 		sub	r0, r0, #25728
 2853 0076 0738     		subs	r0, r0, #7
 2854 0078 F7E7     		b	.L358
 2855              	.L355:
 752:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2856              		.loc 1 752 0 is_stmt 1
 2857 007a 5906     		lsls	r1, r3, #25
 2858 007c 31D5     		bpl	.L361
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2859              		.loc 1 753 0
 2860 007e 9FED387A 		flds	s14, .L374+4
 2861 0082 D4ED547A 		flds	s15, [r4, #336]
 2862 0086 67EE877A 		fmuls	s15, s15, s14
 754:state.c       ****     SetBit(state.speed_status, SPEED_NED_I);
 2863              		.loc 1 754 0
 2864 008a 43F00203 		orr	r3, r3, #2
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2865              		.loc 1 753 0
 2866 008e FDEEE77A 		ftosizs	s15, s15
 2867              		.loc 1 754 0
 2868 0092 A4F81431 		strh	r3, [r4, #276]	@ movhi
 753:state.c       ****     SPEEDS_BFP_OF_REAL(state.ned_speed_i, state.ned_speed_f);
 2869              		.loc 1 753 0
 2870 0096 17EE901A 		fmrs	r1, s15	@ int
 2871 009a C4ED497A 		fsts	s15, [r4, #292]	@ int
 2872 009e D4ED557A 		flds	s15, [r4, #340]
 2873 00a2 67EE877A 		fmuls	s15, s15, s14
 2874 00a6 FDEEE77A 		ftosizs	s15, s15
 2875 00aa 17EE900A 		fmrs	r0, s15	@ int
 2876 00ae C4ED4A7A 		fsts	s15, [r4, #296]	@ int
 2877 00b2 D4ED567A 		flds	s15, [r4, #344]
 2878 00b6 67EE877A 		fmuls	s15, s15, s14
 2879 00ba FDEEE77A 		ftosizs	s15, s15
 2880 00be C4ED4B7A 		fsts	s15, [r4, #300]	@ int
 755:state.c       ****     state.h_speed_dir_i = int32_atan2(state.ned_speed_i.y, state.ned_speed_i.x);
 2881              		.loc 1 755 0
 2882 00c2 FFF7FEFF 		bl	int32_atan2
 2883              	.LVL175:
 2884              	.L362:
 756:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2885              		.loc 1 756 0 discriminator 1
 2886 00c6 0028     		cmp	r0, #0
 2887 00c8 03DA     		bge	.L364
 2888              		.loc 1 756 0 is_stmt 0 discriminator 2
 2889 00ca 00F5C940 		add	r0, r0, #25728
 2890 00ce 0730     		adds	r0, r0, #7
 2891 00d0 F9E7     		b	.L362
 2892              	.L364:
 2893              		.loc 1 756 0 discriminator 3
 2894 00d2 46F28643 		movw	r3, #25734
 2895 00d6 9842     		cmp	r0, r3
 2896 00d8 37DD     		ble	.L373
 2897              		.loc 1 756 0 discriminator 4
 2898 00da A0F5C940 		sub	r0, r0, #25728
 2899 00de 0738     		subs	r0, r0, #7
 2900 00e0 F7E7     		b	.L364
 2901              	.L361:
 757:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2902              		.loc 1 757 0 is_stmt 1
 2903 00e2 1A06     		lsls	r2, r3, #24
 2904 00e4 33D5     		bpl	.L349
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2905              		.loc 1 758 0
 2906 00e6 9FED1E7A 		flds	s14, .L374+4
 2907 00ea D4ED577A 		flds	s15, [r4, #348]
 2908 00ee 67EE877A 		fmuls	s15, s15, s14
 759:state.c       ****     SetBit(state.speed_status, SPEED_ENU_I);
 2909              		.loc 1 759 0
 2910 00f2 43F00403 		orr	r3, r3, #4
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2911              		.loc 1 758 0
 2912 00f6 FDEEE77A 		ftosizs	s15, s15
 2913              		.loc 1 759 0
 2914 00fa A4F81431 		strh	r3, [r4, #276]	@ movhi
 758:state.c       ****     SPEEDS_BFP_OF_REAL(state.enu_speed_i, state.enu_speed_f);
 2915              		.loc 1 758 0
 2916 00fe 17EE900A 		fmrs	r0, s15	@ int
 2917 0102 C4ED4C7A 		fsts	s15, [r4, #304]	@ int
 2918 0106 D4ED587A 		flds	s15, [r4, #352]
 2919 010a 67EE877A 		fmuls	s15, s15, s14
 2920 010e FDEEE77A 		ftosizs	s15, s15
 2921 0112 17EE901A 		fmrs	r1, s15	@ int
 2922 0116 C4ED4D7A 		fsts	s15, [r4, #308]	@ int
 2923 011a D4ED597A 		flds	s15, [r4, #356]
 2924 011e 67EE877A 		fmuls	s15, s15, s14
 2925 0122 FDEEE77A 		ftosizs	s15, s15
 2926 0126 C4ED4E7A 		fsts	s15, [r4, #312]	@ int
 760:state.c       ****     state.h_speed_dir_i = int32_atan2(state.enu_speed_i.x, state.enu_speed_i.y);
 2927              		.loc 1 760 0
 2928 012a FFF7FEFF 		bl	int32_atan2
 2929              	.LVL176:
 2930              	.L366:
 761:state.c       ****     INT32_COURSE_NORMALIZE(state.h_speed_dir_i);
 2931              		.loc 1 761 0 discriminator 1
 2932 012e 0028     		cmp	r0, #0
 2933 0130 03DA     		bge	.L368
 2934              		.loc 1 761 0 is_stmt 0 discriminator 2
 2935 0132 00F5C940 		add	r0, r0, #25728
 2936 0136 0730     		adds	r0, r0, #7
 2937 0138 F9E7     		b	.L366
 2938              	.L368:
 2939              		.loc 1 761 0 discriminator 3
 2940 013a 46F28643 		movw	r3, #25734
 2941 013e 9842     		cmp	r0, r3
 2942 0140 03DD     		ble	.L373
 2943              		.loc 1 761 0 discriminator 4
 2944 0142 A0F5C940 		sub	r0, r0, #25728
 2945 0146 0738     		subs	r0, r0, #7
 2946 0148 F7E7     		b	.L368
 2947              	.L373:
 2948 014a C4F84001 		str	r0, [r4, #320]
 2949              	.L349:
 762:state.c       ****   }
 763:state.c       ****   /* set bit to indicate this representation is computed */
 764:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_I);
 2950              		.loc 1 764 0 is_stmt 1
 2951 014e B4F81431 		ldrh	r3, [r4, #276]
 2952 0152 43F01003 		orr	r3, r3, #16
 2953 0156 A4F81431 		strh	r3, [r4, #276]	@ movhi
 2954              	.L346:
 2955 015a 10BD     		pop	{r4, pc}
 2956              	.L375:
 2957              		.align	2
 2958              	.L374:
 2959 015c 00000000 		.word	.LANCHOR0
 2960 0160 00000049 		.word	1224736768
 2961              		.cfi_endproc
 2962              	.LFE153:
 2964              		.section	.text.stateCalcSpeedNed_f,"ax",%progbits
 2965              		.align	1
 2966              		.global	stateCalcSpeedNed_f
 2967              		.thumb
 2968              		.thumb_func
 2970              	stateCalcSpeedNed_f:
 2971              	.LFB154:
 765:state.c       **** }
 766:state.c       **** 
 767:state.c       **** void stateCalcSpeedNed_f(void)
 768:state.c       **** {
 2972              		.loc 1 768 0
 2973              		.cfi_startproc
 2974              		@ args = 0, pretend = 0, frame = 0
 2975              		@ frame_needed = 0, uses_anonymous_args = 0
 2976 0000 10B5     		push	{r4, lr}
 2977              		.cfi_def_cfa_offset 8
 2978              		.cfi_offset 4, -8
 2979              		.cfi_offset 14, -4
 769:state.c       ****   if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 2980              		.loc 1 769 0
 2981 0002 4B4C     		ldr	r4, .L400
 2982 0004 B4F81431 		ldrh	r3, [r4, #276]
 2983 0008 5806     		lsls	r0, r3, #25
 2984 000a 00F18F80 		bmi	.L376
 2985              	.LVL177:
 770:state.c       ****     return;
 771:state.c       ****   }
 772:state.c       **** 
 773:state.c       ****   int errno = 0;
 774:state.c       ****   if (state.ned_initialized_f) {
 2986              		.loc 1 774 0
 2987 000e 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 2988 0012 002A     		cmp	r2, #0
 2989 0014 3BD0     		beq	.L378
 775:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 2990              		.loc 1 775 0
 2991 0016 9907     		lsls	r1, r3, #30
 2992 0018 3FD4     		bmi	.L399
 776:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 777:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 2993              		.loc 1 777 0
 2994 001a 1A06     		lsls	r2, r3, #24
 2995 001c 0AD5     		bpl	.L381
 2996              	.L385:
 778:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 2997              		.loc 1 778 0
 2998 001e D4F86031 		ldr	r3, [r4, #352]	@ float
 2999 0022 C4F85031 		str	r3, [r4, #336]	@ float
 3000 0026 D4F85C31 		ldr	r3, [r4, #348]	@ float
 3001 002a C4F85431 		str	r3, [r4, #340]	@ float
 3002 002e D4ED597A 		flds	s15, [r4, #356]
 3003 0032 71E0     		b	.L396
 3004              	.L381:
 779:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3005              		.loc 1 779 0
 3006 0034 5807     		lsls	r0, r3, #29
 3007 0036 4DD4     		bmi	.L398
 780:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 781:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 782:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 783:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3008              		.loc 1 783 0
 3009 0038 9906     		lsls	r1, r3, #26
 3010 003a 1FD4     		bmi	.L397
 784:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 785:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3011              		.loc 1 785 0
 3012 003c DA07     		lsls	r2, r3, #31
 3013 003e 6FD5     		bpl	.L380
 786:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
 787:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3014              		.loc 1 787 0
 3015 0040 D4ED467A 		flds	s15, [r4, #280]	@ int
 3016 0044 DFED3B6A 		flds	s13, .L400+4
 3017 0048 B8EEE77A 		fsitos	s14, s15
 3018 004c D4ED477A 		flds	s15, [r4, #284]	@ int
 3019 0050 27EE267A 		fmuls	s14, s14, s13
 788:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3020              		.loc 1 788 0
 3021 0054 43F02003 		orr	r3, r3, #32
 787:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3022              		.loc 1 787 0
 3023 0058 84ED517A 		fsts	s14, [r4, #324]
 3024 005c B8EEE77A 		fsitos	s14, s15
 3025 0060 D4ED487A 		flds	s15, [r4, #288]	@ int
 3026              		.loc 1 788 0
 3027 0064 A4F81431 		strh	r3, [r4, #276]	@ movhi
 787:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3028              		.loc 1 787 0
 3029 0068 F8EEE77A 		fsitos	s15, s15
 3030 006c 27EE267A 		fmuls	s14, s14, s13
 3031 0070 67EEA67A 		fmuls	s15, s15, s13
 3032 0074 84ED527A 		fsts	s14, [r4, #328]
 3033 0078 C4ED537A 		fsts	s15, [r4, #332]
 3034              	.L397:
 789:state.c       ****       ned_of_ecef_vect_f(&state.ned_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3035              		.loc 1 789 0
 3036 007c 04F5A870 		add	r0, r4, #336
 3037 0080 04F1A401 		add	r1, r4, #164
 3038 0084 04F5A272 		add	r2, r4, #324
 3039 0088 FFF7FEFF 		bl	ned_of_ecef_vect_f
 3040              	.LVL178:
 3041 008c 48E0     		b	.L380
 3042              	.L378:
 790:state.c       ****     } else { /* could not get this representation,  set errno */
 791:state.c       ****       errno = 1;
 792:state.c       ****     }
 793:state.c       ****   } else if (state.utm_initialized_f) {
 3043              		.loc 1 793 0
 3044 008e 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 3045 0092 002A     		cmp	r2, #0
 3046 0094 44D0     		beq	.L380
 794:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3047              		.loc 1 794 0
 3048 0096 9807     		lsls	r0, r3, #30
 3049 0098 18D5     		bpl	.L384
 3050              	.L399:
 795:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3051              		.loc 1 795 0
 3052 009a D4ED497A 		flds	s15, [r4, #292]	@ int
 3053 009e DFED256A 		flds	s13, .L400+4
 3054 00a2 B8EEE77A 		fsitos	s14, s15
 3055 00a6 D4ED4A7A 		flds	s15, [r4, #296]	@ int
 3056 00aa 27EE267A 		fmuls	s14, s14, s13
 3057 00ae 84ED547A 		fsts	s14, [r4, #336]
 3058 00b2 B8EEE77A 		fsitos	s14, s15
 3059 00b6 D4ED4B7A 		flds	s15, [r4, #300]	@ int
 3060 00ba 27EE267A 		fmuls	s14, s14, s13
 3061 00be F8EEE77A 		fsitos	s15, s15
 3062 00c2 84ED557A 		fsts	s14, [r4, #340]
 3063 00c6 67EEA67A 		fmuls	s15, s15, s13
 3064 00ca 27E0     		b	.L395
 3065              	.L384:
 796:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3066              		.loc 1 796 0
 3067 00cc 1906     		lsls	r1, r3, #24
 3068 00ce A6D4     		bmi	.L385
 797:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 798:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3069              		.loc 1 798 0
 3070 00d0 5A07     		lsls	r2, r3, #29
 3071 00d2 25D5     		bpl	.L380
 3072              	.L398:
 799:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3073              		.loc 1 799 0
 3074 00d4 D4ED4C7A 		flds	s15, [r4, #304]	@ int
 3075 00d8 9FED166A 		flds	s12, .L400+4
 3076 00dc B8EEE77A 		fsitos	s14, s15
 3077 00e0 D4ED4D7A 		flds	s15, [r4, #308]	@ int
 3078 00e4 F8EEE76A 		fsitos	s13, s15
 3079 00e8 D4ED4E7A 		flds	s15, [r4, #312]	@ int
 3080 00ec F8EEE77A 		fsitos	s15, s15
 3081 00f0 27EE067A 		fmuls	s14, s14, s12
 3082 00f4 66EE866A 		fmuls	s13, s13, s12
 3083 00f8 67EE867A 		fmuls	s15, s15, s12
 800:state.c       ****       SetBit(state.speed_status, SPEED_ENU_F);
 3084              		.loc 1 800 0
 3085 00fc 43F08003 		orr	r3, r3, #128
 799:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3086              		.loc 1 799 0
 3087 0100 84ED577A 		fsts	s14, [r4, #348]
 3088 0104 C4ED586A 		fsts	s13, [r4, #352]
 3089 0108 C4ED597A 		fsts	s15, [r4, #356]
 3090              		.loc 1 800 0
 3091 010c A4F81431 		strh	r3, [r4, #276]	@ movhi
 801:state.c       ****       VECT3_NED_OF_ENU(state.ned_speed_f, state.enu_speed_f);
 3092              		.loc 1 801 0
 3093 0110 C4ED546A 		fsts	s13, [r4, #336]
 3094 0114 84ED557A 		fsts	s14, [r4, #340]
 3095              	.L396:
 3096 0118 F1EE677A 		fnegs	s15, s15
 3097              	.L395:
 3098 011c C4ED567A 		fsts	s15, [r4, #344]
 3099              	.L380:
 802:state.c       ****     } else { /* could not get this representation,  set errno */
 803:state.c       ****       errno = 2;
 804:state.c       ****     }
 805:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 806:state.c       ****     errno = 3;
 807:state.c       ****   }
 808:state.c       ****   if (errno) {
 809:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
 810:state.c       ****     //return _ned_zero;
 811:state.c       ****   }
 812:state.c       ****   /* set bit to indicate this representation is computed */
 813:state.c       ****   SetBit(state.speed_status, SPEED_NED_F);
 3100              		.loc 1 813 0
 3101 0120 B4F81431 		ldrh	r3, [r4, #276]
 3102 0124 43F04003 		orr	r3, r3, #64
 3103 0128 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3104              	.LVL179:
 3105              	.L376:
 3106 012c 10BD     		pop	{r4, pc}
 3107              	.L401:
 3108 012e 00BF     		.align	2
 3109              	.L400:
 3110 0130 00000000 		.word	.LANCHOR0
 3111 0134 00000036 		.word	905969664
 3112              		.cfi_endproc
 3113              	.LFE154:
 3115              		.section	.text.stateCalcSpeedEnu_f,"ax",%progbits
 3116              		.align	1
 3117              		.global	stateCalcSpeedEnu_f
 3118              		.thumb
 3119              		.thumb_func
 3121              	stateCalcSpeedEnu_f:
 3122              	.LFB155:
 814:state.c       **** }
 815:state.c       **** 
 816:state.c       **** void stateCalcSpeedEnu_f(void)
 817:state.c       **** {
 3123              		.loc 1 817 0
 3124              		.cfi_startproc
 3125              		@ args = 0, pretend = 0, frame = 0
 3126              		@ frame_needed = 0, uses_anonymous_args = 0
 3127 0000 10B5     		push	{r4, lr}
 3128              		.cfi_def_cfa_offset 8
 3129              		.cfi_offset 4, -8
 3130              		.cfi_offset 14, -4
 818:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3131              		.loc 1 818 0
 3132 0002 4B4C     		ldr	r4, .L426
 3133 0004 B4F81431 		ldrh	r3, [r4, #276]
 3134 0008 1906     		lsls	r1, r3, #24
 3135 000a 00F18F80 		bmi	.L402
 3136              	.LVL180:
 819:state.c       ****     return;
 820:state.c       ****   }
 821:state.c       **** 
 822:state.c       ****   int errno = 0;
 823:state.c       ****   if (state.ned_initialized_f) {
 3137              		.loc 1 823 0
 3138 000e 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 3139 0012 002A     		cmp	r2, #0
 3140 0014 3BD0     		beq	.L404
 824:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3141              		.loc 1 824 0
 3142 0016 5A06     		lsls	r2, r3, #25
 3143 0018 0AD5     		bpl	.L405
 3144              	.L410:
 825:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3145              		.loc 1 825 0
 3146 001a D4F85431 		ldr	r3, [r4, #340]	@ float
 3147 001e C4F85C31 		str	r3, [r4, #348]	@ float
 3148 0022 D4F85031 		ldr	r3, [r4, #336]	@ float
 3149 0026 C4F86031 		str	r3, [r4, #352]	@ float
 3150 002a D4ED567A 		flds	s15, [r4, #344]
 3151 002e 73E0     		b	.L421
 3152              	.L405:
 826:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3153              		.loc 1 826 0
 3154 0030 5807     		lsls	r0, r3, #29
 3155 0032 34D4     		bmi	.L425
 827:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 828:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3156              		.loc 1 828 0
 3157 0034 9907     		lsls	r1, r3, #30
 3158 0036 4DD4     		bmi	.L424
 829:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 830:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 831:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 832:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3159              		.loc 1 832 0
 3160 0038 9A06     		lsls	r2, r3, #26
 3161 003a 1FD4     		bmi	.L423
 833:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 834:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3162              		.loc 1 834 0
 3163 003c D807     		lsls	r0, r3, #31
 3164 003e 6FD5     		bpl	.L406
 835:state.c       ****       /* transform ecef_I -> ecef_f -> enu_f , set status bits */
 836:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ecef_speed_i);
 3165              		.loc 1 836 0
 3166 0040 D4ED467A 		flds	s15, [r4, #280]	@ int
 3167 0044 DFED3B6A 		flds	s13, .L426+4
 3168 0048 B8EEE77A 		fsitos	s14, s15
 3169 004c D4ED477A 		flds	s15, [r4, #284]	@ int
 3170 0050 27EE267A 		fmuls	s14, s14, s13
 837:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3171              		.loc 1 837 0
 3172 0054 43F02003 		orr	r3, r3, #32
 836:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3173              		.loc 1 836 0
 3174 0058 84ED517A 		fsts	s14, [r4, #324]
 3175 005c B8EEE77A 		fsitos	s14, s15
 3176 0060 D4ED487A 		flds	s15, [r4, #288]	@ int
 3177              		.loc 1 837 0
 3178 0064 A4F81431 		strh	r3, [r4, #276]	@ movhi
 836:state.c       ****       SetBit(state.speed_status, SPEED_ECEF_F);
 3179              		.loc 1 836 0
 3180 0068 F8EEE77A 		fsitos	s15, s15
 3181 006c 27EE267A 		fmuls	s14, s14, s13
 3182 0070 67EEA67A 		fmuls	s15, s15, s13
 3183 0074 84ED527A 		fsts	s14, [r4, #328]
 3184 0078 C4ED537A 		fsts	s15, [r4, #332]
 3185              	.L423:
 838:state.c       ****       enu_of_ecef_vect_f(&state.enu_speed_f, &state.ned_origin_f, &state.ecef_speed_f);
 3186              		.loc 1 838 0
 3187 007c 04F5AE70 		add	r0, r4, #348
 3188 0080 04F1A401 		add	r1, r4, #164
 3189 0084 04F5A272 		add	r2, r4, #324
 3190 0088 FFF7FEFF 		bl	enu_of_ecef_vect_f
 3191              	.LVL181:
 3192 008c 48E0     		b	.L406
 3193              	.L404:
 839:state.c       ****     } else { /* could not get this representation,  set errno */
 840:state.c       ****       errno = 1;
 841:state.c       ****     }
 842:state.c       ****   } else if (state.utm_initialized_f) {
 3194              		.loc 1 842 0
 3195 008e 94F8F820 		ldrb	r2, [r4, #248]	@ zero_extendqisi2
 3196 0092 002A     		cmp	r2, #0
 3197 0094 44D0     		beq	.L406
 843:state.c       ****     if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3198              		.loc 1 843 0
 3199 0096 5906     		lsls	r1, r3, #25
 3200 0098 BFD4     		bmi	.L410
 844:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 845:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3201              		.loc 1 845 0
 3202 009a 5A07     		lsls	r2, r3, #29
 3203 009c 18D5     		bpl	.L411
 3204              	.L425:
 846:state.c       ****       ENU_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3205              		.loc 1 846 0
 3206 009e D4ED4C7A 		flds	s15, [r4, #304]	@ int
 3207 00a2 DFED256A 		flds	s13, .L426+8
 3208 00a6 B8EEE77A 		fsitos	s14, s15
 3209 00aa D4ED4D7A 		flds	s15, [r4, #308]	@ int
 3210 00ae 27EE267A 		fmuls	s14, s14, s13
 3211 00b2 84ED577A 		fsts	s14, [r4, #348]
 3212 00b6 B8EEE77A 		fsitos	s14, s15
 3213 00ba D4ED4E7A 		flds	s15, [r4, #312]	@ int
 3214 00be 27EE267A 		fmuls	s14, s14, s13
 3215 00c2 F8EEE77A 		fsitos	s15, s15
 3216 00c6 84ED587A 		fsts	s14, [r4, #352]
 3217 00ca 67EEA67A 		fmuls	s15, s15, s13
 3218 00ce 25E0     		b	.L422
 3219              	.L411:
 847:state.c       ****     } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3220              		.loc 1 847 0
 3221 00d0 9B07     		lsls	r3, r3, #30
 3222 00d2 25D5     		bpl	.L406
 3223              	.L424:
 848:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3224              		.loc 1 848 0
 3225 00d4 D4ED497A 		flds	s15, [r4, #292]	@ int
 3226 00d8 9FED166A 		flds	s12, .L426+4
 849:state.c       ****       SetBit(state.pos_status, SPEED_NED_F);
 3227              		.loc 1 849 0
 3228 00dc 2388     		ldrh	r3, [r4]
 848:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3229              		.loc 1 848 0
 3230 00de B8EEE77A 		fsitos	s14, s15
 3231 00e2 D4ED4A7A 		flds	s15, [r4, #296]	@ int
 3232 00e6 F8EEE76A 		fsitos	s13, s15
 3233 00ea D4ED4B7A 		flds	s15, [r4, #300]	@ int
 3234 00ee F8EEE77A 		fsitos	s15, s15
 3235 00f2 27EE067A 		fmuls	s14, s14, s12
 3236 00f6 66EE866A 		fmuls	s13, s13, s12
 3237 00fa 67EE867A 		fmuls	s15, s15, s12
 3238              		.loc 1 849 0
 3239 00fe 43F04003 		orr	r3, r3, #64
 848:state.c       ****       SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3240              		.loc 1 848 0
 3241 0102 84ED547A 		fsts	s14, [r4, #336]
 3242 0106 C4ED556A 		fsts	s13, [r4, #340]
 3243 010a C4ED567A 		fsts	s15, [r4, #344]
 3244              		.loc 1 849 0
 3245 010e 2380     		strh	r3, [r4]	@ movhi
 850:state.c       ****       VECT3_ENU_OF_NED(state.enu_speed_f, state.ned_speed_f);
 3246              		.loc 1 850 0
 3247 0110 C4ED576A 		fsts	s13, [r4, #348]
 3248 0114 84ED587A 		fsts	s14, [r4, #352]
 3249              	.L421:
 3250 0118 F1EE677A 		fnegs	s15, s15
 3251              	.L422:
 3252 011c C4ED597A 		fsts	s15, [r4, #356]
 3253              	.L406:
 851:state.c       ****     } else { /* could not get this representation,  set errno */
 852:state.c       ****       errno = 2;
 853:state.c       ****     }
 854:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 855:state.c       ****     errno = 3;
 856:state.c       ****   }
 857:state.c       ****   if (errno) {
 858:state.c       ****     //struct EnuCoor_f _enu_zero = {0};
 859:state.c       ****     //return _enu_zero;
 860:state.c       ****   }
 861:state.c       ****   /* set bit to indicate this representation is computed */
 862:state.c       ****   SetBit(state.speed_status, SPEED_ENU_F);
 3254              		.loc 1 862 0
 3255 0120 B4F81431 		ldrh	r3, [r4, #276]
 3256 0124 43F08003 		orr	r3, r3, #128
 3257 0128 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3258              	.LVL182:
 3259              	.L402:
 3260 012c 10BD     		pop	{r4, pc}
 3261              	.L427:
 3262 012e 00BF     		.align	2
 3263              	.L426:
 3264 0130 00000000 		.word	.LANCHOR0
 3265 0134 00000036 		.word	905969664
 3266 0138 0000803B 		.word	998244352
 3267              		.cfi_endproc
 3268              	.LFE155:
 3270              		.section	.text.stateCalcSpeedEcef_f,"ax",%progbits
 3271              		.align	1
 3272              		.global	stateCalcSpeedEcef_f
 3273              		.thumb
 3274              		.thumb_func
 3276              	stateCalcSpeedEcef_f:
 3277              	.LFB156:
 863:state.c       **** }
 864:state.c       **** 
 865:state.c       **** void stateCalcSpeedEcef_f(void)
 866:state.c       **** {
 3278              		.loc 1 866 0
 3279              		.cfi_startproc
 3280              		@ args = 0, pretend = 0, frame = 0
 3281              		@ frame_needed = 0, uses_anonymous_args = 0
 3282 0000 10B5     		push	{r4, lr}
 3283              		.cfi_def_cfa_offset 8
 3284              		.cfi_offset 4, -8
 3285              		.cfi_offset 14, -4
 867:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_F)) {
 3286              		.loc 1 867 0
 3287 0002 294C     		ldr	r4, .L437
 3288 0004 B4F81431 		ldrh	r3, [r4, #276]
 3289 0008 9A06     		lsls	r2, r3, #26
 3290 000a 4CD4     		bmi	.L428
 868:state.c       ****     return;
 869:state.c       ****   }
 870:state.c       **** 
 871:state.c       ****   if (bit_is_set(state.speed_status, SPEED_ECEF_I)) {
 3291              		.loc 1 871 0
 3292 000c D807     		lsls	r0, r3, #31
 3293 000e 1AD5     		bpl	.L430
 872:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ecef_speed_f, state.ned_speed_i);
 3294              		.loc 1 872 0
 3295 0010 D4ED497A 		flds	s15, [r4, #292]	@ int
 3296 0014 DFED256A 		flds	s13, .L437+4
 3297 0018 B8EEE77A 		fsitos	s14, s15
 3298 001c D4ED4A7A 		flds	s15, [r4, #296]	@ int
 3299 0020 27EE267A 		fmuls	s14, s14, s13
 3300 0024 84ED517A 		fsts	s14, [r4, #324]
 3301 0028 B8EEE77A 		fsitos	s14, s15
 3302 002c D4ED4B7A 		flds	s15, [r4, #300]	@ int
 3303 0030 F8EEE77A 		fsitos	s15, s15
 3304 0034 27EE267A 		fmuls	s14, s14, s13
 3305 0038 67EEA67A 		fmuls	s15, s15, s13
 3306 003c 84ED527A 		fsts	s14, [r4, #328]
 3307 0040 C4ED537A 		fsts	s15, [r4, #332]
 3308 0044 29E0     		b	.L431
 3309              	.L430:
 873:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3310              		.loc 1 873 0
 3311 0046 5906     		lsls	r1, r3, #25
 3312 0048 1FD4     		bmi	.L436
 874:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 875:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3313              		.loc 1 875 0
 3314 004a 9A07     		lsls	r2, r3, #30
 3315 004c 25D5     		bpl	.L431
 876:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 877:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3316              		.loc 1 877 0
 3317 004e D4ED497A 		flds	s15, [r4, #292]	@ int
 3318 0052 DFED166A 		flds	s13, .L437+4
 3319 0056 B8EEE77A 		fsitos	s14, s15
 3320 005a D4ED4A7A 		flds	s15, [r4, #296]	@ int
 3321 005e 27EE267A 		fmuls	s14, s14, s13
 878:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3322              		.loc 1 878 0
 3323 0062 43F04003 		orr	r3, r3, #64
 877:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3324              		.loc 1 877 0
 3325 0066 84ED547A 		fsts	s14, [r4, #336]
 3326 006a B8EEE77A 		fsitos	s14, s15
 3327 006e D4ED4B7A 		flds	s15, [r4, #300]	@ int
 3328              		.loc 1 878 0
 3329 0072 A4F81431 		strh	r3, [r4, #276]	@ movhi
 877:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3330              		.loc 1 877 0
 3331 0076 F8EEE77A 		fsitos	s15, s15
 3332 007a 27EE267A 		fmuls	s14, s14, s13
 3333 007e 67EEA67A 		fmuls	s15, s15, s13
 3334 0082 84ED557A 		fsts	s14, [r4, #340]
 3335 0086 C4ED567A 		fsts	s15, [r4, #344]
 3336              	.L436:
 879:state.c       ****     ecef_of_ned_vect_f(&state.ecef_speed_f, &state.ned_origin_f, &state.ned_speed_f);
 3337              		.loc 1 879 0
 3338 008a 04F5A270 		add	r0, r4, #324
 3339 008e 04F1A401 		add	r1, r4, #164
 3340 0092 04F5A872 		add	r2, r4, #336
 3341 0096 FFF7FEFF 		bl	ecef_of_ned_vect_f
 3342              	.LVL183:
 3343              	.L431:
 880:state.c       ****   } else {
 881:state.c       ****     /* could not get this representation,  set errno */
 882:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
 883:state.c       ****     //return _ecef_zero;
 884:state.c       ****   }
 885:state.c       ****   /* set bit to indicate this representation is computed */
 886:state.c       ****   SetBit(state.speed_status, SPEED_ECEF_F);
 3344              		.loc 1 886 0
 3345 009a B4F81431 		ldrh	r3, [r4, #276]
 3346 009e 43F02003 		orr	r3, r3, #32
 3347 00a2 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3348              	.L428:
 3349 00a6 10BD     		pop	{r4, pc}
 3350              	.L438:
 3351              		.align	2
 3352              	.L437:
 3353 00a8 00000000 		.word	.LANCHOR0
 3354 00ac 00000036 		.word	905969664
 3355              		.cfi_endproc
 3356              	.LFE156:
 3358              		.section	.text.stateCalcHorizontalSpeedNorm_f,"ax",%progbits
 3359              		.align	1
 3360              		.global	stateCalcHorizontalSpeedNorm_f
 3361              		.thumb
 3362              		.thumb_func
 3364              	stateCalcHorizontalSpeedNorm_f:
 3365              	.LFB157:
 887:state.c       **** }
 888:state.c       **** 
 889:state.c       **** void stateCalcHorizontalSpeedNorm_f(void)
 890:state.c       **** {
 3366              		.loc 1 890 0
 3367              		.cfi_startproc
 3368              		@ args = 0, pretend = 0, frame = 0
 3369              		@ frame_needed = 0, uses_anonymous_args = 0
 3370 0000 10B5     		push	{r4, lr}
 3371              		.cfi_def_cfa_offset 8
 3372              		.cfi_offset 4, -8
 3373              		.cfi_offset 14, -4
 891:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_F)) {
 3374              		.loc 1 891 0
 3375 0002 364C     		ldr	r4, .L451
 3376 0004 B4F81431 		ldrh	r3, [r4, #276]
 3377 0008 D805     		lsls	r0, r3, #23
 3378 000a 65D4     		bmi	.L439
 892:state.c       ****     return;
 893:state.c       ****   }
 894:state.c       **** 
 895:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HNORM_I)) {
 3379              		.loc 1 895 0
 3380 000c 1907     		lsls	r1, r3, #28
 3381 000e 06D5     		bpl	.L441
 896:state.c       ****     state.h_speed_norm_f = SPEED_FLOAT_OF_BFP(state.h_speed_norm_i);
 3382              		.loc 1 896 0
 3383 0010 D4ED4F7A 		flds	s15, [r4, #316]	@ int
 3384 0014 FBEEE67A 		vcvt.f32.u32	s15, s15, #19
 3385 0018 C4ED5A7A 		fsts	s15, [r4, #360]
 3386 001c 56E0     		b	.L442
 3387              	.L441:
 897:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3388              		.loc 1 897 0
 3389 001e 5A06     		lsls	r2, r3, #25
 3390 0020 04D5     		bpl	.L443
 898:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 3391              		.loc 1 898 0
 3392 0022 94ED547A 		flds	s14, [r4, #336]
 3393 0026 D4ED557A 		flds	s15, [r4, #340]
 3394 002a 45E0     		b	.L449
 3395              	.L443:
 899:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3396              		.loc 1 899 0
 3397 002c 1806     		lsls	r0, r3, #24
 3398 002e 04D5     		bpl	.L444
 900:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 3399              		.loc 1 900 0
 3400 0030 94ED577A 		flds	s14, [r4, #348]
 3401 0034 D4ED587A 		flds	s15, [r4, #352]
 3402 0038 3EE0     		b	.L449
 3403              	.L444:
 901:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3404              		.loc 1 901 0
 3405 003a 9907     		lsls	r1, r3, #30
 3406 003c 1CD5     		bpl	.L445
 902:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3407              		.loc 1 902 0
 3408 003e D4ED497A 		flds	s15, [r4, #292]	@ int
 3409 0042 D4ED4B6A 		flds	s13, [r4, #300]	@ int
 3410 0046 9FED266A 		flds	s12, .L451+4
 3411 004a B8EEE77A 		fsitos	s14, s15
 3412 004e D4ED4A7A 		flds	s15, [r4, #296]	@ int
 3413 0052 F8EEE66A 		fsitos	s13, s13
 3414 0056 F8EEE77A 		fsitos	s15, s15
 3415 005a 27EE067A 		fmuls	s14, s14, s12
 3416 005e 67EE867A 		fmuls	s15, s15, s12
 3417 0062 66EE866A 		fmuls	s13, s13, s12
 3418 0066 84ED547A 		fsts	s14, [r4, #336]
 3419 006a C4ED557A 		fsts	s15, [r4, #340]
 3420 006e C4ED566A 		fsts	s13, [r4, #344]
 903:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3421              		.loc 1 903 0
 3422 0072 43F04003 		orr	r3, r3, #64
 3423 0076 1DE0     		b	.L450
 3424              	.L445:
 904:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.ned_speed_f);
 905:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3425              		.loc 1 905 0
 3426 0078 5A07     		lsls	r2, r3, #29
 3427 007a 27D5     		bpl	.L442
 906:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3428              		.loc 1 906 0
 3429 007c D4ED4C7A 		flds	s15, [r4, #304]	@ int
 3430 0080 D4ED4E6A 		flds	s13, [r4, #312]	@ int
 3431 0084 9FED166A 		flds	s12, .L451+4
 3432 0088 B8EEE77A 		fsitos	s14, s15
 3433 008c D4ED4D7A 		flds	s15, [r4, #308]	@ int
 3434 0090 F8EEE66A 		fsitos	s13, s13
 3435 0094 F8EEE77A 		fsitos	s15, s15
 3436 0098 27EE067A 		fmuls	s14, s14, s12
 3437 009c 67EE867A 		fmuls	s15, s15, s12
 3438 00a0 66EE866A 		fmuls	s13, s13, s12
 3439 00a4 84ED577A 		fsts	s14, [r4, #348]
 3440 00a8 C4ED587A 		fsts	s15, [r4, #352]
 3441 00ac C4ED596A 		fsts	s13, [r4, #356]
 907:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3442              		.loc 1 907 0
 3443 00b0 43F08003 		orr	r3, r3, #128
 3444              	.L450:
 3445 00b4 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3446              	.L449:
 908:state.c       ****     state.h_speed_norm_f = FLOAT_VECT2_NORM(state.enu_speed_f);
 3447              		.loc 1 908 0
 3448 00b8 67EEA77A 		fmuls	s15, s15, s15
 3449 00bc E7EE077A 		vfma.f32	s15, s14, s14
 3450 00c0 17EE900A 		fmrs	r0, s15
 3451 00c4 FFF7FEFF 		bl	sqrtf
 3452              	.LVL184:
 3453 00c8 C4F86801 		str	r0, [r4, #360]	@ float
 3454              	.L442:
 909:state.c       ****   }
 910:state.c       ****   /* set bit to indicate this representation is computed */
 911:state.c       ****   SetBit(state.speed_status, SPEED_HNORM_F);
 3455              		.loc 1 911 0
 3456 00cc B4F81431 		ldrh	r3, [r4, #276]
 3457 00d0 43F48073 		orr	r3, r3, #256
 3458 00d4 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3459              	.L439:
 3460 00d8 10BD     		pop	{r4, pc}
 3461              	.L452:
 3462 00da 00BF     		.align	2
 3463              	.L451:
 3464 00dc 00000000 		.word	.LANCHOR0
 3465 00e0 00000036 		.word	905969664
 3466              		.cfi_endproc
 3467              	.LFE157:
 3469              		.section	.text.stateCalcHorizontalSpeedDir_f,"ax",%progbits
 3470              		.align	1
 3471              		.global	stateCalcHorizontalSpeedDir_f
 3472              		.thumb
 3473              		.thumb_func
 3475              	stateCalcHorizontalSpeedDir_f:
 3476              	.LFB158:
 912:state.c       **** }
 913:state.c       **** 
 914:state.c       **** void stateCalcHorizontalSpeedDir_f(void)
 915:state.c       **** {
 3477              		.loc 1 915 0
 3478              		.cfi_startproc
 3479              		@ args = 0, pretend = 0, frame = 0
 3480              		@ frame_needed = 0, uses_anonymous_args = 0
 3481 0000 10B5     		push	{r4, lr}
 3482              		.cfi_def_cfa_offset 8
 3483              		.cfi_offset 4, -8
 3484              		.cfi_offset 14, -4
 916:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_F)) {
 3485              		.loc 1 916 0
 3486 0002 354C     		ldr	r4, .L465
 3487 0004 B4F81431 		ldrh	r3, [r4, #276]
 3488 0008 9805     		lsls	r0, r3, #22
 3489 000a 63D4     		bmi	.L453
 917:state.c       ****     return;
 918:state.c       ****   }
 919:state.c       **** 
 920:state.c       ****   if (bit_is_set(state.speed_status, SPEED_HDIR_I)) {
 3490              		.loc 1 920 0
 3491 000c D906     		lsls	r1, r3, #27
 3492 000e 06D5     		bpl	.L455
 921:state.c       ****     state.h_speed_dir_f = SPEED_FLOAT_OF_BFP(state.h_speed_dir_i);
 3493              		.loc 1 921 0
 3494 0010 D4ED507A 		flds	s15, [r4, #320]	@ int
 3495 0014 FAEEE67A 		vcvt.f32.s32	s15, s15, #19
 3496 0018 C4ED5B7A 		fsts	s15, [r4, #364]
 3497 001c 54E0     		b	.L456
 3498              	.L455:
 922:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_F)) {
 3499              		.loc 1 922 0
 3500 001e 5A06     		lsls	r2, r3, #25
 3501 0020 04D5     		bpl	.L457
 923:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
 3502              		.loc 1 923 0
 3503 0022 D4F85401 		ldr	r0, [r4, #340]	@ float
 3504 0026 D4F85011 		ldr	r1, [r4, #336]	@ float
 3505 002a 49E0     		b	.L463
 3506              	.L457:
 924:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_F)) {
 3507              		.loc 1 924 0
 3508 002c 1806     		lsls	r0, r3, #24
 3509 002e 04D5     		bpl	.L458
 925:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3510              		.loc 1 925 0
 3511 0030 D4F85C01 		ldr	r0, [r4, #348]	@ float
 3512 0034 D4F86011 		ldr	r1, [r4, #352]	@ float
 3513 0038 42E0     		b	.L463
 3514              	.L458:
 926:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_NED_I)) {
 3515              		.loc 1 926 0
 3516 003a 9907     		lsls	r1, r3, #30
 3517 003c 1CD5     		bpl	.L459
 927:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.ned_speed_f, state.ned_speed_i);
 3518              		.loc 1 927 0
 3519 003e D4ED497A 		flds	s15, [r4, #292]	@ int
 3520 0042 94ED4A7A 		flds	s14, [r4, #296]	@ int
 3521 0046 D4ED4B6A 		flds	s13, [r4, #300]	@ int
 3522 004a 9FED246A 		flds	s12, .L465+4
 3523 004e F8EEE77A 		fsitos	s15, s15
 3524 0052 B8EEC77A 		fsitos	s14, s14
 3525 0056 F8EEE66A 		fsitos	s13, s13
 3526 005a 67EE867A 		fmuls	s15, s15, s12
 3527 005e 27EE067A 		fmuls	s14, s14, s12
 3528 0062 66EE866A 		fmuls	s13, s13, s12
 3529 0066 C4ED547A 		fsts	s15, [r4, #336]
 3530 006a 84ED557A 		fsts	s14, [r4, #340]
 3531 006e C4ED566A 		fsts	s13, [r4, #344]
 928:state.c       ****     SetBit(state.speed_status, SPEED_NED_F);
 3532              		.loc 1 928 0
 3533 0072 43F04003 		orr	r3, r3, #64
 3534 0076 1DE0     		b	.L464
 3535              	.L459:
 929:state.c       ****     state.h_speed_dir_f = atan2f(state.ned_speed_f.y, state.ned_speed_f.x);
 930:state.c       ****   } else if (bit_is_set(state.speed_status, SPEED_ENU_I)) {
 3536              		.loc 1 930 0
 3537 0078 5A07     		lsls	r2, r3, #29
 3538 007a 25D5     		bpl	.L456
 931:state.c       ****     SPEEDS_FLOAT_OF_BFP(state.enu_speed_f, state.enu_speed_i);
 3539              		.loc 1 931 0
 3540 007c D4ED4C7A 		flds	s15, [r4, #304]	@ int
 3541 0080 D4ED4E6A 		flds	s13, [r4, #312]	@ int
 3542 0084 9FED156A 		flds	s12, .L465+4
 3543 0088 B8EEE77A 		fsitos	s14, s15
 3544 008c D4ED4D7A 		flds	s15, [r4, #308]	@ int
 3545 0090 F8EEE66A 		fsitos	s13, s13
 3546 0094 F8EEE77A 		fsitos	s15, s15
 3547 0098 27EE067A 		fmuls	s14, s14, s12
 3548 009c 67EE867A 		fmuls	s15, s15, s12
 3549 00a0 66EE866A 		fmuls	s13, s13, s12
 3550 00a4 84ED577A 		fsts	s14, [r4, #348]
 3551 00a8 C4ED587A 		fsts	s15, [r4, #352]
 3552 00ac C4ED596A 		fsts	s13, [r4, #356]
 932:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3553              		.loc 1 932 0
 3554 00b0 43F08003 		orr	r3, r3, #128
 3555              	.L464:
 933:state.c       ****     state.h_speed_dir_f = atan2f(state.enu_speed_f.x, state.enu_speed_f.y);
 3556              		.loc 1 933 0
 3557 00b4 17EE100A 		fmrs	r0, s14
 3558 00b8 17EE901A 		fmrs	r1, s15
 932:state.c       ****     SetBit(state.speed_status, SPEED_ENU_F);
 3559              		.loc 1 932 0
 3560 00bc A4F81431 		strh	r3, [r4, #276]	@ movhi
 3561              	.L463:
 3562              		.loc 1 933 0
 3563 00c0 FFF7FEFF 		bl	atan2f
 3564              	.LVL185:
 3565 00c4 C4F86C01 		str	r0, [r4, #364]	@ float
 3566              	.L456:
 934:state.c       ****   }
 935:state.c       ****   /* set bit to indicate this representation is computed */
 936:state.c       ****   SetBit(state.speed_status, SPEED_HDIR_F);
 3567              		.loc 1 936 0
 3568 00c8 B4F81431 		ldrh	r3, [r4, #276]
 3569 00cc 43F40073 		orr	r3, r3, #512
 3570 00d0 A4F81431 		strh	r3, [r4, #276]	@ movhi
 3571              	.L453:
 3572 00d4 10BD     		pop	{r4, pc}
 3573              	.L466:
 3574 00d6 00BF     		.align	2
 3575              	.L465:
 3576 00d8 00000000 		.word	.LANCHOR0
 3577 00dc 00000036 		.word	905969664
 3578              		.cfi_endproc
 3579              	.LFE158:
 3581              		.section	.text.stateCalcAccelNed_i,"ax",%progbits
 3582              		.align	1
 3583              		.global	stateCalcAccelNed_i
 3584              		.thumb
 3585              		.thumb_func
 3587              	stateCalcAccelNed_i:
 3588              	.LFB159:
 937:state.c       **** }
 938:state.c       **** /** @}*/
 939:state.c       **** 
 940:state.c       **** 
 941:state.c       **** 
 942:state.c       **** /******************************************************************************
 943:state.c       ****  *                                                                            *
 944:state.c       ****  * Transformation functions for the ACCELERATION representations              *
 945:state.c       ****  *                                                                            *
 946:state.c       ****  *****************************************************************************/
 947:state.c       **** /** @addtogroup state_acceleration
 948:state.c       ****  *  @{ */
 949:state.c       **** 
 950:state.c       **** void stateCalcAccelNed_i(void)
 951:state.c       **** {
 3589              		.loc 1 951 0
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 0
 3592              		@ frame_needed = 0, uses_anonymous_args = 0
 3593 0000 10B5     		push	{r4, lr}
 3594              		.cfi_def_cfa_offset 8
 3595              		.cfi_offset 4, -8
 3596              		.cfi_offset 14, -4
 952:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3597              		.loc 1 952 0
 3598 0002 2B4C     		ldr	r4, .L479
 3599 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3600 0008 9A07     		lsls	r2, r3, #30
 3601 000a 50D4     		bmi	.L467
 3602              	.LVL186:
 953:state.c       ****     return;
 954:state.c       ****   }
 955:state.c       **** 
 956:state.c       ****   int errno = 0;
 957:state.c       ****   if (state.ned_initialized_i) {
 3603              		.loc 1 957 0
 3604 000c 94F85C20 		ldrb	r2, [r4, #92]	@ zero_extendqisi2
 3605 0010 002A     		cmp	r2, #0
 3606 0012 46D0     		beq	.L469
 958:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3607              		.loc 1 958 0
 3608 0014 1807     		lsls	r0, r3, #28
 3609 0016 1AD5     		bpl	.L470
 959:state.c       ****       ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3610              		.loc 1 959 0
 3611 0018 DFED266A 		flds	s13, .L479+4
 3612 001c 94ED637A 		flds	s14, [r4, #396]
 3613 0020 D4ED657A 		flds	s15, [r4, #404]
 3614 0024 27EE267A 		fmuls	s14, s14, s13
 3615 0028 67EEA67A 		fmuls	s15, s15, s13
 3616 002c BDEEC77A 		ftosizs	s14, s14
 3617 0030 FDEEE77A 		ftosizs	s15, s15
 3618 0034 84ED5D7A 		fsts	s14, [r4, #372]	@ int
 3619 0038 94ED647A 		flds	s14, [r4, #400]
 3620 003c C4ED5F7A 		fsts	s15, [r4, #380]	@ int
 3621 0040 27EE267A 		fmuls	s14, s14, s13
 3622 0044 BDEEC77A 		ftosizs	s14, s14
 3623 0048 84ED5E7A 		fsts	s14, [r4, #376]	@ int
 3624 004c 29E0     		b	.L469
 3625              	.L470:
 960:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3626              		.loc 1 960 0
 3627 004e D907     		lsls	r1, r3, #31
 3628 0050 1FD4     		bmi	.L478
 961:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
 962:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3629              		.loc 1 962 0
 3630 0052 5A07     		lsls	r2, r3, #29
 3631 0054 25D5     		bpl	.L469
 963:state.c       ****       /* transform ecef_f -> ecef_i -> ned_i , set status bits */
 964:state.c       ****       ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3632              		.loc 1 964 0
 3633 0056 DFED176A 		flds	s13, .L479+4
 3634 005a 94ED667A 		flds	s14, [r4, #408]
 3635 005e D4ED687A 		flds	s15, [r4, #416]
 3636 0062 27EE267A 		fmuls	s14, s14, s13
 3637 0066 67EEA67A 		fmuls	s15, s15, s13
 3638 006a BDEEC77A 		ftosizs	s14, s14
 3639 006e FDEEE77A 		ftosizs	s15, s15
 3640 0072 84ED607A 		fsts	s14, [r4, #384]	@ int
 3641 0076 94ED677A 		flds	s14, [r4, #412]
 3642 007a C4ED627A 		fsts	s15, [r4, #392]	@ int
 3643 007e 27EE267A 		fmuls	s14, s14, s13
 965:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_I);
 3644              		.loc 1 965 0
 3645 0082 43F00103 		orr	r3, r3, #1
 964:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_I);
 3646              		.loc 1 964 0
 3647 0086 BDEEC77A 		ftosizs	s14, s14
 3648              		.loc 1 965 0
 3649 008a 84F87031 		strb	r3, [r4, #368]
 964:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_I);
 3650              		.loc 1 964 0
 3651 008e 84ED617A 		fsts	s14, [r4, #388]	@ int
 3652              	.L478:
 966:state.c       ****       ned_of_ecef_vect_i(&state.ned_accel_i, &state.ned_origin_i, &state.ecef_accel_i);
 3653              		.loc 1 966 0
 3654 0092 04F5BA70 		add	r0, r4, #372
 3655 0096 04F11C01 		add	r1, r4, #28
 3656 009a 04F5C072 		add	r2, r4, #384
 3657 009e FFF7FEFF 		bl	ned_of_ecef_vect_i
 3658              	.LVL187:
 3659              	.L469:
 967:state.c       ****     } else { /* could not get this representation,  set errno */
 968:state.c       ****       errno = 1;
 969:state.c       ****     }
 970:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
 971:state.c       ****     errno = 2;
 972:state.c       ****   }
 973:state.c       ****   if (errno) {
 974:state.c       ****     //struct NedCoor_i _ned_zero = {0};
 975:state.c       ****     //return _ned_zero;
 976:state.c       ****   }
 977:state.c       ****   /* set bit to indicate this representation is computed */
 978:state.c       ****   SetBit(state.accel_status, ACCEL_NED_I);
 3660              		.loc 1 978 0
 3661 00a2 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3662 00a6 43F00203 		orr	r3, r3, #2
 3663 00aa 84F87031 		strb	r3, [r4, #368]
 3664              	.LVL188:
 3665              	.L467:
 3666 00ae 10BD     		pop	{r4, pc}
 3667              	.L480:
 3668              		.align	2
 3669              	.L479:
 3670 00b0 00000000 		.word	.LANCHOR0
 3671 00b4 00008044 		.word	1149239296
 3672              		.cfi_endproc
 3673              	.LFE159:
 3675              		.section	.text.stateCalcAccelEcef_i,"ax",%progbits
 3676              		.align	1
 3677              		.global	stateCalcAccelEcef_i
 3678              		.thumb
 3679              		.thumb_func
 3681              	stateCalcAccelEcef_i:
 3682              	.LFB160:
 979:state.c       **** }
 980:state.c       **** 
 981:state.c       **** void stateCalcAccelEcef_i(void)
 982:state.c       **** {
 3683              		.loc 1 982 0
 3684              		.cfi_startproc
 3685              		@ args = 0, pretend = 0, frame = 0
 3686              		@ frame_needed = 0, uses_anonymous_args = 0
 3687 0000 10B5     		push	{r4, lr}
 3688              		.cfi_def_cfa_offset 8
 3689              		.cfi_offset 4, -8
 3690              		.cfi_offset 14, -4
 983:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3691              		.loc 1 983 0
 3692 0002 294C     		ldr	r4, .L490
 3693 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3694 0008 DA07     		lsls	r2, r3, #31
 3695 000a 4CD4     		bmi	.L481
 984:state.c       ****     return;
 985:state.c       ****   }
 986:state.c       **** 
 987:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3696              		.loc 1 987 0
 3697 000c 5807     		lsls	r0, r3, #29
 3698 000e 1AD5     		bpl	.L483
 988:state.c       ****     ACCELS_BFP_OF_REAL(state.ecef_accel_i, state.ecef_accel_f);
 3699              		.loc 1 988 0
 3700 0010 DFED266A 		flds	s13, .L490+4
 3701 0014 94ED667A 		flds	s14, [r4, #408]
 3702 0018 D4ED687A 		flds	s15, [r4, #416]
 3703 001c 27EE267A 		fmuls	s14, s14, s13
 3704 0020 67EEA67A 		fmuls	s15, s15, s13
 3705 0024 BDEEC77A 		ftosizs	s14, s14
 3706 0028 FDEEE77A 		ftosizs	s15, s15
 3707 002c 84ED607A 		fsts	s14, [r4, #384]	@ int
 3708 0030 94ED677A 		flds	s14, [r4, #412]
 3709 0034 C4ED627A 		fsts	s15, [r4, #392]	@ int
 3710 0038 27EE267A 		fmuls	s14, s14, s13
 3711 003c BDEEC77A 		ftosizs	s14, s14
 3712 0040 84ED617A 		fsts	s14, [r4, #388]	@ int
 3713 0044 29E0     		b	.L484
 3714              	.L483:
 989:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3715              		.loc 1 989 0
 3716 0046 9907     		lsls	r1, r3, #30
 3717 0048 1FD4     		bmi	.L489
 990:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
 991:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3718              		.loc 1 991 0
 3719 004a 1A07     		lsls	r2, r3, #28
 3720 004c 25D5     		bpl	.L484
 992:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
 993:state.c       ****     ACCELS_BFP_OF_REAL(state.ned_accel_i, state.ned_accel_f);
 3721              		.loc 1 993 0
 3722 004e DFED176A 		flds	s13, .L490+4
 3723 0052 94ED637A 		flds	s14, [r4, #396]
 3724 0056 D4ED657A 		flds	s15, [r4, #404]
 3725 005a 27EE267A 		fmuls	s14, s14, s13
 3726 005e 67EEA67A 		fmuls	s15, s15, s13
 3727 0062 BDEEC77A 		ftosizs	s14, s14
 3728 0066 FDEEE77A 		ftosizs	s15, s15
 3729 006a 84ED5D7A 		fsts	s14, [r4, #372]	@ int
 3730 006e 94ED647A 		flds	s14, [r4, #400]
 3731 0072 C4ED5F7A 		fsts	s15, [r4, #380]	@ int
 3732 0076 27EE267A 		fmuls	s14, s14, s13
 994:state.c       ****     SetBit(state.accel_status, ACCEL_NED_I);
 3733              		.loc 1 994 0
 3734 007a 43F00203 		orr	r3, r3, #2
 993:state.c       ****     SetBit(state.accel_status, ACCEL_NED_I);
 3735              		.loc 1 993 0
 3736 007e BDEEC77A 		ftosizs	s14, s14
 3737              		.loc 1 994 0
 3738 0082 84F87031 		strb	r3, [r4, #368]
 993:state.c       ****     SetBit(state.accel_status, ACCEL_NED_I);
 3739              		.loc 1 993 0
 3740 0086 84ED5E7A 		fsts	s14, [r4, #376]	@ int
 3741              	.L489:
 995:state.c       ****     ecef_of_ned_vect_i(&state.ecef_accel_i, &state.ned_origin_i, &state.ned_accel_i);
 3742              		.loc 1 995 0
 3743 008a 04F5C070 		add	r0, r4, #384
 3744 008e 04F11C01 		add	r1, r4, #28
 3745 0092 04F5BA72 		add	r2, r4, #372
 3746 0096 FFF7FEFF 		bl	ecef_of_ned_vect_i
 3747              	.LVL189:
 3748              	.L484:
 996:state.c       ****   } else {
 997:state.c       ****     /* could not get this representation,  set errno */
 998:state.c       ****     //struct EcefCoor_i _ecef_zero = {0};
 999:state.c       ****     //return _ecef_zero;
1000:state.c       ****   }
1001:state.c       ****   /* set bit to indicate this representation is computed */
1002:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_I);
 3749              		.loc 1 1002 0
 3750 009a 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3751 009e 43F00103 		orr	r3, r3, #1
 3752 00a2 84F87031 		strb	r3, [r4, #368]
 3753              	.L481:
 3754 00a6 10BD     		pop	{r4, pc}
 3755              	.L491:
 3756              		.align	2
 3757              	.L490:
 3758 00a8 00000000 		.word	.LANCHOR0
 3759 00ac 00008044 		.word	1149239296
 3760              		.cfi_endproc
 3761              	.LFE160:
 3763              		.section	.text.stateCalcAccelNed_f,"ax",%progbits
 3764              		.align	1
 3765              		.global	stateCalcAccelNed_f
 3766              		.thumb
 3767              		.thumb_func
 3769              	stateCalcAccelNed_f:
 3770              	.LFB161:
1003:state.c       **** }
1004:state.c       **** 
1005:state.c       **** void stateCalcAccelNed_f(void)
1006:state.c       **** {
 3771              		.loc 1 1006 0
 3772              		.cfi_startproc
 3773              		@ args = 0, pretend = 0, frame = 0
 3774              		@ frame_needed = 0, uses_anonymous_args = 0
 3775 0000 10B5     		push	{r4, lr}
 3776              		.cfi_def_cfa_offset 8
 3777              		.cfi_offset 4, -8
 3778              		.cfi_offset 14, -4
1007:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3779              		.loc 1 1007 0
 3780 0002 2B4C     		ldr	r4, .L504
 3781 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3782 0008 1A07     		lsls	r2, r3, #28
 3783 000a 50D4     		bmi	.L492
 3784              	.LVL190:
1008:state.c       ****     return;
1009:state.c       ****   }
1010:state.c       **** 
1011:state.c       ****   int errno = 0;
1012:state.c       ****   if (state.ned_initialized_f) {
 3785              		.loc 1 1012 0
 3786 000c 94F8E420 		ldrb	r2, [r4, #228]	@ zero_extendqisi2
 3787 0010 002A     		cmp	r2, #0
 3788 0012 46D0     		beq	.L494
1013:state.c       ****     if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3789              		.loc 1 1013 0
 3790 0014 9807     		lsls	r0, r3, #30
 3791 0016 1AD5     		bpl	.L495
1014:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3792              		.loc 1 1014 0
 3793 0018 D4ED5D7A 		flds	s15, [r4, #372]	@ int
 3794 001c DFED256A 		flds	s13, .L504+4
 3795 0020 B8EEE77A 		fsitos	s14, s15
 3796 0024 D4ED5E7A 		flds	s15, [r4, #376]	@ int
 3797 0028 27EE267A 		fmuls	s14, s14, s13
 3798 002c 84ED637A 		fsts	s14, [r4, #396]
 3799 0030 B8EEE77A 		fsitos	s14, s15
 3800 0034 D4ED5F7A 		flds	s15, [r4, #380]	@ int
 3801 0038 F8EEE77A 		fsitos	s15, s15
 3802 003c 27EE267A 		fmuls	s14, s14, s13
 3803 0040 67EEA67A 		fmuls	s15, s15, s13
 3804 0044 84ED647A 		fsts	s14, [r4, #400]
 3805 0048 C4ED657A 		fsts	s15, [r4, #404]
 3806 004c 29E0     		b	.L494
 3807              	.L495:
1015:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3808              		.loc 1 1015 0
 3809 004e 5907     		lsls	r1, r3, #29
 3810 0050 1FD4     		bmi	.L503
1016:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
1017:state.c       ****     } else if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3811              		.loc 1 1017 0
 3812 0052 DA07     		lsls	r2, r3, #31
 3813 0054 25D5     		bpl	.L494
1018:state.c       ****       /* transform ecef_i -> ecef_f -> ned_f , set status bits */
1019:state.c       ****       ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ecef_accel_i);
 3814              		.loc 1 1019 0
 3815 0056 D4ED607A 		flds	s15, [r4, #384]	@ int
 3816 005a DFED166A 		flds	s13, .L504+4
 3817 005e B8EEE77A 		fsitos	s14, s15
 3818 0062 D4ED617A 		flds	s15, [r4, #388]	@ int
 3819 0066 27EE267A 		fmuls	s14, s14, s13
1020:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_F);
 3820              		.loc 1 1020 0
 3821 006a 43F00403 		orr	r3, r3, #4
1019:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_F);
 3822              		.loc 1 1019 0
 3823 006e 84ED667A 		fsts	s14, [r4, #408]
 3824 0072 B8EEE77A 		fsitos	s14, s15
 3825 0076 D4ED627A 		flds	s15, [r4, #392]	@ int
 3826              		.loc 1 1020 0
 3827 007a 84F87031 		strb	r3, [r4, #368]
1019:state.c       ****       SetBit(state.accel_status, ACCEL_ECEF_F);
 3828              		.loc 1 1019 0
 3829 007e F8EEE77A 		fsitos	s15, s15
 3830 0082 27EE267A 		fmuls	s14, s14, s13
 3831 0086 67EEA67A 		fmuls	s15, s15, s13
 3832 008a 84ED677A 		fsts	s14, [r4, #412]
 3833 008e C4ED687A 		fsts	s15, [r4, #416]
 3834              	.L503:
1021:state.c       ****       ned_of_ecef_vect_f(&state.ned_accel_f, &state.ned_origin_f, &state.ecef_accel_f);
 3835              		.loc 1 1021 0
 3836 0092 04F5C670 		add	r0, r4, #396
 3837 0096 04F1A401 		add	r1, r4, #164
 3838 009a 04F5CC72 		add	r2, r4, #408
 3839 009e FFF7FEFF 		bl	ned_of_ecef_vect_f
 3840              	.LVL191:
 3841              	.L494:
1022:state.c       ****     } else { /* could not get this representation,  set errno */
1023:state.c       ****       errno = 1;
1024:state.c       ****     }
1025:state.c       ****   } else { /* ned coordinate system not initialized,  set errno */
1026:state.c       ****     errno = 2;
1027:state.c       ****   }
1028:state.c       ****   if (errno) {
1029:state.c       ****     //struct NedCoor_f _ned_zero = {0.0f};
1030:state.c       ****     //return _ned_zero;
1031:state.c       ****   }
1032:state.c       ****   /* set bit to indicate this representation is computed */
1033:state.c       ****   SetBit(state.accel_status, ACCEL_NED_F);
 3842              		.loc 1 1033 0
 3843 00a2 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3844 00a6 43F00803 		orr	r3, r3, #8
 3845 00aa 84F87031 		strb	r3, [r4, #368]
 3846              	.LVL192:
 3847              	.L492:
 3848 00ae 10BD     		pop	{r4, pc}
 3849              	.L505:
 3850              		.align	2
 3851              	.L504:
 3852 00b0 00000000 		.word	.LANCHOR0
 3853 00b4 0000803A 		.word	981467136
 3854              		.cfi_endproc
 3855              	.LFE161:
 3857              		.section	.text.stateCalcAccelEcef_f,"ax",%progbits
 3858              		.align	1
 3859              		.global	stateCalcAccelEcef_f
 3860              		.thumb
 3861              		.thumb_func
 3863              	stateCalcAccelEcef_f:
 3864              	.LFB162:
1034:state.c       **** }
1035:state.c       **** 
1036:state.c       **** void stateCalcAccelEcef_f(void)
1037:state.c       **** {
 3865              		.loc 1 1037 0
 3866              		.cfi_startproc
 3867              		@ args = 0, pretend = 0, frame = 0
 3868              		@ frame_needed = 0, uses_anonymous_args = 0
 3869 0000 10B5     		push	{r4, lr}
 3870              		.cfi_def_cfa_offset 8
 3871              		.cfi_offset 4, -8
 3872              		.cfi_offset 14, -4
1038:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_F)) {
 3873              		.loc 1 1038 0
 3874 0002 294C     		ldr	r4, .L515
 3875 0004 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3876 0008 5A07     		lsls	r2, r3, #29
 3877 000a 4CD4     		bmi	.L506
1039:state.c       ****     return;
1040:state.c       ****   }
1041:state.c       **** 
1042:state.c       ****   if (bit_is_set(state.accel_status, ACCEL_ECEF_I)) {
 3878              		.loc 1 1042 0
 3879 000c D807     		lsls	r0, r3, #31
 3880 000e 1AD5     		bpl	.L508
1043:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ecef_accel_f, state.ned_accel_i);
 3881              		.loc 1 1043 0
 3882 0010 D4ED5D7A 		flds	s15, [r4, #372]	@ int
 3883 0014 DFED256A 		flds	s13, .L515+4
 3884 0018 B8EEE77A 		fsitos	s14, s15
 3885 001c D4ED5E7A 		flds	s15, [r4, #376]	@ int
 3886 0020 27EE267A 		fmuls	s14, s14, s13
 3887 0024 84ED667A 		fsts	s14, [r4, #408]
 3888 0028 B8EEE77A 		fsitos	s14, s15
 3889 002c D4ED5F7A 		flds	s15, [r4, #380]	@ int
 3890 0030 F8EEE77A 		fsitos	s15, s15
 3891 0034 27EE267A 		fmuls	s14, s14, s13
 3892 0038 67EEA67A 		fmuls	s15, s15, s13
 3893 003c 84ED677A 		fsts	s14, [r4, #412]
 3894 0040 C4ED687A 		fsts	s15, [r4, #416]
 3895 0044 29E0     		b	.L509
 3896              	.L508:
1044:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_F)) {
 3897              		.loc 1 1044 0
 3898 0046 1907     		lsls	r1, r3, #28
 3899 0048 1FD4     		bmi	.L514
1045:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
1046:state.c       ****   } else if (bit_is_set(state.accel_status, ACCEL_NED_I)) {
 3900              		.loc 1 1046 0
 3901 004a 9A07     		lsls	r2, r3, #30
 3902 004c 25D5     		bpl	.L509
1047:state.c       ****     /* transform ned_f -> ned_i -> ecef_i , set status bits */
1048:state.c       ****     ACCELS_FLOAT_OF_BFP(state.ned_accel_f, state.ned_accel_i);
 3903              		.loc 1 1048 0
 3904 004e D4ED5D7A 		flds	s15, [r4, #372]	@ int
 3905 0052 DFED166A 		flds	s13, .L515+4
 3906 0056 B8EEE77A 		fsitos	s14, s15
 3907 005a D4ED5E7A 		flds	s15, [r4, #376]	@ int
 3908 005e 27EE267A 		fmuls	s14, s14, s13
1049:state.c       ****     SetBit(state.accel_status, ACCEL_NED_F);
 3909              		.loc 1 1049 0
 3910 0062 43F00803 		orr	r3, r3, #8
1048:state.c       ****     SetBit(state.accel_status, ACCEL_NED_F);
 3911              		.loc 1 1048 0
 3912 0066 84ED637A 		fsts	s14, [r4, #396]
 3913 006a B8EEE77A 		fsitos	s14, s15
 3914 006e D4ED5F7A 		flds	s15, [r4, #380]	@ int
 3915              		.loc 1 1049 0
 3916 0072 84F87031 		strb	r3, [r4, #368]
1048:state.c       ****     SetBit(state.accel_status, ACCEL_NED_F);
 3917              		.loc 1 1048 0
 3918 0076 F8EEE77A 		fsitos	s15, s15
 3919 007a 27EE267A 		fmuls	s14, s14, s13
 3920 007e 67EEA67A 		fmuls	s15, s15, s13
 3921 0082 84ED647A 		fsts	s14, [r4, #400]
 3922 0086 C4ED657A 		fsts	s15, [r4, #404]
 3923              	.L514:
1050:state.c       ****     ecef_of_ned_vect_f(&state.ecef_accel_f, &state.ned_origin_f, &state.ned_accel_f);
 3924              		.loc 1 1050 0
 3925 008a 04F5CC70 		add	r0, r4, #408
 3926 008e 04F1A401 		add	r1, r4, #164
 3927 0092 04F5C672 		add	r2, r4, #396
 3928 0096 FFF7FEFF 		bl	ecef_of_ned_vect_f
 3929              	.LVL193:
 3930              	.L509:
1051:state.c       ****   } else {
1052:state.c       ****     /* could not get this representation,  set errno */
1053:state.c       ****     //struct EcefCoor_f _ecef_zero = {0.0f};
1054:state.c       ****     //return _ecef_zero;
1055:state.c       ****   }
1056:state.c       ****   /* set bit to indicate this representation is computed */
1057:state.c       ****   SetBit(state.accel_status, ACCEL_ECEF_F);
 3931              		.loc 1 1057 0
 3932 009a 94F87031 		ldrb	r3, [r4, #368]	@ zero_extendqisi2
 3933 009e 43F00403 		orr	r3, r3, #4
 3934 00a2 84F87031 		strb	r3, [r4, #368]
 3935              	.L506:
 3936 00a6 10BD     		pop	{r4, pc}
 3937              	.L516:
 3938              		.align	2
 3939              	.L515:
 3940 00a8 00000000 		.word	.LANCHOR0
 3941 00ac 0000803A 		.word	981467136
 3942              		.cfi_endproc
 3943              	.LFE162:
 3945              		.section	.text.stateCalcBodyRates_i,"ax",%progbits
 3946              		.align	1
 3947              		.global	stateCalcBodyRates_i
 3948              		.thumb
 3949              		.thumb_func
 3951              	stateCalcBodyRates_i:
 3952              	.LFB163:
1058:state.c       **** }
1059:state.c       **** /** @}*/
1060:state.c       **** 
1061:state.c       **** /******************************************************************************
1062:state.c       ****  *                                                                            *
1063:state.c       ****  * Transformation functions for the ANGULAR RATE representations              *
1064:state.c       ****  *                                                                            *
1065:state.c       ****  *****************************************************************************/
1066:state.c       **** /** @addtogroup state_rate
1067:state.c       ****  *  @{ */
1068:state.c       **** 
1069:state.c       **** void stateCalcBodyRates_i(void)
1070:state.c       **** {
 3953              		.loc 1 1070 0
 3954              		.cfi_startproc
 3955              		@ args = 0, pretend = 0, frame = 0
 3956              		@ frame_needed = 0, uses_anonymous_args = 0
 3957              		@ link register save eliminated.
1071:state.c       ****   if (bit_is_set(state.rate_status, RATE_I)) {
 3958              		.loc 1 1071 0
 3959 0000 124B     		ldr	r3, .L523
 3960 0002 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 3961 0006 D007     		lsls	r0, r2, #31
 3962 0008 1FD4     		bmi	.L517
1072:state.c       ****     return;
1073:state.c       ****   }
1074:state.c       **** 
1075:state.c       ****   if (bit_is_set(state.rate_status, RATE_F)) {
 3963              		.loc 1 1075 0
 3964 000a 9107     		lsls	r1, r2, #30
 3965 000c 19D5     		bpl	.L519
1076:state.c       ****     RATES_BFP_OF_REAL(state.body_rates_i, state.body_rates_f);
 3966              		.loc 1 1076 0
 3967 000e DFED106A 		flds	s13, .L523+4
 3968 0012 93ED8E7A 		flds	s14, [r3, #568]
 3969 0016 D3ED907A 		flds	s15, [r3, #576]
 3970 001a 27EE267A 		fmuls	s14, s14, s13
 3971 001e 67EEA67A 		fmuls	s15, s15, s13
 3972 0022 BDEEC77A 		ftosizs	s14, s14
 3973 0026 FDEEE77A 		ftosizs	s15, s15
 3974 002a 83ED8B7A 		fsts	s14, [r3, #556]	@ int
 3975 002e 93ED8F7A 		flds	s14, [r3, #572]
 3976 0032 C3ED8D7A 		fsts	s15, [r3, #564]	@ int
 3977 0036 27EE267A 		fmuls	s14, s14, s13
 3978 003a BDEEC77A 		ftosizs	s14, s14
 3979 003e 83ED8C7A 		fsts	s14, [r3, #560]	@ int
 3980              	.L519:
1077:state.c       ****   }
1078:state.c       ****   /* set bit to indicate this representation is computed */
1079:state.c       ****   SetBit(state.rate_status, RATE_I);
 3981              		.loc 1 1079 0
 3982 0042 42F00102 		orr	r2, r2, #1
 3983 0046 83F82822 		strb	r2, [r3, #552]
 3984              	.L517:
 3985 004a 7047     		bx	lr
 3986              	.L524:
 3987              		.align	2
 3988              	.L523:
 3989 004c 00000000 		.word	.LANCHOR0
 3990 0050 00008045 		.word	1166016512
 3991              		.cfi_endproc
 3992              	.LFE163:
 3994              		.section	.text.stateCalcBodyRates_f,"ax",%progbits
 3995              		.align	1
 3996              		.global	stateCalcBodyRates_f
 3997              		.thumb
 3998              		.thumb_func
 4000              	stateCalcBodyRates_f:
 4001              	.LFB164:
1080:state.c       **** }
1081:state.c       **** 
1082:state.c       **** void stateCalcBodyRates_f(void)
1083:state.c       **** {
 4002              		.loc 1 1083 0
 4003              		.cfi_startproc
 4004              		@ args = 0, pretend = 0, frame = 0
 4005              		@ frame_needed = 0, uses_anonymous_args = 0
 4006              		@ link register save eliminated.
1084:state.c       ****   if (bit_is_set(state.rate_status, RATE_F)) {
 4007              		.loc 1 1084 0
 4008 0000 124B     		ldr	r3, .L531
 4009 0002 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4010 0006 9007     		lsls	r0, r2, #30
 4011 0008 1FD4     		bmi	.L525
1085:state.c       ****     return;
1086:state.c       ****   }
1087:state.c       **** 
1088:state.c       ****   if (bit_is_set(state.rate_status, RATE_I)) {
 4012              		.loc 1 1088 0
 4013 000a D107     		lsls	r1, r2, #31
 4014 000c 19D5     		bpl	.L527
1089:state.c       ****     RATES_FLOAT_OF_BFP(state.body_rates_f, state.body_rates_i);
 4015              		.loc 1 1089 0
 4016 000e D3ED8B7A 		flds	s15, [r3, #556]	@ int
 4017 0012 DFED0F6A 		flds	s13, .L531+4
 4018 0016 B8EEE77A 		fsitos	s14, s15
 4019 001a D3ED8C7A 		flds	s15, [r3, #560]	@ int
 4020 001e 27EE267A 		fmuls	s14, s14, s13
 4021 0022 83ED8E7A 		fsts	s14, [r3, #568]
 4022 0026 B8EEE77A 		fsitos	s14, s15
 4023 002a D3ED8D7A 		flds	s15, [r3, #564]	@ int
 4024 002e F8EEE77A 		fsitos	s15, s15
 4025 0032 27EE267A 		fmuls	s14, s14, s13
 4026 0036 67EEA67A 		fmuls	s15, s15, s13
 4027 003a 83ED8F7A 		fsts	s14, [r3, #572]
 4028 003e C3ED907A 		fsts	s15, [r3, #576]
 4029              	.L527:
1090:state.c       ****   }
1091:state.c       ****   /* set bit to indicate this representation is computed */
1092:state.c       ****   SetBit(state.rate_status, RATE_F);
 4030              		.loc 1 1092 0
 4031 0042 42F00202 		orr	r2, r2, #2
 4032 0046 83F82822 		strb	r2, [r3, #552]
 4033              	.L525:
 4034 004a 7047     		bx	lr
 4035              	.L532:
 4036              		.align	2
 4037              	.L531:
 4038 004c 00000000 		.word	.LANCHOR0
 4039 0050 00008039 		.word	964689920
 4040              		.cfi_endproc
 4041              	.LFE164:
 4043              		.section	.text.stateCalcHorizontalWindspeed_i,"ax",%progbits
 4044              		.align	1
 4045              		.global	stateCalcHorizontalWindspeed_i
 4046              		.thumb
 4047              		.thumb_func
 4049              	stateCalcHorizontalWindspeed_i:
 4050              	.LFB165:
1093:state.c       **** }
1094:state.c       **** 
1095:state.c       **** /** @}*/
1096:state.c       **** 
1097:state.c       **** 
1098:state.c       **** /******************************************************************************
1099:state.c       ****  *                                                                            *
1100:state.c       ****  * Transformation functions for the WIND- AND AIRSPEED representations        *
1101:state.c       ****  *                                                                            *
1102:state.c       ****  *****************************************************************************/
1103:state.c       **** /** @addtogroup state_wind_airspeed
1104:state.c       ****  *  @{ */
1105:state.c       **** 
1106:state.c       **** void stateCalcHorizontalWindspeed_i(void)
1107:state.c       **** {
 4051              		.loc 1 1107 0
 4052              		.cfi_startproc
 4053              		@ args = 0, pretend = 0, frame = 0
 4054              		@ frame_needed = 0, uses_anonymous_args = 0
 4055              		@ link register save eliminated.
1108:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I)) {
 4056              		.loc 1 1108 0
 4057 0000 0F4B     		ldr	r3, .L539
 4058 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4059 0006 D107     		lsls	r1, r2, #31
 4060 0008 19D4     		bmi	.L533
1109:state.c       ****     return;
1110:state.c       ****   }
1111:state.c       **** 
1112:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F)) {
 4061              		.loc 1 1112 0
 4062 000a 5207     		lsls	r2, r2, #29
 4063 000c 11D5     		bpl	.L535
1113:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4064              		.loc 1 1113 0
 4065 000e DFED0D6A 		flds	s13, .L539+4
 4066 0012 93ED957A 		flds	s14, [r3, #596]
1114:state.c       ****     state.h_windspeed_i.y = SPEED_BFP_OF_REAL(state.h_windspeed_f.y);
 4067              		.loc 1 1114 0
 4068 0016 D3ED967A 		flds	s15, [r3, #600]
1113:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4069              		.loc 1 1113 0
 4070 001a 27EE267A 		fmuls	s14, s14, s13
 4071              		.loc 1 1114 0
 4072 001e 67EEA67A 		fmuls	s15, s15, s13
1113:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4073              		.loc 1 1113 0
 4074 0022 BDEEC77A 		ftosizs	s14, s14
 4075              		.loc 1 1114 0
 4076 0026 FDEEE77A 		ftosizs	s15, s15
1113:state.c       ****     state.h_windspeed_i.x = SPEED_BFP_OF_REAL(state.h_windspeed_f.x);
 4077              		.loc 1 1113 0
 4078 002a 83ED927A 		fsts	s14, [r3, #584]	@ int
 4079              		.loc 1 1114 0
 4080 002e C3ED937A 		fsts	s15, [r3, #588]	@ int
 4081              	.L535:
1115:state.c       ****   }
1116:state.c       ****   /* set bit to indicate this representation is computed */
1117:state.c       ****   SetBit(state.rate_status, WINDSPEED_I);
 4082              		.loc 1 1117 0
 4083 0032 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
 4084 0036 42F00102 		orr	r2, r2, #1
 4085 003a 83F82822 		strb	r2, [r3, #552]
 4086              	.L533:
 4087 003e 7047     		bx	lr
 4088              	.L540:
 4089              		.align	2
 4090              	.L539:
 4091 0040 00000000 		.word	.LANCHOR0
 4092 0044 00000049 		.word	1224736768
 4093              		.cfi_endproc
 4094              	.LFE165:
 4096              		.section	.text.stateCalcAirspeed_i,"ax",%progbits
 4097              		.align	1
 4098              		.global	stateCalcAirspeed_i
 4099              		.thumb
 4100              		.thumb_func
 4102              	stateCalcAirspeed_i:
 4103              	.LFB166:
1118:state.c       **** }
1119:state.c       **** 
1120:state.c       **** void stateCalcAirspeed_i(void)
1121:state.c       **** {
 4104              		.loc 1 1121 0
 4105              		.cfi_startproc
 4106              		@ args = 0, pretend = 0, frame = 0
 4107              		@ frame_needed = 0, uses_anonymous_args = 0
 4108              		@ link register save eliminated.
1122:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I)) {
 4109              		.loc 1 1122 0
 4110 0000 094B     		ldr	r3, .L547
 4111 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4112 0006 9007     		lsls	r0, r2, #30
 4113 0008 0CD4     		bmi	.L541
1123:state.c       ****     return;
1124:state.c       ****   }
1125:state.c       **** 
1126:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F)) {
 4114              		.loc 1 1126 0
 4115 000a 1107     		lsls	r1, r2, #28
1127:state.c       ****     state.airspeed_i = SPEED_BFP_OF_REAL(state.airspeed_f);
 4116              		.loc 1 1127 0
 4117 000c 44BF     		itt	mi
 4118 000e D3ED977A 		fldsmi	s15, [r3, #604]
 4119 0012 FEEEE67A 		vcvtmi.s32.f32	s15, s15, #19
1128:state.c       ****   }
1129:state.c       ****   /* set bit to indicate this representation is computed */
1130:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_I);
 4120              		.loc 1 1130 0
 4121 0016 42F00202 		orr	r2, r2, #2
1127:state.c       ****     state.airspeed_i = SPEED_BFP_OF_REAL(state.airspeed_f);
 4122              		.loc 1 1127 0
 4123 001a 48BF     		it	mi
 4124 001c C3ED947A 		fstsmi	s15, [r3, #592]	@ int
 4125              		.loc 1 1130 0
 4126 0020 83F84422 		strb	r2, [r3, #580]
 4127              	.L541:
 4128 0024 7047     		bx	lr
 4129              	.L548:
 4130 0026 00BF     		.align	2
 4131              	.L547:
 4132 0028 00000000 		.word	.LANCHOR0
 4133              		.cfi_endproc
 4134              	.LFE166:
 4136              		.section	.text.stateCalcHorizontalWindspeed_f,"ax",%progbits
 4137              		.align	1
 4138              		.global	stateCalcHorizontalWindspeed_f
 4139              		.thumb
 4140              		.thumb_func
 4142              	stateCalcHorizontalWindspeed_f:
 4143              	.LFB167:
1131:state.c       **** }
1132:state.c       **** 
1133:state.c       **** void stateCalcHorizontalWindspeed_f(void)
1134:state.c       **** {
 4144              		.loc 1 1134 0
 4145              		.cfi_startproc
 4146              		@ args = 0, pretend = 0, frame = 0
 4147              		@ frame_needed = 0, uses_anonymous_args = 0
 4148              		@ link register save eliminated.
1135:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_F)) {
 4149              		.loc 1 1135 0
 4150 0000 0A4B     		ldr	r3, .L555
 4151 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4152 0006 5107     		lsls	r1, r2, #29
 4153 0008 0FD4     		bmi	.L549
1136:state.c       ****     return;
1137:state.c       ****   }
1138:state.c       **** 
1139:state.c       ****   if (bit_is_set(state.wind_air_status, WINDSPEED_I)) {
 4154              		.loc 1 1139 0
 4155 000a D207     		lsls	r2, r2, #31
1140:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.x);
1141:state.c       ****     state.h_windspeed_f.x = SPEED_FLOAT_OF_BFP(state.h_windspeed_i.y);
 4156              		.loc 1 1141 0
 4157 000c 48BF     		it	mi
 4158 000e D3ED937A 		fldsmi	s15, [r3, #588]	@ int
1142:state.c       ****   }
1143:state.c       ****   /* set bit to indicate this representation is computed */
1144:state.c       ****   SetBit(state.rate_status, WINDSPEED_F);
 4159              		.loc 1 1144 0
 4160 0012 93F82822 		ldrb	r2, [r3, #552]	@ zero_extendqisi2
1141:state.c       ****   }
 4161              		.loc 1 1141 0
 4162 0016 48BF     		it	mi
 4163 0018 FAEEE67A 		vcvtmi.f32.s32	s15, s15, #19
 4164              		.loc 1 1144 0
 4165 001c 42F00402 		orr	r2, r2, #4
1141:state.c       ****   }
 4166              		.loc 1 1141 0
 4167 0020 48BF     		it	mi
 4168 0022 C3ED957A 		fstsmi	s15, [r3, #596]
 4169              		.loc 1 1144 0
 4170 0026 83F82822 		strb	r2, [r3, #552]
 4171              	.L549:
 4172 002a 7047     		bx	lr
 4173              	.L556:
 4174              		.align	2
 4175              	.L555:
 4176 002c 00000000 		.word	.LANCHOR0
 4177              		.cfi_endproc
 4178              	.LFE167:
 4180              		.section	.text.stateCalcAirspeed_f,"ax",%progbits
 4181              		.align	1
 4182              		.global	stateCalcAirspeed_f
 4183              		.thumb
 4184              		.thumb_func
 4186              	stateCalcAirspeed_f:
 4187              	.LFB168:
1145:state.c       **** }
1146:state.c       **** 
1147:state.c       **** void stateCalcAirspeed_f(void)
1148:state.c       **** {
 4188              		.loc 1 1148 0
 4189              		.cfi_startproc
 4190              		@ args = 0, pretend = 0, frame = 0
 4191              		@ frame_needed = 0, uses_anonymous_args = 0
 4192              		@ link register save eliminated.
1149:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_F)) {
 4193              		.loc 1 1149 0
 4194 0000 094B     		ldr	r3, .L563
 4195 0002 93F84422 		ldrb	r2, [r3, #580]	@ zero_extendqisi2
 4196 0006 1007     		lsls	r0, r2, #28
 4197 0008 0CD4     		bmi	.L557
1150:state.c       ****     return;
1151:state.c       ****   }
1152:state.c       **** 
1153:state.c       ****   if (bit_is_set(state.wind_air_status, AIRSPEED_I)) {
 4198              		.loc 1 1153 0
 4199 000a 9107     		lsls	r1, r2, #30
1154:state.c       ****     state.airspeed_f = SPEED_FLOAT_OF_BFP(state.airspeed_i);
 4200              		.loc 1 1154 0
 4201 000c 44BF     		itt	mi
 4202 000e D3ED947A 		fldsmi	s15, [r3, #592]	@ int
 4203 0012 FAEEE67A 		vcvtmi.f32.s32	s15, s15, #19
1155:state.c       ****   }
1156:state.c       ****   /* set bit to indicate this representation is computed */
1157:state.c       ****   SetBit(state.wind_air_status, AIRSPEED_F);
 4204              		.loc 1 1157 0
 4205 0016 42F00802 		orr	r2, r2, #8
1154:state.c       ****     state.airspeed_f = SPEED_FLOAT_OF_BFP(state.airspeed_i);
 4206              		.loc 1 1154 0
 4207 001a 48BF     		it	mi
 4208 001c C3ED977A 		fstsmi	s15, [r3, #604]
 4209              		.loc 1 1157 0
 4210 0020 83F84422 		strb	r2, [r3, #580]
 4211              	.L557:
 4212 0024 7047     		bx	lr
 4213              	.L564:
 4214 0026 00BF     		.align	2
 4215              	.L563:
 4216 0028 00000000 		.word	.LANCHOR0
 4217              		.cfi_endproc
 4218              	.LFE168:
 4220              		.global	state
 4221              		.section	.bss.state,"aw",%nobits
 4222              		.align	2
 4223              		.set	.LANCHOR0,. + 0
 4226              	state:
 4227 0000 00000000 		.space	616
 4227      00000000 
 4227      00000000 
 4227      00000000 
 4227      00000000 
 4228              		.text
 4229              	.Letext0:
 4230              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 4231              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 4232              		.file 4 "/home/dino/paparazzi/sw/include/std.h"
 4233              		.file 5 "math/pprz_algebra_int.h"
 4234              		.file 6 "math/pprz_algebra_float.h"
 4235              		.file 7 "math/pprz_geodetic_int.h"
 4236              		.file 8 "math/pprz_geodetic_float.h"
 4237              		.file 9 "math/pprz_orientation_conversion.h"
 4238              		.file 10 "state.h"
 4239              		.file 11 "/usr/arm-none-eabi/include/math.h"
 4240              		.file 12 "./math/pprz_trig_int.h"
DEFINED SYMBOLS
                            *ABS*:00000000 state.c
     /tmp/ccYcmBYX.s:20     .text.stateInit:00000000 $t
     /tmp/ccYcmBYX.s:25     .text.stateInit:00000000 stateInit
     /tmp/ccYcmBYX.s:57     .text.stateInit:00000028 $d
     /tmp/ccYcmBYX.s:65     .text.stateCalcPositionEcef_i:00000000 $t
     /tmp/ccYcmBYX.s:70     .text.stateCalcPositionEcef_i:00000000 stateCalcPositionEcef_i
     /tmp/ccYcmBYX.s:220    .text.stateCalcPositionEcef_i:00000104 $d
     /tmp/ccYcmBYX.s:230    .text.stateCalcPositionNed_i:00000000 $t
     /tmp/ccYcmBYX.s:235    .text.stateCalcPositionNed_i:00000000 stateCalcPositionNed_i
     /tmp/ccYcmBYX.s:523    .text.stateCalcPositionNed_i:00000260 $d
     /tmp/ccYcmBYX.s:534    .text.stateCalcPositionEnu_i:00000000 $t
     /tmp/ccYcmBYX.s:539    .text.stateCalcPositionEnu_i:00000000 stateCalcPositionEnu_i
     /tmp/ccYcmBYX.s:823    .text.stateCalcPositionEnu_i:00000258 $d
     /tmp/ccYcmBYX.s:834    .text.stateCalcPositionLla_i:00000000 $t
     /tmp/ccYcmBYX.s:839    .text.stateCalcPositionLla_i:00000000 stateCalcPositionLla_i
     /tmp/ccYcmBYX.s:1084   .text.stateCalcPositionLla_i:000001e0 $d
     /tmp/ccYcmBYX.s:1097   .text.stateCalcPositionUtm_f:00000000 $t
     /tmp/ccYcmBYX.s:1102   .text.stateCalcPositionUtm_f:00000000 stateCalcPositionUtm_f
     /tmp/ccYcmBYX.s:1311   .text.stateCalcPositionUtm_f:000001d0 $d
     /tmp/ccYcmBYX.s:1323   .text.stateCalcPositionEcef_f:00000000 $t
     /tmp/ccYcmBYX.s:1328   .text.stateCalcPositionEcef_f:00000000 stateCalcPositionEcef_f
     /tmp/ccYcmBYX.s:1478   .text.stateCalcPositionEcef_f:00000120 $d
     /tmp/ccYcmBYX.s:1489   .text.stateCalcPositionNed_f:00000000 $t
     /tmp/ccYcmBYX.s:1494   .text.stateCalcPositionNed_f:00000000 stateCalcPositionNed_f
     /tmp/ccYcmBYX.s:1730   .text.stateCalcPositionNed_f:000001f8 $d
     /tmp/ccYcmBYX.s:1741   .text.stateCalcPositionEnu_f:00000000 $t
     /tmp/ccYcmBYX.s:1746   .text.stateCalcPositionEnu_f:00000000 stateCalcPositionEnu_f
     /tmp/ccYcmBYX.s:1991   .text.stateCalcPositionEnu_f:00000200 $d
     /tmp/ccYcmBYX.s:2002   .text.stateCalcPositionLla_f:00000000 $t
     /tmp/ccYcmBYX.s:2007   .text.stateCalcPositionLla_f:00000000 stateCalcPositionLla_f
     /tmp/ccYcmBYX.s:2195   .text.stateCalcPositionLla_f:00000178 $d
     /tmp/ccYcmBYX.s:2208   .text.stateCalcSpeedNed_i:00000000 $t
     /tmp/ccYcmBYX.s:2213   .text.stateCalcSpeedNed_i:00000000 stateCalcSpeedNed_i
     /tmp/ccYcmBYX.s:2364   .text.stateCalcSpeedNed_i:00000144 $d
     /tmp/ccYcmBYX.s:2370   .text.stateCalcSpeedEnu_i:00000000 $t
     /tmp/ccYcmBYX.s:2375   .text.stateCalcSpeedEnu_i:00000000 stateCalcSpeedEnu_i
     /tmp/ccYcmBYX.s:2536   .text.stateCalcSpeedEnu_i:0000015c $d
     /tmp/ccYcmBYX.s:2544   .text.stateCalcSpeedEcef_i:00000000 $t
     /tmp/ccYcmBYX.s:2549   .text.stateCalcSpeedEcef_i:00000000 stateCalcSpeedEcef_i
     /tmp/ccYcmBYX.s:2626   .text.stateCalcSpeedEcef_i:000000a8 $d
     /tmp/ccYcmBYX.s:2632   .text.stateCalcHorizontalSpeedNorm_i:00000000 $t
     /tmp/ccYcmBYX.s:2637   .text.stateCalcHorizontalSpeedNorm_i:00000000 stateCalcHorizontalSpeedNorm_i
     /tmp/ccYcmBYX.s:2769   .text.stateCalcHorizontalSpeedNorm_i:000000e0 $d
     /tmp/ccYcmBYX.s:2775   .text.stateCalcHorizontalSpeedDir_i:00000000 $t
     /tmp/ccYcmBYX.s:2780   .text.stateCalcHorizontalSpeedDir_i:00000000 stateCalcHorizontalSpeedDir_i
     /tmp/ccYcmBYX.s:2959   .text.stateCalcHorizontalSpeedDir_i:0000015c $d
     /tmp/ccYcmBYX.s:2965   .text.stateCalcSpeedNed_f:00000000 $t
     /tmp/ccYcmBYX.s:2970   .text.stateCalcSpeedNed_f:00000000 stateCalcSpeedNed_f
     /tmp/ccYcmBYX.s:3110   .text.stateCalcSpeedNed_f:00000130 $d
     /tmp/ccYcmBYX.s:3116   .text.stateCalcSpeedEnu_f:00000000 $t
     /tmp/ccYcmBYX.s:3121   .text.stateCalcSpeedEnu_f:00000000 stateCalcSpeedEnu_f
     /tmp/ccYcmBYX.s:3264   .text.stateCalcSpeedEnu_f:00000130 $d
     /tmp/ccYcmBYX.s:3271   .text.stateCalcSpeedEcef_f:00000000 $t
     /tmp/ccYcmBYX.s:3276   .text.stateCalcSpeedEcef_f:00000000 stateCalcSpeedEcef_f
     /tmp/ccYcmBYX.s:3353   .text.stateCalcSpeedEcef_f:000000a8 $d
     /tmp/ccYcmBYX.s:3359   .text.stateCalcHorizontalSpeedNorm_f:00000000 $t
     /tmp/ccYcmBYX.s:3364   .text.stateCalcHorizontalSpeedNorm_f:00000000 stateCalcHorizontalSpeedNorm_f
     /tmp/ccYcmBYX.s:3464   .text.stateCalcHorizontalSpeedNorm_f:000000dc $d
     /tmp/ccYcmBYX.s:3470   .text.stateCalcHorizontalSpeedDir_f:00000000 $t
     /tmp/ccYcmBYX.s:3475   .text.stateCalcHorizontalSpeedDir_f:00000000 stateCalcHorizontalSpeedDir_f
     /tmp/ccYcmBYX.s:3576   .text.stateCalcHorizontalSpeedDir_f:000000d8 $d
     /tmp/ccYcmBYX.s:3582   .text.stateCalcAccelNed_i:00000000 $t
     /tmp/ccYcmBYX.s:3587   .text.stateCalcAccelNed_i:00000000 stateCalcAccelNed_i
     /tmp/ccYcmBYX.s:3670   .text.stateCalcAccelNed_i:000000b0 $d
     /tmp/ccYcmBYX.s:3676   .text.stateCalcAccelEcef_i:00000000 $t
     /tmp/ccYcmBYX.s:3681   .text.stateCalcAccelEcef_i:00000000 stateCalcAccelEcef_i
     /tmp/ccYcmBYX.s:3758   .text.stateCalcAccelEcef_i:000000a8 $d
     /tmp/ccYcmBYX.s:3764   .text.stateCalcAccelNed_f:00000000 $t
     /tmp/ccYcmBYX.s:3769   .text.stateCalcAccelNed_f:00000000 stateCalcAccelNed_f
     /tmp/ccYcmBYX.s:3852   .text.stateCalcAccelNed_f:000000b0 $d
     /tmp/ccYcmBYX.s:3858   .text.stateCalcAccelEcef_f:00000000 $t
     /tmp/ccYcmBYX.s:3863   .text.stateCalcAccelEcef_f:00000000 stateCalcAccelEcef_f
     /tmp/ccYcmBYX.s:3940   .text.stateCalcAccelEcef_f:000000a8 $d
     /tmp/ccYcmBYX.s:3946   .text.stateCalcBodyRates_i:00000000 $t
     /tmp/ccYcmBYX.s:3951   .text.stateCalcBodyRates_i:00000000 stateCalcBodyRates_i
     /tmp/ccYcmBYX.s:3989   .text.stateCalcBodyRates_i:0000004c $d
     /tmp/ccYcmBYX.s:3995   .text.stateCalcBodyRates_f:00000000 $t
     /tmp/ccYcmBYX.s:4000   .text.stateCalcBodyRates_f:00000000 stateCalcBodyRates_f
     /tmp/ccYcmBYX.s:4038   .text.stateCalcBodyRates_f:0000004c $d
     /tmp/ccYcmBYX.s:4044   .text.stateCalcHorizontalWindspeed_i:00000000 $t
     /tmp/ccYcmBYX.s:4049   .text.stateCalcHorizontalWindspeed_i:00000000 stateCalcHorizontalWindspeed_i
     /tmp/ccYcmBYX.s:4091   .text.stateCalcHorizontalWindspeed_i:00000040 $d
     /tmp/ccYcmBYX.s:4097   .text.stateCalcAirspeed_i:00000000 $t
     /tmp/ccYcmBYX.s:4102   .text.stateCalcAirspeed_i:00000000 stateCalcAirspeed_i
     /tmp/ccYcmBYX.s:4132   .text.stateCalcAirspeed_i:00000028 $d
     /tmp/ccYcmBYX.s:4137   .text.stateCalcHorizontalWindspeed_f:00000000 $t
     /tmp/ccYcmBYX.s:4142   .text.stateCalcHorizontalWindspeed_f:00000000 stateCalcHorizontalWindspeed_f
     /tmp/ccYcmBYX.s:4176   .text.stateCalcHorizontalWindspeed_f:0000002c $d
     /tmp/ccYcmBYX.s:4181   .text.stateCalcAirspeed_f:00000000 $t
     /tmp/ccYcmBYX.s:4186   .text.stateCalcAirspeed_f:00000000 stateCalcAirspeed_f
     /tmp/ccYcmBYX.s:4216   .text.stateCalcAirspeed_f:00000028 $d
     /tmp/ccYcmBYX.s:4226   .bss.state:00000000 state
     /tmp/ccYcmBYX.s:4222   .bss.state:00000000 $d
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.0.7f506cdee5614e5fae524d20989ad8c8
                           .group:00000000 wm4.newlib.h.8.2702bca278809460f0af6fba1d84eb68
                           .group:00000000 wm4.features.h.22.2e382148a0560adabf236cddd4e880f4
                           .group:00000000 wm4.config.h.220.a09b0b0de3c25be3f39d71990e617bff
                           .group:00000000 wm4._intsup.h.10.b2832a532eae49c14d45880be6d4ca65
                           .group:00000000 wm4._default_types.h.6.35ee9e747940367bf2a634907d1c2382
                           .group:00000000 wm4._stdint.h.10.f76354baea1c7088202064e6f3d4f5e3
                           .group:00000000 wm4.stdint.h.23.373a9d32a9e4c2e88fd347156532d281
                           .group:00000000 wm4.stddef.h.263.49e44f5ee9cdd8820580fc4aa239e32a
                           .group:00000000 wm4.inttypes.h.23.a096771aacee9aba4b33c2d04aacc9b1
                           .group:00000000 wm4.stdbool.h.29.1c9ee6859ce8145f7838a4f2549ccec2
                           .group:00000000 wm4._ansi.h.13.1b5575dc7921a4c0cff7dbaa2f33e670
                           .group:00000000 wm4.stddef.h.39.2b75ea897b59bf67f50e970d678806e4
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4._types.h.54.d3d34a3b7f3cc230cd159baf022b4b08
                           .group:00000000 wm4.stddef.h.158.61317cdbfb4026324507d123a50b0fd6
                           .group:00000000 wm4.reent.h.17.8bd9e4098e0428508c282cad794fae43
                           .group:00000000 wm4.math.h.35.ad242c9287d2217c7d2035216e5d04ca
                           .group:00000000 wm4.message_pragmas.h.2.a703592919ab94db061a475289156c21
                           .group:00000000 wm4.std.h.37.c94f17957e155d4dda789b7ad0549a32
                           .group:00000000 wm4.float.h.29.1cf88a0527b6b1225d49fbee2b32acb7
                           .group:00000000 wm4.cdefs.h.47.3052445825803de6c3a3b68ec8193866
                           .group:00000000 wm4.string.h.15.dab3980bf35408a4c507182805e2de3a
                           .group:00000000 wm4.stddef.h.158.a7efb00f6cbc6f43213b50e183c9830c
                           .group:00000000 wm4.pprz_algebra.h.47.d249264ea6bacf2198e290d461cf6dbe
                           .group:00000000 wm4.pprz_trig_int.h.28.b756be608c9d9f3092a41321446e5fa2
                           .group:00000000 wm4.stdlib.h.13.4ed386f5c1a80d71e72172885d946ef2
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.54.cd3744e0b066087ec8fbb1bdc22d1043
                           .group:00000000 wm4.pprz_algebra_int.h.68.04ac162ae1e1d94f716d0bb402062624
                           .group:00000000 wm4.pprz_algebra_float.h.98.bb035bcbfa66bb186e7ea81143fd64bc
                           .group:00000000 wm4.pprz_geodetic.h.35.f7fdb5d11659b92d11c7ce67b6317005
                           .group:00000000 wm4.pprz_geodetic_int.h.127.8e737bed5ba4468e470311184b1fca7f
                           .group:00000000 wm4.pprz_orientation_conversion.h.69.5cce798fefad8bb761767fd414e61db5
                           .group:00000000 wm4.state.h.65.b18954aacb3801ec3e27b4e857d620d3

UNDEFINED SYMBOLS
__aeabi_f2d
__aeabi_dmul
__aeabi_d2iz
ecef_of_ned_pos_i
ecef_of_ned_point_f
ecef_of_lla_i
ecef_of_lla_f
__aeabi_ddiv
__aeabi_d2f
ned_of_ecef_pos_i
ned_of_ecef_point_f
ned_of_lla_point_i
utm_of_lla_f
enu_of_ecef_pos_i
enu_of_ecef_point_f
enu_of_lla_point_i
lla_of_ecef_i
ecef_of_enu_pos_i
lla_of_utm_f
__aeabi_i2d
ned_of_lla_point_f
enu_of_lla_point_f
lla_of_ecef_f
ned_of_ecef_vect_i
enu_of_ecef_vect_i
ecef_of_ned_vect_i
int32_sqrt
ned_of_ecef_vect_f
sqrtf
int32_atan2
enu_of_ecef_vect_f
ecef_of_ned_vect_f
atan2f
